-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parse source to template-haskell abstract syntax.
--   
--   The translation from haskell-src-exts abstract syntax to
--   template-haskell abstract syntax isn't 100% complete yet.
@package haskell-src-meta
@version 0.8.3


module Language.Haskell.Meta.Syntax.Translate
class ToDerivClauses a
toDerivClauses :: ToDerivClauses a => a -> [DerivClause]
type DerivClause = DerivClause
class ToInjectivityAnn a
toInjectivityAnn :: ToInjectivityAnn a => a -> InjectivityAnn
class ToMaybeKind a
toMaybeKind :: ToMaybeKind a => a -> Maybe Kind
class ToTyVars a
toTyVars :: ToTyVars a => a -> [TyVarBndr]
class ToPred a
toPred :: ToPred a => a -> Pred
class ToCxt a
toCxt :: ToCxt a => a -> Cxt
class ToLoc a
toLoc :: ToLoc a => a -> Loc
class ToStmt a
toStmt :: ToStmt a => a -> Stmt
class ToDec a
toDec :: ToDec a => a -> Dec
class ToDecs a
toDecs :: ToDecs a => a -> [Dec]
class ToExp a
toExp :: ToExp a => a -> Exp
class ToPat a
toPat :: ToPat a => a -> Pat
class ToType a
toType :: ToType a => a -> Type
class ToLit a
toLit :: ToLit a => a -> Lit
class ToNames a
toNames :: ToNames a => a -> [Name]
class ToName a
toName :: ToName a => a -> Name
moduleName :: String
noTH :: (Functor f, Show (f ())) => String -> f e -> a
noTHyet :: (Functor f, Show (f ())) => String -> String -> f e -> a
todo :: (Functor f, Show (f ())) => String -> f e -> a
nonsense :: (Functor f, Show (f ())) => String -> String -> f e -> a
toFieldExp :: FieldUpdate l -> FieldExp
toMatch :: Alt l -> Match
toBody :: Rhs l -> Body
toGuard :: GuardedRhs l -> (Guard, Exp)
toKind :: Kind l -> Kind
toTyVar :: TyVarBind l -> TyVarBndr
toStrictType :: Type l -> StrictType
(.->.) :: Type -> Type -> Type
toDerivStrategy :: DerivStrategy l -> DerivStrategy
foldAppT :: Type -> [Type] -> Type
transAct :: Maybe (Activation l) -> Phases
qualConDeclToCon :: QualConDecl l -> Con
conDeclToCon :: ConDecl l -> Con
hsMatchesToFunD :: [Match l] -> Dec
hsMatchToClause :: Match l -> Clause
hsRhsToBody :: Rhs l -> Body
hsGuardedRhsToBody :: GuardedRhs l -> Body
hsStmtToGuard :: Stmt l -> Guard
instance Language.Haskell.Meta.Syntax.Translate.ToDerivClauses (Language.Haskell.Exts.Syntax.Deriving l)
instance Language.Haskell.Meta.Syntax.Translate.ToDerivClauses a => Language.Haskell.Meta.Syntax.Translate.ToDerivClauses (GHC.Maybe.Maybe a)
instance Language.Haskell.Meta.Syntax.Translate.ToDerivClauses a => Language.Haskell.Meta.Syntax.Translate.ToDerivClauses [a]
instance Language.Haskell.Meta.Syntax.Translate.ToDec (Language.Haskell.Exts.Syntax.Decl l)
instance Language.Haskell.Meta.Syntax.Translate.ToInjectivityAnn (Language.Haskell.Exts.Syntax.InjectivityInfo l)
instance Language.Haskell.Meta.Syntax.Translate.ToMaybeKind (Language.Haskell.Exts.Syntax.ResultSig l)
instance Language.Haskell.Meta.Syntax.Translate.ToMaybeKind a => Language.Haskell.Meta.Syntax.Translate.ToMaybeKind (GHC.Maybe.Maybe a)
instance Language.Haskell.Meta.Syntax.Translate.ToTyVars (Language.Haskell.Exts.Syntax.DeclHead l)
instance Language.Haskell.Meta.Syntax.Translate.ToTyVars a => Language.Haskell.Meta.Syntax.Translate.ToTyVars (GHC.Maybe.Maybe a)
instance Language.Haskell.Meta.Syntax.Translate.ToTyVars a => Language.Haskell.Meta.Syntax.Translate.ToTyVars [a]
instance Language.Haskell.Meta.Syntax.Translate.ToTyVars (Language.Haskell.Exts.Syntax.TyVarBind l)
instance Language.Haskell.Meta.Syntax.Translate.ToPred (Language.Haskell.Exts.Syntax.Asst l)
instance Language.Haskell.Meta.Syntax.Translate.ToCxt (Language.Haskell.Exts.Syntax.Context l)
instance Language.Haskell.Meta.Syntax.Translate.ToType (Language.Haskell.Exts.Syntax.Type l)
instance Language.Haskell.Meta.Syntax.Translate.ToCxt (Language.Haskell.Exts.Syntax.InstRule l)
instance Language.Haskell.Meta.Syntax.Translate.ToCxt a => Language.Haskell.Meta.Syntax.Translate.ToCxt (GHC.Maybe.Maybe a)
instance Language.Haskell.Meta.Syntax.Translate.ToLoc Language.Haskell.Exts.SrcLoc.SrcLoc
instance Language.Haskell.Meta.Syntax.Translate.ToExp (Language.Haskell.Exts.Syntax.Exp l)
instance Language.Haskell.Meta.Syntax.Translate.ToStmt (Language.Haskell.Exts.Syntax.Stmt l)
instance Language.Haskell.Meta.Syntax.Translate.ToDecs (Language.Haskell.Exts.Syntax.Decl l)
instance Language.Haskell.Meta.Syntax.Translate.ToDecs a => Language.Haskell.Meta.Syntax.Translate.ToDecs (GHC.Maybe.Maybe a)
instance Language.Haskell.Meta.Syntax.Translate.ToDecs (Language.Haskell.Exts.Syntax.Binds l)
instance Language.Haskell.Meta.Syntax.Translate.ToDecs (Language.Haskell.Exts.Syntax.ClassDecl l)
instance Language.Haskell.Meta.Syntax.Translate.ToDecs (Language.Haskell.Exts.Syntax.InstDecl l)
instance Language.Haskell.Meta.Syntax.Translate.ToDecs a => Language.Haskell.Meta.Syntax.Translate.ToDecs [a]
instance Language.Haskell.Meta.Syntax.Translate.ToExp Language.Haskell.TH.Syntax.Lit
instance Language.Haskell.Meta.Syntax.Translate.ToExp a => Language.Haskell.Meta.Syntax.Translate.ToExp [a]
instance (Language.Haskell.Meta.Syntax.Translate.ToExp a, Language.Haskell.Meta.Syntax.Translate.ToExp b) => Language.Haskell.Meta.Syntax.Translate.ToExp (a, b)
instance (Language.Haskell.Meta.Syntax.Translate.ToExp a, Language.Haskell.Meta.Syntax.Translate.ToExp b, Language.Haskell.Meta.Syntax.Translate.ToExp c) => Language.Haskell.Meta.Syntax.Translate.ToExp (a, b, c)
instance (Language.Haskell.Meta.Syntax.Translate.ToExp a, Language.Haskell.Meta.Syntax.Translate.ToExp b, Language.Haskell.Meta.Syntax.Translate.ToExp c, Language.Haskell.Meta.Syntax.Translate.ToExp d) => Language.Haskell.Meta.Syntax.Translate.ToExp (a, b, c, d)
instance Language.Haskell.Meta.Syntax.Translate.ToPat (Language.Haskell.Exts.Syntax.Pat l)
instance Language.Haskell.Meta.Syntax.Translate.ToExp (Language.Haskell.Exts.Syntax.QOp l)
instance Language.Haskell.Meta.Syntax.Translate.ToPat Language.Haskell.TH.Syntax.Lit
instance Language.Haskell.Meta.Syntax.Translate.ToPat a => Language.Haskell.Meta.Syntax.Translate.ToPat [a]
instance (Language.Haskell.Meta.Syntax.Translate.ToPat a, Language.Haskell.Meta.Syntax.Translate.ToPat b) => Language.Haskell.Meta.Syntax.Translate.ToPat (a, b)
instance (Language.Haskell.Meta.Syntax.Translate.ToPat a, Language.Haskell.Meta.Syntax.Translate.ToPat b, Language.Haskell.Meta.Syntax.Translate.ToPat c) => Language.Haskell.Meta.Syntax.Translate.ToPat (a, b, c)
instance (Language.Haskell.Meta.Syntax.Translate.ToPat a, Language.Haskell.Meta.Syntax.Translate.ToPat b, Language.Haskell.Meta.Syntax.Translate.ToPat c, Language.Haskell.Meta.Syntax.Translate.ToPat d) => Language.Haskell.Meta.Syntax.Translate.ToPat (a, b, c, d)
instance Language.Haskell.Meta.Syntax.Translate.ToType (Language.Haskell.Exts.Syntax.InstRule l)
instance Language.Haskell.Meta.Syntax.Translate.ToType (Language.Haskell.Exts.Syntax.InstHead l)
instance Language.Haskell.Meta.Syntax.Translate.ToType (Language.Haskell.Exts.Syntax.QName l)
instance Language.Haskell.Meta.Syntax.Translate.ToLit GHC.Types.Char
instance Language.Haskell.Meta.Syntax.Translate.ToLit GHC.Base.String
instance Language.Haskell.Meta.Syntax.Translate.ToLit GHC.Integer.Type.Integer
instance Language.Haskell.Meta.Syntax.Translate.ToLit GHC.Types.Int
instance Language.Haskell.Meta.Syntax.Translate.ToLit GHC.Types.Float
instance Language.Haskell.Meta.Syntax.Translate.ToLit GHC.Types.Double
instance Language.Haskell.Meta.Syntax.Translate.ToLit (Language.Haskell.Exts.Syntax.Literal l)
instance Language.Haskell.Meta.Syntax.Translate.ToNames a => Language.Haskell.Meta.Syntax.Translate.ToNames (GHC.Maybe.Maybe a)
instance Language.Haskell.Meta.Syntax.Translate.ToNames (Language.Haskell.Exts.Syntax.Deriving l)
instance Language.Haskell.Meta.Syntax.Translate.ToNames (Language.Haskell.Exts.Syntax.InstRule l)
instance Language.Haskell.Meta.Syntax.Translate.ToNames (Language.Haskell.Exts.Syntax.InstHead l)
instance Language.Haskell.Meta.Syntax.Translate.ToName GHC.Base.String
instance Language.Haskell.Meta.Syntax.Translate.ToName (Language.Haskell.Exts.Syntax.Name l)
instance Language.Haskell.Meta.Syntax.Translate.ToName (Language.Haskell.Exts.Syntax.SpecialCon l)
instance Language.Haskell.Meta.Syntax.Translate.ToName (Language.Haskell.Exts.Syntax.QName l)
instance Language.Haskell.Meta.Syntax.Translate.ToName (Language.Haskell.Exts.Syntax.MaybePromotedName l)
instance Language.Haskell.Meta.Syntax.Translate.ToName (Language.Haskell.Exts.Syntax.Op l)
instance Language.Haskell.Meta.Syntax.Translate.ToName (Language.Haskell.Exts.Syntax.TyVarBind l)
instance Language.Haskell.Meta.Syntax.Translate.ToName Language.Haskell.TH.Syntax.Name
instance Language.Haskell.Meta.Syntax.Translate.ToName Language.Haskell.TH.Syntax.TyVarBndr
instance Language.Haskell.Meta.Syntax.Translate.ToName (Language.Haskell.Exts.Syntax.DeclHead l)


module Language.Haskell.Meta.Parse
parsePat :: String -> Either String Pat
parseExp :: String -> Either String Exp
parseType :: String -> Either String Type
parseDecs :: String -> Either String [Dec]

parseDecsWithMode :: ParseMode -> String -> Either String [Dec]

-- | <i>Deprecated: The provided ParseModes aren't very meaningful, use
--   your own instead</i>
myDefaultParseMode :: ParseMode

-- | <i>Deprecated: The provided ParseModes aren't very meaningful, use
--   your own instead</i>
myDefaultExtensions :: [KnownExtension]
parseResultToEither :: ParseResult a -> Either String a
parseHsModule :: String -> Either String (Module SrcSpanInfo)
parseHsDecls :: String -> Either String [Decl SrcSpanInfo]

parseHsDeclsWithMode :: ParseMode -> String -> Either String [Decl SrcSpanInfo]
parseHsType :: String -> Either String (Type SrcSpanInfo)
parseHsExp :: String -> Either String (Exp SrcSpanInfo)
parseHsPat :: String -> Either String (Pat SrcSpanInfo)
pprHsModule :: Module SrcSpanInfo -> String
moduleDecls :: Module SrcSpanInfo -> [Decl SrcSpanInfo]
noSrcSpanInfo :: SrcSpanInfo
emptyHsModule :: String -> Module SrcSpanInfo


module Language.Haskell.Meta


-- | This module is a staging ground for to-be-organized-and-merged-nicely
--   code.
module Language.Haskell.Meta.Utils
cleanNames :: Data a => a -> a

-- | The type passed in must have a <tt>Show</tt> instance which produces a
--   valid Haskell expression. Returns an empty <tt>String</tt> if this is
--   not the case. This is not TH-specific, but useful in general.
pretty :: Show a => a -> String
pp :: (Data a, Ppr a) => a -> String
ppDoc :: (Data a, Ppr a) => a -> Doc
gpretty :: Data a => a -> String

-- | <pre>
--   unsafeRunQ = unsafePerformIO . runQ
--   </pre>
unsafeRunQ :: Q a -> a
nameToRawCodeStr :: Name -> String
(|$|) :: ExpQ -> ExpQ -> ExpQ
infixr 0 |$|
(|.|) :: ExpQ -> ExpQ -> ExpQ
infixr 9 |.|
(|->|) :: TypeQ -> TypeQ -> TypeQ
infixr 9 |->|
unForall :: Type -> Type
functionT :: [TypeQ] -> TypeQ
mkVarT :: String -> TypeQ

-- | Infinite list of names composed of lowercase letters
myNames :: [Name]

-- | Generalisation of renameTs
renameThings :: (t1 -> t2 -> a1 -> (a2, t1, t2)) -> t1 -> t2 -> [a2] -> [a1] -> ([a2], t1, t2)

-- | renameT applied to a list of types
renameTs :: [(Name, Name)] -> [Name] -> [Type] -> [Type] -> ([Type], [(Name, Name)], [Name])

-- | Rename type variables in the Type according to the given association
--   list. Normalise constructor names (remove qualification, etc.) If a
--   name is not found in the association list, replace it with one from
--   the fresh names list, and add this translation to the returned list.
--   The fresh names list should be infinite; myNames is a good example.
renameT :: [(Name, Name)] -> [Name] -> Type -> (Type, [(Name, Name)], [Name])

-- | Remove qualification, etc.
normaliseName :: Name -> Name
applyT :: Type -> Type -> Type
substT :: [(Name, Type)] -> [Name] -> Type -> Type
splitCon :: Con -> (Name, [Type])
strictTypeTy :: StrictType -> Type
varStrictTypeTy :: VarStrictType -> Type
conTypes :: Con -> [Type]
conToConType :: Type -> Con -> Type
decCons :: Dec -> [Con]
decTyVars :: Dec -> [TyVarBndr]
decName :: Dec -> Maybe Name
foreignName :: Foreign -> Name
unwindT :: Type -> [Type]
unwindE :: Exp -> [Exp]

-- | The arity of a Type.
arityT :: Type -> Int
typeToName :: Type -> Maybe Name

-- | Randomly useful.
nameSpaceOf :: Name -> Maybe NameSpace
conName :: Con -> Name
recCName :: Con -> Maybe Name
dataDCons :: Dec -> [Con]
fromDataConI :: Info -> Q (Maybe Exp)
fromTyConI :: Info -> Maybe Dec
mkFunD :: Name -> [Pat] -> Exp -> Dec
mkClauseQ :: [PatQ] -> ExpQ -> ClauseQ

-- | The strategy for producing QuasiQuoters which this datatype aims to
--   facilitate is as follows. Given a collection of datatypes which make
--   up the to-be-quasiquoted languages AST, make each type in this
--   collection an instance of at least <tt>Show</tt> and <tt>Lift</tt>.
--   Now, assuming <tt>parsePat</tt> and <tt>parseExp</tt>, both of type
--   <tt>String -&gt; Q a</tt> (where <tt>a</tt> is the top level type of
--   the AST), are the pair of functions you wish to use for parsing in
--   pattern and expression context respectively, put them inside a
--   <tt>Quoter</tt> datatype and pass this to quasify.
toExpQ :: Lift a => (String -> Q a) -> String -> ExpQ
toPatQ :: Show a => (String -> Q a) -> String -> PatQ
showToPatQ :: Show a => a -> PatQ
eitherQ :: (e -> String) -> Either e a -> Q a
normalizeT :: Data a => a -> a
instance GHC.Show.Show Language.Haskell.TH.Lib.Internal.ExpQ
instance GHC.Show.Show (Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec])
instance GHC.Show.Show Language.Haskell.TH.Lib.Internal.DecQ
instance GHC.Show.Show Language.Haskell.TH.Lib.Internal.TypeQ
instance GHC.Show.Show (Language.Haskell.TH.Syntax.Q GHC.Base.String)
instance GHC.Show.Show (Language.Haskell.TH.Syntax.Q Text.PrettyPrint.HughesPJ.Doc)
