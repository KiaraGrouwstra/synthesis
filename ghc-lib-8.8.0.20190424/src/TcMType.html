<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">{-
(c) The University of Glasgow 2006
(c) The GRASP/AQUA Project, Glasgow University, 1992-1998


Monadic type operations

This module contains monadic operations over types that contain
mutable type variables
-}</span><span>
</span><a name="line-11"></a><span>
</span><a name="line-12"></a><span class="hs-pragma">{-# LANGUAGE CPP, TupleSections, MultiWayIf #-}</span><span>
</span><a name="line-13"></a><span>
</span><a name="line-14"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">TcMType</span><span> </span><span class="hs-special">(</span><span>
</span><a name="line-15"></a><span>  </span><span class="hs-identifier hs-type">TcTyVar</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">TcKind</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">TcType</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">TcTauType</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">TcThetaType</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">TcTyVarSet</span><span class="hs-special">,</span><span>
</span><a name="line-16"></a><span>
</span><a name="line-17"></a><span>  </span><span class="hs-comment">--------------------------------</span><span>
</span><a name="line-18"></a><span>  </span><span class="hs-comment">-- Creating new mutable type variables</span><span>
</span><a name="line-19"></a><span>  </span><a href="TcMType.html#newFlexiTyVar"><span class="hs-identifier hs-var">newFlexiTyVar</span></a><span class="hs-special">,</span><span>
</span><a name="line-20"></a><span>  </span><a href="TcMType.html#newFlexiTyVarTy"><span class="hs-identifier hs-var">newFlexiTyVarTy</span></a><span class="hs-special">,</span><span>              </span><span class="hs-comment">-- Kind -&gt; TcM TcType</span><span>
</span><a name="line-21"></a><span>  </span><a href="TcMType.html#newFlexiTyVarTys"><span class="hs-identifier hs-var">newFlexiTyVarTys</span></a><span class="hs-special">,</span><span>             </span><span class="hs-comment">-- Int -&gt; Kind -&gt; TcM [TcType]</span><span>
</span><a name="line-22"></a><span>  </span><a href="TcMType.html#newOpenFlexiTyVarTy"><span class="hs-identifier hs-var">newOpenFlexiTyVarTy</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newOpenTypeKind"><span class="hs-identifier hs-var">newOpenTypeKind</span></a><span class="hs-special">,</span><span>
</span><a name="line-23"></a><span>  </span><a href="TcMType.html#newMetaKindVar"><span class="hs-identifier hs-var">newMetaKindVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newMetaKindVars"><span class="hs-identifier hs-var">newMetaKindVars</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newMetaTyVarTyAtLevel"><span class="hs-identifier hs-var">newMetaTyVarTyAtLevel</span></a><span class="hs-special">,</span><span>
</span><a name="line-24"></a><span>  </span><a href="TcMType.html#cloneMetaTyVar"><span class="hs-identifier hs-var">cloneMetaTyVar</span></a><span class="hs-special">,</span><span>
</span><a name="line-25"></a><span>  </span><a href="TcMType.html#newFmvTyVar"><span class="hs-identifier hs-var">newFmvTyVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newFskTyVar"><span class="hs-identifier hs-var">newFskTyVar</span></a><span class="hs-special">,</span><span>
</span><a name="line-26"></a><span>
</span><a name="line-27"></a><span>  </span><a href="TcMType.html#readMetaTyVar"><span class="hs-identifier hs-var">readMetaTyVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#writeMetaTyVar"><span class="hs-identifier hs-var">writeMetaTyVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#writeMetaTyVarRef"><span class="hs-identifier hs-var">writeMetaTyVarRef</span></a><span class="hs-special">,</span><span>
</span><a name="line-28"></a><span>  </span><a href="TcMType.html#newMetaDetails"><span class="hs-identifier hs-var">newMetaDetails</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#isFilledMetaTyVar_maybe"><span class="hs-identifier hs-var">isFilledMetaTyVar_maybe</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#isFilledMetaTyVar"><span class="hs-identifier hs-var">isFilledMetaTyVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#isUnfilledMetaTyVar"><span class="hs-identifier hs-var">isUnfilledMetaTyVar</span></a><span class="hs-special">,</span><span>
</span><a name="line-29"></a><span>
</span><a name="line-30"></a><span>  </span><span class="hs-comment">--------------------------------</span><span>
</span><a name="line-31"></a><span>  </span><span class="hs-comment">-- Expected types</span><span>
</span><a name="line-32"></a><span>  </span><span class="hs-identifier hs-type">ExpType</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">ExpSigmaType</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">ExpRhoType</span><span class="hs-special">,</span><span>
</span><a name="line-33"></a><span>  </span><span class="hs-identifier hs-var">mkCheckExpType</span><span class="hs-special">,</span><span>
</span><a name="line-34"></a><span>  </span><a href="TcMType.html#newInferExpType"><span class="hs-identifier hs-var">newInferExpType</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newInferExpTypeInst"><span class="hs-identifier hs-var">newInferExpTypeInst</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newInferExpTypeNoInst"><span class="hs-identifier hs-var">newInferExpTypeNoInst</span></a><span class="hs-special">,</span><span>
</span><a name="line-35"></a><span>  </span><a href="TcMType.html#readExpType"><span class="hs-identifier hs-var">readExpType</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#readExpType_maybe"><span class="hs-identifier hs-var">readExpType_maybe</span></a><span class="hs-special">,</span><span>
</span><a name="line-36"></a><span>  </span><a href="TcMType.html#expTypeToType"><span class="hs-identifier hs-var">expTypeToType</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#checkingExpType_maybe"><span class="hs-identifier hs-var">checkingExpType_maybe</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#checkingExpType"><span class="hs-identifier hs-var">checkingExpType</span></a><span class="hs-special">,</span><span>
</span><a name="line-37"></a><span>  </span><a href="TcMType.html#tauifyExpType"><span class="hs-identifier hs-var">tauifyExpType</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#inferResultToType"><span class="hs-identifier hs-var">inferResultToType</span></a><span class="hs-special">,</span><span>
</span><a name="line-38"></a><span>
</span><a name="line-39"></a><span>  </span><span class="hs-comment">--------------------------------</span><span>
</span><a name="line-40"></a><span>  </span><span class="hs-comment">-- Creating new evidence variables</span><span>
</span><a name="line-41"></a><span>  </span><a href="TcMType.html#newEvVar"><span class="hs-identifier hs-var">newEvVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newEvVars"><span class="hs-identifier hs-var">newEvVars</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newDict"><span class="hs-identifier hs-var">newDict</span></a><span class="hs-special">,</span><span>
</span><a name="line-42"></a><span>  </span><a href="TcMType.html#newWanted"><span class="hs-identifier hs-var">newWanted</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newWanteds"><span class="hs-identifier hs-var">newWanteds</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newHoleCt"><span class="hs-identifier hs-var">newHoleCt</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#cloneWanted"><span class="hs-identifier hs-var">cloneWanted</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#cloneWC"><span class="hs-identifier hs-var">cloneWC</span></a><span class="hs-special">,</span><span>
</span><a name="line-43"></a><span>  </span><a href="TcMType.html#emitWanted"><span class="hs-identifier hs-var">emitWanted</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#emitWantedEq"><span class="hs-identifier hs-var">emitWantedEq</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#emitWantedEvVar"><span class="hs-identifier hs-var">emitWantedEvVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#emitWantedEvVars"><span class="hs-identifier hs-var">emitWantedEvVars</span></a><span class="hs-special">,</span><span>
</span><a name="line-44"></a><span>  </span><a href="TcMType.html#emitDerivedEqs"><span class="hs-identifier hs-var">emitDerivedEqs</span></a><span class="hs-special">,</span><span>
</span><a name="line-45"></a><span>  </span><a href="TcRnMonad.html#newTcEvBinds"><span class="hs-identifier hs-var">newTcEvBinds</span></a><span class="hs-special">,</span><span> </span><a href="TcRnMonad.html#newNoTcEvBinds"><span class="hs-identifier hs-var">newNoTcEvBinds</span></a><span class="hs-special">,</span><span> </span><a href="TcRnMonad.html#addTcEvBind"><span class="hs-identifier hs-var">addTcEvBind</span></a><span class="hs-special">,</span><span>
</span><a name="line-46"></a><span>
</span><a name="line-47"></a><span>  </span><a href="TcMType.html#newCoercionHole"><span class="hs-identifier hs-var">newCoercionHole</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#fillCoercionHole"><span class="hs-identifier hs-var">fillCoercionHole</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#isFilledCoercionHole"><span class="hs-identifier hs-var">isFilledCoercionHole</span></a><span class="hs-special">,</span><span>
</span><a name="line-48"></a><span>  </span><a href="TcMType.html#unpackCoercionHole"><span class="hs-identifier hs-var">unpackCoercionHole</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#unpackCoercionHole_maybe"><span class="hs-identifier hs-var">unpackCoercionHole_maybe</span></a><span class="hs-special">,</span><span>
</span><a name="line-49"></a><span>  </span><a href="TcMType.html#checkCoercionHole"><span class="hs-identifier hs-var">checkCoercionHole</span></a><span class="hs-special">,</span><span>
</span><a name="line-50"></a><span>
</span><a name="line-51"></a><span>  </span><span class="hs-comment">--------------------------------</span><span>
</span><a name="line-52"></a><span>  </span><span class="hs-comment">-- Instantiation</span><span>
</span><a name="line-53"></a><span>  </span><a href="TcMType.html#newMetaTyVars"><span class="hs-identifier hs-var">newMetaTyVars</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newMetaTyVarX"><span class="hs-identifier hs-var">newMetaTyVarX</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newMetaTyVarsX"><span class="hs-identifier hs-var">newMetaTyVarsX</span></a><span class="hs-special">,</span><span>
</span><a name="line-54"></a><span>  </span><a href="TcMType.html#newMetaTyVarTyVars"><span class="hs-identifier hs-var">newMetaTyVarTyVars</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newMetaTyVarTyVarX"><span class="hs-identifier hs-var">newMetaTyVarTyVarX</span></a><span class="hs-special">,</span><span>
</span><a name="line-55"></a><span>  </span><a href="TcMType.html#newTyVarTyVar"><span class="hs-identifier hs-var">newTyVarTyVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newTauTyVar"><span class="hs-identifier hs-var">newTauTyVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newSkolemTyVar"><span class="hs-identifier hs-var">newSkolemTyVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#newWildCardX"><span class="hs-identifier hs-var">newWildCardX</span></a><span class="hs-special">,</span><span>
</span><a name="line-56"></a><span>  </span><a href="TcMType.html#tcInstType"><span class="hs-identifier hs-var">tcInstType</span></a><span class="hs-special">,</span><span>
</span><a name="line-57"></a><span>  </span><a href="TcMType.html#tcInstSkolTyVars"><span class="hs-identifier hs-var">tcInstSkolTyVars</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#tcInstSkolTyVarsX"><span class="hs-identifier hs-var">tcInstSkolTyVarsX</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#tcInstSkolTyVarsAt"><span class="hs-identifier hs-var">tcInstSkolTyVarsAt</span></a><span class="hs-special">,</span><span>
</span><a name="line-58"></a><span>  </span><a href="TcMType.html#tcSkolDFunType"><span class="hs-identifier hs-var">tcSkolDFunType</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#tcSuperSkolTyVars"><span class="hs-identifier hs-var">tcSuperSkolTyVars</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#tcInstSuperSkolTyVarsX"><span class="hs-identifier hs-var">tcInstSuperSkolTyVarsX</span></a><span class="hs-special">,</span><span>
</span><a name="line-59"></a><span>
</span><a name="line-60"></a><span>  </span><a href="TcMType.html#freshenTyVarBndrs"><span class="hs-identifier hs-var">freshenTyVarBndrs</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#freshenCoVarBndrsX"><span class="hs-identifier hs-var">freshenCoVarBndrsX</span></a><span class="hs-special">,</span><span>
</span><a name="line-61"></a><span>
</span><a name="line-62"></a><span>  </span><span class="hs-comment">--------------------------------</span><span>
</span><a name="line-63"></a><span>  </span><span class="hs-comment">-- Zonking and tidying</span><span>
</span><a name="line-64"></a><span>  </span><a href="TcMType.html#zonkTidyTcType"><span class="hs-identifier hs-var">zonkTidyTcType</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkTidyTcTypes"><span class="hs-identifier hs-var">zonkTidyTcTypes</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkTidyOrigin"><span class="hs-identifier hs-var">zonkTidyOrigin</span></a><span class="hs-special">,</span><span>
</span><a name="line-65"></a><span>  </span><a href="TcMType.html#tidyEvVar"><span class="hs-identifier hs-var">tidyEvVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#tidyCt"><span class="hs-identifier hs-var">tidyCt</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#tidySkolemInfo"><span class="hs-identifier hs-var">tidySkolemInfo</span></a><span class="hs-special">,</span><span>
</span><a name="line-66"></a><span>    </span><a href="TcMType.html#zonkTcTyVar"><span class="hs-identifier hs-var">zonkTcTyVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkTcTyVars"><span class="hs-identifier hs-var">zonkTcTyVars</span></a><span class="hs-special">,</span><span>
</span><a name="line-67"></a><span>  </span><a href="TcMType.html#zonkTcTyVarToTyVar"><span class="hs-identifier hs-var">zonkTcTyVarToTyVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkTyVarTyVarPairs"><span class="hs-identifier hs-var">zonkTyVarTyVarPairs</span></a><span class="hs-special">,</span><span>
</span><a name="line-68"></a><span>  </span><a href="TcMType.html#zonkTyCoVarsAndFV"><span class="hs-identifier hs-var">zonkTyCoVarsAndFV</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkTcTypeAndFV"><span class="hs-identifier hs-var">zonkTcTypeAndFV</span></a><span class="hs-special">,</span><span>
</span><a name="line-69"></a><span>  </span><a href="TcMType.html#zonkTyCoVarsAndFVList"><span class="hs-identifier hs-var">zonkTyCoVarsAndFVList</span></a><span class="hs-special">,</span><span>
</span><a name="line-70"></a><span>  </span><a href="TcMType.html#candidateQTyVarsOfType"><span class="hs-identifier hs-var">candidateQTyVarsOfType</span></a><span class="hs-special">,</span><span>  </span><a href="TcMType.html#candidateQTyVarsOfKind"><span class="hs-identifier hs-var">candidateQTyVarsOfKind</span></a><span class="hs-special">,</span><span>
</span><a name="line-71"></a><span>  </span><a href="TcMType.html#candidateQTyVarsOfTypes"><span class="hs-identifier hs-var">candidateQTyVarsOfTypes</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#candidateQTyVarsOfKinds"><span class="hs-identifier hs-var">candidateQTyVarsOfKinds</span></a><span class="hs-special">,</span><span>
</span><a name="line-72"></a><span>  </span><a href="TcMType.html#CandidatesQTvs"><span class="hs-identifier hs-type">CandidatesQTvs</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="TcMType.html#delCandidates"><span class="hs-identifier hs-var">delCandidates</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#candidateKindVars"><span class="hs-identifier hs-var">candidateKindVars</span></a><span class="hs-special">,</span><span>
</span><a name="line-73"></a><span>  </span><a href="TcMType.html#skolemiseQuantifiedTyVar"><span class="hs-identifier hs-var">skolemiseQuantifiedTyVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#defaultTyVar"><span class="hs-identifier hs-var">defaultTyVar</span></a><span class="hs-special">,</span><span>
</span><a name="line-74"></a><span>  </span><a href="TcMType.html#quantifyTyVars"><span class="hs-identifier hs-var">quantifyTyVars</span></a><span class="hs-special">,</span><span>
</span><a name="line-75"></a><span>  </span><a href="TcMType.html#zonkTcTyCoVarBndr"><span class="hs-identifier hs-var">zonkTcTyCoVarBndr</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkTyConBinders"><span class="hs-identifier hs-var">zonkTyConBinders</span></a><span class="hs-special">,</span><span>
</span><a name="line-76"></a><span>  </span><a href="TcMType.html#zonkTcType"><span class="hs-identifier hs-var">zonkTcType</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkTcTypes"><span class="hs-identifier hs-var">zonkTcTypes</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkCo"><span class="hs-identifier hs-var">zonkCo</span></a><span class="hs-special">,</span><span>
</span><a name="line-77"></a><span>  </span><a href="TcMType.html#zonkTyCoVarKind"><span class="hs-identifier hs-var">zonkTyCoVarKind</span></a><span class="hs-special">,</span><span>
</span><a name="line-78"></a><span>
</span><a name="line-79"></a><span>  </span><a href="TcMType.html#zonkEvVar"><span class="hs-identifier hs-var">zonkEvVar</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkWC"><span class="hs-identifier hs-var">zonkWC</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkSimples"><span class="hs-identifier hs-var">zonkSimples</span></a><span class="hs-special">,</span><span>
</span><a name="line-80"></a><span>  </span><a href="TcMType.html#zonkId"><span class="hs-identifier hs-var">zonkId</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkCoVar"><span class="hs-identifier hs-var">zonkCoVar</span></a><span class="hs-special">,</span><span>
</span><a name="line-81"></a><span>  </span><a href="TcMType.html#zonkCt"><span class="hs-identifier hs-var">zonkCt</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#zonkSkolemInfo"><span class="hs-identifier hs-var">zonkSkolemInfo</span></a><span class="hs-special">,</span><span>
</span><a name="line-82"></a><span>
</span><a name="line-83"></a><span>  </span><a href="TcMType.html#tcGetGlobalTyCoVars"><span class="hs-identifier hs-var">tcGetGlobalTyCoVars</span></a><span class="hs-special">,</span><span>
</span><a name="line-84"></a><span>
</span><a name="line-85"></a><span>  </span><span class="hs-comment">------------------------------</span><span>
</span><a name="line-86"></a><span>  </span><span class="hs-comment">-- Levity polymorphism</span><span>
</span><a name="line-87"></a><span>  </span><a href="TcMType.html#ensureNotLevPoly"><span class="hs-identifier hs-var">ensureNotLevPoly</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#checkForLevPoly"><span class="hs-identifier hs-var">checkForLevPoly</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#checkForLevPolyX"><span class="hs-identifier hs-var">checkForLevPolyX</span></a><span class="hs-special">,</span><span> </span><a href="TcMType.html#formatLevPolyErr"><span class="hs-identifier hs-var">formatLevPolyErr</span></a><span>
</span><a name="line-88"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-89"></a><span>
</span><a name="line-90"></a><span class="hs-cpp">#include &quot;HsVersions.h&quot;
</span><span>
</span><a name="line-92"></a><span class="hs-comment">-- friends:</span><span>
</span><a name="line-93"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">GhcPrelude</span><span>
</span><a name="line-94"></a><span>
</span><a name="line-95"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">TyCoRep</span><span>
</span><a name="line-96"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">TcType</span><span>
</span><a name="line-97"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Type</span><span>
</span><a name="line-98"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">TyCon</span><span>
</span><a name="line-99"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Coercion</span><span>
</span><a name="line-100"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Class</span><span>
</span><a name="line-101"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Var</span><span>
</span><a name="line-102"></a><span>
</span><a name="line-103"></a><span class="hs-comment">-- others:</span><span>
</span><a name="line-104"></a><span class="hs-keyword">import</span><span> </span><a href="TcRnMonad.html"><span class="hs-identifier">TcRnMonad</span></a><span>        </span><span class="hs-comment">-- TcType, amongst others</span><span>
</span><a name="line-105"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">TcEvidence</span><span>
</span><a name="line-106"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Id</span><span>
</span><a name="line-107"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Name</span><span>
</span><a name="line-108"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">VarSet</span><span>
</span><a name="line-109"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">TysWiredIn</span><span>
</span><a name="line-110"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">TysPrim</span><span>
</span><a name="line-111"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">VarEnv</span><span>
</span><a name="line-112"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">NameEnv</span><span>
</span><a name="line-113"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">PrelNames</span><span>
</span><a name="line-114"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Util</span><span>
</span><a name="line-115"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Outputable</span><span>
</span><a name="line-116"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">FastString</span><span>
</span><a name="line-117"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Bag</span><span>
</span><a name="line-118"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Pair</span><span>
</span><a name="line-119"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">UniqSet</span><span>
</span><a name="line-120"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">GHC.LanguageExtensions</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">LangExt</span><span>
</span><a name="line-121"></a><span>
</span><a name="line-122"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control.Monad</span><span>
</span><a name="line-123"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Maybes</span><span>
</span><a name="line-124"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data.List</span><span>        </span><span class="hs-special">(</span><span> </span><span class="hs-identifier hs-var">mapAccumL</span><span> </span><span class="hs-special">)</span><span>
</span><a name="line-125"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control.Arrow</span><span>    </span><span class="hs-special">(</span><span> </span><span class="hs-identifier hs-var">second</span><span> </span><span class="hs-special">)</span><span>
</span><a name="line-126"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data.Semigroup</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">Semi</span><span>
</span><a name="line-127"></a><span>
</span><a name="line-128"></a><span class="hs-comment">{-
************************************************************************
*                                                                      *
        Kind variables
*                                                                      *
************************************************************************
-}</span><span>
</span><a name="line-135"></a><span>
</span><a name="line-136"></a><span class="hs-identifier">mkKindName</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Unique</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Name</span><span>
</span><a name="line-137"></a><a name="mkKindName"><a href="TcMType.html#mkKindName"><span class="hs-identifier">mkKindName</span></a></a><span> </span><a name="local-6989586621681373386"><a href="#local-6989586621681373386"><span class="hs-identifier">unique</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkSystemName</span><span> </span><a href="#local-6989586621681373386"><span class="hs-identifier hs-var">unique</span></a><span> </span><a href="TcMType.html#kind_var_occ"><span class="hs-identifier hs-var">kind_var_occ</span></a><span>
</span><a name="line-138"></a><span>
</span><a name="line-139"></a><span class="hs-identifier">kind_var_occ</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">OccName</span><span> </span><span class="hs-comment">-- Just one for all MetaKindVars</span><span>
</span><a name="line-140"></a><span>                        </span><span class="hs-comment">-- They may be jiggled by tidying</span><span>
</span><a name="line-141"></a><a name="kind_var_occ"><a href="TcMType.html#kind_var_occ"><span class="hs-identifier">kind_var_occ</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkOccName</span><span> </span><span class="hs-identifier hs-var">tvName</span><span> </span><span class="hs-string">&quot;k&quot;</span><span>
</span><a name="line-142"></a><span>
</span><a name="line-143"></a><span class="hs-identifier">newMetaKindVar</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-identifier hs-type">TcKind</span><span>
</span><a name="line-144"></a><a name="newMetaKindVar"><a href="TcMType.html#newMetaKindVar"><span class="hs-identifier">newMetaKindVar</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><a name="local-6989586621681373387"><a href="#local-6989586621681373387"><span class="hs-identifier">uniq</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcRnMonad.html#newUnique"><span class="hs-identifier hs-var">newUnique</span></a><span>
</span><a name="line-145"></a><span>                    </span><span class="hs-special">;</span><span> </span><a name="local-6989586621681373388"><a href="#local-6989586621681373388"><span class="hs-identifier">details</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcMType.html#newMetaDetails"><span class="hs-identifier hs-var">newMetaDetails</span></a><span> </span><span class="hs-identifier hs-var">TauTv</span><span>
</span><a name="line-146"></a><span>                    </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621681373389"><a href="#local-6989586621681373389"><span class="hs-identifier">kv</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkTcTyVar</span><span> </span><span class="hs-special">(</span><a href="TcMType.html#mkKindName"><span class="hs-identifier hs-var">mkKindName</span></a><span> </span><a href="#local-6989586621681373387"><span class="hs-identifier hs-var">uniq</span></a><span class="hs-special">)</span><span> </span><span class="hs-identifier hs-var">liftedTypeKind</span><span> </span><a href="#local-6989586621681373388"><span class="hs-identifier hs-var">details</span></a><span>
</span><a name="line-147"></a><span>                    </span><span class="hs-special">;</span><span> </span><a href="TcRnMonad.html#traceTc"><span class="hs-identifier hs-var">traceTc</span></a><span> </span><span class="hs-string">&quot;newMetaKindVar&quot;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ppr</span><span> </span><a href="#local-6989586621681373389"><span class="hs-identifier hs-var">kv</span></a><span class="hs-special">)</span><span>
</span><a name="line-148"></a><span>                    </span><span class="hs-special">;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">mkTyVarTy</span><span> </span><a href="#local-6989586621681373389"><span class="hs-identifier hs-var">kv</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-149"></a><span>
</span><a name="line-150"></a><span class="hs-identifier">newMetaKindVars</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Int</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TcKind</span><span class="hs-special">]</span><span>
</span><a name="line-151"></a><a name="newMetaKindVars"><a href="TcMType.html#newMetaKindVars"><span class="hs-identifier">newMetaKindVars</span></a></a><span> </span><a name="local-6989586621681373390"><a href="#local-6989586621681373390"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mapM</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="TcMType.html#newMetaKindVar"><span class="hs-identifier hs-var">newMetaKindVar</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">nOfThem</span><span> </span><a href="#local-6989586621681373390"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-152"></a><span>
</span><a name="line-153"></a><span class="hs-comment">{-
************************************************************************
*                                                                      *
     Evidence variables; range over constraints we can abstract over
*                                                                      *
************************************************************************
-}</span><span>
</span><a name="line-160"></a><span>
</span><a name="line-161"></a><span class="hs-identifier">newEvVars</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">TcThetaType</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">EvVar</span><span class="hs-special">]</span><span>
</span><a name="line-162"></a><a name="newEvVars"><a href="TcMType.html#newEvVars"><span class="hs-identifier">newEvVars</span></a></a><span> </span><a name="local-6989586621681373391"><a href="#local-6989586621681373391"><span class="hs-identifier">theta</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mapM</span><span> </span><a href="TcMType.html#newEvVar"><span class="hs-identifier hs-var">newEvVar</span></a><span> </span><a href="#local-6989586621681373391"><span class="hs-identifier hs-var">theta</span></a><span>
</span><a name="line-163"></a><span>
</span><a name="line-164"></a><span class="hs-comment">--------------</span><span>
</span><a name="line-165"></a><span>
</span><a name="line-166"></a><span class="hs-identifier">newEvVar</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">TcPredType</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcRnIf</span><span> </span><a href="#local-6989586621681373384"><span class="hs-identifier hs-type">gbl</span></a><span> </span><a href="#local-6989586621681373385"><span class="hs-identifier hs-type">lcl</span></a><span> </span><span class="hs-identifier hs-type">EvVar</span><span>
</span><a name="line-167"></a><span class="hs-comment">-- Creates new *rigid* variables for predicates</span><span>
</span><a name="line-168"></a><a name="newEvVar"><a href="TcMType.html#newEvVar"><span class="hs-identifier">newEvVar</span></a></a><span> </span><a name="local-6989586621681373392"><a href="#local-6989586621681373392"><span class="hs-identifier">ty</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><a name="local-6989586621681373393"><a href="#local-6989586621681373393"><span class="hs-identifier">name</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcRnMonad.html#newSysName"><span class="hs-identifier hs-var">newSysName</span></a><span> </span><span class="hs-special">(</span><a href="TcMType.html#predTypeOccName"><span class="hs-identifier hs-var">predTypeOccName</span></a><span> </span><a href="#local-6989586621681373392"><span class="hs-identifier hs-var">ty</span></a><span class="hs-special">)</span><span>
</span><a name="line-169"></a><span>                 </span><span class="hs-special">;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">mkLocalIdOrCoVar</span><span> </span><a href="#local-6989586621681373393"><span class="hs-identifier hs-var">name</span></a><span> </span><a href="#local-6989586621681373392"><span class="hs-identifier hs-var">ty</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-170"></a><span>
</span><a name="line-171"></a><span class="hs-identifier">newWanted</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">CtOrigin</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-identifier hs-type">TypeOrKind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">PredType</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-identifier hs-type">CtEvidence</span><span>
</span><a name="line-172"></a><span class="hs-comment">-- Deals with both equality and non-equality predicates</span><span>
</span><a name="line-173"></a><a name="newWanted"><a href="TcMType.html#newWanted"><span class="hs-identifier">newWanted</span></a></a><span> </span><a name="local-6989586621681373394"><a href="#local-6989586621681373394"><span class="hs-identifier">orig</span></a></a><span> </span><a name="local-6989586621681373395"><a href="#local-6989586621681373395"><span class="hs-identifier">t_or_k</span></a></a><span> </span><a name="local-6989586621681373396"><a href="#local-6989586621681373396"><span class="hs-identifier">pty</span></a></a><span>
</span><a name="line-174"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><a name="local-6989586621681373397"><a href="#local-6989586621681373397"><span class="hs-identifier">loc</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcRnMonad.html#getCtLocM"><span class="hs-identifier hs-var">getCtLocM</span></a><span> </span><a href="#local-6989586621681373394"><span class="hs-identifier hs-var">orig</span></a><span> </span><a href="#local-6989586621681373395"><span class="hs-identifier hs-var">t_or_k</span></a><span>
</span><a name="line-175"></a><span>       </span><a name="local-6989586621681373398"><a href="#local-6989586621681373398"><span class="hs-identifier">d</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier hs-var">isEqPred</span><span> </span><a href="#local-6989586621681373396"><span class="hs-identifier hs-var">pty</span></a><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-identifier hs-var">HoleDest</span><span>  </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="TcMType.html#newCoercionHole"><span class="hs-identifier hs-var">newCoercionHole</span></a><span> </span><a href="#local-6989586621681373396"><span class="hs-identifier hs-var">pty</span></a><span>
</span><a name="line-176"></a><span>                            </span><span class="hs-keyword">else</span><span> </span><span class="hs-identifier hs-var">EvVarDest</span><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="TcMType.html#newEvVar"><span class="hs-identifier hs-var">newEvVar</span></a><span> </span><a href="#local-6989586621681373396"><span class="hs-identifier hs-var">pty</span></a><span>
</span><a name="line-177"></a><span>       </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">CtWanted</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">ctev_dest</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373398"><span class="hs-identifier hs-var">d</span></a><span>
</span><a name="line-178"></a><span>                         </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_pred</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373396"><span class="hs-identifier hs-var">pty</span></a><span>
</span><a name="line-179"></a><span>                         </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_nosh</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">WDeriv</span><span>
</span><a name="line-180"></a><span>                         </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_loc</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373397"><span class="hs-identifier hs-var">loc</span></a><span> </span><span class="hs-special">}</span><span>
</span><a name="line-181"></a><span>
</span><a name="line-182"></a><span class="hs-identifier">newWanteds</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">CtOrigin</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">ThetaType</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">CtEvidence</span><span class="hs-special">]</span><span>
</span><a name="line-183"></a><a name="newWanteds"><a href="TcMType.html#newWanteds"><span class="hs-identifier">newWanteds</span></a></a><span> </span><a name="local-6989586621681373399"><a href="#local-6989586621681373399"><span class="hs-identifier">orig</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mapM</span><span> </span><span class="hs-special">(</span><a href="TcMType.html#newWanted"><span class="hs-identifier hs-var">newWanted</span></a><span> </span><a href="#local-6989586621681373399"><span class="hs-identifier hs-var">orig</span></a><span> </span><span class="hs-identifier hs-var">Nothing</span><span class="hs-special">)</span><span>
</span><a name="line-184"></a><span>
</span><a name="line-185"></a><span class="hs-comment">-- | Create a new 'CHoleCan' 'Ct'.</span><span>
</span><a name="line-186"></a><span class="hs-identifier">newHoleCt</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Hole</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Id</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-identifier hs-type">Ct</span><span>
</span><a name="line-187"></a><a name="newHoleCt"><a href="TcMType.html#newHoleCt"><span class="hs-identifier">newHoleCt</span></a></a><span> </span><a name="local-6989586621681373400"><a href="#local-6989586621681373400"><span class="hs-identifier">hole</span></a></a><span> </span><a name="local-6989586621681373401"><a href="#local-6989586621681373401"><span class="hs-identifier">ev</span></a></a><span> </span><a name="local-6989586621681373402"><a href="#local-6989586621681373402"><span class="hs-identifier">ty</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-188"></a><span>  </span><a name="local-6989586621681373403"><a href="#local-6989586621681373403"><span class="hs-identifier">loc</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcRnMonad.html#getCtLocM"><span class="hs-identifier hs-var">getCtLocM</span></a><span> </span><span class="hs-identifier hs-var">HoleOrigin</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span>
</span><a name="line-189"></a><span>  </span><span class="hs-identifier hs-var">pure</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">CHoleCan</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">cc_ev</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">CtWanted</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">ctev_pred</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373402"><span class="hs-identifier hs-var">ty</span></a><span>
</span><a name="line-190"></a><span>                                     </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_dest</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">EvVarDest</span><span> </span><a href="#local-6989586621681373401"><span class="hs-identifier hs-var">ev</span></a><span>
</span><a name="line-191"></a><span>                                     </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_nosh</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">WDeriv</span><span>
</span><a name="line-192"></a><span>                                     </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_loc</span><span>  </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373403"><span class="hs-identifier hs-var">loc</span></a><span> </span><span class="hs-special">}</span><span>
</span><a name="line-193"></a><span>                  </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">cc_hole</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373400"><span class="hs-identifier hs-var">hole</span></a><span> </span><span class="hs-special">}</span><span>
</span><a name="line-194"></a><span>
</span><a name="line-195"></a><span class="hs-comment">----------------------------------------------</span><span>
</span><a name="line-196"></a><span class="hs-comment">-- Cloning constraints</span><span>
</span><a name="line-197"></a><span class="hs-comment">----------------------------------------------</span><span>
</span><a name="line-198"></a><span>
</span><a name="line-199"></a><span class="hs-identifier">cloneWanted</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Ct</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-identifier hs-type">Ct</span><span>
</span><a name="line-200"></a><a name="cloneWanted"><a href="TcMType.html#cloneWanted"><span class="hs-identifier">cloneWanted</span></a></a><span> </span><a name="local-6989586621681373404"><a href="#local-6989586621681373404"><span class="hs-identifier">ct</span></a></a><span>
</span><a name="line-201"></a><span>  </span><span class="hs-glyph">|</span><span> </span><a name="local-6989586621681373405"><a href="#local-6989586621681373405"><span class="hs-identifier">ev</span></a></a><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="hs-identifier hs-var">CtWanted</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">ctev_dest</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">HoleDest</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_pred</span><span> </span><span class="hs-glyph">=</span><span> </span><a name="local-6989586621681373406"><a href="#local-6989586621681373406"><span class="hs-identifier">pty</span></a></a><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">ctEvidence</span><span> </span><a href="#local-6989586621681373404"><span class="hs-identifier hs-var">ct</span></a><span>
</span><a name="line-202"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><a name="local-6989586621681373407"><a href="#local-6989586621681373407"><span class="hs-identifier">co_hole</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcMType.html#newCoercionHole"><span class="hs-identifier hs-var">newCoercionHole</span></a><span> </span><a href="#local-6989586621681373406"><span class="hs-identifier hs-var">pty</span></a><span>
</span><a name="line-203"></a><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">mkNonCanonical</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621681373405"><span class="hs-identifier hs-var">ev</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">ctev_dest</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">HoleDest</span><span> </span><a href="#local-6989586621681373407"><span class="hs-identifier hs-var">co_hole</span></a><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-204"></a><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">otherwise</span><span>
</span><a name="line-205"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><a href="#local-6989586621681373404"><span class="hs-identifier hs-var">ct</span></a><span>
</span><a name="line-206"></a><span>
</span><a name="line-207"></a><span class="hs-identifier">cloneWC</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">WantedConstraints</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-identifier hs-type">WantedConstraints</span><span>
</span><a name="line-208"></a><span class="hs-comment">-- Clone all the evidence bindings in</span><span>
</span><a name="line-209"></a><span class="hs-comment">--   a) the ic_bind field of any implications</span><span>
</span><a name="line-210"></a><span class="hs-comment">--   b) the CoercionHoles of any wanted constraints</span><span>
</span><a name="line-211"></a><span class="hs-comment">-- so that solving the WantedConstraints will not have any visible side</span><span>
</span><a name="line-212"></a><span class="hs-comment">-- effect, /except/ from causing unifications</span><span>
</span><a name="line-213"></a><a name="cloneWC"><a href="TcMType.html#cloneWC"><span class="hs-identifier">cloneWC</span></a></a><span> </span><a name="local-6989586621681373408"><a href="#local-6989586621681373408"><span class="hs-identifier">wc</span></a></a><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="hs-identifier hs-var">WC</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">wc_simple</span><span> </span><span class="hs-glyph">=</span><span> </span><a name="local-6989586621681373409"><a href="#local-6989586621681373409"><span class="hs-identifier">simples</span></a></a><span class="hs-special">,</span><span> </span><span class="hs-identifier">wc_impl</span><span> </span><span class="hs-glyph">=</span><span> </span><a name="local-6989586621681373410"><a href="#local-6989586621681373410"><span class="hs-identifier">implics</span></a></a><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><a name="line-214"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><a name="local-6989586621681373411"><a href="#local-6989586621681373411"><span class="hs-identifier">simples'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">mapBagM</span><span> </span><a href="TcMType.html#cloneWanted"><span class="hs-identifier hs-var">cloneWanted</span></a><span> </span><a href="#local-6989586621681373409"><span class="hs-identifier hs-var">simples</span></a><span>
</span><a name="line-215"></a><span>       </span><span class="hs-special">;</span><span> </span><a name="local-6989586621681373412"><a href="#local-6989586621681373412"><span class="hs-identifier">implics'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">mapBagM</span><span> </span><a href="TcMType.html#cloneImplication"><span class="hs-identifier hs-var">cloneImplication</span></a><span> </span><a href="#local-6989586621681373410"><span class="hs-identifier hs-var">implics</span></a><span>
</span><a name="line-216"></a><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621681373408"><span class="hs-identifier hs-var">wc</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">wc_simple</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373411"><span class="hs-identifier hs-var">simples'</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier">wc_impl</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373412"><span class="hs-identifier hs-var">implics'</span></a><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-217"></a><span>
</span><a name="line-218"></a><span class="hs-identifier">cloneImplication</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Implication</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-identifier hs-type">Implication</span><span>
</span><a name="line-219"></a><a name="cloneImplication"><a href="TcMType.html#cloneImplication"><span class="hs-identifier">cloneImplication</span></a></a><span> </span><a name="local-6989586621681373413"><a href="#local-6989586621681373413"><span class="hs-identifier">implic</span></a></a><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="hs-identifier hs-var">Implic</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">ic_binds</span><span> </span><span class="hs-glyph">=</span><span> </span><a name="local-6989586621681373414"><a href="#local-6989586621681373414"><span class="hs-identifier">binds</span></a></a><span class="hs-special">,</span><span> </span><span class="hs-identifier">ic_wanted</span><span> </span><span class="hs-glyph">=</span><span> </span><a name="local-6989586621681373415"><a href="#local-6989586621681373415"><span class="hs-identifier">inner_wanted</span></a></a><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><a name="line-220"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><a name="local-6989586621681373416"><a href="#local-6989586621681373416"><span class="hs-identifier">binds'</span></a></a><span>        </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcRnMonad.html#cloneEvBindsVar"><span class="hs-identifier hs-var">cloneEvBindsVar</span></a><span> </span><a href="#local-6989586621681373414"><span class="hs-identifier hs-var">binds</span></a><span>
</span><a name="line-221"></a><span>       </span><span class="hs-special">;</span><span> </span><a name="local-6989586621681373417"><a href="#local-6989586621681373417"><span class="hs-identifier">inner_wanted'</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcMType.html#cloneWC"><span class="hs-identifier hs-var">cloneWC</span></a><span> </span><a href="#local-6989586621681373415"><span class="hs-identifier hs-var">inner_wanted</span></a><span>
</span><a name="line-222"></a><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621681373413"><span class="hs-identifier hs-var">implic</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">ic_binds</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373416"><span class="hs-identifier hs-var">binds'</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier">ic_wanted</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373417"><span class="hs-identifier hs-var">inner_wanted'</span></a><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-223"></a><span>
</span><a name="line-224"></a><span class="hs-comment">----------------------------------------------</span><span>
</span><a name="line-225"></a><span class="hs-comment">-- Emitting constraints</span><span>
</span><a name="line-226"></a><span class="hs-comment">----------------------------------------------</span><span>
</span><a name="line-227"></a><span>
</span><a name="line-228"></a><span class="hs-comment">-- | Emits a new Wanted. Deals with both equalities and non-equalities.</span><span>
</span><a name="line-229"></a><span class="hs-identifier">emitWanted</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">CtOrigin</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcPredType</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-identifier hs-type">EvTerm</span><span>
</span><a name="line-230"></a><a name="emitWanted"><a href="TcMType.html#emitWanted"><span class="hs-identifier">emitWanted</span></a></a><span> </span><a name="local-6989586621681373418"><a href="#local-6989586621681373418"><span class="hs-identifier">origin</span></a></a><span> </span><a name="local-6989586621681373419"><a href="#local-6989586621681373419"><span class="hs-identifier">pty</span></a></a><span>
</span><a name="line-231"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><a name="local-6989586621681373420"><a href="#local-6989586621681373420"><span class="hs-identifier">ev</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcMType.html#newWanted"><span class="hs-identifier hs-var">newWanted</span></a><span> </span><a href="#local-6989586621681373418"><span class="hs-identifier hs-var">origin</span></a><span> </span><span class="hs-identifier hs-var">Nothing</span><span> </span><a href="#local-6989586621681373419"><span class="hs-identifier hs-var">pty</span></a><span>
</span><a name="line-232"></a><span>       </span><span class="hs-special">;</span><span> </span><a href="TcRnMonad.html#emitSimple"><span class="hs-identifier hs-var">emitSimple</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">mkNonCanonical</span><span> </span><a href="#local-6989586621681373420"><span class="hs-identifier hs-var">ev</span></a><span>
</span><a name="line-233"></a><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">ctEvTerm</span><span> </span><a href="#local-6989586621681373420"><span class="hs-identifier hs-var">ev</span></a><span> </span><span class="hs-special">}</span><span>
</span><a name="line-234"></a><span>
</span><a name="line-235"></a><span class="hs-identifier">emitDerivedEqs</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">CtOrigin</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="hs-identifier hs-type">TcType</span><span class="hs-special">,</span><span class="hs-identifier hs-type">TcType</span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-236"></a><span class="hs-comment">-- Emit some new derived nominal equalities</span><span>
</span><a name="line-237"></a><a name="emitDerivedEqs"><a href="TcMType.html#emitDerivedEqs"><span class="hs-identifier">emitDerivedEqs</span></a></a><span> </span><a name="local-6989586621681373421"><a href="#local-6989586621681373421"><span class="hs-identifier">origin</span></a></a><span> </span><a name="local-6989586621681373422"><a href="#local-6989586621681373422"><span class="hs-identifier">pairs</span></a></a><span>
</span><a name="line-238"></a><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">null</span><span> </span><a href="#local-6989586621681373422"><span class="hs-identifier hs-var">pairs</span></a><span>
</span><a name="line-239"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-240"></a><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier hs-var">otherwise</span><span>
</span><a name="line-241"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><a name="local-6989586621681373427"><a href="#local-6989586621681373427"><span class="hs-identifier">loc</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcRnMonad.html#getCtLocM"><span class="hs-identifier hs-var">getCtLocM</span></a><span> </span><a href="#local-6989586621681373421"><span class="hs-identifier hs-var">origin</span></a><span> </span><span class="hs-identifier hs-var">Nothing</span><span>
</span><a name="line-242"></a><span>       </span><span class="hs-special">;</span><span> </span><a href="TcRnMonad.html#emitSimples"><span class="hs-identifier hs-var">emitSimples</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">listToBag</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621681373423"><span class="hs-identifier hs-var">mk_one</span></a><span> </span><a href="#local-6989586621681373427"><span class="hs-identifier hs-var">loc</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621681373422"><span class="hs-identifier hs-var">pairs</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-243"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-244"></a><span>    </span><a name="local-6989586621681373423"><a href="#local-6989586621681373423"><span class="hs-identifier">mk_one</span></a></a><span> </span><a name="local-6989586621681373424"><a href="#local-6989586621681373424"><span class="hs-identifier">loc</span></a></a><span> </span><span class="hs-special">(</span><a name="local-6989586621681373425"><a href="#local-6989586621681373425"><span class="hs-identifier">ty1</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621681373426"><a href="#local-6989586621681373426"><span class="hs-identifier">ty2</span></a></a><span class="hs-special">)</span><span>
</span><a name="line-245"></a><span>       </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkNonCanonical</span><span> </span><span class="hs-operator hs-var">$</span><span>
</span><a name="line-246"></a><span>         </span><span class="hs-identifier hs-var">CtDerived</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">ctev_pred</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkPrimEqPred</span><span> </span><a href="#local-6989586621681373425"><span class="hs-identifier hs-var">ty1</span></a><span> </span><a href="#local-6989586621681373426"><span class="hs-identifier hs-var">ty2</span></a><span>
</span><a name="line-247"></a><span>                   </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_loc</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373424"><span class="hs-identifier hs-var">loc</span></a><span> </span><span class="hs-special">}</span><span>
</span><a name="line-248"></a><span>
</span><a name="line-249"></a><span class="hs-comment">-- | Emits a new equality constraint</span><span>
</span><a name="line-250"></a><span class="hs-identifier">emitWantedEq</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">CtOrigin</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TypeOrKind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Role</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcType</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcType</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-identifier hs-type">Coercion</span><span>
</span><a name="line-251"></a><a name="emitWantedEq"><a href="TcMType.html#emitWantedEq"><span class="hs-identifier">emitWantedEq</span></a></a><span> </span><a name="local-6989586621681373428"><a href="#local-6989586621681373428"><span class="hs-identifier">origin</span></a></a><span> </span><a name="local-6989586621681373429"><a href="#local-6989586621681373429"><span class="hs-identifier">t_or_k</span></a></a><span> </span><span class="hs-keyword">role</span><span> </span><a name="local-6989586621681373431"><a href="#local-6989586621681373431"><span class="hs-identifier">ty1</span></a></a><span> </span><a name="local-6989586621681373432"><a href="#local-6989586621681373432"><span class="hs-identifier">ty2</span></a></a><span>
</span><a name="line-252"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><a name="local-6989586621681373434"><a href="#local-6989586621681373434"><span class="hs-identifier">hole</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcMType.html#newCoercionHole"><span class="hs-identifier hs-var">newCoercionHole</span></a><span> </span><a href="#local-6989586621681373433"><span class="hs-identifier hs-var">pty</span></a><span>
</span><a name="line-253"></a><span>       </span><span class="hs-special">;</span><span> </span><a name="local-6989586621681373435"><a href="#local-6989586621681373435"><span class="hs-identifier">loc</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcRnMonad.html#getCtLocM"><span class="hs-identifier hs-var">getCtLocM</span></a><span> </span><a href="#local-6989586621681373428"><span class="hs-identifier hs-var">origin</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Just</span><span> </span><a href="#local-6989586621681373429"><span class="hs-identifier hs-var">t_or_k</span></a><span class="hs-special">)</span><span>
</span><a name="line-254"></a><span>       </span><span class="hs-special">;</span><span> </span><a href="TcRnMonad.html#emitSimple"><span class="hs-identifier hs-var">emitSimple</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">mkNonCanonical</span><span> </span><span class="hs-operator hs-var">$</span><span>
</span><a name="line-255"></a><span>         </span><span class="hs-identifier hs-var">CtWanted</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">ctev_pred</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373433"><span class="hs-identifier hs-var">pty</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_dest</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">HoleDest</span><span> </span><a href="#local-6989586621681373434"><span class="hs-identifier hs-var">hole</span></a><span>
</span><a name="line-256"></a><span>                  </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_nosh</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">WDeriv</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_loc</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373435"><span class="hs-identifier hs-var">loc</span></a><span> </span><span class="hs-special">}</span><span>
</span><a name="line-257"></a><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">HoleCo</span><span> </span><a href="#local-6989586621681373434"><span class="hs-identifier hs-var">hole</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-258"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a name="line-259"></a><span>    </span><a name="local-6989586621681373433"><a href="#local-6989586621681373433"><span class="hs-identifier">pty</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mkPrimEqPredRole</span><span> </span><span class="hs-keyword">role</span><span> </span><a href="#local-6989586621681373431"><span class="hs-identifier hs-var">ty1</span></a><span> </span><a href="#local-6989586621681373432"><span class="hs-identifier hs-var">ty2</span></a><span>
</span><a name="line-260"></a><span>
</span><a name="line-261"></a><span class="hs-comment">-- | Creates a new EvVar and immediately emits it as a Wanted.</span><span>
</span><a name="line-262"></a><span class="hs-comment">-- No equality predicates here.</span><span>
</span><a name="line-263"></a><span class="hs-identifier">emitWantedEvVar</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">CtOrigin</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcPredType</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-identifier hs-type">EvVar</span><span>
</span><a name="line-264"></a><a name="emitWantedEvVar"><a href="TcMType.html#emitWantedEvVar"><span class="hs-identifier">emitWantedEvVar</span></a></a><span> </span><a name="local-6989586621681373436"><a href="#local-6989586621681373436"><span class="hs-identifier">origin</span></a></a><span> </span><a name="local-6989586621681373437"><a href="#local-6989586621681373437"><span class="hs-identifier">ty</span></a></a><span>
</span><a name="line-265"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><a name="local-6989586621681373438"><a href="#local-6989586621681373438"><span class="hs-identifier">new_cv</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcMType.html#newEvVar"><span class="hs-identifier hs-var">newEvVar</span></a><span> </span><a href="#local-6989586621681373437"><span class="hs-identifier hs-var">ty</span></a><span>
</span><a name="line-266"></a><span>       </span><span class="hs-special">;</span><span> </span><a name="local-6989586621681373439"><a href="#local-6989586621681373439"><span class="hs-identifier">loc</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcRnMonad.html#getCtLocM"><span class="hs-identifier hs-var">getCtLocM</span></a><span> </span><a href="#local-6989586621681373436"><span class="hs-identifier hs-var">origin</span></a><span> </span><span class="hs-identifier hs-var">Nothing</span><span>
</span><a name="line-267"></a><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621681373440"><a href="#local-6989586621681373440"><span class="hs-identifier">ctev</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">CtWanted</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">ctev_dest</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">EvVarDest</span><span> </span><a href="#local-6989586621681373438"><span class="hs-identifier hs-var">new_cv</span></a><span>
</span><a name="line-268"></a><span>                             </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_pred</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373437"><span class="hs-identifier hs-var">ty</span></a><span>
</span><a name="line-269"></a><span>                             </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_nosh</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">WDeriv</span><span>
</span><a name="line-270"></a><span>                             </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">ctev_loc</span><span>  </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373439"><span class="hs-identifier hs-var">loc</span></a><span> </span><span class="hs-special">}</span><span>
</span><a name="line-271"></a><span>       </span><span class="hs-special">;</span><span> </span><a href="TcRnMonad.html#emitSimple"><span class="hs-identifier hs-var">emitSimple</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">mkNonCanonical</span><span> </span><a href="#local-6989586621681373440"><span class="hs-identifier hs-var">ctev</span></a><span>
</span><a name="line-272"></a><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><a href="#local-6989586621681373438"><span class="hs-identifier hs-var">new_cv</span></a><span> </span><span class="hs-special">}</span><span>
</span><a name="line-273"></a><span>
</span><a name="line-274"></a><span class="hs-identifier">emitWantedEvVars</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">CtOrigin</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TcPredType</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">EvVar</span><span class="hs-special">]</span><span>
</span><a name="line-275"></a><a name="emitWantedEvVars"><a href="TcMType.html#emitWantedEvVars"><span class="hs-identifier">emitWantedEvVars</span></a></a><span> </span><a name="local-6989586621681373441"><a href="#local-6989586621681373441"><span class="hs-identifier">orig</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">mapM</span><span> </span><span class="hs-special">(</span><a href="TcMType.html#emitWantedEvVar"><span class="hs-identifier hs-var">emitWantedEvVar</span></a><span> </span><a href="#local-6989586621681373441"><span class="hs-identifier hs-var">orig</span></a><span class="hs-special">)</span><span>
</span><a name="line-276"></a><span>
</span><a name="line-277"></a><span class="hs-identifier">newDict</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Class</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">TcType</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-identifier hs-type">DictId</span><span>
</span><a name="line-278"></a><a name="newDict"><a href="TcMType.html#newDict"><span class="hs-identifier">newDict</span></a></a><span> </span><a name="local-6989586621681373442"><a href="#local-6989586621681373442"><span class="hs-identifier">cls</span></a></a><span> </span><a name="local-6989586621681373443"><a href="#local-6989586621681373443"><span class="hs-identifier">tys</span></a></a><span>
</span><a name="line-279"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><a name="local-6989586621681373444"><a href="#local-6989586621681373444"><span class="hs-identifier">name</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcRnMonad.html#newSysName"><span class="hs-identifier hs-var">newSysName</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">mkDictOcc</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">getOccName</span><span> </span><a href="#local-6989586621681373442"><span class="hs-identifier hs-var">cls</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-280"></a><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">mkLocalId</span><span> </span><a href="#local-6989586621681373444"><span class="hs-identifier hs-var">name</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">mkClassPred</span><span> </span><a href="#local-6989586621681373442"><span class="hs-identifier hs-var">cls</span></a><span> </span><a href="#local-6989586621681373443"><span class="hs-identifier hs-var">tys</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-281"></a><span>
</span><a name="line-282"></a><span class="hs-identifier">predTypeOccName</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">PredType</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">OccName</span><span>
</span><a name="line-283"></a><a name="predTypeOccName"><a href="TcMType.html#predTypeOccName"><span class="hs-identifier">predTypeOccName</span></a></a><span> </span><a name="local-6989586621681373445"><a href="#local-6989586621681373445"><span class="hs-identifier">ty</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier hs-var">classifyPredType</span><span> </span><a href="#local-6989586621681373445"><span class="hs-identifier hs-var">ty</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a name="line-284"></a><span>    </span><span class="hs-identifier hs-var">ClassPred</span><span> </span><a name="local-6989586621681373446"><a href="#local-6989586621681373446"><span class="hs-identifier">cls</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">mkDictOcc</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">getOccName</span><span> </span><a href="#local-6989586621681373446"><span class="hs-identifier hs-var">cls</span></a><span class="hs-special">)</span><span>
</span><a name="line-285"></a><span>    </span><span class="hs-identifier hs-var">EqPred</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">mkVarOccFS</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">fsLit</span><span> </span><span class="hs-string">&quot;co&quot;</span><span class="hs-special">)</span><span>
</span><a name="line-286"></a><span>    </span><span class="hs-identifier hs-var">IrredPred</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">mkVarOccFS</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">fsLit</span><span> </span><span class="hs-string">&quot;irred&quot;</span><span class="hs-special">)</span><span>
</span><a name="line-287"></a><span>    </span><span class="hs-identifier hs-var">ForAllPred</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">mkVarOccFS</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">fsLit</span><span> </span><span class="hs-string">&quot;df&quot;</span><span class="hs-special">)</span><span>
</span><a name="line-288"></a><span>
</span><a name="line-289"></a><span class="hs-comment">{-
************************************************************************
*                                                                      *
        Coercion holes
*                                                                      *
************************************************************************
-}</span><span>
</span><a name="line-296"></a><span>
</span><a name="line-297"></a><span class="hs-identifier">newCoercionHole</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">TcPredType</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-identifier hs-type">CoercionHole</span><span>
</span><a name="line-298"></a><a name="newCoercionHole"><a href="TcMType.html#newCoercionHole"><span class="hs-identifier">newCoercionHole</span></a></a><span> </span><a name="local-6989586621681373447"><a href="#local-6989586621681373447"><span class="hs-identifier">pred_ty</span></a></a><span>
</span><a name="line-299"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><a name="local-6989586621681373448"><a href="#local-6989586621681373448"><span class="hs-identifier">co_var</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="TcMType.html#newEvVar"><span class="hs-identifier hs-var">newEvVar</span></a><span> </span><a href="#local-6989586621681373447"><span class="hs-identifier hs-var">pred_ty</span></a><span>
</span><a name="line-300"></a><span>       </span><span class="hs-special">;</span><span> </span><a href="TcRnMonad.html#traceTc"><span class="hs-identifier hs-var">traceTc</span></a><span> </span><span class="hs-string">&quot;New coercion hole:&quot;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ppr</span><span> </span><a href="#local-6989586621681373448"><span class="hs-identifier hs-var">co_var</span></a><span class="hs-special">)</span><span>
</span><a name="line-301"></a><span>       </span><span class="hs-special">;</span><span> </span><a name="local-6989586621681373449"><a href="#local-6989586621681373449"><span class="hs-identifier">ref</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">newMutVar</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span>
</span><a name="line-302"></a><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">CoercionHole</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">ch_co_var</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373448"><span class="hs-identifier hs-var">co_var</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier">ch_ref</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621681373449"><span class="hs-identifier hs-var">ref</span></a><span> </span><span class="hs-special">}</span><span> </span><span class="hs-special">}</span><span>
</span><a name="line-303"></a><span>
</span><a name="line-304"></a><span class="hs-comment">-- | Put a value in a coercion hole</span><span>
</span><a name="line-305"></a><span class="hs-identifier">fillCoercionHole</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">CoercionHole</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Coercion</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">TcM</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-306"></a><a name="fillCoercionHole"><a href="TcMType.html#fillCoercionHole"><span class="hs-identifier">fillCoercionHole</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">CoercionHole</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">ch_ref</span><span> </span><span class="hs-glyph">=</span><span> </span><a name="local-6989586621681373450"><a href="#local-6989586621681373450"><span class="hs-identifier">ref</span></a></a><span class="hs-special">,</span><span> </span><span class="hs-identifier">ch_co_var</span><span> </span><span class="hs-glyph">=</span><span> </span><a name="local-6989586621681373451"><a href="#local-6989586621681373451"><span class="hs-identifier">cv</span></a></a><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><a name="local-6989586621681373452"><a href="#local-6989586621681373452"><span class="hs-identifier">co</span></a></a><span>
</span><a name="line-307"></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span>
</span><a name="line-308"></a><span class="hs-cpp">#if defined(DEBUG)
</span><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-identifier">cts</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">readTcRef</span><span> </span><span class="hs-identifier">ref</span><span>
</span><a name="line-310"></a><span>       </span><span class="hs-special">;</span><span> </span><span class="hs-identifier">whenIsJust</span><span> </span><span class="hs-identifier">cts</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-glyph">\</span><span class="hs-identifier">old_co</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><a name="line-311"></a><span>         </span><span class="hs-identifier">pprPanic</span><span> </span><span class="hs-string">&quot;Filling a filled coercion hole&quot;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ppr</span><span> </span><span class="hs-identifier">cv</span><span> </span><span class="hs-operator">$$</span><span> </span><span class="hs-identifier">ppr</span><span> </span><span class="hs-identifier">co</span><span> </span><span class="hs-operator">$$</span><span> </span><span class="hs-identifier">ppr</span><span> </span><span class="hs-identifier">old_co</span><span class="hs-special">)</span><span>
</span><a name="line-312"></a><span class="hs-cpp">#endif
</span><span class="">       ; traceTc &quot;Filling coercion hole&quot; (ppr cv &lt;+&gt; text &quot;:=&quot; &lt;+&gt; ppr co)
       ; writeTcRef ref (Just co) }

-- | Is a coercion hole filled in?
isFilledCoercionHole :: CoercionHole -&gt; TcM Bool
isFilledCoercionHole (CoercionHole { ch_ref = ref }) = isJust &lt;$&gt; readTcRef ref

-- | Retrieve the contents of a coercion hole. Panics if the hole
-- is unfilled
unpackCoercionHole :: CoercionHole -&gt; TcM Coercion
unpackCoercionHole hole
  = do { contents &lt;- unpackCoercionHole_maybe hole
       ; case contents of
           Just co -&gt; return co
           Nothing -&gt; pprPanic &quot;Unfilled coercion hole&quot; (ppr hole) }

-- | Retrieve the contents of a coercion hole, if it is filled
unpackCoercionHole_maybe :: CoercionHole -&gt; TcM (Maybe Coercion)
unpackCoercionHole_maybe (CoercionHole { ch_ref = ref }) = readTcRef ref

-- | Check that a coercion is appropriate for filling a hole. (The hole
-- itself is needed only for printing.
-- Always returns the checked coercion, but this return value is necessary
-- so that the input coercion is forced only when the output is forced.
checkCoercionHole :: CoVar -&gt; Coercion -&gt; TcM Coercion
checkCoercionHole cv co
  | debugIsOn
  = do { cv_ty &lt;- zonkTcType (varType cv)
                  -- co is already zonked, but cv might not be
       ; return $
         ASSERT2( ok cv_ty
                , (text &quot;Bad coercion hole&quot; &lt;+&gt;
                   ppr cv &lt;&gt; colon &lt;+&gt; vcat [ ppr t1, ppr t2, ppr role
                                            , ppr cv_ty ]) )
         co }
  | otherwise
  = return co

  where
    (Pair t1 t2, role) = coercionKindRole co
    ok cv_ty | EqPred cv_rel cv_t1 cv_t2 &lt;- classifyPredType cv_ty
             =  t1 `eqType` cv_t1
             &amp;&amp; t2 `eqType` cv_t2
             &amp;&amp; role == eqRelRole cv_rel
             | otherwise
             = False

{-
************************************************************************
*
    Expected types
*
************************************************************************

Note [ExpType]
~~~~~~~~~~~~~~

An ExpType is used as the &quot;expected type&quot; when type-checking an expression.
An ExpType can hold a &quot;hole&quot; that can be filled in by the type-checker.
This allows us to have one tcExpr that works in both checking mode and
synthesis mode (that is, bidirectional type-checking). Previously, this
was achieved by using ordinary unification variables, but we don't need
or want that generality. (For example, #11397 was caused by doing the
wrong thing with unification variables.) Instead, we observe that these
holes should

1. never be nested
2. never appear as the type of a variable
3. be used linearly (never be duplicated)

By defining ExpType, separately from Type, we can achieve goals 1 and 2
statically.

See also [wiki:Typechecking]

Note [TcLevel of ExpType]
~~~~~~~~~~~~~~~~~~~~~~~~~
Consider

  data G a where
    MkG :: G Bool

  foo MkG = True

This is a classic untouchable-variable / ambiguous GADT return type
scenario. But, with ExpTypes, we'll be inferring the type of the RHS.
And, because there is only one branch of the case, we won't trigger
Note [Case branches must never infer a non-tau type] of TcMatches.
We thus must track a TcLevel in an Inferring ExpType. If we try to
fill the ExpType and find that the TcLevels don't work out, we
fill the ExpType with a tau-tv at the low TcLevel, hopefully to
be worked out later by some means. This is triggered in
test gadt/gadt-escape1.

-}

-- actual data definition is in TcType

-- | Make an 'ExpType' suitable for inferring a type of kind * or #.
newInferExpTypeNoInst :: TcM ExpSigmaType
newInferExpTypeNoInst = newInferExpType False

newInferExpTypeInst :: TcM ExpRhoType
newInferExpTypeInst = newInferExpType True

newInferExpType :: Bool -&gt; TcM ExpType
newInferExpType inst
  = do { u &lt;- newUnique
       ; tclvl &lt;- getTcLevel
       ; traceTc &quot;newOpenInferExpType&quot; (ppr u &lt;+&gt; ppr inst &lt;+&gt; ppr tclvl)
       ; ref &lt;- newMutVar Nothing
       ; return (Infer (IR { ir_uniq = u, ir_lvl = tclvl
                           , ir_ref = ref, ir_inst = inst })) }

-- | Extract a type out of an ExpType, if one exists. But one should always
-- exist. Unless you're quite sure you know what you're doing.
readExpType_maybe :: ExpType -&gt; TcM (Maybe TcType)
readExpType_maybe (Check ty)                   = return (Just ty)
readExpType_maybe (Infer (IR { ir_ref = ref})) = readMutVar ref

-- | Extract a type out of an ExpType. Otherwise, panics.
readExpType :: ExpType -&gt; TcM TcType
readExpType exp_ty
  = do { mb_ty &lt;- readExpType_maybe exp_ty
       ; case mb_ty of
           Just ty -&gt; return ty
           Nothing -&gt; pprPanic &quot;Unknown expected type&quot; (ppr exp_ty) }

-- | Returns the expected type when in checking mode.
checkingExpType_maybe :: ExpType -&gt; Maybe TcType
checkingExpType_maybe (Check ty) = Just ty
checkingExpType_maybe _          = Nothing

-- | Returns the expected type when in checking mode. Panics if in inference
-- mode.
checkingExpType :: String -&gt; ExpType -&gt; TcType
checkingExpType _   (Check ty) = ty
checkingExpType err et         = pprPanic &quot;checkingExpType&quot; (text err $$ ppr et)

tauifyExpType :: ExpType -&gt; TcM ExpType
-- ^ Turn a (Infer hole) type into a (Check alpha),
-- where alpha is a fresh unification variable
tauifyExpType (Check ty)      = return (Check ty)  -- No-op for (Check ty)
tauifyExpType (Infer inf_res) = do { ty &lt;- inferResultToType inf_res
                                   ; return (Check ty) }

-- | Extracts the expected type if there is one, or generates a new
-- TauTv if there isn't.
expTypeToType :: ExpType -&gt; TcM TcType
expTypeToType (Check ty)      = return ty
expTypeToType (Infer inf_res) = inferResultToType inf_res

inferResultToType :: InferResult -&gt; TcM Type
inferResultToType (IR { ir_uniq = u, ir_lvl = tc_lvl
                      , ir_ref = ref })
  = do { rr  &lt;- newMetaTyVarTyAtLevel tc_lvl runtimeRepTy
       ; tau &lt;- newMetaTyVarTyAtLevel tc_lvl (tYPE rr)
             -- See Note [TcLevel of ExpType]
       ; writeMutVar ref (Just tau)
       ; traceTc &quot;Forcing ExpType to be monomorphic:&quot;
                 (ppr u &lt;+&gt; text &quot;:=&quot; &lt;+&gt; ppr tau)
       ; return tau }


{- *********************************************************************
*                                                                      *
        SkolemTvs (immutable)
*                                                                      *
********************************************************************* -}

tcInstType :: ([TyVar] -&gt; TcM (TCvSubst, [TcTyVar]))
                   -- ^ How to instantiate the type variables
           -&gt; Id                                            -- ^ Type to instantiate
           -&gt; TcM ([(Name, TcTyVar)], TcThetaType, TcType)  -- ^ Result
                -- (type vars, preds (incl equalities), rho)
tcInstType inst_tyvars id
  = case tcSplitForAllTys (idType id) of
        ([],    rho) -&gt; let     -- There may be overloading despite no type variables;
                                --      (?x :: Int) =&gt; Int -&gt; Int
                                (theta, tau) = tcSplitPhiTy rho
                            in
                            return ([], theta, tau)

        (tyvars, rho) -&gt; do { (subst, tyvars') &lt;- inst_tyvars tyvars
                            ; let (theta, tau) = tcSplitPhiTy (substTyAddInScope subst rho)
                                  tv_prs       = map tyVarName tyvars `zip` tyvars'
                            ; return (tv_prs, theta, tau) }

tcSkolDFunType :: DFunId -&gt; TcM ([TcTyVar], TcThetaType, TcType)
-- Instantiate a type signature with skolem constants.
-- We could give them fresh names, but no need to do so
tcSkolDFunType dfun
  = do { (tv_prs, theta, tau) &lt;- tcInstType tcInstSuperSkolTyVars dfun
       ; return (map snd tv_prs, theta, tau) }

tcSuperSkolTyVars :: [TyVar] -&gt; (TCvSubst, [TcTyVar])
-- Make skolem constants, but do *not* give them new names, as above
-- Moreover, make them &quot;super skolems&quot;; see comments with superSkolemTv
-- see Note [Kind substitution when instantiating]
-- Precondition: tyvars should be ordered by scoping
tcSuperSkolTyVars = mapAccumL tcSuperSkolTyVar emptyTCvSubst

tcSuperSkolTyVar :: TCvSubst -&gt; TyVar -&gt; (TCvSubst, TcTyVar)
tcSuperSkolTyVar subst tv
  = (extendTvSubstWithClone subst tv new_tv, new_tv)
  where
    kind   = substTyUnchecked subst (tyVarKind tv)
    new_tv = mkTcTyVar (tyVarName tv) kind superSkolemTv

-- | Given a list of @['TyVar']@, skolemize the type variables,
-- returning a substitution mapping the original tyvars to the
-- skolems, and the list of newly bound skolems.
tcInstSkolTyVars :: [TyVar] -&gt; TcM (TCvSubst, [TcTyVar])
-- See Note [Skolemising type variables]
tcInstSkolTyVars = tcInstSkolTyVarsX emptyTCvSubst

tcInstSkolTyVarsX :: TCvSubst -&gt; [TyVar] -&gt; TcM (TCvSubst, [TcTyVar])
-- See Note [Skolemising type variables]
tcInstSkolTyVarsX = tcInstSkolTyVarsPushLevel False

tcInstSuperSkolTyVars :: [TyVar] -&gt; TcM (TCvSubst, [TcTyVar])
-- See Note [Skolemising type variables]
tcInstSuperSkolTyVars = tcInstSuperSkolTyVarsX emptyTCvSubst

tcInstSuperSkolTyVarsX :: TCvSubst -&gt; [TyVar] -&gt; TcM (TCvSubst, [TcTyVar])
-- See Note [Skolemising type variables]
tcInstSuperSkolTyVarsX subst = tcInstSkolTyVarsPushLevel True subst

tcInstSkolTyVarsPushLevel :: Bool -&gt; TCvSubst -&gt; [TyVar]
                          -&gt; TcM (TCvSubst, [TcTyVar])
-- Skolemise one level deeper, hence pushTcLevel
-- See Note [Skolemising type variables]
tcInstSkolTyVarsPushLevel overlappable subst tvs
  = do { tc_lvl &lt;- getTcLevel
       ; let pushed_lvl = pushTcLevel tc_lvl
       ; tcInstSkolTyVarsAt pushed_lvl overlappable subst tvs }

tcInstSkolTyVarsAt :: TcLevel -&gt; Bool
                   -&gt; TCvSubst -&gt; [TyVar]
                   -&gt; TcM (TCvSubst, [TcTyVar])
tcInstSkolTyVarsAt lvl overlappable subst tvs
  = freshenTyCoVarsX new_skol_tv subst tvs
  where
    details = SkolemTv lvl overlappable
    new_skol_tv name kind = mkTcTyVar name kind details

------------------
freshenTyVarBndrs :: [TyVar] -&gt; TcM (TCvSubst, [TyVar])
-- ^ Give fresh uniques to a bunch of TyVars, but they stay
--   as TyVars, rather than becoming TcTyVars
-- Used in FamInst.newFamInst, and Inst.newClsInst
freshenTyVarBndrs = freshenTyCoVars mkTyVar

freshenCoVarBndrsX :: TCvSubst -&gt; [CoVar] -&gt; TcM (TCvSubst, [CoVar])
-- ^ Give fresh uniques to a bunch of CoVars
-- Used in FamInst.newFamInst
freshenCoVarBndrsX subst = freshenTyCoVarsX mkCoVar subst

------------------
freshenTyCoVars :: (Name -&gt; Kind -&gt; TyCoVar)
                -&gt; [TyVar] -&gt; TcM (TCvSubst, [TyCoVar])
freshenTyCoVars mk_tcv = freshenTyCoVarsX mk_tcv emptyTCvSubst

freshenTyCoVarsX :: (Name -&gt; Kind -&gt; TyCoVar)
                 -&gt; TCvSubst -&gt; [TyCoVar]
                 -&gt; TcM (TCvSubst, [TyCoVar])
freshenTyCoVarsX mk_tcv = mapAccumLM (freshenTyCoVarX mk_tcv)

freshenTyCoVarX :: (Name -&gt; Kind -&gt; TyCoVar)
                -&gt; TCvSubst -&gt; TyCoVar -&gt; TcM (TCvSubst, TyCoVar)
-- This a complete freshening operation:
-- the skolems have a fresh unique, and a location from the monad
-- See Note [Skolemising type variables]
freshenTyCoVarX mk_tcv subst tycovar
  = do { loc  &lt;- getSrcSpanM
       ; uniq &lt;- newUnique
       ; let old_name = tyVarName tycovar
             new_name = mkInternalName uniq (getOccName old_name) loc
             new_kind = substTyUnchecked subst (tyVarKind tycovar)
             new_tcv  = mk_tcv new_name new_kind
             subst1   = extendTCvSubstWithClone subst tycovar new_tcv
       ; return (subst1, new_tcv) }

{- Note [Skolemising type variables]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The tcInstSkolTyVars family of functions instantiate a list of TyVars
to fresh skolem TcTyVars. Important notes:

a) Level allocation. We generally skolemise /before/ calling
   pushLevelAndCaptureConstraints.  So we want their level to the level
   of the soon-to-be-created implication, which has a level ONE HIGHER
   than the current level.  Hence the pushTcLevel.  It feels like a
   slight hack.

b) The [TyVar] should be ordered (kind vars first)
   See Note [Kind substitution when instantiating]

c) It's a complete freshening operation: the skolems have a fresh
   unique, and a location from the monad

d) The resulting skolems are
        non-overlappable for tcInstSkolTyVars,
   but overlappable for tcInstSuperSkolTyVars
   See TcDerivInfer Note [Overlap and deriving] for an example
   of where this matters.

Note [Kind substitution when instantiating]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When we instantiate a bunch of kind and type variables, first we
expect them to be topologically sorted.
Then we have to instantiate the kind variables, build a substitution
from old variables to the new variables, then instantiate the type
variables substituting the original kind.

Exemple: If we want to instantiate
  [(k1 :: *), (k2 :: *), (a :: k1 -&gt; k2), (b :: k1)]
we want
  [(?k1 :: *), (?k2 :: *), (?a :: ?k1 -&gt; ?k2), (?b :: ?k1)]
instead of the buggous
  [(?k1 :: *), (?k2 :: *), (?a :: k1 -&gt; k2), (?b :: k1)]


************************************************************************
*                                                                      *
        MetaTvs (meta type variables; mutable)
*                                                                      *
************************************************************************
-}

{-
Note [TyVarTv]
~~~~~~~~~~~~

A TyVarTv can unify with type *variables* only, including other TyVarTvs and
skolems. Sometimes, they can unify with type variables that the user would
rather keep distinct; see #11203 for an example.  So, any client of this
function needs to either allow the TyVarTvs to unify with each other or check
that they don't (say, with a call to findDubTyVarTvs).

Before #15050 this (under the name SigTv) was used for ScopedTypeVariables in
patterns, to make sure these type variables only refer to other type variables,
but this restriction was dropped, and ScopedTypeVariables can now refer to full
types (GHC Proposal 29).

The remaining uses of newTyVarTyVars are
* In kind signatures, see
  TcTyClsDecls Note [Inferring kinds for type declarations]
           and Note [Kind checking for GADTs]
* In partial type signatures, see Note [Quantified variables in partial type signatures]
-}

-- see Note [TyVarTv]
newTyVarTyVar :: Name -&gt; Kind -&gt; TcM TcTyVar
newTyVarTyVar name kind
  = do { details &lt;- newMetaDetails TyVarTv
       ; let tyvar = mkTcTyVar name kind details
       ; traceTc &quot;newTyVarTyVar&quot; (ppr tyvar)
       ; return tyvar }


-- makes a new skolem tv
newSkolemTyVar :: Name -&gt; Kind -&gt; TcM TcTyVar
newSkolemTyVar name kind = do { lvl &lt;- getTcLevel
                              ; return (mkTcTyVar name kind (SkolemTv lvl False)) }

newFskTyVar :: TcType -&gt; TcM TcTyVar
newFskTyVar fam_ty
  = do { uniq &lt;- newUnique
       ; ref  &lt;- newMutVar Flexi
       ; tclvl &lt;- getTcLevel
       ; let details = MetaTv { mtv_info  = FlatSkolTv
                              , mtv_ref   = ref
                              , mtv_tclvl = tclvl }
             name = mkMetaTyVarName uniq (fsLit &quot;fsk&quot;)
       ; return (mkTcTyVar name (tcTypeKind fam_ty) details) }

newFmvTyVar :: TcType -&gt; TcM TcTyVar
-- Very like newMetaTyVar, except sets mtv_tclvl to one less
-- so that the fmv is untouchable.
newFmvTyVar fam_ty
  = do { uniq &lt;- newUnique
       ; ref  &lt;- newMutVar Flexi
       ; tclvl &lt;- getTcLevel
       ; let details = MetaTv { mtv_info  = FlatMetaTv
                              , mtv_ref   = ref
                              , mtv_tclvl = tclvl }
             name = mkMetaTyVarName uniq (fsLit &quot;s&quot;)
       ; return (mkTcTyVar name (tcTypeKind fam_ty) details) }

newMetaDetails :: MetaInfo -&gt; TcM TcTyVarDetails
newMetaDetails info
  = do { ref &lt;- newMutVar Flexi
       ; tclvl &lt;- getTcLevel
       ; return (MetaTv { mtv_info = info
                        , mtv_ref = ref
                        , mtv_tclvl = tclvl }) }

cloneMetaTyVar :: TcTyVar -&gt; TcM TcTyVar
cloneMetaTyVar tv
  = ASSERT( isTcTyVar tv )
    do  { uniq &lt;- newUnique
        ; ref  &lt;- newMutVar Flexi
        ; let name'    = setNameUnique (tyVarName tv) uniq
              details' = case tcTyVarDetails tv of
                           details@(MetaTv {}) -&gt; details { mtv_ref = ref }
                           _ -&gt; pprPanic &quot;cloneMetaTyVar&quot; (ppr tv)
              tyvar = mkTcTyVar name' (tyVarKind tv) details'
        ; traceTc &quot;cloneMetaTyVar&quot; (ppr tyvar)
        ; return tyvar }

-- Works for both type and kind variables
readMetaTyVar :: TyVar -&gt; TcM MetaDetails
readMetaTyVar tyvar = ASSERT2( isMetaTyVar tyvar, ppr tyvar )
                      readMutVar (metaTyVarRef tyvar)

isFilledMetaTyVar_maybe :: TcTyVar -&gt; TcM (Maybe Type)
isFilledMetaTyVar_maybe tv
 | MetaTv { mtv_ref = ref } &lt;- tcTyVarDetails tv
 = do { cts &lt;- readTcRef ref
      ; case cts of
          Indirect ty -&gt; return (Just ty)
          Flexi       -&gt; return Nothing }
 | otherwise
 = return Nothing

isFilledMetaTyVar :: TyVar -&gt; TcM Bool
-- True of a filled-in (Indirect) meta type variable
isFilledMetaTyVar tv = isJust &lt;$&gt; isFilledMetaTyVar_maybe tv

isUnfilledMetaTyVar :: TyVar -&gt; TcM Bool
-- True of a un-filled-in (Flexi) meta type variable
-- NB: Not the opposite of isFilledMetaTyVar
isUnfilledMetaTyVar tv
  | MetaTv { mtv_ref = ref } &lt;- tcTyVarDetails tv
  = do  { details &lt;- readMutVar ref
        ; return (isFlexi details) }
  | otherwise = return False

--------------------
-- Works with both type and kind variables
writeMetaTyVar :: TcTyVar -&gt; TcType -&gt; TcM ()
-- Write into a currently-empty MetaTyVar

writeMetaTyVar tyvar ty
  | not debugIsOn
  = writeMetaTyVarRef tyvar (metaTyVarRef tyvar) ty

-- Everything from here on only happens if DEBUG is on
  | not (isTcTyVar tyvar)
  = WARN( True, text &quot;Writing to non-tc tyvar&quot; &lt;+&gt; ppr tyvar )
    return ()

  | MetaTv { mtv_ref = ref } &lt;- tcTyVarDetails tyvar
  = writeMetaTyVarRef tyvar ref ty

  | otherwise
  = WARN( True, text &quot;Writing to non-meta tyvar&quot; &lt;+&gt; ppr tyvar )
    return ()

--------------------
writeMetaTyVarRef :: TcTyVar -&gt; TcRef MetaDetails -&gt; TcType -&gt; TcM ()
-- Here the tyvar is for error checking only;
-- the ref cell must be for the same tyvar
writeMetaTyVarRef tyvar ref ty
  | not debugIsOn
  = do { traceTc &quot;writeMetaTyVar&quot; (ppr tyvar &lt;+&gt; dcolon &lt;+&gt; ppr (tyVarKind tyvar)
                                   &lt;+&gt; text &quot;:=&quot; &lt;+&gt; ppr ty)
       ; writeTcRef ref (Indirect ty) }

  -- Everything from here on only happens if DEBUG is on
  | otherwise
  = do { meta_details &lt;- readMutVar ref;
       -- Zonk kinds to allow the error check to work
       ; zonked_tv_kind &lt;- zonkTcType tv_kind
       ; zonked_ty      &lt;- zonkTcType ty
       ; let zonked_ty_kind = tcTypeKind zonked_ty  -- Need to zonk even before typeKind;
                                                    -- otherwise, we can panic in piResultTy
             kind_check_ok = tcIsConstraintKind zonked_tv_kind
                          || tcEqKind zonked_ty_kind zonked_tv_kind
             -- Hack alert! tcIsConstraintKind: see TcHsType
             -- Note [Extra-constraint holes in partial type signatures]

             kind_msg = hang (text &quot;Ill-kinded update to meta tyvar&quot;)
                           2 (    ppr tyvar &lt;+&gt; text &quot;::&quot; &lt;+&gt; (ppr tv_kind $$ ppr zonked_tv_kind)
                              &lt;+&gt; text &quot;:=&quot;
                              &lt;+&gt; ppr ty &lt;+&gt; text &quot;::&quot; &lt;+&gt; (ppr zonked_ty_kind) )

       ; traceTc &quot;writeMetaTyVar&quot; (ppr tyvar &lt;+&gt; text &quot;:=&quot; &lt;+&gt; ppr ty)

       -- Check for double updates
       ; MASSERT2( isFlexi meta_details, double_upd_msg meta_details )

       -- Check for level OK
       -- See Note [Level check when unifying]
       ; MASSERT2( level_check_ok, level_check_msg )

       -- Check Kinds ok
       ; MASSERT2( kind_check_ok, kind_msg )

       -- Do the write
       ; writeMutVar ref (Indirect ty) }
  where
    tv_kind = tyVarKind tyvar

    tv_lvl = tcTyVarLevel tyvar
    ty_lvl = tcTypeLevel ty

    level_check_ok  = not (ty_lvl `strictlyDeeperThan` tv_lvl)
    level_check_msg = ppr ty_lvl $$ ppr tv_lvl $$ ppr tyvar $$ ppr ty

    double_upd_msg details = hang (text &quot;Double update of meta tyvar&quot;)
                                2 (ppr tyvar $$ ppr details)

{- Note [Level check when unifying]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When unifying
     alpha:lvl := ty
we expect that the TcLevel of 'ty' will be &lt;= lvl.
However, during unflatting we do
     fuv:l := ty:(l+1)
which is usually wrong; hence the check isFmmvTyVar in level_check_ok.
See Note [TcLevel assignment] in TcType.
-}

{-
% Generating fresh variables for pattern match check
-}


{-
************************************************************************
*                                                                      *
        MetaTvs: TauTvs
*                                                                      *
************************************************************************

Note [Never need to instantiate coercion variables]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
With coercion variables sloshing around in types, it might seem that we
sometimes need to instantiate coercion variables. This would be problematic,
because coercion variables inhabit unboxed equality (~#), and the constraint
solver thinks in terms only of boxed equality (~). The solution is that
we never need to instantiate coercion variables in the first place.

The tyvars that we need to instantiate come from the types of functions,
data constructors, and patterns. These will never be quantified over
coercion variables, except for the special case of the promoted Eq#. But,
that can't ever appear in user code, so we're safe!
-}

newTauTyVar :: Name -&gt; Kind -&gt; TcM TcTyVar
newTauTyVar name kind
  = do { details &lt;- newMetaDetails TauTv
       ; let tyvar = mkTcTyVar name kind details
       ; traceTc &quot;newTauTyVar&quot; (ppr tyvar)
       ; return tyvar }


mkMetaTyVarName :: Unique -&gt; FastString -&gt; Name
-- Makes a /System/ Name, which is eagerly eliminated by
-- the unifier; see TcUnify.nicer_to_update_tv1, and
-- TcCanonical.canEqTyVarTyVar (nicer_to_update_tv2)
mkMetaTyVarName uniq str = mkSystemName uniq (mkTyVarOccFS str)

newAnonMetaTyVar :: MetaInfo -&gt; Kind -&gt; TcM TcTyVar
-- Make a new meta tyvar out of thin air
newAnonMetaTyVar meta_info kind
  = do  { uniq &lt;- newUnique
        ; let name = mkMetaTyVarName uniq s
              s = case meta_info of
                        TauTv       -&gt; fsLit &quot;t&quot;
                        FlatMetaTv  -&gt; fsLit &quot;fmv&quot;
                        FlatSkolTv  -&gt; fsLit &quot;fsk&quot;
                        TyVarTv      -&gt; fsLit &quot;a&quot;
        ; details &lt;- newMetaDetails meta_info
        ; let tyvar = mkTcTyVar name kind details
        ; traceTc &quot;newAnonMetaTyVar&quot; (ppr tyvar)
        ; return tyvar }

cloneAnonMetaTyVar :: MetaInfo -&gt; TyVar -&gt; TcKind -&gt; TcM TcTyVar
-- Same as newAnonMetaTyVar, but use a supplied TyVar as the source of the print-name
cloneAnonMetaTyVar info tv kind
  = do  { uniq    &lt;- newUnique
        ; details &lt;- newMetaDetails info
        ; let name = mkSystemName uniq (getOccName tv)
                       -- See Note [Name of an instantiated type variable]
              tyvar = mkTcTyVar name kind details
        ; traceTc &quot;cloneAnonMetaTyVar&quot; (ppr tyvar)
        ; return tyvar }

{- Note [Name of an instantiated type variable]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
At the moment we give a unification variable a System Name, which
influences the way it is tidied; see TypeRep.tidyTyVarBndr.
-}

newFlexiTyVar :: Kind -&gt; TcM TcTyVar
newFlexiTyVar kind = newAnonMetaTyVar TauTv kind

newFlexiTyVarTy :: Kind -&gt; TcM TcType
newFlexiTyVarTy kind = do
    tc_tyvar &lt;- newFlexiTyVar kind
    return (mkTyVarTy tc_tyvar)

newFlexiTyVarTys :: Int -&gt; Kind -&gt; TcM [TcType]
newFlexiTyVarTys n kind = mapM newFlexiTyVarTy (nOfThem n kind)

newOpenTypeKind :: TcM TcKind
newOpenTypeKind
  = do { rr &lt;- newFlexiTyVarTy runtimeRepTy
       ; return (tYPE rr) }

-- | Create a tyvar that can be a lifted or unlifted type.
-- Returns alpha :: TYPE kappa, where both alpha and kappa are fresh
newOpenFlexiTyVarTy :: TcM TcType
newOpenFlexiTyVarTy
  = do { kind &lt;- newOpenTypeKind
       ; newFlexiTyVarTy kind }

newMetaTyVars :: [TyVar] -&gt; TcM (TCvSubst, [TcTyVar])
-- Instantiate with META type variables
-- Note that this works for a sequence of kind, type, and coercion variables
-- variables.  Eg    [ (k:*), (a:k-&gt;k) ]
--             Gives [ (k7:*), (a8:k7-&gt;k7) ]
newMetaTyVars = newMetaTyVarsX emptyTCvSubst
    -- emptyTCvSubst has an empty in-scope set, but that's fine here
    -- Since the tyvars are freshly made, they cannot possibly be
    -- captured by any existing for-alls.

newMetaTyVarsX :: TCvSubst -&gt; [TyVar] -&gt; TcM (TCvSubst, [TcTyVar])
-- Just like newMetaTyVars, but start with an existing substitution.
newMetaTyVarsX subst = mapAccumLM newMetaTyVarX subst

newMetaTyVarX :: TCvSubst -&gt; TyVar -&gt; TcM (TCvSubst, TcTyVar)
-- Make a new unification variable tyvar whose Name and Kind come from
-- an existing TyVar. We substitute kind variables in the kind.
newMetaTyVarX subst tyvar = new_meta_tv_x TauTv subst tyvar

newMetaTyVarTyVars :: [TyVar] -&gt; TcM (TCvSubst, [TcTyVar])
newMetaTyVarTyVars = mapAccumLM newMetaTyVarTyVarX emptyTCvSubst

newMetaTyVarTyVarX :: TCvSubst -&gt; TyVar -&gt; TcM (TCvSubst, TcTyVar)
-- Just like newMetaTyVarX, but make a TyVarTv
newMetaTyVarTyVarX subst tyvar = new_meta_tv_x TyVarTv subst tyvar

newWildCardX :: TCvSubst -&gt; TyVar -&gt; TcM (TCvSubst, TcTyVar)
newWildCardX subst tv
  = do { new_tv &lt;- newAnonMetaTyVar TauTv (substTy subst (tyVarKind tv))
       ; return (extendTvSubstWithClone subst tv new_tv, new_tv) }

new_meta_tv_x :: MetaInfo -&gt; TCvSubst -&gt; TyVar -&gt; TcM (TCvSubst, TcTyVar)
new_meta_tv_x info subst tv
  = do  { new_tv &lt;- cloneAnonMetaTyVar info tv substd_kind
        ; let subst1 = extendTvSubstWithClone subst tv new_tv
        ; return (subst1, new_tv) }
  where
    substd_kind = substTyUnchecked subst (tyVarKind tv)
      -- NOTE: Trac #12549 is fixed so we could use
      -- substTy here, but the tc_infer_args problem
      -- is not yet fixed so leaving as unchecked for now.
      -- OLD NOTE:
      -- Unchecked because we call newMetaTyVarX from
      -- tcInstTyBinder, which is called from tcInferApps
      -- which does not yet take enough trouble to ensure
      -- the in-scope set is right; e.g. Trac #12785 trips
      -- if we use substTy here

newMetaTyVarTyAtLevel :: TcLevel -&gt; TcKind -&gt; TcM TcType
newMetaTyVarTyAtLevel tc_lvl kind
  = do  { uniq &lt;- newUnique
        ; ref  &lt;- newMutVar Flexi
        ; let name = mkMetaTyVarName uniq (fsLit &quot;p&quot;)
              details = MetaTv { mtv_info  = TauTv
                               , mtv_ref   = ref
                               , mtv_tclvl = tc_lvl }
        ; return (mkTyVarTy (mkTcTyVar name kind details)) }

{- *********************************************************************
*                                                                      *
          Finding variables to quantify over
*                                                                      *
********************************************************************* -}

{- Note [Dependent type variables]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In Haskell type inference we quantify over type variables; but we only
quantify over /kind/ variables when -XPolyKinds is on.  Without -XPolyKinds
we default the kind variables to *.

So, to support this defaulting, and only for that reason, when
collecting the free vars of a type, prior to quantifying, we must keep
the type and kind variables separate.

But what does that mean in a system where kind variables /are/ type
variables? It's a fairly arbitrary distinction based on how the
variables appear:

  - &quot;Kind variables&quot; appear in the kind of some other free variable

     These are the ones we default to * if -XPolyKinds is off

  - &quot;Type variables&quot; are all free vars that are not kind variables

E.g.  In the type    T k (a::k)
      'k' is a kind variable, because it occurs in the kind of 'a',
          even though it also appears at &quot;top level&quot; of the type
      'a' is a type variable, because it doesn't

We gather these variables using a CandidatesQTvs record:
  DV { dv_kvs: Variables free in the kind of a free type variable
               or of a forall-bound type variable
     , dv_tvs: Variables sytactically free in the type }

So:  dv_kvs            are the kind variables of the type
     (dv_tvs - dv_kvs) are the type variable of the type

Note that

* A variable can occur in both.
      T k (x::k)    The first occurrence of k makes it
                    show up in dv_tvs, the second in dv_kvs

* We include any coercion variables in the &quot;dependent&quot;,
  &quot;kind-variable&quot; set because we never quantify over them.

* The &quot;kind variables&quot; might depend on each other; e.g
     (k1 :: k2), (k2 :: *)
  The &quot;type variables&quot; do not depend on each other; if
  one did, it'd be classified as a kind variable!

Note [CandidatesQTvs determinism and order]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* Determinism: when we quantify over type variables we decide the
  order in which they appear in the final type. Because the order of
  type variables in the type can end up in the interface file and
  affects some optimizations like worker-wrapper, we want this order to
  be deterministic.

  To achieve that we use deterministic sets of variables that can be
  converted to lists in a deterministic order. For more information
  about deterministic sets see Note [Deterministic UniqFM] in UniqDFM.

* Order: as well as being deterministic, we use an
  accumulating-parameter style for candidateQTyVarsOfType so that we
  add variables one at a time, left to right.  That means we tend to
  produce the variables in left-to-right order.  This is just to make
  it bit more predicatable for the programmer.

Note [Naughty quantification candidates]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider (#14880, dependent/should_compile/T14880-2), suppose
we are trying to generalise this type:

  forall arg. ... (alpha[tau]:arg) ...

We have a metavariable alpha whose kind mentions a skolem variable
boudn inside the very type we are generalising.
This can arise while type-checking a user-written type signature
(see the test case for the full code).

We cannot generalise over alpha!  That would produce a type like
  forall {a :: arg}. forall arg. ...blah...
The fact that alpha's kind mentions arg renders it completely
ineligible for generaliation.

However, we are not going to learn any new constraints on alpha,
because its kind isn't even in scope in the outer context.  So alpha
is entirely unconstrained.

What then should we do with alpha?  During generalization, every
metavariable is either (A) promoted, (B) generalized, or (C) zapped
(according again to Note [Recipe for checking a signature] in
TcHsType).

 * We can't generalise it.
 * We can't promote it, because its kind prevents that
 * We can't simply leave it be, because this type is about to
   go into the typing environment (as the type of some let-bound
   variable, say), and then chaos erupts when we try to instantiate.

So, we zap it, eagerly, to Any. We don't have to do this eager zapping
in terms (say, in `length []`) because terms are never re-examined before
the final zonk (which zaps any lingering metavariables to Any).

We do this eager zapping in candidateQTyVars, which always precedes
generalisation, because at that moment we have a clear picture of
what skolems are in scope.

-}

data CandidatesQTvs
  -- See Note [Dependent type variables]
  -- See Note [CandidatesQTvs determinism and order]
  --
  -- Invariants:
  --   * All variables stored here are MetaTvs. No exceptions.
  --   * All variables are fully zonked, including their kinds
  --
  = DV { dv_kvs :: DTyVarSet    -- &quot;kind&quot; metavariables (dependent)
       , dv_tvs :: DTyVarSet    -- &quot;type&quot; metavariables (non-dependent)
         -- A variable may appear in both sets
         -- E.g.   T k (x::k)    The first occurrence of k makes it
         --                      show up in dv_tvs, the second in dv_kvs
         -- See Note [Dependent type variables]

       , dv_cvs :: CoVarSet
         -- These are covars. We will *not* quantify over these, but
         -- we must make sure also not to quantify over any cv's kinds,
         -- so we include them here as further direction for quantifyTyVars
    }

instance Semi.Semigroup CandidatesQTvs where
   (DV { dv_kvs = kv1, dv_tvs = tv1, dv_cvs = cv1 })
     &lt;&gt; (DV { dv_kvs = kv2, dv_tvs = tv2, dv_cvs = cv2 })
          = DV { dv_kvs = kv1 `unionDVarSet` kv2
               , dv_tvs = tv1 `unionDVarSet` tv2
               , dv_cvs = cv1 `unionVarSet` cv2 }

instance Monoid CandidatesQTvs where
   mempty = DV { dv_kvs = emptyDVarSet, dv_tvs = emptyDVarSet, dv_cvs = emptyVarSet }
   mappend = (Semi.&lt;&gt;)

instance Outputable CandidatesQTvs where
  ppr (DV {dv_kvs = kvs, dv_tvs = tvs, dv_cvs = cvs })
    = text &quot;DV&quot; &lt;+&gt; braces (pprWithCommas id [ text &quot;dv_kvs =&quot; &lt;+&gt; ppr kvs
                                             , text &quot;dv_tvs =&quot; &lt;+&gt; ppr tvs
                                             , text &quot;dv_cvs =&quot; &lt;+&gt; ppr cvs ])


candidateKindVars :: CandidatesQTvs -&gt; TyVarSet
candidateKindVars dvs = dVarSetToVarSet (dv_kvs dvs)

-- | Gathers free variables to use as quantification candidates (in
-- 'quantifyTyVars'). This might output the same var
-- in both sets, if it's used in both a type and a kind.
-- See Note [CandidatesQTvs determinism and order]
-- See Note [Dependent type variables]
candidateQTyVarsOfType :: TcType       -- not necessarily zonked
                       -&gt; TcM CandidatesQTvs
candidateQTyVarsOfType ty = collect_cand_qtvs False emptyVarSet mempty ty

-- | Like 'splitDepVarsOfType', but over a list of types
candidateQTyVarsOfTypes :: [Type] -&gt; TcM CandidatesQTvs
candidateQTyVarsOfTypes tys = foldlM (collect_cand_qtvs False emptyVarSet) mempty tys

-- | Like 'candidateQTyVarsOfType', but consider every free variable
-- to be dependent. This is appropriate when generalizing a *kind*,
-- instead of a type. (That way, -XNoPolyKinds will default the variables
-- to Type.)
candidateQTyVarsOfKind :: TcKind       -- Not necessarily zonked
                       -&gt; TcM CandidatesQTvs
candidateQTyVarsOfKind ty = collect_cand_qtvs True emptyVarSet mempty ty

candidateQTyVarsOfKinds :: [TcKind]    -- Not necessarily zonked
                       -&gt; TcM CandidatesQTvs
candidateQTyVarsOfKinds tys = foldM (collect_cand_qtvs True emptyVarSet) mempty tys

delCandidates :: CandidatesQTvs -&gt; [Var] -&gt; CandidatesQTvs
delCandidates (DV { dv_kvs = kvs, dv_tvs = tvs, dv_cvs = cvs }) vars
  = DV { dv_kvs = kvs `delDVarSetList` vars
       , dv_tvs = tvs `delDVarSetList` vars
       , dv_cvs = cvs `delVarSetList`  vars }

collect_cand_qtvs
  :: Bool            -- True &lt;=&gt; consider every fv in Type to be dependent
  -&gt; VarSet          -- Bound variables (both locally bound and globally bound)
  -&gt; CandidatesQTvs  -- Accumulating parameter
  -&gt; Type            -- Not necessarily zonked
  -&gt; TcM CandidatesQTvs

-- Key points:
--   * Looks through meta-tyvars as it goes;
--     no need to zonk in advance
--
--   * Needs to be monadic anyway, because it does the zap-naughty
--     stuff; see Note [Naughty quantification candidates]
--
--   * Returns fully-zonked CandidateQTvs, including their kinds
--     so that subsequent dependency analysis (to build a well
--     scoped telescope) works correctly

collect_cand_qtvs is_dep bound dvs ty
  = go dvs ty
  where
    is_bound tv = tv `elemVarSet` bound

    -----------------
    go :: CandidatesQTvs -&gt; TcType -&gt; TcM CandidatesQTvs
    -- Uses accumulating-parameter style
    go dv (AppTy t1 t2)    = foldlM go dv [t1, t2]
    go dv (TyConApp _ tys) = foldlM go dv tys
    go dv (FunTy arg res)  = foldlM go dv [arg, res]
    go dv (LitTy {})       = return dv
    go dv (CastTy ty co)   = do dv1 &lt;- go dv ty
                                collect_cand_qtvs_co bound dv1 co
    go dv (CoercionTy co)  = collect_cand_qtvs_co bound dv co

    go dv (TyVarTy tv)
      | is_bound tv = return dv
      | otherwise   = do { m_contents &lt;- isFilledMetaTyVar_maybe tv
                         ; case m_contents of
                             Just ind_ty -&gt; go dv ind_ty
                             Nothing     -&gt; go_tv dv tv }

    go dv (ForAllTy (Bndr tv _) ty)
      = do { dv1 &lt;- collect_cand_qtvs True bound dv (tyVarKind tv)
           ; collect_cand_qtvs is_dep (bound `extendVarSet` tv) dv1 ty }

    -----------------
    go_tv dv@(DV { dv_kvs = kvs, dv_tvs = tvs }) tv
      | tv `elemDVarSet` kvs = return dv  -- We have met this tyvar aleady
      | not is_dep
      , tv `elemDVarSet` tvs = return dv  -- We have met this tyvar aleady
      | otherwise
      = do { tv_kind &lt;- zonkTcType (tyVarKind tv)
                 -- This zonk is annoying, but it is necessary, both to
                 -- ensure that the collected candidates have zonked kinds
                 -- (Trac #15795) and to make the naughty check
                 -- (which comes next) works correctly
           ; if intersectsVarSet bound (tyCoVarsOfType tv_kind)

             then -- See Note [Naughty quantification candidates]
                  do { traceTc &quot;Zapping naughty quantifier&quot; (pprTyVar tv)
                     ; writeMetaTyVar tv (anyTypeOfKind tv_kind)
                     ; collect_cand_qtvs True bound dv tv_kind }

             else do { let tv' = tv `setTyVarKind` tv_kind
                           dv' | is_dep    = dv { dv_kvs = kvs `extendDVarSet` tv' }
                               | otherwise = dv { dv_tvs = tvs `extendDVarSet` tv' }
                               -- See Note [Order of accumulation]
                     ; collect_cand_qtvs True emptyVarSet dv' tv_kind } }

collect_cand_qtvs_co :: VarSet -- bound variables
                     -&gt; CandidatesQTvs -&gt; Coercion
                     -&gt; TcM CandidatesQTvs
collect_cand_qtvs_co bound = go_co
  where
    go_co dv (Refl ty)             = collect_cand_qtvs True bound dv ty
    go_co dv (GRefl _ ty mco)      = do dv1 &lt;- collect_cand_qtvs True bound dv ty
                                        go_mco dv1 mco
    go_co dv (TyConAppCo _ _ cos)  = foldlM go_co dv cos
    go_co dv (AppCo co1 co2)       = foldlM go_co dv [co1, co2]
    go_co dv (FunCo _ co1 co2)     = foldlM go_co dv [co1, co2]
    go_co dv (AxiomInstCo _ _ cos) = foldlM go_co dv cos
    go_co dv (AxiomRuleCo _ cos)   = foldlM go_co dv cos
    go_co dv (UnivCo prov _ t1 t2) = do dv1 &lt;- go_prov dv prov
                                        dv2 &lt;- collect_cand_qtvs True bound dv1 t1
                                        collect_cand_qtvs True bound dv2 t2
    go_co dv (SymCo co)            = go_co dv co
    go_co dv (TransCo co1 co2)     = foldlM go_co dv [co1, co2]
    go_co dv (NthCo _ _ co)        = go_co dv co
    go_co dv (LRCo _ co)           = go_co dv co
    go_co dv (InstCo co1 co2)      = foldlM go_co dv [co1, co2]
    go_co dv (KindCo co)           = go_co dv co
    go_co dv (SubCo co)            = go_co dv co

    go_co dv (HoleCo hole) = do m_co &lt;- unpackCoercionHole_maybe hole
                                case m_co of
                                  Just co -&gt; go_co dv co
                                  Nothing -&gt; go_cv dv (coHoleCoVar hole)

    go_co dv (CoVarCo cv) = go_cv dv cv

    go_co dv (ForAllCo tcv kind_co co)
      = do { dv1 &lt;- go_co dv kind_co
           ; collect_cand_qtvs_co (bound `extendVarSet` tcv) dv1 co }

    go_mco dv MRefl    = return dv
    go_mco dv (MCo co) = go_co dv co

    go_prov dv UnsafeCoerceProv    = return dv
    go_prov dv (PhantomProv co)    = go_co dv co
    go_prov dv (ProofIrrelProv co) = go_co dv co
    go_prov dv (PluginProv _)      = return dv

    go_cv :: CandidatesQTvs -&gt; CoVar -&gt; TcM CandidatesQTvs
    go_cv dv@(DV { dv_cvs = cvs }) cv
      | is_bound cv         = return dv
      | cv `elemVarSet` cvs = return dv
      | otherwise           = collect_cand_qtvs True emptyVarSet
                                    (dv { dv_cvs = cvs `extendVarSet` cv })
                                    (idType cv)

    is_bound tv = tv `elemVarSet` bound

{- Note [Order of accumulation]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
You might be tempted (like I was) to use unitDVarSet and mappend
rather than extendDVarSet.  However, the union algorithm for
deterministic sets depends on (roughly) the size of the sets. The
elements from the smaller set end up to the right of the elements from
the larger one. When sets are equal, the left-hand argument to
`mappend` goes to the right of the right-hand argument.

In our case, if we use unitDVarSet and mappend, we learn that the free
variables of (a -&gt; b -&gt; c -&gt; d) are [b, a, c, d], and we then quantify
over them in that order. (The a comes after the b because we union the
singleton sets as ({a} `mappend` {b}), producing {b, a}. Thereafter,
the size criterion works to our advantage.) This is just annoying to
users, so I use `extendDVarSet`, which unambiguously puts the new
element to the right.

Note that the unitDVarSet/mappend implementation would not be wrong
against any specification -- just suboptimal and confounding to users.
-}

{- *********************************************************************
*                                                                      *
             Quantification
*                                                                      *
************************************************************************

Note [quantifyTyVars]
~~~~~~~~~~~~~~~~~~~~~
quantifyTyVars is given the free vars of a type that we
are about to wrap in a forall.

It takes these free type/kind variables (partitioned into dependent and
non-dependent variables) and
  1. Zonks them and remove globals and covars
  2. Extends kvs1 with free kind vars in the kinds of tvs (removing globals)
  3. Calls skolemiseQuantifiedTyVar on each

Step (2) is often unimportant, because the kind variable is often
also free in the type.  Eg
     Typeable k (a::k)
has free vars {k,a}.  But the type (see Trac #7916)
    (f::k-&gt;*) (a::k)
has free vars {f,a}, but we must add 'k' as well! Hence step (2).

* This function distinguishes between dependent and non-dependent
  variables only to keep correct defaulting behavior with -XNoPolyKinds.
  With -XPolyKinds, it treats both classes of variables identically.

* quantifyTyVars never quantifies over
    - a coercion variable (or any tv mentioned in the kind of a covar)
    - a runtime-rep variable

Note [quantifyTyVars determinism]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The results of quantifyTyVars are wrapped in a forall and can end up in the
interface file. One such example is inferred type signatures. They also affect
the results of optimizations, for example worker-wrapper. This means that to
get deterministic builds quantifyTyVars needs to be deterministic.

To achieve this CandidatesQTvs is backed by deterministic sets which allows them
to be later converted to a list in a deterministic order.

For more information about deterministic sets see
Note [Deterministic UniqFM] in UniqDFM.
-}

quantifyTyVars
  :: TcTyCoVarSet     -- Global tvs; already zonked
  -&gt; CandidatesQTvs   -- See Note [Dependent type variables]
                      -- Already zonked
  -&gt; TcM [TcTyVar]
-- See Note [quantifyTyVars]
-- Can be given a mixture of TcTyVars and TyVars, in the case of
--   associated type declarations. Also accepts covars, but *never* returns any.
quantifyTyVars gbl_tvs
               dvs@(DV{ dv_kvs = dep_tkvs, dv_tvs = nondep_tkvs, dv_cvs = covars })
  = do { outer_tclvl &lt;- getTcLevel
       ; traceTc &quot;quantifyTyVars 1&quot; (vcat [ppr outer_tclvl, ppr dvs, ppr gbl_tvs])
       ; let co_tvs = closeOverKinds covars
             mono_tvs = gbl_tvs `unionVarSet` co_tvs
              -- NB: All variables in the kind of a covar must not be
              -- quantified over, as we don't quantify over the covar.

             dep_kvs = dVarSetElemsWellScoped $
                       dep_tkvs `dVarSetMinusVarSet` mono_tvs
                       -- dVarSetElemsWellScoped: put the kind variables into
                       --    well-scoped order.
                       --    E.g.  [k, (a::k)] not the other way roud

             nondep_tvs = dVarSetElems $
                          (nondep_tkvs `minusDVarSet` dep_tkvs)
                           `dVarSetMinusVarSet` mono_tvs
                 -- See Note [Dependent type variables]
                 -- The `minus` dep_tkvs removes any kind-level vars
                 --    e.g. T k (a::k)   Since k appear in a kind it'll
                 --    be in dv_kvs, and is dependent. So remove it from
                 --    dv_tvs which will also contain k
                 -- No worry about dependent covars here;
                 --    they are all in dep_tkvs
                 -- NB kinds of tvs are zonked by zonkTyCoVarsAndFV

       -- This block uses level numbers to decide what to quantify
       -- and emits a warning if the two methods do not give the same answer
       ; let dep_kvs2    = dVarSetElemsWellScoped $
                           filterDVarSet (quantifiableTv outer_tclvl) dep_tkvs
             nondep_tvs2 = filter (quantifiableTv outer_tclvl) $
                           dVarSetElems (nondep_tkvs `minusDVarSet` dep_tkvs)

             all_ok = dep_kvs == dep_kvs2 &amp;&amp; nondep_tvs == nondep_tvs2
             bad_msg = hang (text &quot;Quantification by level numbers would fail&quot;)
                          2 (vcat [ text &quot;Outer level =&quot; &lt;+&gt; ppr outer_tclvl
                                  , text &quot;dep_tkvs =&quot;    &lt;+&gt; ppr dep_tkvs
                                  , text &quot;co_vars =&quot;     &lt;+&gt; vcat [ ppr cv &lt;+&gt; dcolon &lt;+&gt; ppr (varType cv)
                                                                  | cv &lt;- nonDetEltsUniqSet covars ]
                                  , text &quot;co_tvs =&quot;      &lt;+&gt; ppr co_tvs
                                  , text &quot;dep_kvs =&quot;     &lt;+&gt; ppr dep_kvs
                                  , text &quot;dep_kvs2 =&quot;    &lt;+&gt; ppr dep_kvs2
                                  , text &quot;nondep_tvs =&quot;  &lt;+&gt; ppr nondep_tvs
                                  , text &quot;nondep_tvs2 =&quot; &lt;+&gt; ppr nondep_tvs2 ])
       ; WARN( not all_ok, bad_msg ) return ()

             -- In the non-PolyKinds case, default the kind variables
             -- to *, and zonk the tyvars as usual.  Notice that this
             -- may make quantifyTyVars return a shorter list
             -- than it was passed, but that's ok
       ; poly_kinds  &lt;- xoptM LangExt.PolyKinds
       ; dep_kvs'    &lt;- mapMaybeM (zonk_quant (not poly_kinds)) dep_kvs
       ; nondep_tvs' &lt;- mapMaybeM (zonk_quant False)            nondep_tvs
       ; let final_qtvs = dep_kvs' ++ nondep_tvs'
           -- Because of the order, any kind variables
           -- mentioned in the kinds of the nondep_tvs'
           -- now refer to the dep_kvs'

       ; traceTc &quot;quantifyTyVars 2&quot;
           (vcat [ text &quot;globals:&quot;    &lt;+&gt; ppr gbl_tvs
                 , text &quot;mono_tvs:&quot;   &lt;+&gt; ppr mono_tvs
                 , text &quot;nondep:&quot;     &lt;+&gt; pprTyVars nondep_tvs
                 , text &quot;dep:&quot;        &lt;+&gt; pprTyVars dep_kvs
                 , text &quot;dep_kvs'&quot;    &lt;+&gt; pprTyVars dep_kvs'
                 , text &quot;nondep_tvs'&quot; &lt;+&gt; pprTyVars nondep_tvs' ])

       -- We should never quantify over coercion variables; check this
       ; let co_vars = filter isCoVar final_qtvs
       ; MASSERT2( null co_vars, ppr co_vars )

       ; return final_qtvs }
  where
    -- zonk_quant returns a tyvar if it should be quantified over;
    -- otherwise, it returns Nothing. The latter case happens for
    --    * Kind variables, with -XNoPolyKinds: don't quantify over these
    --    * RuntimeRep variables: we never quantify over these
    zonk_quant default_kind tkv
      | not (isTyVar tkv)
      = return Nothing   -- this can happen for a covar that's associated with
                         -- a coercion hole. Test case: typecheck/should_compile/T2494

      | not (isTcTyVar tkv)  -- I don't think this can ever happen.
                             -- Hence the assert
      = ASSERT2( False, text &quot;quantifying over a TyVar&quot; &lt;+&gt; ppr tkv)
        return (Just tkv)

      | otherwise
      = do { deflt_done &lt;- defaultTyVar default_kind tkv
           ; case deflt_done of
               True  -&gt; return Nothing
               False -&gt; do { tv &lt;- skolemiseQuantifiedTyVar tkv
                           ; return (Just tv) } }

quantifiableTv :: TcLevel   -- Level of the context, outside the quantification
               -&gt; TcTyVar
               -&gt; Bool
quantifiableTv outer_tclvl tcv
  | isTcTyVar tcv  -- Might be a CoVar; change this when gather covars separtely
  = tcTyVarLevel tcv &gt; outer_tclvl
  | otherwise
  = False

skolemiseQuantifiedTyVar :: TcTyVar -&gt; TcM TcTyVar
-- The quantified type variables often include meta type variables
-- we want to freeze them into ordinary type variables
-- The meta tyvar is updated to point to the new skolem TyVar.  Now any
-- bound occurrences of the original type variable will get zonked to
-- the immutable version.
--
-- We leave skolem TyVars alone; they are immutable.
--
-- This function is called on both kind and type variables,
-- but kind variables *only* if PolyKinds is on.

skolemiseQuantifiedTyVar tv
  = case tcTyVarDetails tv of
      SkolemTv {} -&gt; do { kind &lt;- zonkTcType (tyVarKind tv)
                        ; return (setTyVarKind tv kind) }
        -- It might be a skolem type variable,
        -- for example from a user type signature

      MetaTv {} -&gt; skolemiseUnboundMetaTyVar tv

      _other -&gt; pprPanic &quot;skolemiseQuantifiedTyVar&quot; (ppr tv) -- RuntimeUnk

defaultTyVar :: Bool      -- True &lt;=&gt; please default this kind variable to *
             -&gt; TcTyVar   -- If it's a MetaTyVar then it is unbound
             -&gt; TcM Bool  -- True &lt;=&gt; defaulted away altogether

defaultTyVar default_kind tv
  | not (isMetaTyVar tv)
  = return False

  | isTyVarTyVar tv
    -- Do not default TyVarTvs. Doing so would violate the invariants
    -- on TyVarTvs; see Note [Signature skolems] in TcType.
    -- Trac #13343 is an example; #14555 is another
    -- See Note [Inferring kinds for type declarations] in TcTyClsDecls
  = return False


  | isRuntimeRepVar tv  -- Do not quantify over a RuntimeRep var
                        -- unless it is a TyVarTv, handled earlier
  = do { traceTc &quot;Defaulting a RuntimeRep var to LiftedRep&quot; (ppr tv)
       ; writeMetaTyVar tv liftedRepTy
       ; return True }

  | default_kind                 -- -XNoPolyKinds and this is a kind var
  = do { default_kind_var tv     -- so default it to * if possible
       ; return True }

  | otherwise
  = return False

  where
    default_kind_var :: TyVar -&gt; TcM ()
       -- defaultKindVar is used exclusively with -XNoPolyKinds
       -- See Note [Defaulting with -XNoPolyKinds]
       -- It takes an (unconstrained) meta tyvar and defaults it.
       -- Works only on vars of type *; for other kinds, it issues an error.
    default_kind_var kv
      | isLiftedTypeKind (tyVarKind kv)
      = do { traceTc &quot;Defaulting a kind var to *&quot; (ppr kv)
           ; writeMetaTyVar kv liftedTypeKind }
      | otherwise
      = addErr (vcat [ text &quot;Cannot default kind variable&quot; &lt;+&gt; quotes (ppr kv')
                     , text &quot;of kind:&quot; &lt;+&gt; ppr (tyVarKind kv')
                     , text &quot;Perhaps enable PolyKinds or add a kind signature&quot; ])
      where
        (_, kv') = tidyOpenTyCoVar emptyTidyEnv kv

skolemiseUnboundMetaTyVar :: TcTyVar -&gt; TcM TyVar
-- We have a Meta tyvar with a ref-cell inside it
-- Skolemise it, so that we are totally out of Meta-tyvar-land
-- We create a skolem TcTyVar, not a regular TyVar
--   See Note [Zonking to Skolem]
skolemiseUnboundMetaTyVar tv
  = ASSERT2( isMetaTyVar tv, ppr tv )
    do  { when debugIsOn (check_empty tv)
        ; span &lt;- getSrcSpanM    -- Get the location from &quot;here&quot;
                                 -- ie where we are generalising
        ; kind &lt;- zonkTcType (tyVarKind tv)
        ; let uniq        = getUnique tv
                -- NB: Use same Unique as original tyvar. This is
                -- convenient in reading dumps, but is otherwise inessential.

              tv_name     = getOccName tv
              final_name  = mkInternalName uniq tv_name span
              final_tv    = mkTcTyVar final_name kind details

        ; traceTc &quot;Skolemising&quot; (ppr tv &lt;+&gt; text &quot;:=&quot; &lt;+&gt; ppr final_tv)
        ; writeMetaTyVar tv (mkTyVarTy final_tv)
        ; return final_tv }

  where
    details = SkolemTv (metaTyVarTcLevel tv) False
    check_empty tv       -- [Sept 04] Check for non-empty.
      = when debugIsOn $  -- See note [Silly Type Synonym]
        do { cts &lt;- readMetaTyVar tv
           ; case cts of
               Flexi       -&gt; return ()
               Indirect ty -&gt; WARN( True, ppr tv $$ ppr ty )
                              return () }

{- Note [Defaulting with -XNoPolyKinds]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider

  data Compose f g a = Mk (f (g a))

We infer

  Compose :: forall k1 k2. (k2 -&gt; *) -&gt; (k1 -&gt; k2) -&gt; k1 -&gt; *
  Mk :: forall k1 k2 (f :: k2 -&gt; *) (g :: k1 -&gt; k2) (a :: k1).
        f (g a) -&gt; Compose k1 k2 f g a

Now, in another module, we have -XNoPolyKinds -XDataKinds in effect.
What does 'Mk mean? Pre GHC-8.0 with -XNoPolyKinds,
we just defaulted all kind variables to *. But that's no good here,
because the kind variables in 'Mk aren't of kind *, so defaulting to *
is ill-kinded.

After some debate on #11334, we decided to issue an error in this case.
The code is in defaultKindVar.

Note [What is a meta variable?]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A &quot;meta type-variable&quot;, also know as a &quot;unification variable&quot; is a placeholder
introduced by the typechecker for an as-yet-unknown monotype.

For example, when we see a call `reverse (f xs)`, we know that we calling
    reverse :: forall a. [a] -&gt; [a]
So we know that the argument `f xs` must be a &quot;list of something&quot;. But what is
the &quot;something&quot;? We don't know until we explore the `f xs` a bit more. So we set
out what we do know at the call of `reverse` by instantiate its type with a fresh
meta tyvar, `alpha` say. So now the type of the argument `f xs`, and of the
result, is `[alpha]`. The unification variable `alpha` stands for the
as-yet-unknown type of the elements of the list.

As type inference progresses we may learn more about `alpha`. For example, suppose
`f` has the type
    f :: forall b. b -&gt; [Maybe b]
Then we instantiate `f`'s type with another fresh unification variable, say
`beta`; and equate `f`'s result type with reverse's argument type, thus
`[alpha] ~ [Maybe beta]`.

Now we can solve this equality to learn that `alpha ~ Maybe beta`, so we've
refined our knowledge about `alpha`. And so on.

If you found this Note useful, you may also want to have a look at
Section 5 of &quot;Practical type inference for higher rank types&quot; (Peyton Jones,
Vytiniotis, Weirich and Shields. J. Functional Programming. 2011).

Note [What is zonking?]
~~~~~~~~~~~~~~~~~~~~~~~
GHC relies heavily on mutability in the typechecker for efficient operation.
For this reason, throughout much of the type checking process meta type
variables (the MetaTv constructor of TcTyVarDetails) are represented by mutable
variables (known as TcRefs).

Zonking is the process of ripping out these mutable variables and replacing them
with a real Type. This involves traversing the entire type expression, but the
interesting part of replacing the mutable variables occurs in zonkTyVarOcc.

There are two ways to zonk a Type:

 * zonkTcTypeToType, which is intended to be used at the end of type-checking
   for the final zonk. It has to deal with unfilled metavars, either by filling
   it with a value like Any or failing (determined by the UnboundTyVarZonker
   used).

 * zonkTcType, which will happily ignore unfilled metavars. This is the
   appropriate function to use while in the middle of type-checking.

Note [Zonking to Skolem]
~~~~~~~~~~~~~~~~~~~~~~~~
We used to zonk quantified type variables to regular TyVars.  However, this
leads to problems.  Consider this program from the regression test suite:

  eval :: Int -&gt; String -&gt; String -&gt; String
  eval 0 root actual = evalRHS 0 root actual

  evalRHS :: Int -&gt; a
  evalRHS 0 root actual = eval 0 root actual

It leads to the deferral of an equality (wrapped in an implication constraint)

  forall a. () =&gt; ((String -&gt; String -&gt; String) ~ a)

which is propagated up to the toplevel (see TcSimplify.tcSimplifyInferCheck).
In the meantime `a' is zonked and quantified to form `evalRHS's signature.
This has the *side effect* of also zonking the `a' in the deferred equality
(which at this point is being handed around wrapped in an implication
constraint).

Finally, the equality (with the zonked `a') will be handed back to the
simplifier by TcRnDriver.tcRnSrcDecls calling TcSimplify.tcSimplifyTop.
If we zonk `a' with a regular type variable, we will have this regular type
variable now floating around in the simplifier, which in many places assumes to
only see proper TcTyVars.

We can avoid this problem by zonking with a skolem.  The skolem is rigid
(which we require for a quantified variable), but is still a TcTyVar that the
simplifier knows how to deal with.

Note [Silly Type Synonyms]
~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider this:
        type C u a = u  -- Note 'a' unused

        foo :: (forall a. C u a -&gt; C u a) -&gt; u
        foo x = ...

        bar :: Num u =&gt; u
        bar = foo (\t -&gt; t + t)

* From the (\t -&gt; t+t) we get type  {Num d} =&gt;  d -&gt; d
  where d is fresh.

* Now unify with type of foo's arg, and we get:
        {Num (C d a)} =&gt;  C d a -&gt; C d a
  where a is fresh.

* Now abstract over the 'a', but float out the Num (C d a) constraint
  because it does not 'really' mention a.  (see exactTyVarsOfType)
  The arg to foo becomes
        \/\a -&gt; \t -&gt; t+t

* So we get a dict binding for Num (C d a), which is zonked to give
        a = ()
  [Note Sept 04: now that we are zonking quantified type variables
  on construction, the 'a' will be frozen as a regular tyvar on
  quantification, so the floated dict will still have type (C d a).
  Which renders this whole note moot; happily!]

* Then the \/\a abstraction has a zonked 'a' in it.

All very silly.   I think its harmless to ignore the problem.  We'll end up with
a \/\a in the final result but all the occurrences of a will be zonked to ()

************************************************************************
*                                                                      *
              Zonking types
*                                                                      *
************************************************************************

-}

-- | @tcGetGlobalTyCoVars@ returns a fully-zonked set of *scoped* tyvars free in
-- the environment. To improve subsequent calls to the same function it writes
-- the zonked set back into the environment. Note that this returns all
-- variables free in anything (term-level or type-level) in scope. We thus
-- don't have to worry about clashes with things that are not in scope, because
-- if they are reachable, then they'll be returned here.
-- NB: This is closed over kinds, so it can return unification variables mentioned
-- in the kinds of in-scope tyvars.
tcGetGlobalTyCoVars :: TcM TcTyVarSet
tcGetGlobalTyCoVars
  = do { (TcLclEnv {tcl_tyvars = gtv_var}) &lt;- getLclEnv
       ; gbl_tvs  &lt;- readMutVar gtv_var
       ; gbl_tvs' &lt;- zonkTyCoVarsAndFV gbl_tvs
       ; writeMutVar gtv_var gbl_tvs'
       ; return gbl_tvs' }

zonkTcTypeAndFV :: TcType -&gt; TcM DTyCoVarSet
-- Zonk a type and take its free variables
-- With kind polymorphism it can be essential to zonk *first*
-- so that we find the right set of free variables.  Eg
--    forall k1. forall (a:k2). a
-- where k2:=k1 is in the substitution.  We don't want
-- k2 to look free in this type!
zonkTcTypeAndFV ty
  = tyCoVarsOfTypeDSet &lt;$&gt; zonkTcType ty

zonkTyCoVar :: TyCoVar -&gt; TcM TcType
-- Works on TyVars and TcTyVars
zonkTyCoVar tv | isTcTyVar tv = zonkTcTyVar tv
               | isTyVar   tv = mkTyVarTy &lt;$&gt; zonkTyCoVarKind tv
               | otherwise    = ASSERT2( isCoVar tv, ppr tv )
                                mkCoercionTy . mkCoVarCo &lt;$&gt; zonkTyCoVarKind tv
   -- Hackily, when typechecking type and class decls
   -- we have TyVars in scope added (only) in
   -- TcHsType.bindTyClTyVars, but it seems
   -- painful to make them into TcTyVars there

zonkTyCoVarsAndFV :: TyCoVarSet -&gt; TcM TyCoVarSet
zonkTyCoVarsAndFV tycovars
  = tyCoVarsOfTypes &lt;$&gt; mapM zonkTyCoVar (nonDetEltsUniqSet tycovars)
  -- It's OK to use nonDetEltsUniqSet here because we immediately forget about
  -- the ordering by turning it into a nondeterministic set and the order
  -- of zonking doesn't matter for determinism.

-- Takes a list of TyCoVars, zonks them and returns a
-- deterministically ordered list of their free variables.
zonkTyCoVarsAndFVList :: [TyCoVar] -&gt; TcM [TyCoVar]
zonkTyCoVarsAndFVList tycovars
  = tyCoVarsOfTypesList &lt;$&gt; mapM zonkTyCoVar tycovars

zonkTcTyVars :: [TcTyVar] -&gt; TcM [TcType]
zonkTcTyVars tyvars = mapM zonkTcTyVar tyvars

-----------------  Types
zonkTyCoVarKind :: TyCoVar -&gt; TcM TyCoVar
zonkTyCoVarKind tv = do { kind' &lt;- zonkTcType (tyVarKind tv)
                        ; return (setTyVarKind tv kind') }

zonkTcTypes :: [TcType] -&gt; TcM [TcType]
zonkTcTypes tys = mapM zonkTcType tys

{-
************************************************************************
*                                                                      *
              Zonking constraints
*                                                                      *
************************************************************************
-}

zonkImplication :: Implication -&gt; TcM Implication
zonkImplication implic@(Implic { ic_skols  = skols
                               , ic_given  = given
                               , ic_wanted = wanted
                               , ic_info   = info })
  = do { skols'  &lt;- mapM zonkTyCoVarKind skols  -- Need to zonk their kinds!
                                                -- as Trac #7230 showed
       ; given'  &lt;- mapM zonkEvVar given
       ; info'   &lt;- zonkSkolemInfo info
       ; wanted' &lt;- zonkWCRec wanted
       ; return (implic { ic_skols  = skols'
                        , ic_given  = given'
                        , ic_wanted = wanted'
                        , ic_info   = info' }) }

zonkEvVar :: EvVar -&gt; TcM EvVar
zonkEvVar var = do { ty' &lt;- zonkTcType (varType var)
                   ; return (setVarType var ty') }


zonkWC :: WantedConstraints -&gt; TcM WantedConstraints
zonkWC wc = zonkWCRec wc

zonkWCRec :: WantedConstraints -&gt; TcM WantedConstraints
zonkWCRec (WC { wc_simple = simple, wc_impl = implic })
  = do { simple' &lt;- zonkSimples simple
       ; implic' &lt;- mapBagM zonkImplication implic
       ; return (WC { wc_simple = simple', wc_impl = implic' }) }

zonkSimples :: Cts -&gt; TcM Cts
zonkSimples cts = do { cts' &lt;- mapBagM zonkCt' cts
                     ; traceTc &quot;zonkSimples done:&quot; (ppr cts')
                     ; return cts' }

zonkCt' :: Ct -&gt; TcM Ct
zonkCt' ct = zonkCt ct

{- Note [zonkCt behaviour]
~~~~~~~~~~~~~~~~~~~~~~~~~~
zonkCt tries to maintain the canonical form of a Ct.  For example,
  - a CDictCan should stay a CDictCan;
  - a CTyEqCan should stay a CTyEqCan (if the LHS stays as a variable.).
  - a CHoleCan should stay a CHoleCan
  - a CIrredCan should stay a CIrredCan with its cc_insol flag intact

Why?, for example:
- For CDictCan, the @TcSimplify.expandSuperClasses@ step, which runs after the
  simple wanted and plugin loop, looks for @CDictCan@s. If a plugin is in use,
  constraints are zonked before being passed to the plugin. This means if we
  don't preserve a canonical form, @expandSuperClasses@ fails to expand
  superclasses. This is what happened in Trac #11525.

- For CHoleCan, once we forget that it's a hole, we can never recover that info.

- For CIrredCan we want to see if a constraint is insoluble with insolubleWC

NB: we do not expect to see any CFunEqCans, because zonkCt is only
called on unflattened constraints.

NB: Constraints are always re-flattened etc by the canonicaliser in
@TcCanonical@ even if they come in as CDictCan. Only canonical constraints that
are actually in the inert set carry all the guarantees. So it is okay if zonkCt
creates e.g. a CDictCan where the cc_tyars are /not/ function free.
-}

zonkCt :: Ct -&gt; TcM Ct
zonkCt ct@(CHoleCan { cc_ev = ev })
  = do { ev' &lt;- zonkCtEvidence ev
       ; return $ ct { cc_ev = ev' } }

zonkCt ct@(CDictCan { cc_ev = ev, cc_tyargs = args })
  = do { ev'   &lt;- zonkCtEvidence ev
       ; args' &lt;- mapM zonkTcType args
       ; return $ ct { cc_ev = ev', cc_tyargs = args' } }

zonkCt ct@(CTyEqCan { cc_ev = ev, cc_tyvar = tv, cc_rhs = rhs })
  = do { ev'    &lt;- zonkCtEvidence ev
       ; tv_ty' &lt;- zonkTcTyVar tv
       ; case getTyVar_maybe tv_ty' of
           Just tv' -&gt; do { rhs' &lt;- zonkTcType rhs
                          ; return ct { cc_ev    = ev'
                                      , cc_tyvar = tv'
                                      , cc_rhs   = rhs' } }
           Nothing  -&gt; return (mkNonCanonical ev') }

zonkCt ct@(CIrredCan { cc_ev = ev }) -- Preserve the cc_insol flag
  = do { ev' &lt;- zonkCtEvidence ev
       ; return (ct { cc_ev = ev' }) }

zonkCt ct
  = ASSERT( not (isCFunEqCan ct) )
  -- We do not expect to see any CFunEqCans, because zonkCt is only called on
  -- unflattened constraints.
    do { fl' &lt;- zonkCtEvidence (ctEvidence ct)
       ; return (mkNonCanonical fl') }

zonkCtEvidence :: CtEvidence -&gt; TcM CtEvidence
zonkCtEvidence ctev@(CtGiven { ctev_pred = pred })
  = do { pred' &lt;- zonkTcType pred
       ; return (ctev { ctev_pred = pred'}) }
zonkCtEvidence ctev@(CtWanted { ctev_pred = pred, ctev_dest = dest })
  = do { pred' &lt;- zonkTcType pred
       ; let dest' = case dest of
                       EvVarDest ev -&gt; EvVarDest $ setVarType ev pred'
                         -- necessary in simplifyInfer
                       HoleDest h   -&gt; HoleDest h
       ; return (ctev { ctev_pred = pred', ctev_dest = dest' }) }
zonkCtEvidence ctev@(CtDerived { ctev_pred = pred })
  = do { pred' &lt;- zonkTcType pred
       ; return (ctev { ctev_pred = pred' }) }

zonkSkolemInfo :: SkolemInfo -&gt; TcM SkolemInfo
zonkSkolemInfo (SigSkol cx ty tv_prs)  = do { ty' &lt;- zonkTcType ty
                                            ; return (SigSkol cx ty' tv_prs) }
zonkSkolemInfo (InferSkol ntys) = do { ntys' &lt;- mapM do_one ntys
                                     ; return (InferSkol ntys') }
  where
    do_one (n, ty) = do { ty' &lt;- zonkTcType ty; return (n, ty') }
zonkSkolemInfo skol_info = return skol_info

{-
%************************************************************************
%*                                                                      *
\subsection{Zonking -- the main work-horses: zonkTcType, zonkTcTyVar}
*                                                                      *
*              For internal use only!                                  *
*                                                                      *
************************************************************************

-}

-- zonkId is used *during* typechecking just to zonk the Id's type
zonkId :: TcId -&gt; TcM TcId
zonkId id
  = do { ty' &lt;- zonkTcType (idType id)
       ; return (Id.setIdType id ty') }

zonkCoVar :: CoVar -&gt; TcM CoVar
zonkCoVar = zonkId

-- | A suitable TyCoMapper for zonking a type during type-checking,
-- before all metavars are filled in.
zonkTcTypeMapper :: TyCoMapper () TcM
zonkTcTypeMapper = TyCoMapper
  { tcm_smart = True
  , tcm_tyvar = const zonkTcTyVar
  , tcm_covar = const (\cv -&gt; mkCoVarCo &lt;$&gt; zonkTyCoVarKind cv)
  , tcm_hole  = hole
  , tcm_tycobinder = \_env tv _vis -&gt; ((), ) &lt;$&gt; zonkTyCoVarKind tv
  , tcm_tycon = return }
  where
    hole :: () -&gt; CoercionHole -&gt; TcM Coercion
    hole _ hole@(CoercionHole { ch_ref = ref, ch_co_var = cv })
      = do { contents &lt;- readTcRef ref
           ; case contents of
               Just co -&gt; do { co' &lt;- zonkCo co
                             ; checkCoercionHole cv co' }
               Nothing -&gt; do { cv' &lt;- zonkCoVar cv
                             ; return $ HoleCo (hole { ch_co_var = cv' }) } }

-- For unbound, mutable tyvars, zonkType uses the function given to it
-- For tyvars bound at a for-all, zonkType zonks them to an immutable
--      type variable and zonks the kind too
zonkTcType :: TcType -&gt; TcM TcType
zonkTcType = mapType zonkTcTypeMapper ()

-- | &quot;Zonk&quot; a coercion -- really, just zonk any types in the coercion
zonkCo :: Coercion -&gt; TcM Coercion
zonkCo = mapCoercion zonkTcTypeMapper ()

zonkTcTyCoVarBndr :: TcTyCoVar -&gt; TcM TcTyCoVar
-- A tyvar binder is never a unification variable (TauTv),
-- rather it is always a skolem. It *might* be a TyVarTv.
-- (Because non-CUSK type declarations use TyVarTvs.)
-- Regardless, it may have a kind
-- that has not yet been zonked, and may include kind
-- unification variables.
zonkTcTyCoVarBndr tyvar
  | isTyVarTyVar tyvar
     -- We want to preserve the binding location of the original TyVarTv.
     -- This is important for error messages. If we don't do this, then
     -- we get bad locations in, e.g., typecheck/should_fail/T2688
  = do { zonked_ty &lt;- zonkTcTyVar tyvar
       ; let zonked_tyvar = tcGetTyVar &quot;zonkTcTyCoVarBndr TyVarTv&quot; zonked_ty
             zonked_name  = getName zonked_tyvar
             reloc'd_name = setNameLoc zonked_name (getSrcSpan tyvar)
       ; return (setTyVarName zonked_tyvar reloc'd_name) }

  | otherwise
  = ASSERT2( isImmutableTyVar tyvar || isCoVar tyvar, pprTyVar tyvar )
    zonkTyCoVarKind tyvar

zonkTyConBinders :: [TyConBinder] -&gt; TcM [TyConBinder]
zonkTyConBinders = mapM zonk1
  where
    zonk1 (Bndr tv vis)
      = do { tv' &lt;- zonkTcTyCoVarBndr tv
           ; return (Bndr tv' vis) }

zonkTcTyVar :: TcTyVar -&gt; TcM TcType
-- Simply look through all Flexis
zonkTcTyVar tv
  | isTcTyVar tv
  = case tcTyVarDetails tv of
      SkolemTv {}   -&gt; zonk_kind_and_return
      RuntimeUnk {} -&gt; zonk_kind_and_return
      MetaTv { mtv_ref = ref }
         -&gt; do { cts &lt;- readMutVar ref
               ; case cts of
                    Flexi       -&gt; zonk_kind_and_return
                    Indirect ty -&gt; do { zty &lt;- zonkTcType ty
                                      ; writeTcRef ref (Indirect zty)
                                        -- See Note [Sharing in zonking]
                                      ; return zty } }

  | otherwise -- coercion variable
  = zonk_kind_and_return
  where
    zonk_kind_and_return = do { z_tv &lt;- zonkTyCoVarKind tv
                              ; return (mkTyVarTy z_tv) }

-- Variant that assumes that any result of zonking is still a TyVar.
-- Should be used only on skolems and TyVarTvs
zonkTcTyVarToTyVar :: HasDebugCallStack =&gt; TcTyVar -&gt; TcM TcTyVar
zonkTcTyVarToTyVar tv
  = do { ty &lt;- zonkTcTyVar tv
       ; let tv' = case tcGetTyVar_maybe ty of
                     Just tv' -&gt; tv'
                     Nothing  -&gt; pprPanic &quot;zonkTcTyVarToTyVar&quot;
                                          (ppr tv $$ ppr ty)
       ; return tv' }

zonkTyVarTyVarPairs :: [(Name,TcTyVar)] -&gt; TcM [(Name,TcTyVar)]
zonkTyVarTyVarPairs prs
  = mapM do_one prs
  where
    do_one (nm, tv) = do { tv' &lt;- zonkTcTyVarToTyVar tv
                         ; return (nm, tv') }

{- Note [Sharing in zonking]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose we have
   alpha :-&gt; beta :-&gt; gamma :-&gt; ty
where the &quot;:-&gt;&quot; means that the unification variable has been
filled in with Indirect. Then when zonking alpha, it'd be nice
to short-circuit beta too, so we end up with
   alpha :-&gt; zty
   beta  :-&gt; zty
   gamma :-&gt; zty
where zty is the zonked version of ty.  That way, if we come across
beta later, we'll have less work to do.  (And indeed the same for
alpha.)

This is easily achieved: just overwrite (Indirect ty) with (Indirect
zty).  Non-systematic perf comparisons suggest that this is a modest
win.

But c.f Note [Sharing when zonking to Type] in TcHsSyn.

%************************************************************************
%*                                                                      *
                 Tidying
*                                                                      *
************************************************************************
-}

zonkTidyTcType :: TidyEnv -&gt; TcType -&gt; TcM (TidyEnv, TcType)
zonkTidyTcType env ty = do { ty' &lt;- zonkTcType ty
                           ; return (tidyOpenType env ty') }

zonkTidyTcTypes :: TidyEnv -&gt; [TcType] -&gt; TcM (TidyEnv, [TcType])
zonkTidyTcTypes = zonkTidyTcTypes' []
  where zonkTidyTcTypes' zs env [] = return (env, reverse zs)
        zonkTidyTcTypes' zs env (ty:tys)
          = do { (env', ty') &lt;- zonkTidyTcType env ty
               ; zonkTidyTcTypes' (ty':zs) env' tys }

zonkTidyOrigin :: TidyEnv -&gt; CtOrigin -&gt; TcM (TidyEnv, CtOrigin)
zonkTidyOrigin env (GivenOrigin skol_info)
  = do { skol_info1 &lt;- zonkSkolemInfo skol_info
       ; let skol_info2 = tidySkolemInfo env skol_info1
       ; return (env, GivenOrigin skol_info2) }
zonkTidyOrigin env orig@(TypeEqOrigin { uo_actual   = act
                                      , uo_expected = exp })
  = do { (env1, act') &lt;- zonkTidyTcType env  act
       ; (env2, exp') &lt;- zonkTidyTcType env1 exp
       ; return ( env2, orig { uo_actual   = act'
                             , uo_expected = exp' }) }
zonkTidyOrigin env (KindEqOrigin ty1 m_ty2 orig t_or_k)
  = do { (env1, ty1')   &lt;- zonkTidyTcType env  ty1
       ; (env2, m_ty2') &lt;- case m_ty2 of
                             Just ty2 -&gt; second Just &lt;$&gt; zonkTidyTcType env1 ty2
                             Nothing  -&gt; return (env1, Nothing)
       ; (env3, orig')  &lt;- zonkTidyOrigin env2 orig
       ; return (env3, KindEqOrigin ty1' m_ty2' orig' t_or_k) }
zonkTidyOrigin env (FunDepOrigin1 p1 l1 p2 l2)
  = do { (env1, p1') &lt;- zonkTidyTcType env  p1
       ; (env2, p2') &lt;- zonkTidyTcType env1 p2
       ; return (env2, FunDepOrigin1 p1' l1 p2' l2) }
zonkTidyOrigin env (FunDepOrigin2 p1 o1 p2 l2)
  = do { (env1, p1') &lt;- zonkTidyTcType env  p1
       ; (env2, p2') &lt;- zonkTidyTcType env1 p2
       ; (env3, o1') &lt;- zonkTidyOrigin env2 o1
       ; return (env3, FunDepOrigin2 p1' o1' p2' l2) }
zonkTidyOrigin env orig = return (env, orig)

----------------
tidyCt :: TidyEnv -&gt; Ct -&gt; Ct
-- Used only in error reporting
-- Also converts it to non-canonical
tidyCt env ct
  = case ct of
     CHoleCan { cc_ev = ev }
       -&gt; ct { cc_ev = tidy_ev env ev }
     _ -&gt; mkNonCanonical (tidy_ev env (ctEvidence ct))
  where
    tidy_ev :: TidyEnv -&gt; CtEvidence -&gt; CtEvidence
     -- NB: we do not tidy the ctev_evar field because we don't
     --     show it in error messages
    tidy_ev env ctev@(CtGiven { ctev_pred = pred })
      = ctev { ctev_pred = tidyType env pred }
    tidy_ev env ctev@(CtWanted { ctev_pred = pred })
      = ctev { ctev_pred = tidyType env pred }
    tidy_ev env ctev@(CtDerived { ctev_pred = pred })
      = ctev { ctev_pred = tidyType env pred }

----------------
tidyEvVar :: TidyEnv -&gt; EvVar -&gt; EvVar
tidyEvVar env var = setVarType var (tidyType env (varType var))

----------------
tidySkolemInfo :: TidyEnv -&gt; SkolemInfo -&gt; SkolemInfo
tidySkolemInfo env (DerivSkol ty)         = DerivSkol (tidyType env ty)
tidySkolemInfo env (SigSkol cx ty tv_prs) = tidySigSkol env cx ty tv_prs
tidySkolemInfo env (InferSkol ids)        = InferSkol (mapSnd (tidyType env) ids)
tidySkolemInfo env (UnifyForAllSkol ty)   = UnifyForAllSkol (tidyType env ty)
tidySkolemInfo _   info                   = info

tidySigSkol :: TidyEnv -&gt; UserTypeCtxt
            -&gt; TcType -&gt; [(Name,TcTyVar)] -&gt; SkolemInfo
-- We need to take special care when tidying SigSkol
-- See Note [SigSkol SkolemInfo] in TcRnTypes
tidySigSkol env cx ty tv_prs
  = SigSkol cx (tidy_ty env ty) tv_prs'
  where
    tv_prs' = mapSnd (tidyTyCoVarOcc env) tv_prs
    inst_env = mkNameEnv tv_prs'

    tidy_ty env (ForAllTy (Bndr tv vis) ty)
      = ForAllTy (Bndr tv' vis) (tidy_ty env' ty)
      where
        (env', tv') = tidy_tv_bndr env tv

    tidy_ty env (FunTy arg res)
      = FunTy (tidyType env arg) (tidy_ty env res)

    tidy_ty env ty = tidyType env ty

    tidy_tv_bndr :: TidyEnv -&gt; TyCoVar -&gt; (TidyEnv, TyCoVar)
    tidy_tv_bndr env@(occ_env, subst) tv
      | Just tv' &lt;- lookupNameEnv inst_env (tyVarName tv)
      = ((occ_env, extendVarEnv subst tv tv'), tv')

      | otherwise
      = tidyVarBndr env tv

-------------------------------------------------------------------------
{-
%************************************************************************
%*                                                                      *
             Levity polymorphism checks
*                                                                      *
************************************************************************

See Note [Levity polymorphism checking] in DsMonad

-}

-- | According to the rules around representation polymorphism
-- (see https://ghc.haskell.org/trac/ghc/wiki/NoSubKinds), no binder
-- can have a representation-polymorphic type. This check ensures
-- that we respect this rule. It is a bit regrettable that this error
-- occurs in zonking, after which we should have reported all errors.
-- But it's hard to see where else to do it, because this can be discovered
-- only after all solving is done. And, perhaps most importantly, this
-- isn't really a compositional property of a type system, so it's
-- not a terrible surprise that the check has to go in an awkward spot.
ensureNotLevPoly :: Type  -- its zonked type
                 -&gt; SDoc  -- where this happened
                 -&gt; TcM ()
ensureNotLevPoly ty doc
  = whenNoErrs $   -- sometimes we end up zonking bogus definitions of type
                   -- forall a. a. See, for example, test ghci/scripts/T9140
    checkForLevPoly doc ty

  -- See Note [Levity polymorphism checking] in DsMonad
checkForLevPoly :: SDoc -&gt; Type -&gt; TcM ()
checkForLevPoly = checkForLevPolyX addErr

checkForLevPolyX :: Monad m
                 =&gt; (SDoc -&gt; m ())  -- how to report an error
                 -&gt; SDoc -&gt; Type -&gt; m ()
checkForLevPolyX add_err extra ty
  | isTypeLevPoly ty
  = add_err (formatLevPolyErr ty $$ extra)
  | otherwise
  = return ()

formatLevPolyErr :: Type  -- levity-polymorphic type
                 -&gt; SDoc
formatLevPolyErr ty
  = hang (text &quot;A levity-polymorphic type is not allowed here:&quot;)
       2 (vcat [ text &quot;Type:&quot; &lt;+&gt; pprWithTYPE tidy_ty
               , text &quot;Kind:&quot; &lt;+&gt; pprWithTYPE tidy_ki ])
  where
    (tidy_env, tidy_ty) = tidyOpenType emptyTidyEnv ty
    tidy_ki             = tidyType tidy_env (tcTypeKind ty)
</span></pre></body></html>