<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Compact.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE BangPatterns #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE MagicHash #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE UnboxedTuples #-}</span>
<a name="line-5"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-redundant-constraints -Wno-name-shadowing #-}</span>
<a name="line-6"></a>
<a name="line-7"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-8"></a><span class='hs-comment'>-- |</span>
<a name="line-9"></a><span class='hs-comment'>-- Module      :  GHC.Compact</span>
<a name="line-10"></a><span class='hs-comment'>-- Copyright   :  (c) The University of Glasgow 2001-2009</span>
<a name="line-11"></a><span class='hs-comment'>--                (c) Giovanni Campagna &lt;gcampagn@cs.stanford.edu&gt; 2014</span>
<a name="line-12"></a><span class='hs-comment'>-- License     :  BSD-style (see the file LICENSE)</span>
<a name="line-13"></a><span class='hs-comment'>--</span>
<a name="line-14"></a><span class='hs-comment'>-- Maintainer  :  libraries@haskell.org</span>
<a name="line-15"></a><span class='hs-comment'>-- Stability   :  unstable</span>
<a name="line-16"></a><span class='hs-comment'>-- Portability :  non-portable (GHC Extensions)</span>
<a name="line-17"></a><span class='hs-comment'>--</span>
<a name="line-18"></a><span class='hs-comment'>-- This module provides a data structure, called a 'Compact', for</span>
<a name="line-19"></a><span class='hs-comment'>-- holding immutable, fully evaluated data in a consecutive block of memory.</span>
<a name="line-20"></a><span class='hs-comment'>-- Compact regions are good for two things:</span>
<a name="line-21"></a><span class='hs-comment'>--</span>
<a name="line-22"></a><span class='hs-comment'>--  1. Data in a compact region is not traversed during GC; any</span>
<a name="line-23"></a><span class='hs-comment'>--  incoming pointer to a compact region keeps the entire region</span>
<a name="line-24"></a><span class='hs-comment'>--  live.  Thus, if you put a long-lived data structure in a compact</span>
<a name="line-25"></a><span class='hs-comment'>--  region, you may save a lot of cycles during major collections,</span>
<a name="line-26"></a><span class='hs-comment'>--  since you will no longer be (uselessly) retraversing this</span>
<a name="line-27"></a><span class='hs-comment'>--  data structure.</span>
<a name="line-28"></a><span class='hs-comment'>--</span>
<a name="line-29"></a><span class='hs-comment'>--  2. Because the data is stored contiguously, you can easily</span>
<a name="line-30"></a><span class='hs-comment'>--  dump the memory to disk and/or send it over the network.</span>
<a name="line-31"></a><span class='hs-comment'>--  For applications that are not bandwidth bound (GHC's heap</span>
<a name="line-32"></a><span class='hs-comment'>--  representation can be as much of a x4 expansion over a</span>
<a name="line-33"></a><span class='hs-comment'>--  binary serialization), this can lead to substantial speedups.</span>
<a name="line-34"></a><span class='hs-comment'>--</span>
<a name="line-35"></a><span class='hs-comment'>-- For example, suppose you have a function @loadBigStruct :: IO BigStruct@,</span>
<a name="line-36"></a><span class='hs-comment'>-- which loads a large data structure from the file system.  You can "compact"</span>
<a name="line-37"></a><span class='hs-comment'>-- the structure with the following code:</span>
<a name="line-38"></a><span class='hs-comment'>--</span>
<a name="line-39"></a><span class='hs-comment'>-- @</span>
<a name="line-40"></a><span class='hs-comment'>--      do r &lt;- 'compact' =&lt;&lt; loadBigStruct</span>
<a name="line-41"></a><span class='hs-comment'>--         let x = 'getCompact' r :: BigStruct</span>
<a name="line-42"></a><span class='hs-comment'>--         -- Do things with x</span>
<a name="line-43"></a><span class='hs-comment'>-- @</span>
<a name="line-44"></a><span class='hs-comment'>--</span>
<a name="line-45"></a><span class='hs-comment'>-- Note that 'compact' will not preserve internal sharing; use</span>
<a name="line-46"></a><span class='hs-comment'>-- 'compactWithSharing' (which is 10x slower) if you have cycles and/or</span>
<a name="line-47"></a><span class='hs-comment'>-- must preserve sharing.  The 'Compact' pointer @r@ can be used</span>
<a name="line-48"></a><span class='hs-comment'>-- to add more data to a compact region; see 'compactAdd' or</span>
<a name="line-49"></a><span class='hs-comment'>-- 'compactAddWithSharing'.</span>
<a name="line-50"></a><span class='hs-comment'>--</span>
<a name="line-51"></a><span class='hs-comment'>-- The implementation of compact regions is described by:</span>
<a name="line-52"></a><span class='hs-comment'>--</span>
<a name="line-53"></a><span class='hs-comment'>--  * Edward Z. Yang, Giovanni Campagna, Ömer Ağacan, Ahmed El-Hassany, Abhishek</span>
<a name="line-54"></a><span class='hs-comment'>--    Kulkarni, Ryan Newton. \"/Efficient communication and Collection with Compact</span>
<a name="line-55"></a><span class='hs-comment'>--    Normal Forms/\". In Proceedings of the 20th ACM SIGPLAN International</span>
<a name="line-56"></a><span class='hs-comment'>--    Conference on Functional Programming. September 2015. &lt;<a href="http://ezyang.com/compact.html">http://ezyang.com/compact.html</a>&gt;</span>
<a name="line-57"></a><span class='hs-comment'>--</span>
<a name="line-58"></a><span class='hs-comment'>-- This library is supported by GHC 8.2 and later.</span>
<a name="line-59"></a>
<a name="line-60"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Compact</span> <span class='hs-layout'>(</span>
<a name="line-61"></a>  <span class='hs-comment'>-- * The Compact type</span>
<a name="line-62"></a>  <span class='hs-conid'>Compact</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-63"></a>
<a name="line-64"></a>  <span class='hs-comment'>-- * Compacting data</span>
<a name="line-65"></a>  <span class='hs-varid'>compact</span><span class='hs-layout'>,</span>
<a name="line-66"></a>  <span class='hs-varid'>compactWithSharing</span><span class='hs-layout'>,</span>
<a name="line-67"></a>  <span class='hs-varid'>compactAdd</span><span class='hs-layout'>,</span>
<a name="line-68"></a>  <span class='hs-varid'>compactAddWithSharing</span><span class='hs-layout'>,</span>
<a name="line-69"></a>
<a name="line-70"></a>  <span class='hs-comment'>-- * Inspecting a Compact</span>
<a name="line-71"></a>  <span class='hs-varid'>getCompact</span><span class='hs-layout'>,</span>
<a name="line-72"></a>  <span class='hs-varid'>inCompact</span><span class='hs-layout'>,</span>
<a name="line-73"></a>  <span class='hs-varid'>isCompact</span><span class='hs-layout'>,</span>
<a name="line-74"></a>  <span class='hs-varid'>compactSize</span><span class='hs-layout'>,</span>
<a name="line-75"></a>
<a name="line-76"></a>  <span class='hs-comment'>-- * Other utilities</span>
<a name="line-77"></a>  <span class='hs-varid'>compactResize</span><span class='hs-layout'>,</span>
<a name="line-78"></a>
<a name="line-79"></a>  <span class='hs-comment'>-- * Internal operations</span>
<a name="line-80"></a>  <span class='hs-varid'>mkCompact</span><span class='hs-layout'>,</span>
<a name="line-81"></a>  <span class='hs-varid'>compactSized</span><span class='hs-layout'>,</span>
<a name="line-82"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-83"></a>
<a name="line-84"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Concurrent.MVar</span>
<a name="line-85"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prim</span>
<a name="line-86"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types</span>
<a name="line-87"></a>
<a name="line-88"></a><a name="Compact"></a><span class='hs-comment'>-- | A 'Compact' contains fully evaluated, pure, immutable data.</span>
<a name="line-89"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-90"></a><a name="Compact"></a><span class='hs-comment'>-- 'Compact' serves two purposes:</span>
<a name="line-91"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-92"></a><a name="Compact"></a><span class='hs-comment'>-- * Data stored in a 'Compact' has no garbage collection overhead.</span>
<a name="line-93"></a><a name="Compact"></a><span class='hs-comment'>--   The garbage collector considers the whole 'Compact' to be alive</span>
<a name="line-94"></a><a name="Compact"></a><span class='hs-comment'>--   if there is a reference to any object within it.</span>
<a name="line-95"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-96"></a><a name="Compact"></a><span class='hs-comment'>-- * A 'Compact' can be serialized, stored, and deserialized again.</span>
<a name="line-97"></a><a name="Compact"></a><span class='hs-comment'>--   The serialized data can only be deserialized by the exact binary</span>
<a name="line-98"></a><a name="Compact"></a><span class='hs-comment'>--   that created it, but it can be stored indefinitely before</span>
<a name="line-99"></a><a name="Compact"></a><span class='hs-comment'>--   deserialization.</span>
<a name="line-100"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-101"></a><a name="Compact"></a><span class='hs-comment'>-- Compacts are self-contained, so compacting data involves copying</span>
<a name="line-102"></a><a name="Compact"></a><span class='hs-comment'>-- it; if you have data that lives in two 'Compact's, each will have a</span>
<a name="line-103"></a><a name="Compact"></a><span class='hs-comment'>-- separate copy of the data.</span>
<a name="line-104"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-105"></a><a name="Compact"></a><span class='hs-comment'>-- The cost of compaction is similar to the cost of GC for the same</span>
<a name="line-106"></a><a name="Compact"></a><span class='hs-comment'>-- data, but it is performed only once.  However, because</span>
<a name="line-107"></a><a name="Compact"></a><span class='hs-comment'>-- "GHC.Compact.compact" does not stop-the-world, retaining internal</span>
<a name="line-108"></a><a name="Compact"></a><span class='hs-comment'>-- sharing during the compaction process is very costly. The user</span>
<a name="line-109"></a><a name="Compact"></a><span class='hs-comment'>-- can choose whether to 'compact' or 'compactWithSharing'.</span>
<a name="line-110"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-111"></a><a name="Compact"></a><span class='hs-comment'>-- When you have a @'Compact' a@, you can get a pointer to the actual object</span>
<a name="line-112"></a><a name="Compact"></a><span class='hs-comment'>-- in the region using "GHC.Compact.getCompact".  The 'Compact' type</span>
<a name="line-113"></a><a name="Compact"></a><span class='hs-comment'>-- serves as handle on the region itself; you can use this handle</span>
<a name="line-114"></a><a name="Compact"></a><span class='hs-comment'>-- to add data to a specific 'Compact' with 'compactAdd' or</span>
<a name="line-115"></a><a name="Compact"></a><span class='hs-comment'>-- 'compactAddWithSharing' (giving you a new handle which corresponds</span>
<a name="line-116"></a><a name="Compact"></a><span class='hs-comment'>-- to the same compact region, but points to the newly added object</span>
<a name="line-117"></a><a name="Compact"></a><span class='hs-comment'>-- in the region).  At the moment, due to technical reasons,</span>
<a name="line-118"></a><a name="Compact"></a><span class='hs-comment'>-- it's not possible to get the @'Compact' a@ if you only have an @a@,</span>
<a name="line-119"></a><a name="Compact"></a><span class='hs-comment'>-- so make sure you hold on to the handle as necessary.</span>
<a name="line-120"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-121"></a><a name="Compact"></a><span class='hs-comment'>-- Data in a compact doesn't ever move, so compacting data is also a</span>
<a name="line-122"></a><a name="Compact"></a><span class='hs-comment'>-- way to pin arbitrary data structures in memory.</span>
<a name="line-123"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-124"></a><a name="Compact"></a><span class='hs-comment'>-- There are some limitations on what can be compacted:</span>
<a name="line-125"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-126"></a><a name="Compact"></a><span class='hs-comment'>-- * Functions.  Compaction only applies to data.</span>
<a name="line-127"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-128"></a><a name="Compact"></a><span class='hs-comment'>-- * Pinned 'ByteArray#' objects cannot be compacted.  This is for a</span>
<a name="line-129"></a><a name="Compact"></a><span class='hs-comment'>--   good reason: the memory is pinned so that it can be referenced by</span>
<a name="line-130"></a><a name="Compact"></a><span class='hs-comment'>--   address (the address might be stored in a C data structure, for</span>
<a name="line-131"></a><a name="Compact"></a><span class='hs-comment'>--   example), so we can't make a copy of it to store in the 'Compact'.</span>
<a name="line-132"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-133"></a><a name="Compact"></a><span class='hs-comment'>-- * Objects with mutable pointer fields (e.g. 'Data.IORef.IORef',</span>
<a name="line-134"></a><a name="Compact"></a><span class='hs-comment'>--   'GHC.Array.MutableArray') also cannot be compacted, because subsequent</span>
<a name="line-135"></a><a name="Compact"></a><span class='hs-comment'>--   mutation would destroy the property that a compact is self-contained.</span>
<a name="line-136"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-137"></a><a name="Compact"></a><span class='hs-comment'>-- If compaction encounters any of the above, a 'CompactionFailed'</span>
<a name="line-138"></a><a name="Compact"></a><span class='hs-comment'>-- exception will be thrown by the compaction operation.</span>
<a name="line-139"></a><a name="Compact"></a><span class='hs-comment'>--</span>
<a name="line-140"></a><a name="Compact"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Compact</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Compact</span> <span class='hs-conid'>Compact</span><span class='hs-cpp'>#</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>MVar</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span>
<a name="line-141"></a>    <span class='hs-comment'>-- we can *read* from a Compact without taking a lock, but only</span>
<a name="line-142"></a>    <span class='hs-comment'>-- one thread can be writing to the compact at any given time.</span>
<a name="line-143"></a>    <span class='hs-comment'>-- The MVar here is to enforce mutual exclusion among writers.</span>
<a name="line-144"></a>    <span class='hs-comment'>-- Note: the MVar protects the Compact# only, not the pure value 'a'</span>
<a name="line-145"></a>
<a name="line-146"></a><a name="mkCompact"></a><span class='hs-comment'>-- | Make a new 'Compact' object, given a pointer to the true</span>
<a name="line-147"></a><span class='hs-comment'>-- underlying region.  You must uphold the invariant that @a@ lives</span>
<a name="line-148"></a><span class='hs-comment'>-- in the compact region.</span>
<a name="line-149"></a><span class='hs-comment'>--</span>
<a name="line-150"></a><span class='hs-definition'>mkCompact</span>
<a name="line-151"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Compact</span><span class='hs-cpp'>#</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>State</span><span class='hs-cpp'>#</span> <span class='hs-conid'>RealWorld</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-conid'>State</span><span class='hs-cpp'>#</span> <span class='hs-conid'>RealWorld</span><span class='hs-layout'>,</span> <span class='hs-conid'>Compact</span> <span class='hs-varid'>a</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-152"></a><span class='hs-definition'>mkCompact</span> <span class='hs-varid'>compact</span><span class='hs-cpp'>#</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span>
<a name="line-153"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>unIO</span> <span class='hs-layout'>(</span><span class='hs-varid'>newMVar</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>lock</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-154"></a>  <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-conid'>Compact</span> <span class='hs-varid'>compact</span><span class='hs-cpp'>#</span> <span class='hs-varid'>a</span> <span class='hs-varid'>lock</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-155"></a> <span class='hs-keyword'>where</span>
<a name="line-156"></a>  <span class='hs-varid'>unIO</span> <span class='hs-layout'>(</span><span class='hs-conid'>IO</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>a</span>
<a name="line-157"></a>
<a name="line-158"></a><a name="compactSized"></a><span class='hs-comment'>-- | Transfer @a@ into a new compact region, with a preallocated size,</span>
<a name="line-159"></a><span class='hs-comment'>-- possibly preserving sharing or not.  If you know how big the data</span>
<a name="line-160"></a><span class='hs-comment'>-- structure in question is, you can save time by picking an appropriate</span>
<a name="line-161"></a><span class='hs-comment'>-- block size for the compact region.</span>
<a name="line-162"></a><span class='hs-comment'>--</span>
<a name="line-163"></a><span class='hs-definition'>compactSized</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compact</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-164"></a><span class='hs-definition'>compactSized</span> <span class='hs-layout'>(</span><span class='hs-conid'>I</span><span class='hs-cpp'>#</span> <span class='hs-varid'>size</span><span class='hs-layout'>)</span> <span class='hs-varid'>share</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IO</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>s0</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-165"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>compactNew</span><span class='hs-cpp'>#</span> <span class='hs-layout'>(</span><span class='hs-varid'>int2Word</span><span class='hs-cpp'>#</span> <span class='hs-varid'>size</span><span class='hs-layout'>)</span> <span class='hs-varid'>s0</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>compact</span><span class='hs-cpp'>#</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-166"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>compactAddPrim</span> <span class='hs-varid'>compact</span><span class='hs-cpp'>#</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s1</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s2</span><span class='hs-layout'>,</span> <span class='hs-varid'>pk</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-167"></a>  <span class='hs-varid'>mkCompact</span> <span class='hs-varid'>compact</span><span class='hs-cpp'>#</span> <span class='hs-varid'>pk</span> <span class='hs-varid'>s2</span> <span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-168"></a> <span class='hs-keyword'>where</span>
<a name="line-169"></a>  <span class='hs-varid'>compactAddPrim</span>
<a name="line-170"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>share</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compactAddWithSharing</span><span class='hs-cpp'>#</span>
<a name="line-171"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compactAdd</span><span class='hs-cpp'>#</span>
<a name="line-172"></a>
<a name="line-173"></a><a name="getCompact"></a><span class='hs-comment'>-- | Retrieve a direct pointer to the value pointed at by a 'Compact' reference.</span>
<a name="line-174"></a><span class='hs-comment'>-- If you have used 'compactAdd', there may be multiple 'Compact' references</span>
<a name="line-175"></a><span class='hs-comment'>-- into the same compact region. Upholds the property:</span>
<a name="line-176"></a><span class='hs-comment'>--</span>
<a name="line-177"></a><span class='hs-comment'>-- &gt; inCompact c (getCompact c) == True</span>
<a name="line-178"></a><span class='hs-comment'>--</span>
<a name="line-179"></a><span class='hs-definition'>getCompact</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Compact</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-180"></a><span class='hs-definition'>getCompact</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compact</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>obj</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>obj</span>
<a name="line-181"></a>
<a name="line-182"></a><a name="compact"></a><span class='hs-comment'>-- | Compact a value. /O(size of unshared data)/</span>
<a name="line-183"></a><span class='hs-comment'>--</span>
<a name="line-184"></a><span class='hs-comment'>-- If the structure contains any internal sharing, the shared data</span>
<a name="line-185"></a><span class='hs-comment'>-- will be duplicated during the compaction process.  This will</span>
<a name="line-186"></a><span class='hs-comment'>-- not terminate if the structure contains cycles (use 'compactWithSharing'</span>
<a name="line-187"></a><span class='hs-comment'>-- instead).</span>
<a name="line-188"></a><span class='hs-comment'>--</span>
<a name="line-189"></a><span class='hs-comment'>-- The object in question must not contain any functions or data with mutable</span>
<a name="line-190"></a><span class='hs-comment'>-- pointers; if it does, 'compact' will raise an exception. In the future, we</span>
<a name="line-191"></a><span class='hs-comment'>-- may add a type class which will help statically check if this is the case or</span>
<a name="line-192"></a><span class='hs-comment'>-- not.</span>
<a name="line-193"></a><span class='hs-comment'>--</span>
<a name="line-194"></a><span class='hs-definition'>compact</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compact</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-195"></a><span class='hs-definition'>compact</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compactSized</span> <span class='hs-num'>31268</span> <span class='hs-conid'>False</span>
<a name="line-196"></a>
<a name="line-197"></a><a name="compactWithSharing"></a><span class='hs-comment'>-- | Compact a value, retaining any internal sharing and</span>
<a name="line-198"></a><span class='hs-comment'>-- cycles. /O(size of data)/</span>
<a name="line-199"></a><span class='hs-comment'>--</span>
<a name="line-200"></a><span class='hs-comment'>-- This is typically about 10x slower than 'compact', because it works</span>
<a name="line-201"></a><span class='hs-comment'>-- by maintaining a hash table mapping uncompacted objects to</span>
<a name="line-202"></a><span class='hs-comment'>-- compacted objects.</span>
<a name="line-203"></a><span class='hs-comment'>--</span>
<a name="line-204"></a><span class='hs-comment'>-- The object in question must not contain any functions or data with mutable</span>
<a name="line-205"></a><span class='hs-comment'>-- pointers; if it does, 'compact' will raise an exception. In the future, we</span>
<a name="line-206"></a><span class='hs-comment'>-- may add a type class which will help statically check if this is the case or</span>
<a name="line-207"></a><span class='hs-comment'>-- not.</span>
<a name="line-208"></a><span class='hs-comment'>--</span>
<a name="line-209"></a><span class='hs-definition'>compactWithSharing</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compact</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-210"></a><span class='hs-definition'>compactWithSharing</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compactSized</span> <span class='hs-num'>31268</span> <span class='hs-conid'>True</span>
<a name="line-211"></a>
<a name="line-212"></a><a name="compactAdd"></a><span class='hs-comment'>-- | Add a value to an existing 'Compact'.  This will help you avoid</span>
<a name="line-213"></a><span class='hs-comment'>-- copying when the value contains pointers into the compact region,</span>
<a name="line-214"></a><span class='hs-comment'>-- but remember that after compaction this value will only be deallocated</span>
<a name="line-215"></a><span class='hs-comment'>-- with the entire compact region.</span>
<a name="line-216"></a><span class='hs-comment'>--</span>
<a name="line-217"></a><span class='hs-comment'>-- Behaves exactly like 'compact' with respect to sharing and what data</span>
<a name="line-218"></a><span class='hs-comment'>-- it accepts.</span>
<a name="line-219"></a><span class='hs-comment'>--</span>
<a name="line-220"></a><span class='hs-definition'>compactAdd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Compact</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compact</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-221"></a><span class='hs-definition'>compactAdd</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compact</span> <span class='hs-varid'>compact</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>lock</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>withMVar</span> <span class='hs-varid'>lock</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-222"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>compactAdd</span><span class='hs-cpp'>#</span> <span class='hs-varid'>compact</span><span class='hs-cpp'>#</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>pk</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-223"></a>  <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-conid'>Compact</span> <span class='hs-varid'>compact</span><span class='hs-cpp'>#</span> <span class='hs-varid'>pk</span> <span class='hs-varid'>lock</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-224"></a>
<a name="line-225"></a><a name="compactAddWithSharing"></a><span class='hs-comment'>-- | Add a value to an existing 'Compact', like 'compactAdd',</span>
<a name="line-226"></a><span class='hs-comment'>-- but behaving exactly like 'compactWithSharing' with respect to sharing and</span>
<a name="line-227"></a><span class='hs-comment'>-- what data it accepts.</span>
<a name="line-228"></a><span class='hs-comment'>--</span>
<a name="line-229"></a><span class='hs-definition'>compactAddWithSharing</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Compact</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compact</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-230"></a><span class='hs-definition'>compactAddWithSharing</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compact</span> <span class='hs-varid'>compact</span><span class='hs-cpp'>#</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>lock</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span>
<a name="line-231"></a>  <span class='hs-varid'>withMVar</span> <span class='hs-varid'>lock</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-232"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>compactAddWithSharing</span><span class='hs-cpp'>#</span> <span class='hs-varid'>compact</span><span class='hs-cpp'>#</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>pk</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-233"></a>    <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-conid'>Compact</span> <span class='hs-varid'>compact</span><span class='hs-cpp'>#</span> <span class='hs-varid'>pk</span> <span class='hs-varid'>lock</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-234"></a>
<a name="line-235"></a><a name="inCompact"></a><span class='hs-comment'>-- | Check if the second argument is inside the passed 'Compact'.</span>
<a name="line-236"></a><span class='hs-comment'>--</span>
<a name="line-237"></a><span class='hs-definition'>inCompact</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Compact</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Bool</span>
<a name="line-238"></a><span class='hs-definition'>inCompact</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compact</span> <span class='hs-varid'>buffer</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varop'>!</span><span class='hs-varid'>val</span> <span class='hs-keyglyph'>=</span>
<a name="line-239"></a>  <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>compactContains</span><span class='hs-cpp'>#</span> <span class='hs-varid'>buffer</span> <span class='hs-varid'>val</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span>
<a name="line-240"></a>         <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s'</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s'</span><span class='hs-layout'>,</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-varid'>v</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-241"></a>
<a name="line-242"></a><a name="isCompact"></a><span class='hs-comment'>-- | Check if the argument is in any 'Compact'.  If true, the value in question</span>
<a name="line-243"></a><span class='hs-comment'>-- is also fully evaluated, since any value in a compact region must</span>
<a name="line-244"></a><span class='hs-comment'>-- be fully evaluated.</span>
<a name="line-245"></a><span class='hs-comment'>--</span>
<a name="line-246"></a><span class='hs-definition'>isCompact</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Bool</span>
<a name="line-247"></a><a name="!"></a><span class='hs-definition'>isCompact</span> <span class='hs-varop'>!</span><span class='hs-varid'>val</span> <span class='hs-keyglyph'>=</span>
<a name="line-248"></a>  <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>compactContainsAny</span><span class='hs-cpp'>#</span> <span class='hs-varid'>val</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span>
<a name="line-249"></a>         <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s'</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s'</span><span class='hs-layout'>,</span> <span class='hs-varid'>isTrue</span><span class='hs-cpp'>#</span> <span class='hs-varid'>v</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-250"></a>
<a name="line-251"></a><a name="compactSize"></a><span class='hs-comment'>-- | Returns the size in bytes of the compact region.</span>
<a name="line-252"></a><span class='hs-comment'>--</span>
<a name="line-253"></a><span class='hs-definition'>compactSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Compact</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Word</span>
<a name="line-254"></a><span class='hs-definition'>compactSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compact</span> <span class='hs-varid'>buffer</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>lock</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>withMVar</span> <span class='hs-varid'>lock</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>s0</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-255"></a>   <span class='hs-keyword'>case</span> <span class='hs-varid'>compactSize</span><span class='hs-cpp'>#</span> <span class='hs-varid'>buffer</span> <span class='hs-varid'>s0</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>sz</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-conid'>W</span><span class='hs-cpp'>#</span> <span class='hs-varid'>sz</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
<a name="line-256"></a>
<a name="line-257"></a><a name="compactResize"></a><span class='hs-comment'>-- | *Experimental.*  This function doesn't actually resize a compact</span>
<a name="line-258"></a><span class='hs-comment'>-- region; rather, it changes the default block size which we allocate</span>
<a name="line-259"></a><span class='hs-comment'>-- when the current block runs out of space, and also appends a block</span>
<a name="line-260"></a><span class='hs-comment'>-- to the compact region.</span>
<a name="line-261"></a><span class='hs-comment'>--</span>
<a name="line-262"></a><span class='hs-definition'>compactResize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Compact</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Word</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-263"></a><span class='hs-definition'>compactResize</span> <span class='hs-layout'>(</span><span class='hs-conid'>Compact</span> <span class='hs-varid'>oldBuffer</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>lock</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>W</span><span class='hs-cpp'>#</span> <span class='hs-varid'>new_size</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-264"></a>  <span class='hs-varid'>withMVar</span> <span class='hs-varid'>lock</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-265"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>compactResize</span><span class='hs-cpp'>#</span> <span class='hs-varid'>oldBuffer</span> <span class='hs-varid'>new_size</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span>
<a name="line-266"></a>      <span class='hs-varid'>s'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-cpp'>#</span> <span class='hs-varid'>s'</span><span class='hs-layout'>,</span> <span class='hs-conid'>()</span> <span class='hs-cpp'>#</span><span class='hs-layout'>)</span>
</pre></body>
</html>
