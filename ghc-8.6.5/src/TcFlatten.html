<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck/TcFlatten.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP, ViewPatterns, BangPatterns #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcFlatten</span><span class='hs-layout'>(</span>
<a name="line-4"></a>   <span class='hs-conid'>FlattenMode</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-5"></a>   <span class='hs-varid'>flatten</span><span class='hs-layout'>,</span> <span class='hs-varid'>flattenKind</span><span class='hs-layout'>,</span> <span class='hs-varid'>flattenArgsNom</span><span class='hs-layout'>,</span>
<a name="line-6"></a>
<a name="line-7"></a>   <span class='hs-varid'>unflattenWanteds</span>
<a name="line-8"></a> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GhcPrelude</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnTypes</span>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEvidence</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCoRep</span>   <span class='hs-comment'>-- performs delicate algorithm on types</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Coercion</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSMonad</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TcS</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span><span class='hs-layout'>(</span> <span class='hs-conid'>SwapFlag</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-27"></a>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Pair</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Bag</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad</span>
<a name="line-32"></a>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Arrow</span> <span class='hs-layout'>(</span> <span class='hs-varid'>first</span> <span class='hs-layout'>)</span>
<a name="line-34"></a>
<a name="line-35"></a><span class='hs-comment'>{-
<a name="line-36"></a>Note [The flattening story]
<a name="line-37"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-38"></a>* A CFunEqCan is either of form
<a name="line-39"></a>     [G] &lt;F xis&gt; : F xis ~ fsk   -- fsk is a FlatSkolTv
<a name="line-40"></a>     [W]       x : F xis ~ fmv   -- fmv is a FlatMetaTv
<a name="line-41"></a>  where
<a name="line-42"></a>     x is the witness variable
<a name="line-43"></a>     xis are function-free
<a name="line-44"></a>     fsk/fmv is a flatten skolem;
<a name="line-45"></a>        it is always untouchable (level 0)
<a name="line-46"></a>
<a name="line-47"></a>* CFunEqCans can have any flavour: [G], [W], [WD] or [D]
<a name="line-48"></a>
<a name="line-49"></a>* KEY INSIGHTS:
<a name="line-50"></a>
<a name="line-51"></a>   - A given flatten-skolem, fsk, is known a-priori to be equal to
<a name="line-52"></a>     F xis (the LHS), with &lt;F xis&gt; evidence.  The fsk is still a
<a name="line-53"></a>     unification variable, but it is "owned" by its CFunEqCan, and
<a name="line-54"></a>     is filled in (unflattened) only by unflattenGivens.
<a name="line-55"></a>
<a name="line-56"></a>   - A unification flatten-skolem, fmv, stands for the as-yet-unknown
<a name="line-57"></a>     type to which (F xis) will eventually reduce.  It is filled in
<a name="line-58"></a>
<a name="line-59"></a>
<a name="line-60"></a>   - All fsk/fmv variables are "untouchable".  To make it simple to test,
<a name="line-61"></a>     we simply give them TcLevel=0.  This means that in a CTyVarEq, say,
<a name="line-62"></a>       fmv ~ Int
<a name="line-63"></a>     we NEVER unify fmv.
<a name="line-64"></a>
<a name="line-65"></a>   - A unification flatten-skolem, fmv, ONLY gets unified when either
<a name="line-66"></a>       a) The CFunEqCan takes a step, using an axiom
<a name="line-67"></a>       b) By unflattenWanteds
<a name="line-68"></a>    They are never unified in any other form of equality.
<a name="line-69"></a>    For example [W] ffmv ~ Int  is stuck; it does not unify with fmv.
<a name="line-70"></a>
<a name="line-71"></a>* We *never* substitute in the RHS (i.e. the fsk/fmv) of a CFunEqCan.
<a name="line-72"></a>  That would destroy the invariant about the shape of a CFunEqCan,
<a name="line-73"></a>  and it would risk wanted/wanted interactions. The only way we
<a name="line-74"></a>  learn information about fsk is when the CFunEqCan takes a step.
<a name="line-75"></a>
<a name="line-76"></a>  However we *do* substitute in the LHS of a CFunEqCan (else it
<a name="line-77"></a>  would never get to fire!)
<a name="line-78"></a>
<a name="line-79"></a>* Unflattening:
<a name="line-80"></a>   - We unflatten Givens when leaving their scope (see unflattenGivens)
<a name="line-81"></a>   - We unflatten Wanteds at the end of each attempt to simplify the
<a name="line-82"></a>     wanteds; see unflattenWanteds, called from solveSimpleWanteds.
<a name="line-83"></a>
<a name="line-84"></a>* Ownership of fsk/fmv.  Each canonical [G], [W], or [WD]
<a name="line-85"></a>       CFunEqCan x : F xis ~ fsk/fmv
<a name="line-86"></a>  "owns" a distinct evidence variable x, and flatten-skolem fsk/fmv.
<a name="line-87"></a>  Why? We make a fresh fsk/fmv when the constraint is born;
<a name="line-88"></a>  and we never rewrite the RHS of a CFunEqCan.
<a name="line-89"></a>
<a name="line-90"></a>  In contrast a [D] CFunEqCan /shares/ its fmv with its partner [W],
<a name="line-91"></a>  but does not "own" it.  If we reduce a [D] F Int ~ fmv, where
<a name="line-92"></a>  say type instance F Int = ty, then we don't discharge fmv := ty.
<a name="line-93"></a>  Rather we simply generate [D] fmv ~ ty (in TcInteract.reduce_top_fun_eq,
<a name="line-94"></a>  and dischargeFmv)
<a name="line-95"></a>
<a name="line-96"></a>* Inert set invariant: if F xis1 ~ fsk1, F xis2 ~ fsk2
<a name="line-97"></a>                       then xis1 /= xis2
<a name="line-98"></a>  i.e. at most one CFunEqCan with a particular LHS
<a name="line-99"></a>
<a name="line-100"></a>* Function applications can occur in the RHS of a CTyEqCan.  No reason
<a name="line-101"></a>  not allow this, and it reduces the amount of flattening that must occur.
<a name="line-102"></a>
<a name="line-103"></a>* Flattening a type (F xis):
<a name="line-104"></a>    - If we are flattening in a Wanted/Derived constraint
<a name="line-105"></a>      then create new [W] x : F xis ~ fmv
<a name="line-106"></a>      else create new [G] x : F xis ~ fsk
<a name="line-107"></a>      with fresh evidence variable x and flatten-skolem fsk/fmv
<a name="line-108"></a>
<a name="line-109"></a>    - Add it to the work list
<a name="line-110"></a>
<a name="line-111"></a>    - Replace (F xis) with fsk/fmv in the type you are flattening
<a name="line-112"></a>
<a name="line-113"></a>    - You can also add the CFunEqCan to the "flat cache", which
<a name="line-114"></a>      simply keeps track of all the function applications you
<a name="line-115"></a>      have flattened.
<a name="line-116"></a>
<a name="line-117"></a>    - If (F xis) is in the cache already, just
<a name="line-118"></a>      use its fsk/fmv and evidence x, and emit nothing.
<a name="line-119"></a>
<a name="line-120"></a>    - No need to substitute in the flat-cache. It's not the end
<a name="line-121"></a>      of the world if we start with, say (F alpha ~ fmv1) and
<a name="line-122"></a>      (F Int ~ fmv2) and then find alpha := Int.  Athat will
<a name="line-123"></a>      simply give rise to fmv1 := fmv2 via [Interacting rule] below
<a name="line-124"></a>
<a name="line-125"></a>* Canonicalising a CFunEqCan [G/W] x : F xis ~ fsk/fmv
<a name="line-126"></a>    - Flatten xis (to substitute any tyvars; there are already no functions)
<a name="line-127"></a>                  cos :: xis ~ flat_xis
<a name="line-128"></a>    - New wanted  x2 :: F flat_xis ~ fsk/fmv
<a name="line-129"></a>    - Add new wanted to flat cache
<a name="line-130"></a>    - Discharge x = F cos ; x2
<a name="line-131"></a>
<a name="line-132"></a>* [Interacting rule]
<a name="line-133"></a>    (inert)     [W] x1 : F tys ~ fmv1
<a name="line-134"></a>    (work item) [W] x2 : F tys ~ fmv2
<a name="line-135"></a>  Just solve one from the other:
<a name="line-136"></a>    x2 := x1
<a name="line-137"></a>    fmv2 := fmv1
<a name="line-138"></a>  This just unites the two fsks into one.
<a name="line-139"></a>  Always solve given from wanted if poss.
<a name="line-140"></a>
<a name="line-141"></a>* For top-level reductions, see Note [Top-level reductions for type functions]
<a name="line-142"></a>  in TcInteract
<a name="line-143"></a>
<a name="line-144"></a>
<a name="line-145"></a>Why given-fsks, alone, doesn't work
<a name="line-146"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-147"></a>Could we get away with only flatten meta-tyvars, with no flatten-skolems? No.
<a name="line-148"></a>
<a name="line-149"></a>  [W] w : alpha ~ [F alpha Int]
<a name="line-150"></a>
<a name="line-151"></a>---&gt; flatten
<a name="line-152"></a>  w = ...w'...
<a name="line-153"></a>  [W] w' : alpha ~ [fsk]
<a name="line-154"></a>  [G] &lt;F alpha Int&gt; : F alpha Int ~ fsk
<a name="line-155"></a>
<a name="line-156"></a>--&gt; unify (no occurs check)
<a name="line-157"></a>  alpha := [fsk]
<a name="line-158"></a>
<a name="line-159"></a>But since fsk = F alpha Int, this is really an occurs check error.  If
<a name="line-160"></a>that is all we know about alpha, we will succeed in constraint
<a name="line-161"></a>solving, producing a program with an infinite type.
<a name="line-162"></a>
<a name="line-163"></a>Even if we did finally get (g : fsk ~ Bool) by solving (F alpha Int ~ fsk)
<a name="line-164"></a>using axiom, zonking would not see it, so (x::alpha) sitting in the
<a name="line-165"></a>tree will get zonked to an infinite type.  (Zonking always only does
<a name="line-166"></a>refl stuff.)
<a name="line-167"></a>
<a name="line-168"></a>Why flatten-meta-vars, alone doesn't work
<a name="line-169"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-170"></a>Look at Simple13, with unification-fmvs only
<a name="line-171"></a>
<a name="line-172"></a>  [G] g : a ~ [F a]
<a name="line-173"></a>
<a name="line-174"></a>---&gt; Flatten given
<a name="line-175"></a>  g' = g;[x]
<a name="line-176"></a>  [G] g'  : a ~ [fmv]
<a name="line-177"></a>  [W] x : F a ~ fmv
<a name="line-178"></a>
<a name="line-179"></a>--&gt; subst a in x
<a name="line-180"></a>  g' = g;[x]
<a name="line-181"></a>  x = F g' ; x2
<a name="line-182"></a>  [W] x2 : F [fmv] ~ fmv
<a name="line-183"></a>
<a name="line-184"></a>And now we have an evidence cycle between g' and x!
<a name="line-185"></a>
<a name="line-186"></a>If we used a given instead (ie current story)
<a name="line-187"></a>
<a name="line-188"></a>  [G] g : a ~ [F a]
<a name="line-189"></a>
<a name="line-190"></a>---&gt; Flatten given
<a name="line-191"></a>  g' = g;[x]
<a name="line-192"></a>  [G] g'  : a ~ [fsk]
<a name="line-193"></a>  [G] &lt;F a&gt; : F a ~ fsk
<a name="line-194"></a>
<a name="line-195"></a>---&gt; Substitute for a
<a name="line-196"></a>  [G] g'  : a ~ [fsk]
<a name="line-197"></a>  [G] F (sym g'); &lt;F a&gt; : F [fsk] ~ fsk
<a name="line-198"></a>
<a name="line-199"></a>
<a name="line-200"></a>Why is it right to treat fmv's differently to ordinary unification vars?
<a name="line-201"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-202"></a>  f :: forall a. a -&gt; a -&gt; Bool
<a name="line-203"></a>  g :: F Int -&gt; F Int -&gt; Bool
<a name="line-204"></a>
<a name="line-205"></a>Consider
<a name="line-206"></a>  f (x:Int) (y:Bool)
<a name="line-207"></a>This gives alpha~Int, alpha~Bool.  There is an inconsistency,
<a name="line-208"></a>but really only one error.  SherLoc may tell you which location
<a name="line-209"></a>is most likely, based on other occurrences of alpha.
<a name="line-210"></a>
<a name="line-211"></a>Consider
<a name="line-212"></a>  g (x:Int) (y:Bool)
<a name="line-213"></a>Here we get (F Int ~ Int, F Int ~ Bool), which flattens to
<a name="line-214"></a>  (fmv ~ Int, fmv ~ Bool)
<a name="line-215"></a>But there are really TWO separate errors.
<a name="line-216"></a>
<a name="line-217"></a>  ** We must not complain about Int~Bool. **
<a name="line-218"></a>
<a name="line-219"></a>Moreover these two errors could arise in entirely unrelated parts of
<a name="line-220"></a>the code.  (In the alpha case, there must be *some* connection (eg
<a name="line-221"></a>v:alpha in common envt).)
<a name="line-222"></a>
<a name="line-223"></a>Note [Unflattening can force the solver to iterate]
<a name="line-224"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-225"></a>Look at Trac #10340:
<a name="line-226"></a>   type family Any :: *   -- No instances
<a name="line-227"></a>   get :: MonadState s m =&gt; m s
<a name="line-228"></a>   instance MonadState s (State s) where ...
<a name="line-229"></a>
<a name="line-230"></a>   foo :: State Any Any
<a name="line-231"></a>   foo = get
<a name="line-232"></a>
<a name="line-233"></a>For 'foo' we instantiate 'get' at types mm ss
<a name="line-234"></a>   [WD] MonadState ss mm, [WD] mm ss ~ State Any Any
<a name="line-235"></a>Flatten, and decompose
<a name="line-236"></a>   [WD] MonadState ss mm, [WD] Any ~ fmv
<a name="line-237"></a>   [WD] mm ~ State fmv, [WD] fmv ~ ss
<a name="line-238"></a>Unify mm := State fmv:
<a name="line-239"></a>   [WD] MonadState ss (State fmv)
<a name="line-240"></a>   [WD] Any ~ fmv, [WD] fmv ~ ss
<a name="line-241"></a>Now we are stuck; the instance does not match!!  So unflatten:
<a name="line-242"></a>   fmv := Any
<a name="line-243"></a>   ss := Any    (*)
<a name="line-244"></a>   [WD] MonadState Any (State Any)
<a name="line-245"></a>
<a name="line-246"></a>The unification (*) represents progress, so we must do a second
<a name="line-247"></a>round of solving; this time it succeeds. This is done by the 'go'
<a name="line-248"></a>loop in solveSimpleWanteds.
<a name="line-249"></a>
<a name="line-250"></a>This story does not feel right but it's the best I can do; and the
<a name="line-251"></a>iteration only happens in pretty obscure circumstances.
<a name="line-252"></a>
<a name="line-253"></a>
<a name="line-254"></a>************************************************************************
<a name="line-255"></a>*                                                                      *
<a name="line-256"></a>*                  Examples
<a name="line-257"></a>     Here is a long series of examples I had to work through
<a name="line-258"></a>*                                                                      *
<a name="line-259"></a>************************************************************************
<a name="line-260"></a>
<a name="line-261"></a>Simple20
<a name="line-262"></a>~~~~~~~~
<a name="line-263"></a>axiom F [a] = [F a]
<a name="line-264"></a>
<a name="line-265"></a> [G] F [a] ~ a
<a name="line-266"></a>--&gt;
<a name="line-267"></a> [G] fsk ~ a
<a name="line-268"></a> [G] [F a] ~ fsk  (nc)
<a name="line-269"></a>--&gt;
<a name="line-270"></a> [G] F a ~ fsk2
<a name="line-271"></a> [G] fsk ~ [fsk2]
<a name="line-272"></a> [G] fsk ~ a
<a name="line-273"></a>--&gt;
<a name="line-274"></a> [G] F a ~ fsk2
<a name="line-275"></a> [G] a ~ [fsk2]
<a name="line-276"></a> [G] fsk ~ a
<a name="line-277"></a>
<a name="line-278"></a>----------------------------------------
<a name="line-279"></a>indexed-types/should_compile/T44984
<a name="line-280"></a>
<a name="line-281"></a>  [W] H (F Bool) ~ H alpha
<a name="line-282"></a>  [W] alpha ~ F Bool
<a name="line-283"></a>--&gt;
<a name="line-284"></a>  F Bool  ~ fmv0
<a name="line-285"></a>  H fmv0  ~ fmv1
<a name="line-286"></a>  H alpha ~ fmv2
<a name="line-287"></a>
<a name="line-288"></a>  fmv1 ~ fmv2
<a name="line-289"></a>  fmv0 ~ alpha
<a name="line-290"></a>
<a name="line-291"></a>flatten
<a name="line-292"></a>~~~~~~~
<a name="line-293"></a>  fmv0  := F Bool
<a name="line-294"></a>  fmv1  := H (F Bool)
<a name="line-295"></a>  fmv2  := H alpha
<a name="line-296"></a>  alpha := F Bool
<a name="line-297"></a>plus
<a name="line-298"></a>  fmv1 ~ fmv2
<a name="line-299"></a>
<a name="line-300"></a>But these two are equal under the above assumptions.
<a name="line-301"></a>Solve by Refl.
<a name="line-302"></a>
<a name="line-303"></a>
<a name="line-304"></a>--- under plan B, namely solve fmv1:=fmv2 eagerly ---
<a name="line-305"></a>  [W] H (F Bool) ~ H alpha
<a name="line-306"></a>  [W] alpha ~ F Bool
<a name="line-307"></a>--&gt;
<a name="line-308"></a>  F Bool  ~ fmv0
<a name="line-309"></a>  H fmv0  ~ fmv1
<a name="line-310"></a>  H alpha ~ fmv2
<a name="line-311"></a>
<a name="line-312"></a>  fmv1 ~ fmv2
<a name="line-313"></a>  fmv0 ~ alpha
<a name="line-314"></a>--&gt;
<a name="line-315"></a>  F Bool  ~ fmv0
<a name="line-316"></a>  H fmv0  ~ fmv1
<a name="line-317"></a>  H alpha ~ fmv2    fmv2 := fmv1
<a name="line-318"></a>
<a name="line-319"></a>  fmv0 ~ alpha
<a name="line-320"></a>
<a name="line-321"></a>flatten
<a name="line-322"></a>  fmv0 := F Bool
<a name="line-323"></a>  fmv1 := H fmv0 = H (F Bool)
<a name="line-324"></a>  retain   H alpha ~ fmv2
<a name="line-325"></a>    because fmv2 has been filled
<a name="line-326"></a>  alpha := F Bool
<a name="line-327"></a>
<a name="line-328"></a>
<a name="line-329"></a>----------------------------
<a name="line-330"></a>indexed-types/should_failt/T4179
<a name="line-331"></a>
<a name="line-332"></a>after solving
<a name="line-333"></a>  [W] fmv_1 ~ fmv_2
<a name="line-334"></a>  [W] A3 (FCon x)           ~ fmv_1    (CFunEqCan)
<a name="line-335"></a>  [W] A3 (x (aoa -&gt; fmv_2)) ~ fmv_2    (CFunEqCan)
<a name="line-336"></a>
<a name="line-337"></a>----------------------------------------
<a name="line-338"></a>indexed-types/should_fail/T7729a
<a name="line-339"></a>
<a name="line-340"></a>a)  [W]   BasePrimMonad (Rand m) ~ m1
<a name="line-341"></a>b)  [W]   tt m1 ~ BasePrimMonad (Rand m)
<a name="line-342"></a>
<a name="line-343"></a>---&gt;  process (b) first
<a name="line-344"></a>    BasePrimMonad (Ramd m) ~ fmv_atH
<a name="line-345"></a>    fmv_atH ~ tt m1
<a name="line-346"></a>
<a name="line-347"></a>---&gt;  now process (a)
<a name="line-348"></a>    m1 ~ s_atH ~ tt m1    -- An obscure occurs check
<a name="line-349"></a>
<a name="line-350"></a>
<a name="line-351"></a>----------------------------------------
<a name="line-352"></a>typecheck/TcTypeNatSimple
<a name="line-353"></a>
<a name="line-354"></a>Original constraint
<a name="line-355"></a>  [W] x + y ~ x + alpha  (non-canonical)
<a name="line-356"></a>==&gt;
<a name="line-357"></a>  [W] x + y     ~ fmv1   (CFunEqCan)
<a name="line-358"></a>  [W] x + alpha ~ fmv2   (CFuneqCan)
<a name="line-359"></a>  [W] fmv1 ~ fmv2        (CTyEqCan)
<a name="line-360"></a>
<a name="line-361"></a>(sigh)
<a name="line-362"></a>
<a name="line-363"></a>----------------------------------------
<a name="line-364"></a>indexed-types/should_fail/GADTwrong1
<a name="line-365"></a>
<a name="line-366"></a>  [G] Const a ~ ()
<a name="line-367"></a>==&gt; flatten
<a name="line-368"></a>  [G] fsk ~ ()
<a name="line-369"></a>  work item: Const a ~ fsk
<a name="line-370"></a>==&gt; fire top rule
<a name="line-371"></a>  [G] fsk ~ ()
<a name="line-372"></a>  work item fsk ~ ()
<a name="line-373"></a>
<a name="line-374"></a>Surely the work item should rewrite to () ~ ()?  Well, maybe not;
<a name="line-375"></a>it'a very special case.  More generally, our givens look like
<a name="line-376"></a>F a ~ Int, where (F a) is not reducible.
<a name="line-377"></a>
<a name="line-378"></a>
<a name="line-379"></a>----------------------------------------
<a name="line-380"></a>indexed_types/should_fail/T8227:
<a name="line-381"></a>
<a name="line-382"></a>Why using a different can-rewrite rule in CFunEqCan heads
<a name="line-383"></a>does not work.
<a name="line-384"></a>
<a name="line-385"></a>Assuming NOT rewriting wanteds with wanteds
<a name="line-386"></a>
<a name="line-387"></a>   Inert: [W] fsk_aBh ~ fmv_aBk -&gt; fmv_aBk
<a name="line-388"></a>          [W] fmv_aBk ~ fsk_aBh
<a name="line-389"></a>
<a name="line-390"></a>          [G] Scalar fsk_aBg ~ fsk_aBh
<a name="line-391"></a>          [G] V a ~ f_aBg
<a name="line-392"></a>
<a name="line-393"></a>   Worklist includes  [W] Scalar fmv_aBi ~ fmv_aBk
<a name="line-394"></a>   fmv_aBi, fmv_aBk are flatten unification variables
<a name="line-395"></a>
<a name="line-396"></a>   Work item: [W] V fsk_aBh ~ fmv_aBi
<a name="line-397"></a>
<a name="line-398"></a>Note that the inert wanteds are cyclic, because we do not rewrite
<a name="line-399"></a>wanteds with wanteds.
<a name="line-400"></a>
<a name="line-401"></a>
<a name="line-402"></a>Then we go into a loop when normalise the work-item, because we
<a name="line-403"></a>use rewriteOrSame on the argument of V.
<a name="line-404"></a>
<a name="line-405"></a>Conclusion: Don't make canRewrite context specific; instead use
<a name="line-406"></a>[W] a ~ ty to rewrite a wanted iff 'a' is a unification variable.
<a name="line-407"></a>
<a name="line-408"></a>
<a name="line-409"></a>----------------------------------------
<a name="line-410"></a>
<a name="line-411"></a>Here is a somewhat similar case:
<a name="line-412"></a>
<a name="line-413"></a>   type family G a :: *
<a name="line-414"></a>
<a name="line-415"></a>   blah :: (G a ~ Bool, Eq (G a)) =&gt; a -&gt; a
<a name="line-416"></a>   blah = error "urk"
<a name="line-417"></a>
<a name="line-418"></a>   foo x = blah x
<a name="line-419"></a>
<a name="line-420"></a>For foo we get
<a name="line-421"></a>   [W] Eq (G a), G a ~ Bool
<a name="line-422"></a>Flattening
<a name="line-423"></a>   [W] G a ~ fmv, Eq fmv, fmv ~ Bool
<a name="line-424"></a>We can't simplify away the Eq Bool unless we substitute for fmv.
<a name="line-425"></a>Maybe that doesn't matter: we would still be left with unsolved
<a name="line-426"></a>G a ~ Bool.
<a name="line-427"></a>
<a name="line-428"></a>--------------------------
<a name="line-429"></a>Trac #9318 has a very simple program leading to
<a name="line-430"></a>
<a name="line-431"></a>  [W] F Int ~ Int
<a name="line-432"></a>  [W] F Int ~ Bool
<a name="line-433"></a>
<a name="line-434"></a>We don't want to get "Error Int~Bool".  But if fmv's can rewrite
<a name="line-435"></a>wanteds, we will
<a name="line-436"></a>
<a name="line-437"></a>  [W] fmv ~ Int
<a name="line-438"></a>  [W] fmv ~ Bool
<a name="line-439"></a>---&gt;
<a name="line-440"></a>  [W] Int ~ Bool
<a name="line-441"></a>
<a name="line-442"></a>
<a name="line-443"></a>************************************************************************
<a name="line-444"></a>*                                                                      *
<a name="line-445"></a>*                FlattenEnv &amp; FlatM
<a name="line-446"></a>*             The flattening environment &amp; monad
<a name="line-447"></a>*                                                                      *
<a name="line-448"></a>************************************************************************
<a name="line-449"></a>
<a name="line-450"></a>-}</span>
<a name="line-451"></a>
<a name="line-452"></a><a name="FlatWorkListRef"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>FlatWorkListRef</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TcRef</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- See Note [The flattening work list]</span>
<a name="line-453"></a>
<a name="line-454"></a><a name="FlattenEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>FlattenEnv</span>
<a name="line-455"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_mode</span>    <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>FlattenMode</span>
<a name="line-456"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>fe_loc</span>     <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>CtLoc</span>             <span class='hs-comment'>-- See Note [Flattener CtLoc]</span>
<a name="line-457"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>CtFlavour</span>
<a name="line-458"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>fe_eq_rel</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>EqRel</span>             <span class='hs-comment'>-- See Note [Flattener EqRels]</span>
<a name="line-459"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>fe_work</span>    <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>FlatWorkListRef</span> <span class='hs-layout'>}</span> <span class='hs-comment'>-- See Note [The flattening work list]</span>
<a name="line-460"></a>
<a name="line-461"></a><a name="FlattenMode"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>FlattenMode</span>  <span class='hs-comment'>-- Postcondition for all three: inert wrt the type substitution</span>
<a name="line-462"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FM_FlattenAll</span>          <span class='hs-comment'>-- Postcondition: function-free</span>
<a name="line-463"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FM_SubstOnly</span>           <span class='hs-comment'>-- See Note [Flattening under a forall]</span>
<a name="line-464"></a>
<a name="line-465"></a><span class='hs-comment'>--  | FM_Avoid TcTyVar Bool  -- See Note [Lazy flattening]</span>
<a name="line-466"></a><span class='hs-comment'>--                           -- Postcondition:</span>
<a name="line-467"></a><span class='hs-comment'>--                           --  * tyvar is only mentioned in result under a rigid path</span>
<a name="line-468"></a><span class='hs-comment'>--                           --    e.g.   [a] is ok, but F a won't happen</span>
<a name="line-469"></a><span class='hs-comment'>--                           --  * If flat_top is True, top level is not a function application</span>
<a name="line-470"></a><span class='hs-comment'>--                           --   (but under type constructors is ok e.g. [F a])</span>
<a name="line-471"></a>
<a name="line-472"></a><a name="instance%20Outputable%20FlattenMode"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyword'>where</span>
<a name="line-473"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"FM_FlattenAll"</span>
<a name="line-474"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>FM_SubstOnly</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"FM_SubstOnly"</span>
<a name="line-475"></a>
<a name="line-476"></a><a name="eqFlattenMode"></a><span class='hs-definition'>eqFlattenMode</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-477"></a><span class='hs-definition'>eqFlattenMode</span> <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-478"></a><span class='hs-definition'>eqFlattenMode</span> <span class='hs-conid'>FM_SubstOnly</span>  <span class='hs-conid'>FM_SubstOnly</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-479"></a><span class='hs-comment'>--  FM_Avoid tv1 b1 `eq` FM_Avoid tv2 b2 = tv1 == tv2 &amp;&amp; b1 == b2</span>
<a name="line-480"></a><span class='hs-definition'>eqFlattenMode</span> <span class='hs-keyword'>_</span>  <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-481"></a>
<a name="line-482"></a><a name="FlatM"></a><span class='hs-comment'>-- | The 'FlatM' monad is a wrapper around 'TcS' with the following</span>
<a name="line-483"></a><a name="FlatM"></a><span class='hs-comment'>-- extra capabilities: (1) it offers access to a 'FlattenEnv';</span>
<a name="line-484"></a><a name="FlatM"></a><span class='hs-comment'>-- and (2) it maintains the flattening worklist.</span>
<a name="line-485"></a><a name="FlatM"></a><span class='hs-comment'>-- See Note [The flattening work list].</span>
<a name="line-486"></a><a name="FlatM"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-487"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>{</span> <span class='hs-varid'>runFlatM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-varid'>a</span> <span class='hs-layout'>}</span>
<a name="line-488"></a>
<a name="line-489"></a><a name="instance%20Monad%20FlatM"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-conid'>FlatM</span> <span class='hs-keyword'>where</span>
<a name="line-490"></a>  <span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-491"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>a</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>m</span> <span class='hs-varid'>env</span>
<a name="line-492"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>runFlatM</span> <span class='hs-layout'>(</span><span class='hs-varid'>k</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span> <span class='hs-layout'>}</span>
<a name="line-493"></a>
<a name="line-494"></a><a name="instance%20Functor%20FlatM"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-conid'>FlatM</span> <span class='hs-keyword'>where</span>
<a name="line-495"></a>  <span class='hs-varid'>fmap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftM</span>
<a name="line-496"></a>
<a name="line-497"></a><a name="instance%20Applicative%20FlatM"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-conid'>FlatM</span> <span class='hs-keyword'>where</span>
<a name="line-498"></a>  <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-varid'>const</span> <span class='hs-layout'>(</span><span class='hs-varid'>pure</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-499"></a>  <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ap</span>
<a name="line-500"></a>
<a name="line-501"></a><a name="liftTcS"></a><span class='hs-definition'>liftTcS</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcS</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-502"></a><span class='hs-definition'>liftTcS</span> <span class='hs-varid'>thing_inside</span>
<a name="line-503"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-varid'>const</span> <span class='hs-varid'>thing_inside</span>
<a name="line-504"></a>
<a name="line-505"></a><a name="emitFlatWork"></a><span class='hs-definition'>emitFlatWork</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>()</span>
<a name="line-506"></a><span class='hs-comment'>-- See Note [The flattening work list]</span>
<a name="line-507"></a><span class='hs-definition'>emitFlatWork</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>updTcRef</span> <span class='hs-layout'>(</span><span class='hs-varid'>fe_work</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span> <span class='hs-conop'>:</span><span class='hs-layout'>)</span>
<a name="line-508"></a>
<a name="line-509"></a><a name="runFlattenCtEv"></a><span class='hs-comment'>-- convenient wrapper when you have a CtEvidence describing</span>
<a name="line-510"></a><span class='hs-comment'>-- the flattening operation</span>
<a name="line-511"></a><span class='hs-definition'>runFlattenCtEv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-varid'>a</span>
<a name="line-512"></a><span class='hs-definition'>runFlattenCtEv</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span>
<a name="line-513"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runFlatten</span> <span class='hs-varid'>mode</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvFlavour</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvEqRel</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-514"></a>
<a name="line-515"></a><a name="runFlatten"></a><span class='hs-comment'>-- Run thing_inside (which does flattening), and put all</span>
<a name="line-516"></a><span class='hs-comment'>-- the work it generates onto the main work list</span>
<a name="line-517"></a><span class='hs-comment'>-- See Note [The flattening work list]</span>
<a name="line-518"></a><span class='hs-definition'>runFlatten</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavour</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-varid'>a</span>
<a name="line-519"></a><span class='hs-definition'>runFlatten</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>flav</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>thing_inside</span>
<a name="line-520"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>flat_ref</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcRef</span> <span class='hs-conid'>[]</span>
<a name="line-521"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fmode</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mode</span>
<a name="line-522"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>fe_loc</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span>
<a name="line-523"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flav</span>
<a name="line-524"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq_rel</span>
<a name="line-525"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>fe_work</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flat_ref</span> <span class='hs-layout'>}</span>
<a name="line-526"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-varid'>fmode</span>
<a name="line-527"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_flats</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readTcRef</span> <span class='hs-varid'>flat_ref</span>
<a name="line-528"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>updWorkListTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>add_flats</span> <span class='hs-varid'>new_flats</span><span class='hs-layout'>)</span>
<a name="line-529"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>res</span> <span class='hs-layout'>}</span>
<a name="line-530"></a>  <span class='hs-keyword'>where</span>
<a name="line-531"></a>    <span class='hs-varid'>add_flats</span> <span class='hs-varid'>new_flats</span> <span class='hs-varid'>wl</span>
<a name="line-532"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wl</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wl_funeqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>add_funeqs</span> <span class='hs-varid'>new_flats</span> <span class='hs-layout'>(</span><span class='hs-varid'>wl_funeqs</span> <span class='hs-varid'>wl</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-533"></a>
<a name="line-534"></a>    <span class='hs-varid'>add_funeqs</span> <span class='hs-conid'>[]</span>     <span class='hs-varid'>wl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wl</span>
<a name="line-535"></a>    <span class='hs-varid'>add_funeqs</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span><span class='hs-conop'>:</span><span class='hs-varid'>fs</span><span class='hs-layout'>)</span> <span class='hs-varid'>wl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>add_funeqs</span> <span class='hs-varid'>fs</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span><span class='hs-conop'>:</span><span class='hs-varid'>wl</span><span class='hs-layout'>)</span>
<a name="line-536"></a>      <span class='hs-comment'>-- add_funeqs fs ws = reverse fs ++ ws</span>
<a name="line-537"></a>      <span class='hs-comment'>-- e.g. add_funeqs [f1,f2,f3] [w1,w2,w3,w4]</span>
<a name="line-538"></a>      <span class='hs-comment'>--        = [f3,f2,f1,w1,w2,w3,w4]</span>
<a name="line-539"></a>
<a name="line-540"></a><a name="traceFlat"></a><span class='hs-definition'>traceFlat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>()</span>
<a name="line-541"></a><span class='hs-definition'>traceFlat</span> <span class='hs-varid'>herald</span> <span class='hs-varid'>doc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>traceTcS</span> <span class='hs-varid'>herald</span> <span class='hs-varid'>doc</span>
<a name="line-542"></a>
<a name="line-543"></a><a name="getFlatEnvField"></a><span class='hs-definition'>getFlatEnvField</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-544"></a><span class='hs-definition'>getFlatEnvField</span> <span class='hs-varid'>accessor</span>
<a name="line-545"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>accessor</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-546"></a>
<a name="line-547"></a><a name="getEqRel"></a><span class='hs-definition'>getEqRel</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>EqRel</span>
<a name="line-548"></a><span class='hs-definition'>getEqRel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getFlatEnvField</span> <span class='hs-varid'>fe_eq_rel</span>
<a name="line-549"></a>
<a name="line-550"></a><a name="getRole"></a><span class='hs-definition'>getRole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>Role</span>
<a name="line-551"></a><span class='hs-definition'>getRole</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>getEqRel</span>
<a name="line-552"></a>
<a name="line-553"></a><a name="getFlavour"></a><span class='hs-definition'>getFlavour</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>CtFlavour</span>
<a name="line-554"></a><span class='hs-definition'>getFlavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getFlatEnvField</span> <span class='hs-varid'>fe_flavour</span>
<a name="line-555"></a>
<a name="line-556"></a><a name="getFlavourRole"></a><span class='hs-definition'>getFlavourRole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>CtFlavourRole</span>
<a name="line-557"></a><span class='hs-definition'>getFlavourRole</span>
<a name="line-558"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>flavour</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFlavour</span>
<a name="line-559"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getEqRel</span>
<a name="line-560"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>flavour</span><span class='hs-layout'>,</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-561"></a>
<a name="line-562"></a><a name="getMode"></a><span class='hs-definition'>getMode</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>FlattenMode</span>
<a name="line-563"></a><span class='hs-definition'>getMode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getFlatEnvField</span> <span class='hs-varid'>fe_mode</span>
<a name="line-564"></a>
<a name="line-565"></a><a name="getLoc"></a><span class='hs-definition'>getLoc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>CtLoc</span>
<a name="line-566"></a><span class='hs-definition'>getLoc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getFlatEnvField</span> <span class='hs-varid'>fe_loc</span>
<a name="line-567"></a>
<a name="line-568"></a><a name="checkStackDepth"></a><span class='hs-definition'>checkStackDepth</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>()</span>
<a name="line-569"></a><span class='hs-definition'>checkStackDepth</span> <span class='hs-varid'>ty</span>
<a name="line-570"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getLoc</span>
<a name="line-571"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>checkReductionDepth</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span>
<a name="line-572"></a>
<a name="line-573"></a><a name="setEqRel"></a><span class='hs-comment'>-- | Change the 'EqRel' in a 'FlatM'.</span>
<a name="line-574"></a><span class='hs-definition'>setEqRel</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-575"></a><span class='hs-definition'>setEqRel</span> <span class='hs-varid'>new_eq_rel</span> <span class='hs-varid'>thing_inside</span>
<a name="line-576"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-577"></a>    <span class='hs-keyword'>if</span> <span class='hs-varid'>new_eq_rel</span> <span class='hs-varop'>==</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-varid'>env</span>
<a name="line-578"></a>    <span class='hs-keyword'>then</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-varid'>env</span>
<a name="line-579"></a>    <span class='hs-keyword'>else</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_eq_rel</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-580"></a>
<a name="line-581"></a><a name="setMode"></a><span class='hs-comment'>-- | Change the 'FlattenMode' in a 'FlattenEnv'.</span>
<a name="line-582"></a><span class='hs-definition'>setMode</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-583"></a><span class='hs-definition'>setMode</span> <span class='hs-varid'>new_mode</span> <span class='hs-varid'>thing_inside</span>
<a name="line-584"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-585"></a>    <span class='hs-keyword'>if</span> <span class='hs-varid'>new_mode</span> <span class='hs-varop'>`eqFlattenMode`</span> <span class='hs-varid'>fe_mode</span> <span class='hs-varid'>env</span>
<a name="line-586"></a>    <span class='hs-keyword'>then</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-varid'>env</span>
<a name="line-587"></a>    <span class='hs-keyword'>else</span> <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_mode</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-588"></a>
<a name="line-589"></a><a name="noBogusCoercions"></a><span class='hs-comment'>-- | Make sure that flattening actually produces a coercion (in other</span>
<a name="line-590"></a><span class='hs-comment'>-- words, make sure our flavour is not Derived)</span>
<a name="line-591"></a><span class='hs-comment'>-- Note [No derived kind equalities]</span>
<a name="line-592"></a><span class='hs-definition'>noBogusCoercions</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-593"></a><span class='hs-definition'>noBogusCoercions</span> <span class='hs-varid'>thing_inside</span>
<a name="line-594"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-595"></a>    <span class='hs-comment'>-- No new thunk is made if the flavour hasn't changed (note the bang).</span>
<a name="line-596"></a>    <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>of</span>
<a name="line-597"></a>          <span class='hs-conid'>Derived</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Wanted</span> <span class='hs-conid'>WDeriv</span> <span class='hs-layout'>}</span>
<a name="line-598"></a>          <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>env</span>
<a name="line-599"></a>    <span class='hs-keyword'>in</span>
<a name="line-600"></a>    <span class='hs-varid'>runFlatM</span> <span class='hs-varid'>thing_inside</span> <span class='hs-varid'>env'</span>
<a name="line-601"></a>
<a name="line-602"></a><a name="bumpDepth"></a><span class='hs-definition'>bumpDepth</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-varid'>a</span>
<a name="line-603"></a><span class='hs-definition'>bumpDepth</span> <span class='hs-layout'>(</span><span class='hs-conid'>FlatM</span> <span class='hs-varid'>thing_inside</span><span class='hs-layout'>)</span>
<a name="line-604"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FlatM</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-605"></a>      <span class='hs-comment'>-- bumpDepth can be called a lot during flattening so we force the</span>
<a name="line-606"></a>      <span class='hs-comment'>-- new env to avoid accumulating thunks.</span>
<a name="line-607"></a>      <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bumpCtLocDepth</span> <span class='hs-layout'>(</span><span class='hs-varid'>fe_loc</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-608"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>thing_inside</span> <span class='hs-varid'>env'</span> <span class='hs-layout'>}</span>
<a name="line-609"></a>
<a name="line-610"></a><span class='hs-comment'>{-
<a name="line-611"></a>Note [The flattening work list]
<a name="line-612"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-613"></a>The "flattening work list", held in the fe_work field of FlattenEnv,
<a name="line-614"></a>is a list of CFunEqCans generated during flattening.  The key idea
<a name="line-615"></a>is this.  Consider flattening (Eq (F (G Int) (H Bool)):
<a name="line-616"></a>  * The flattener recursively calls itself on sub-terms before building
<a name="line-617"></a>    the main term, so it will encounter the terms in order
<a name="line-618"></a>              G Int
<a name="line-619"></a>              H Bool
<a name="line-620"></a>              F (G Int) (H Bool)
<a name="line-621"></a>    flattening to sub-goals
<a name="line-622"></a>              w1: G Int ~ fuv0
<a name="line-623"></a>              w2: H Bool ~ fuv1
<a name="line-624"></a>              w3: F fuv0 fuv1 ~ fuv2
<a name="line-625"></a>
<a name="line-626"></a>  * Processing w3 first is BAD, because we can't reduce i t,so it'll
<a name="line-627"></a>    get put into the inert set, and later kicked out when w1, w2 are
<a name="line-628"></a>    solved.  In Trac #9872 this led to inert sets containing hundreds
<a name="line-629"></a>    of suspended calls.
<a name="line-630"></a>
<a name="line-631"></a>  * So we want to process w1, w2 first.
<a name="line-632"></a>
<a name="line-633"></a>  * So you might think that we should just use a FIFO deque for the work-list,
<a name="line-634"></a>    so that putting adding goals in order w1,w2,w3 would mean we processed
<a name="line-635"></a>    w1 first.
<a name="line-636"></a>
<a name="line-637"></a>  * BUT suppose we have 'type instance G Int = H Char'.  Then processing
<a name="line-638"></a>    w1 leads to a new goal
<a name="line-639"></a>                w4: H Char ~ fuv0
<a name="line-640"></a>    We do NOT want to put that on the far end of a deque!  Instead we want
<a name="line-641"></a>    to put it at the *front* of the work-list so that we continue to work
<a name="line-642"></a>    on it.
<a name="line-643"></a>
<a name="line-644"></a>So the work-list structure is this:
<a name="line-645"></a>
<a name="line-646"></a>  * The wl_funeqs (in TcS) is a LIFO stack; we push new goals (such as w4) on
<a name="line-647"></a>    top (extendWorkListFunEq), and take new work from the top
<a name="line-648"></a>    (selectWorkItem).
<a name="line-649"></a>
<a name="line-650"></a>  * When flattening, emitFlatWork pushes new flattening goals (like
<a name="line-651"></a>    w1,w2,w3) onto the flattening work list, fe_work, another
<a name="line-652"></a>    push-down stack.
<a name="line-653"></a>
<a name="line-654"></a>  * When we finish flattening, we *reverse* the fe_work stack
<a name="line-655"></a>    onto the wl_funeqs stack (which brings w1 to the top).
<a name="line-656"></a>
<a name="line-657"></a>The function runFlatten initialises the fe_work stack, and reverses
<a name="line-658"></a>it onto wl_fun_eqs at the end.
<a name="line-659"></a>
<a name="line-660"></a>Note [Flattener EqRels]
<a name="line-661"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-662"></a>When flattening, we need to know which equality relation -- nominal
<a name="line-663"></a>or representation -- we should be respecting. The only difference is
<a name="line-664"></a>that we rewrite variables by representational equalities when fe_eq_rel
<a name="line-665"></a>is ReprEq, and that we unwrap newtypes when flattening w.r.t.
<a name="line-666"></a>representational equality.
<a name="line-667"></a>
<a name="line-668"></a>Note [Flattener CtLoc]
<a name="line-669"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-670"></a>The flattener does eager type-family reduction.
<a name="line-671"></a>Type families might loop, and we
<a name="line-672"></a>don't want GHC to do so. A natural solution is to have a bounded depth
<a name="line-673"></a>to these processes. A central difficulty is that such a solution isn't
<a name="line-674"></a>quite compositional. For example, say it takes F Int 10 steps to get to Bool.
<a name="line-675"></a>How many steps does it take to get from F Int -&gt; F Int to Bool -&gt; Bool?
<a name="line-676"></a>10? 20? What about getting from Const Char (F Int) to Char? 11? 1? Hard to
<a name="line-677"></a>know and hard to track. So, we punt, essentially. We store a CtLoc in
<a name="line-678"></a>the FlattenEnv and just update the environment when recurring. In the
<a name="line-679"></a>TyConApp case, where there may be multiple type families to flatten,
<a name="line-680"></a>we just copy the current CtLoc into each branch. If any branch hits the
<a name="line-681"></a>stack limit, then the whole thing fails.
<a name="line-682"></a>
<a name="line-683"></a>A consequence of this is that setting the stack limits appropriately
<a name="line-684"></a>will be essentially impossible. So, the official recommendation if a
<a name="line-685"></a>stack limit is hit is to disable the check entirely. Otherwise, there
<a name="line-686"></a>will be baffling, unpredictable errors.
<a name="line-687"></a>
<a name="line-688"></a>Note [Lazy flattening]
<a name="line-689"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-690"></a>The idea of FM_Avoid mode is to flatten less aggressively.  If we have
<a name="line-691"></a>       a ~ [F Int]
<a name="line-692"></a>there seems to be no great merit in lifting out (F Int).  But if it was
<a name="line-693"></a>       a ~ [G a Int]
<a name="line-694"></a>then we *do* want to lift it out, in case (G a Int) reduces to Bool, say,
<a name="line-695"></a>which gets rid of the occurs-check problem.  (For the flat_top Bool, see
<a name="line-696"></a>comments above and at call sites.)
<a name="line-697"></a>
<a name="line-698"></a>HOWEVER, the lazy flattening actually seems to make type inference go
<a name="line-699"></a>*slower*, not faster.  perf/compiler/T3064 is a case in point; it gets
<a name="line-700"></a>*dramatically* worse with FM_Avoid.  I think it may be because
<a name="line-701"></a>floating the types out means we normalise them, and that often makes
<a name="line-702"></a>them smaller and perhaps allows more re-use of previously solved
<a name="line-703"></a>goals.  But to be honest I'm not absolutely certain, so I am leaving
<a name="line-704"></a>FM_Avoid in the code base.  What I'm removing is the unique place
<a name="line-705"></a>where it is *used*, namely in TcCanonical.canEqTyVar.
<a name="line-706"></a>
<a name="line-707"></a>See also Note [Conservative unification check] in TcUnify, which gives
<a name="line-708"></a>other examples where lazy flattening caused problems.
<a name="line-709"></a>
<a name="line-710"></a>Bottom line: FM_Avoid is unused for now (Nov 14).
<a name="line-711"></a>Note: T5321Fun got faster when I disabled FM_Avoid
<a name="line-712"></a>      T5837 did too, but it's pathalogical anyway
<a name="line-713"></a>
<a name="line-714"></a>Note [Phantoms in the flattener]
<a name="line-715"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-716"></a>Suppose we have
<a name="line-717"></a>
<a name="line-718"></a>data Proxy p = Proxy
<a name="line-719"></a>
<a name="line-720"></a>and we're flattening (Proxy ty) w.r.t. ReprEq. Then, we know that `ty`
<a name="line-721"></a>is really irrelevant -- it will be ignored when solving for representational
<a name="line-722"></a>equality later on. So, we omit flattening `ty` entirely. This may
<a name="line-723"></a>violate the expectation of "xi"s for a bit, but the canonicaliser will
<a name="line-724"></a>soon throw out the phantoms when decomposing a TyConApp. (Or, the
<a name="line-725"></a>canonicaliser will emit an insoluble, in which case the unflattened version
<a name="line-726"></a>yields a better error message anyway.)
<a name="line-727"></a>
<a name="line-728"></a>Note [No derived kind equalities]
<a name="line-729"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-730"></a>A kind-level coercion can appear in types, via mkCastTy. So, whenever
<a name="line-731"></a>we are generating a coercion in a dependent context (in other words,
<a name="line-732"></a>in a kind) we need to make sure that our flavour is never Derived
<a name="line-733"></a>(as Derived constraints have no evidence). The noBogusCoercions function
<a name="line-734"></a>changes the flavour from Derived just for this purpose.
<a name="line-735"></a>
<a name="line-736"></a>-}</span>
<a name="line-737"></a>
<a name="line-738"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-739"></a>*                                                                      *
<a name="line-740"></a>*      Externally callable flattening functions                        *
<a name="line-741"></a>*                                                                      *
<a name="line-742"></a>*  They are all wrapped in runFlatten, so their                        *
<a name="line-743"></a>*  flattening work gets put into the work list                         *
<a name="line-744"></a>*                                                                      *
<a name="line-745"></a>********************************************************************* -}</span>
<a name="line-746"></a>
<a name="line-747"></a><a name="flatten"></a><span class='hs-definition'>flatten</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>
<a name="line-748"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-749"></a><span class='hs-definition'>flatten</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty</span>
<a name="line-750"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flatten {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>mode</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-751"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runFlattenCtEv</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-752"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flatten }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span>
<a name="line-753"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-754"></a>
<a name="line-755"></a><a name="flattenKind"></a><span class='hs-comment'>-- specialized to flattening kinds: never Derived, always Nominal</span>
<a name="line-756"></a><span class='hs-comment'>-- See Note [No derived kind equalities]</span>
<a name="line-757"></a><span class='hs-definition'>flattenKind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavour</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercionN</span><span class='hs-layout'>)</span>
<a name="line-758"></a><span class='hs-definition'>flattenKind</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>flav</span> <span class='hs-varid'>ty</span>
<a name="line-759"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flattenKind {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>flav</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-760"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>flav'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>flav</span> <span class='hs-keyword'>of</span>
<a name="line-761"></a>                       <span class='hs-conid'>Derived</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Wanted</span> <span class='hs-conid'>WDeriv</span>  <span class='hs-comment'>-- the WDeriv/WOnly choice matters not</span>
<a name="line-762"></a>                       <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flav</span>
<a name="line-763"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runFlatten</span> <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>flav'</span> <span class='hs-conid'>NomEq</span> <span class='hs-layout'>(</span><span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-764"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flattenKind }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty'</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- co is never a panic</span>
<a name="line-765"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-766"></a>
<a name="line-767"></a><a name="flattenArgsNom"></a><span class='hs-definition'>flattenArgsNom</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcCoercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercionN</span><span class='hs-layout'>)</span>
<a name="line-768"></a><span class='hs-comment'>-- Externally-callable, hence runFlatten</span>
<a name="line-769"></a><span class='hs-comment'>-- Flatten a vector of types all at once; in fact they are</span>
<a name="line-770"></a><span class='hs-comment'>-- always the arguments of type family or class, so</span>
<a name="line-771"></a><span class='hs-comment'>--      ctEvFlavour ev = Nominal</span>
<a name="line-772"></a><span class='hs-comment'>-- and we want to flatten all at nominal role</span>
<a name="line-773"></a><span class='hs-comment'>-- The kind passed in is the kind of the type family or class, call it T</span>
<a name="line-774"></a><span class='hs-comment'>-- The last coercion returned has type (typeKind(T xis) ~N typeKind(T tys))</span>
<a name="line-775"></a><span class='hs-definition'>flattenArgsNom</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-776"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flatten_args {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-777"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>tys'</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span>
<a name="line-778"></a>           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runFlattenCtEv</span> <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>flatten_args_tc</span> <span class='hs-varid'>tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>repeat</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-779"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flatten }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-780"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>tys'</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-781"></a>
<a name="line-782"></a>
<a name="line-783"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-784"></a>*                                                                      *
<a name="line-785"></a>*           The main flattening functions
<a name="line-786"></a>*                                                                      *
<a name="line-787"></a>********************************************************************* -}</span>
<a name="line-788"></a>
<a name="line-789"></a><span class='hs-comment'>{- Note [Flattening]
<a name="line-790"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-791"></a>  flatten ty  ==&gt;   (xi, co)
<a name="line-792"></a>    where
<a name="line-793"></a>      xi has no type functions, unless they appear under ForAlls
<a name="line-794"></a>         has no skolems that are mapped in the inert set
<a name="line-795"></a>         has no filled-in metavariables
<a name="line-796"></a>      co :: xi ~ ty
<a name="line-797"></a>
<a name="line-798"></a>Key invariants:
<a name="line-799"></a>  (F0) co :: xi ~ zonk(ty)
<a name="line-800"></a>  (F1) typeKind(xi) succeeds and returns a fully zonked kind
<a name="line-801"></a>  (F2) typeKind(xi) `eqType` zonk(typeKind(ty))
<a name="line-802"></a>
<a name="line-803"></a>Note that it is flatten's job to flatten *every type function it sees*.
<a name="line-804"></a>flatten is only called on *arguments* to type functions, by canEqGiven.
<a name="line-805"></a>
<a name="line-806"></a>Flattening also:
<a name="line-807"></a>  * zonks, removing any metavariables, and
<a name="line-808"></a>  * applies the substitution embodied in the inert set
<a name="line-809"></a>
<a name="line-810"></a>Because flattening zonks and the returned coercion ("co" above) is also
<a name="line-811"></a>zonked, it's possible that (co :: xi ~ ty) isn't quite true. So, instead,
<a name="line-812"></a>we can rely on this fact:
<a name="line-813"></a>
<a name="line-814"></a>  (F1) typeKind(xi) succeeds and returns a fully zonked kind
<a name="line-815"></a>
<a name="line-816"></a>Note that the left-hand type of co is *always* precisely xi. The right-hand
<a name="line-817"></a>type may or may not be ty, however: if ty has unzonked filled-in metavariables,
<a name="line-818"></a>then the right-hand type of co will be the zonked version of ty.
<a name="line-819"></a>It is for this reason that we
<a name="line-820"></a>occasionally have to explicitly zonk, when (co :: xi ~ ty) is important
<a name="line-821"></a>even before we zonk the whole program. For example, see the FTRNotFollowed
<a name="line-822"></a>case in flattenTyVar.
<a name="line-823"></a>
<a name="line-824"></a>Why have these invariants on flattening? Because we sometimes use typeKind
<a name="line-825"></a>during canonicalisation, and we want this kind to be zonked (e.g., see
<a name="line-826"></a>TcCanonical.canEqTyVar).
<a name="line-827"></a>
<a name="line-828"></a>Flattening is always homogeneous. That is, the kind of the result of flattening is
<a name="line-829"></a>always the same as the kind of the input, modulo zonking. More formally:
<a name="line-830"></a>
<a name="line-831"></a>  (F2) typeKind(xi) `eqType` zonk(typeKind(ty))
<a name="line-832"></a>
<a name="line-833"></a>This invariant means that the kind of a flattened type might not itself be flat.
<a name="line-834"></a>
<a name="line-835"></a>Recall that in comments we use alpha[flat = ty] to represent a
<a name="line-836"></a>flattening skolem variable alpha which has been generated to stand in
<a name="line-837"></a>for ty.
<a name="line-838"></a>
<a name="line-839"></a>----- Example of flattening a constraint: ------
<a name="line-840"></a>  flatten (List (F (G Int)))  ==&gt;  (xi, cc)
<a name="line-841"></a>    where
<a name="line-842"></a>      xi  = List alpha
<a name="line-843"></a>      cc  = { G Int ~ beta[flat = G Int],
<a name="line-844"></a>              F beta ~ alpha[flat = F beta] }
<a name="line-845"></a>Here
<a name="line-846"></a>  * alpha and beta are 'flattening skolem variables'.
<a name="line-847"></a>  * All the constraints in cc are 'given', and all their coercion terms
<a name="line-848"></a>    are the identity.
<a name="line-849"></a>
<a name="line-850"></a>NB: Flattening Skolems only occur in canonical constraints, which
<a name="line-851"></a>are never zonked, so we don't need to worry about zonking doing
<a name="line-852"></a>accidental unflattening.
<a name="line-853"></a>
<a name="line-854"></a>Note that we prefer to leave type synonyms unexpanded when possible,
<a name="line-855"></a>so when the flattener encounters one, it first asks whether its
<a name="line-856"></a>transitive expansion contains any type function applications.  If so,
<a name="line-857"></a>it expands the synonym and proceeds; if not, it simply returns the
<a name="line-858"></a>unexpanded synonym.
<a name="line-859"></a>
<a name="line-860"></a>Note [flatten_args performance]
<a name="line-861"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-862"></a>In programs with lots of type-level evaluation, flatten_args becomes
<a name="line-863"></a>part of a tight loop. For example, see test perf/compiler/T9872a, which
<a name="line-864"></a>calls flatten_args a whopping 7,106,808 times. It is thus important
<a name="line-865"></a>that flatten_args be efficient.
<a name="line-866"></a>
<a name="line-867"></a>Performance testing showed that the current implementation is indeed
<a name="line-868"></a>efficient. It's critically important that zipWithAndUnzipM be
<a name="line-869"></a>specialized to TcS, and it's also quite helpful to actually `inline`
<a name="line-870"></a>it. On test T9872a, here are the allocation stats (Dec 16, 2014):
<a name="line-871"></a>
<a name="line-872"></a> * Unspecialized, uninlined:     8,472,613,440 bytes allocated in the heap
<a name="line-873"></a> * Specialized, uninlined:       6,639,253,488 bytes allocated in the heap
<a name="line-874"></a> * Specialized, inlined:         6,281,539,792 bytes allocated in the heap
<a name="line-875"></a>
<a name="line-876"></a>To improve performance even further, flatten_args_nom is split off
<a name="line-877"></a>from flatten_args, as nominal equality is the common case. This would
<a name="line-878"></a>be natural to write using mapAndUnzipM, but even inlined, that function
<a name="line-879"></a>is not as performant as a hand-written loop.
<a name="line-880"></a>
<a name="line-881"></a> * mapAndUnzipM, inlined:        7,463,047,432 bytes allocated in the heap
<a name="line-882"></a> * hand-written recursion:       5,848,602,848 bytes allocated in the heap
<a name="line-883"></a>
<a name="line-884"></a>If you make any change here, pay close attention to the T9872{a,b,c} tests
<a name="line-885"></a>and T5321Fun.
<a name="line-886"></a>
<a name="line-887"></a>If we need to make this yet more performant, a possible way forward is to
<a name="line-888"></a>duplicate the flattener code for the nominal case, and make that case
<a name="line-889"></a>faster. This doesn't seem quite worth it, yet.
<a name="line-890"></a>
<a name="line-891"></a>Note [flatten_args]
<a name="line-892"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-893"></a>Invariant (F2) of Note [Flattening] says that flattening is homogeneous.
<a name="line-894"></a>This causes some trouble when flattening a function applied to a telescope
<a name="line-895"></a>of arguments, perhaps with dependency. For example, suppose
<a name="line-896"></a>
<a name="line-897"></a>  type family F :: forall (j :: Type) (k :: Type). Maybe j -&gt; Either j k -&gt; Bool -&gt; [k]
<a name="line-898"></a>
<a name="line-899"></a>and we wish to flatten the args of (with kind applications explicit)
<a name="line-900"></a>
<a name="line-901"></a>  F a b (Just a c) (Right a b d) False
<a name="line-902"></a>
<a name="line-903"></a>where all variables are skolems and
<a name="line-904"></a>
<a name="line-905"></a>  a :: Type
<a name="line-906"></a>  b :: Type
<a name="line-907"></a>  c :: a
<a name="line-908"></a>  d :: k
<a name="line-909"></a>
<a name="line-910"></a>  [G] aco :: a ~ fa
<a name="line-911"></a>  [G] bco :: b ~ fb
<a name="line-912"></a>  [G] cco :: c ~ fc
<a name="line-913"></a>  [G] dco :: d ~ fd
<a name="line-914"></a>
<a name="line-915"></a>We process the args in left-to-right order. The first two args are easy:
<a name="line-916"></a>
<a name="line-917"></a>  (sym aco, fa) &lt;- flatten a
<a name="line-918"></a>  (sym bco, fb) &lt;- flatten b
<a name="line-919"></a>
<a name="line-920"></a>But now consider flattening (Just a c :: Maybe a). Regardless of how this
<a name="line-921"></a>flattens, the result will have kind (Maybe a), due to (F2). And yet, when
<a name="line-922"></a>we build the application (F fa fb ...), we need this argument to have kind
<a name="line-923"></a>(Maybe fa), not (Maybe a). Suppose (Just a c) flattens to f3 (the "3" is
<a name="line-924"></a>because it's the 3rd argument). We know f3 :: Maybe a. In order to get f3
<a name="line-925"></a>to have kind Maybe fa, we must cast it. The coercion to use is determined
<a name="line-926"></a>by the kind of F: we see in F's kind that the third argument has kind
<a name="line-927"></a>Maybe j. Critically, we also know that the argument corresponding to j
<a name="line-928"></a>(in our example, a) flattened with a coercion (sym aco). We can thus
<a name="line-929"></a>know the coercion needed for the 3rd argument is (Maybe aco).
<a name="line-930"></a>
<a name="line-931"></a>More generally, we must use the Lifting Lemma, as implemented in
<a name="line-932"></a>Coercion.liftCoSubst. As we work left-to-right, any variable that is a
<a name="line-933"></a>dependent parameter (j and k, in our example) gets mapped in a lifting context
<a name="line-934"></a>to the coercion that is output from flattening the corresponding argument (aco
<a name="line-935"></a>and bco, in our example). Then, after flattening later arguments, we lift the
<a name="line-936"></a>kind of these arguments in the lifting context that we've be building up.
<a name="line-937"></a>This coercion is then used to keep the result of flattening well-kinded.
<a name="line-938"></a>
<a name="line-939"></a>Working through our example, this is what happens:
<a name="line-940"></a>
<a name="line-941"></a>  1. Flatten a, getting (sym aco, fa). Extend the (empty) LC with [j |-&gt; sym aco]
<a name="line-942"></a>
<a name="line-943"></a>  2. Flatten b, getting (sym bco, fb). Extend the LC with [k |-&gt; sym bco].
<a name="line-944"></a>
<a name="line-945"></a>  3. Flatten (Just a c), getting (co3, f3). Lifting the kind (Maybe j) with our LC
<a name="line-946"></a>     yields lco3 :: Maybe fa ~ Maybe a. Use (f3 |&gt; sym lco3) as the argument to
<a name="line-947"></a>     F.
<a name="line-948"></a>
<a name="line-949"></a>  4. Flatten (Right a b d), getting (co4, f4). Lifting the kind (Either j k) with our LC
<a name="line-950"></a>     yields lco4 :: Either fa fb ~ Either a b. Use (f4 |&gt; sym lco4) as the 4th
<a name="line-951"></a>     argument to F.
<a name="line-952"></a>
<a name="line-953"></a>  5. Flatten False, getting (&lt;False&gt;, False). We lift Bool with our LC, getting &lt;Bool&gt;;
<a name="line-954"></a>     casting has no effect. (Indeed we lifted and casted with no effect for steps 1 and 2, as well.)
<a name="line-955"></a>
<a name="line-956"></a>We're now almost done, but the new application (F fa fb (f3 |&gt; sym lco3) (f4
<a name="line-957"></a>|&gt; sym lco4) False) has the wrong kind. Its kind is [fb], instead of the original [b].
<a name="line-958"></a>So we must use our LC one last time to lift the result kind [k], getting res_co :: [fb] ~ [b], and
<a name="line-959"></a>we cast our result.
<a name="line-960"></a>
<a name="line-961"></a>Accordingly, the final result is
<a name="line-962"></a>
<a name="line-963"></a>  F fa fb (Just fa (fc |&gt; aco) |&gt; Maybe (sym aco) |&gt; sym (Maybe (sym aco)))
<a name="line-964"></a>          (Right fa fb (fd |&gt; bco) |&gt; Either (sym aco) (sym bco) |&gt; sym (Either (sym aco) (sym bco)))
<a name="line-965"></a>          False
<a name="line-966"></a>            |&gt; [sym bco]
<a name="line-967"></a>
<a name="line-968"></a>The res_co is returned as the third return value from flatten_args.
<a name="line-969"></a>
<a name="line-970"></a>Note [Last case in flatten_args]
<a name="line-971"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-972"></a>In writing flatten_args's `go`, we know here that tys cannot be empty,
<a name="line-973"></a>because that case is first. We've run out of
<a name="line-974"></a>binders. But perhaps inner_ki is a tyvar that has been instantiated with a
<a name="line-975"></a>Π-type. I believe this, today, this Π-type must be an ordinary function.
<a name="line-976"></a>But tomorrow, we may allow, say, visible type application in types. And
<a name="line-977"></a>it's best to be prepared.
<a name="line-978"></a>
<a name="line-979"></a>Here is an example.
<a name="line-980"></a>
<a name="line-981"></a>  a :: forall (k :: Type). k -&gt; k
<a name="line-982"></a>  type family Star
<a name="line-983"></a>  Proxy :: forall j. j -&gt; Type
<a name="line-984"></a>  axStar :: Star ~ Type
<a name="line-985"></a>  type family NoWay :: Bool
<a name="line-986"></a>  axNoWay :: NoWay ~ False
<a name="line-987"></a>  bo :: Type
<a name="line-988"></a>  [G] bc :: bo ~ Bool   (in inert set)
<a name="line-989"></a>
<a name="line-990"></a>  co :: (forall j. j -&gt; Type) ~ (forall (j :: Star). (j |&gt; axStar) -&gt; Star)
<a name="line-991"></a>  co = forall (j :: sym axStar). (&lt;j&gt; -&gt; sym axStar)
<a name="line-992"></a>
<a name="line-993"></a>  We are flattening:
<a name="line-994"></a>  a (forall (j :: Star). (j |&gt; axStar) -&gt; Star)   -- 1
<a name="line-995"></a>    (Proxy |&gt; co)                                 -- 2
<a name="line-996"></a>    (bo |&gt; sym axStar)                            -- 3
<a name="line-997"></a>    (NoWay |&gt; sym bc)                             -- 4
<a name="line-998"></a>      :: Star
<a name="line-999"></a>
<a name="line-1000"></a>Flattening (1) gives us
<a name="line-1001"></a>    (forall j. j -&gt; Type)
<a name="line-1002"></a>    co1 :: (forall j. j -&gt; Type) ~ (forall (j :: Star). (j |&gt; axStar) -&gt; Star)
<a name="line-1003"></a>We also extend the lifting context with
<a name="line-1004"></a>    k |-&gt; co1
<a name="line-1005"></a>
<a name="line-1006"></a>Flattening (2) gives us
<a name="line-1007"></a>    (Proxy |&gt; co)
<a name="line-1008"></a>But building (a (forall j. j -&gt; Type) Proxy) would be ill-kinded. So we cast the
<a name="line-1009"></a>result of flattening by sym co1, to get
<a name="line-1010"></a>    (Proxy |&gt; co |&gt; sym co1)
<a name="line-1011"></a>Happily, co and co1 cancel each other out, leaving us with
<a name="line-1012"></a>    Proxy
<a name="line-1013"></a>    co2 :: Proxy ~ (Proxy |&gt; co)
<a name="line-1014"></a>
<a name="line-1015"></a>Now we need to flatten (3). After flattening, should we tack on a homogenizing
<a name="line-1016"></a>coercion? The way we normally tell is to look at the kind of `a`. (See Note
<a name="line-1017"></a>[flatten_args].) Here, the remainder of the kind of `a` that we're left with
<a name="line-1018"></a>after processing two arguments is just `k`.
<a name="line-1019"></a>
<a name="line-1020"></a>The way forward is look up k in the lifting context, getting co1. If we're at
<a name="line-1021"></a>all well-typed, co1 will be a coercion between Π-types, with enough binders on
<a name="line-1022"></a>both sides to accommodate any remaining arguments in flatten_args. So, let's
<a name="line-1023"></a>decompose co1 with decomposePiCos. This decomposition needs arguments to use
<a name="line-1024"></a>to instantiate any kind parameters. Look at the type of co1. If we just
<a name="line-1025"></a>decomposed it, we would end up with coercions whose types include j, which is
<a name="line-1026"></a>out of scope here. Accordingly, decomposePiCos takes a list of types whose
<a name="line-1027"></a>kinds are the *right-hand* types in the decomposed coercion. (See comments on
<a name="line-1028"></a>decomposePiCos, which also reverses the orientation of the coercions.)
<a name="line-1029"></a>The right-hand types are the unflattened ones -- conveniently what we have to
<a name="line-1030"></a>hand.
<a name="line-1031"></a>
<a name="line-1032"></a>So we now call
<a name="line-1033"></a>
<a name="line-1034"></a>  decomposePiCos (forall j. j -&gt; Type)
<a name="line-1035"></a>                 [bo |&gt; sym axStar, NoWay |&gt; sym bc]
<a name="line-1036"></a>                 co1
<a name="line-1037"></a>
<a name="line-1038"></a>to get
<a name="line-1039"></a>
<a name="line-1040"></a>  co3 :: Star ~ Type
<a name="line-1041"></a>  co4 :: (j |&gt; axStar) ~ (j |&gt; co3), substituted to
<a name="line-1042"></a>                              (bo |&gt; sym axStar |&gt; axStar) ~ (bo |&gt; sym axStar |&gt; co3)
<a name="line-1043"></a>                           == bo ~ bo
<a name="line-1044"></a>  res_co :: Type ~ Star -- this one's not reversed in decomposePiCos
<a name="line-1045"></a>
<a name="line-1046"></a>We then use these casts on (3) and (4) to get
<a name="line-1047"></a>
<a name="line-1048"></a>  (bo |&gt; sym axStar |&gt; co3 :: Type)   -- (C3)
<a name="line-1049"></a>  (NoWay |&gt; sym bc |&gt; co4 :: bo)      -- (C4)
<a name="line-1050"></a>
<a name="line-1051"></a>We can simplify to
<a name="line-1052"></a>
<a name="line-1053"></a>  bo                          -- (C3)
<a name="line-1054"></a>  (NoWay |&gt; sym bc :: bo)     -- (C4)
<a name="line-1055"></a>
<a name="line-1056"></a>Now, to flatten (C3) and (C4), we still need to keep track of dependency.
<a name="line-1057"></a>We know the type of the function applied to (C3) and (C4) must be
<a name="line-1058"></a>(forall j. j -&gt; Type), the flattened type
<a name="line-1059"></a>associated with k (the final type in the kind of `a`.) (We discard the lifting
<a name="line-1060"></a>context up to this point; as we've already substituted k, the domain of the
<a name="line-1061"></a>lifting context we used for (1) and (2), away.)
<a name="line-1062"></a>
<a name="line-1063"></a>We now flatten (C3) to get
<a name="line-1064"></a>  Bool                        -- F3
<a name="line-1065"></a>  co5 :: Bool ~ bo
<a name="line-1066"></a>and flatten (C4) to get
<a name="line-1067"></a>  (False |&gt; sym bc)
<a name="line-1068"></a>Like we did when flattening (2), we need to cast the result of flattening
<a name="line-1069"></a>(4), by lifting the type j with a lifting context containing
<a name="line-1070"></a>[j |-&gt; co5]. This lifting yields co5.
<a name="line-1071"></a>We cast the result of flattening (C4) by sym co5 (this is the normal
<a name="line-1072"></a>cast-after-flattening; see Note [flatten_args]):
<a name="line-1073"></a>  (False |&gt; sym bc |&gt; sym co5)
<a name="line-1074"></a>which is really just
<a name="line-1075"></a>  False                       -- F4
<a name="line-1076"></a>  co4 :: False ~ (NoWay |&gt; sym bc)
<a name="line-1077"></a>
<a name="line-1078"></a>Now, we build up the result
<a name="line-1079"></a>
<a name="line-1080"></a>  a (forall j. j -&gt; Type)
<a name="line-1081"></a>    Proxy
<a name="line-1082"></a>    Bool
<a name="line-1083"></a>    False
<a name="line-1084"></a>      |&gt; res_co
<a name="line-1085"></a>
<a name="line-1086"></a>Let's check whether this is well-typed. We know
<a name="line-1087"></a>
<a name="line-1088"></a>  a :: forall (k :: Type). k -&gt; k
<a name="line-1089"></a>
<a name="line-1090"></a>  a (forall j. j -&gt; Type) :: (forall j. j -&gt; Type) -&gt; forall j. j -&gt; Type
<a name="line-1091"></a>
<a name="line-1092"></a>  a (forall j. j -&gt; Type)
<a name="line-1093"></a>    Proxy
<a name="line-1094"></a>      :: forall j. j -&gt; Type
<a name="line-1095"></a>
<a name="line-1096"></a>  a (forall j. j -&gt; Type)
<a name="line-1097"></a>    Proxy
<a name="line-1098"></a>    Bool
<a name="line-1099"></a>      :: Bool -&gt; Type
<a name="line-1100"></a>
<a name="line-1101"></a>  a (forall j. j -&gt; Type)
<a name="line-1102"></a>    Proxy
<a name="line-1103"></a>    Bool
<a name="line-1104"></a>    False
<a name="line-1105"></a>      :: Type
<a name="line-1106"></a>
<a name="line-1107"></a>  a (forall j. j -&gt; Type)
<a name="line-1108"></a>    Proxy
<a name="line-1109"></a>    Bool
<a name="line-1110"></a>    False
<a name="line-1111"></a>     |&gt; res_co
<a name="line-1112"></a>     :: Star
<a name="line-1113"></a>
<a name="line-1114"></a>as desired. (Why do we want Star? Because we started with something of kind Star!)
<a name="line-1115"></a>
<a name="line-1116"></a>Whew.
<a name="line-1117"></a>
<a name="line-1118"></a>-}</span>
<a name="line-1119"></a>
<a name="line-1120"></a><a name="flatten_args_tc"></a><span class='hs-comment'>{-# INLINE flatten_args_tc #-}</span>
<a name="line-1121"></a><span class='hs-definition'>flatten_args_tc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span>
<a name="line-1122"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>
<a name="line-1123"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-1124"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoercionN</span><span class='hs-layout'>)</span>
<a name="line-1125"></a><span class='hs-definition'>flatten_args_tc</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten_args</span> <span class='hs-varid'>all_bndrs</span> <span class='hs-varid'>any_named_bndrs</span> <span class='hs-varid'>inner_ki</span> <span class='hs-varid'>emptyVarSet</span>
<a name="line-1126"></a>  <span class='hs-comment'>-- NB: TyCon kinds are always closed</span>
<a name="line-1127"></a>  <span class='hs-keyword'>where</span>
<a name="line-1128"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>named</span><span class='hs-layout'>)</span>
<a name="line-1129"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty_con_binders_ty_binders'</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConBinders</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-1130"></a>    <span class='hs-comment'>-- it's possible that the result kind has arrows (for, e.g., a type family)</span>
<a name="line-1131"></a>    <span class='hs-comment'>-- so we must split it</span>
<a name="line-1132"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>inner_bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>inner_ki</span><span class='hs-layout'>,</span> <span class='hs-varid'>inner_named</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>split_pi_tys'</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConResKind</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-1133"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>all_bndrs</span>                           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span> <span class='hs-varop'>`chkAppend`</span> <span class='hs-varid'>inner_bndrs</span>
<a name="line-1134"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>any_named_bndrs</span>                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>named</span> <span class='hs-varop'>||</span> <span class='hs-varid'>inner_named</span>
<a name="line-1135"></a>    <span class='hs-comment'>-- NB: Those bangs there drop allocations in T9872{a,c,d} by 8%.</span>
<a name="line-1136"></a>
<a name="line-1137"></a><a name="flatten_args"></a><span class='hs-comment'>{-# INLINE flatten_args #-}</span>
<a name="line-1138"></a><span class='hs-definition'>flatten_args</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyBinder</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>   <span class='hs-comment'>-- Binders, and True iff any of them are</span>
<a name="line-1139"></a>                                     <span class='hs-comment'>-- named.</span>
<a name="line-1140"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Kind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyCoVarSet</span> <span class='hs-comment'>-- function kind; kind's free vars</span>
<a name="line-1141"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- these are in 1-to-1 correspondence</span>
<a name="line-1142"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoercionN</span><span class='hs-layout'>)</span>
<a name="line-1143"></a><span class='hs-comment'>-- Coercions :: Xi ~ Type, at roles given</span>
<a name="line-1144"></a><span class='hs-comment'>-- Third coercion :: typeKind(fun xis) ~N typeKind(fun tys)</span>
<a name="line-1145"></a><span class='hs-comment'>-- That is, the third coercion relates the kind of some function (whose kind is</span>
<a name="line-1146"></a><span class='hs-comment'>-- passed as the first parameter) instantiated at xis to the kind of that</span>
<a name="line-1147"></a><span class='hs-comment'>-- function instantiated at the tys. This is useful in keeping flattening</span>
<a name="line-1148"></a><span class='hs-comment'>-- homoegeneous. The list of roles must be at least as long as the list of</span>
<a name="line-1149"></a><span class='hs-comment'>-- types.</span>
<a name="line-1150"></a><span class='hs-comment'>-- See Note [flatten_args]</span>
<a name="line-1151"></a><span class='hs-definition'>flatten_args</span> <span class='hs-varid'>orig_binders</span>
<a name="line-1152"></a>             <span class='hs-varid'>any_named_bndrs</span>
<a name="line-1153"></a>             <span class='hs-varid'>orig_inner_ki</span>
<a name="line-1154"></a>             <span class='hs-varid'>orig_fvs</span>
<a name="line-1155"></a>             <span class='hs-varid'>orig_roles</span>
<a name="line-1156"></a>             <span class='hs-varid'>orig_tys</span>
<a name="line-1157"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>any_named_bndrs</span>
<a name="line-1158"></a>    <span class='hs-keyword'>then</span> <span class='hs-varid'>flatten_args_slow</span> <span class='hs-varid'>orig_binders</span>
<a name="line-1159"></a>                           <span class='hs-varid'>orig_inner_ki</span>
<a name="line-1160"></a>                           <span class='hs-varid'>orig_fvs</span>
<a name="line-1161"></a>                           <span class='hs-varid'>orig_roles</span>
<a name="line-1162"></a>                           <span class='hs-varid'>orig_tys</span>
<a name="line-1163"></a>    <span class='hs-keyword'>else</span> <span class='hs-varid'>flatten_args_fast</span> <span class='hs-varid'>orig_binders</span> <span class='hs-varid'>orig_inner_ki</span> <span class='hs-varid'>orig_roles</span> <span class='hs-varid'>orig_tys</span>
<a name="line-1164"></a>
<a name="line-1165"></a><a name="flatten_args_fast"></a><span class='hs-comment'>{-# INLINE flatten_args_fast #-}</span>
<a name="line-1166"></a><span class='hs-comment'>-- | fast path flatten_args, in which none of the binders are named and</span>
<a name="line-1167"></a><span class='hs-comment'>-- therefore we can avoid tracking a lifting context.</span>
<a name="line-1168"></a><span class='hs-comment'>-- There are many bang patterns in here. It's been observed that they</span>
<a name="line-1169"></a><span class='hs-comment'>-- greatly improve performance of an optimized build.</span>
<a name="line-1170"></a><span class='hs-comment'>-- The T9872 test cases are good witnesses of this fact.</span>
<a name="line-1171"></a><span class='hs-definition'>flatten_args_fast</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyBinder</span><span class='hs-keyglyph'>]</span>
<a name="line-1172"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Kind</span>
<a name="line-1173"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>
<a name="line-1174"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-1175"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoercionN</span><span class='hs-layout'>)</span>
<a name="line-1176"></a><span class='hs-definition'>flatten_args_fast</span> <span class='hs-varid'>orig_binders</span> <span class='hs-varid'>orig_inner_ki</span> <span class='hs-varid'>orig_roles</span> <span class='hs-varid'>orig_tys</span>
<a name="line-1177"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>finish</span> <span class='hs-layout'>(</span><span class='hs-varid'>iterate</span> <span class='hs-varid'>orig_tys</span> <span class='hs-varid'>orig_roles</span> <span class='hs-varid'>orig_binders</span><span class='hs-layout'>)</span>
<a name="line-1178"></a>  <span class='hs-keyword'>where</span>
<a name="line-1179"></a>
<a name="line-1180"></a>    <span class='hs-varid'>iterate</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-1181"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>
<a name="line-1182"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyBinder</span><span class='hs-keyglyph'>]</span>
<a name="line-1183"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyBinder</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1184"></a>    <span class='hs-varid'>iterate</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-conop'>:</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>role</span><span class='hs-conop'>:</span><span class='hs-varid'>roles</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>binders</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-1185"></a>      <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty</span>
<a name="line-1186"></a>      <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>binders</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>iterate</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>binders</span>
<a name="line-1187"></a>      <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span> <span class='hs-conop'>:</span> <span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span> <span class='hs-conop'>:</span> <span class='hs-varid'>cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>binders</span><span class='hs-layout'>)</span>
<a name="line-1188"></a>    <span class='hs-varid'>iterate</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>binders</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>binders</span><span class='hs-layout'>)</span>
<a name="line-1189"></a>    <span class='hs-varid'>iterate</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span>
<a name="line-1190"></a>        <span class='hs-str'>"flatten_args wandered into deeper water than usual"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-1191"></a>           <span class='hs-comment'>-- This debug information is commented out because leaving it in</span>
<a name="line-1192"></a>           <span class='hs-comment'>-- causes a ~2% increase in allocations in T9872{a,c,d}.</span>
<a name="line-1193"></a>           <span class='hs-comment'>{-
<a name="line-1194"></a>             (vcat [ppr orig_binders,
<a name="line-1195"></a>                    ppr orig_inner_ki,
<a name="line-1196"></a>                    ppr (take 10 orig_roles), -- often infinite!
<a name="line-1197"></a>                    ppr orig_tys])
<a name="line-1198"></a>           -}</span>
<a name="line-1199"></a>
<a name="line-1200"></a>    <span class='hs-comment'>{-# INLINE go #-}</span>
<a name="line-1201"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Role</span>
<a name="line-1202"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1203"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1204"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty</span>
<a name="line-1205"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>role</span> <span class='hs-keyword'>of</span>
<a name="line-1206"></a>          <span class='hs-comment'>-- In the slow path we bind the Xi and Coercion from the recursive</span>
<a name="line-1207"></a>          <span class='hs-comment'>-- call and then use it such</span>
<a name="line-1208"></a>          <span class='hs-comment'>--</span>
<a name="line-1209"></a>          <span class='hs-comment'>--   let kind_co = mkTcSymCo $ mkReflCo Nominal (tyBinderType binder)</span>
<a name="line-1210"></a>          <span class='hs-comment'>--       casted_xi = xi `mkCastTy` kind_co</span>
<a name="line-1211"></a>          <span class='hs-comment'>--       casted_co = co `mkTcCoherenceLeftCo` kind_co</span>
<a name="line-1212"></a>          <span class='hs-comment'>--</span>
<a name="line-1213"></a>          <span class='hs-comment'>-- but this isn't necessary:</span>
<a name="line-1214"></a>          <span class='hs-comment'>--   mkTcSymCo (Refl a b) = Refl a b,</span>
<a name="line-1215"></a>          <span class='hs-comment'>--   mkCastTy x (Refl _ _) = x</span>
<a name="line-1216"></a>          <span class='hs-comment'>--   mkTcCoherenceLeftCo x (Refl _ _) = x</span>
<a name="line-1217"></a>          <span class='hs-comment'>--</span>
<a name="line-1218"></a>          <span class='hs-comment'>-- Also, no need to check isAnonTyBinder or isNamedTyBinder, since</span>
<a name="line-1219"></a>          <span class='hs-comment'>-- we've already established that they're all anonymous.</span>
<a name="line-1220"></a>          <span class='hs-conid'>Nominal</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>setEqRel</span> <span class='hs-conid'>NomEq</span>  <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span>
<a name="line-1221"></a>          <span class='hs-conid'>Representational</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>setEqRel</span> <span class='hs-conid'>ReprEq</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span>
<a name="line-1222"></a>          <span class='hs-conid'>Phantom</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- See Note [Phantoms in the flattener]</span>
<a name="line-1223"></a>                              <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>ty</span>
<a name="line-1224"></a>                                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkReflCo</span> <span class='hs-conid'>Phantom</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1225"></a>
<a name="line-1226"></a>
<a name="line-1227"></a>    <span class='hs-comment'>{-# INLINE finish #-}</span>
<a name="line-1228"></a>    <span class='hs-varid'>finish</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyBinder</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoercionN</span><span class='hs-layout'>)</span>
<a name="line-1229"></a>    <span class='hs-varid'>finish</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>binders</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span>
<a name="line-1230"></a>      <span class='hs-keyword'>where</span>
<a name="line-1231"></a>        <span class='hs-varid'>final_kind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkPiTys</span> <span class='hs-varid'>binders</span> <span class='hs-varid'>orig_inner_ki</span>
<a name="line-1232"></a>        <span class='hs-varid'>kind_co</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkReflCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>final_kind</span>
<a name="line-1233"></a>
<a name="line-1234"></a><a name="flatten_args_slow"></a><span class='hs-comment'>{-# INLINE flatten_args_slow #-}</span>
<a name="line-1235"></a><span class='hs-comment'>-- | Slow path, compared to flatten_args_fast, because this one must track</span>
<a name="line-1236"></a><span class='hs-comment'>-- a lifting context.</span>
<a name="line-1237"></a><span class='hs-definition'>flatten_args_slow</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyBinder</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Kind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyCoVarSet</span>
<a name="line-1238"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-1239"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoercionN</span><span class='hs-layout'>)</span>
<a name="line-1240"></a><span class='hs-definition'>flatten_args_slow</span> <span class='hs-varid'>orig_binders</span> <span class='hs-varid'>orig_inner_ki</span> <span class='hs-varid'>orig_fvs</span> <span class='hs-varid'>orig_roles</span> <span class='hs-varid'>orig_tys</span>
<a name="line-1241"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>orig_lc</span> <span class='hs-varid'>orig_binders</span> <span class='hs-varid'>orig_inner_ki</span> <span class='hs-varid'>orig_roles</span> <span class='hs-varid'>orig_tys</span>
<a name="line-1242"></a>  <span class='hs-keyword'>where</span>
<a name="line-1243"></a>    <span class='hs-varid'>orig_lc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyLiftingContext</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkInScopeSet</span> <span class='hs-varop'>$</span> <span class='hs-varid'>orig_fvs</span>
<a name="line-1244"></a>
<a name="line-1245"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span>        <span class='hs-comment'>-- Xis accumulator, in reverse order</span>
<a name="line-1246"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- Coercions accumulator, in reverse order</span>
<a name="line-1247"></a>                      <span class='hs-comment'>-- These are in 1-to-1 correspondence</span>
<a name="line-1248"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LiftingContext</span>  <span class='hs-comment'>-- mapping from tyvars to flattening coercions</span>
<a name="line-1249"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyBinder</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- Unsubsted binders of function's kind</span>
<a name="line-1250"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Kind</span>        <span class='hs-comment'>-- Unsubsted result kind of function (not a Pi-type)</span>
<a name="line-1251"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>      <span class='hs-comment'>-- Roles at which to flatten these ...</span>
<a name="line-1252"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>      <span class='hs-comment'>-- ... unflattened types</span>
<a name="line-1253"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoercionN</span><span class='hs-layout'>)</span>
<a name="line-1254"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>acc_xis</span> <span class='hs-varid'>acc_cos</span> <span class='hs-varid'>lc</span> <span class='hs-varid'>binders</span> <span class='hs-varid'>inner_ki</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>
<a name="line-1255"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>acc_xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>acc_cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span>
<a name="line-1256"></a>      <span class='hs-keyword'>where</span>
<a name="line-1257"></a>        <span class='hs-varid'>final_kind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkPiTys</span> <span class='hs-varid'>binders</span> <span class='hs-varid'>inner_ki</span>
<a name="line-1258"></a>        <span class='hs-varid'>kind_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftCoSubst</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>lc</span> <span class='hs-varid'>final_kind</span>
<a name="line-1259"></a>
<a name="line-1260"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>acc_xis</span> <span class='hs-varid'>acc_cos</span> <span class='hs-varid'>lc</span> <span class='hs-layout'>(</span><span class='hs-varid'>binder</span><span class='hs-conop'>:</span><span class='hs-varid'>binders</span><span class='hs-layout'>)</span> <span class='hs-varid'>inner_ki</span> <span class='hs-layout'>(</span><span class='hs-varid'>role</span><span class='hs-conop'>:</span><span class='hs-varid'>roles</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-conop'>:</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1261"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>role</span> <span class='hs-keyword'>of</span>
<a name="line-1262"></a>               <span class='hs-conid'>Nominal</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>setEqRel</span> <span class='hs-conid'>NomEq</span> <span class='hs-varop'>$</span>
<a name="line-1263"></a>                                   <span class='hs-keyword'>if</span> <span class='hs-varid'>isNamedTyBinder</span> <span class='hs-varid'>binder</span>
<a name="line-1264"></a>                                   <span class='hs-keyword'>then</span> <span class='hs-varid'>noBogusCoercions</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span>
<a name="line-1265"></a>                                   <span class='hs-keyword'>else</span>                    <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span>
<a name="line-1266"></a>
<a name="line-1267"></a>               <span class='hs-conid'>Representational</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isAnonTyBinder</span> <span class='hs-varid'>binder</span> <span class='hs-layout'>)</span>
<a name="line-1268"></a>                                   <span class='hs-varid'>setEqRel</span> <span class='hs-conid'>ReprEq</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span>
<a name="line-1269"></a>
<a name="line-1270"></a>               <span class='hs-conid'>Phantom</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- See Note [Phantoms in the flattener]</span>
<a name="line-1271"></a>                                   <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isAnonTyBinder</span> <span class='hs-varid'>binder</span> <span class='hs-layout'>)</span>
<a name="line-1272"></a>                                   <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>ty</span>
<a name="line-1273"></a>                                      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkReflCo</span> <span class='hs-conid'>Phantom</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1274"></a>
<a name="line-1275"></a>             <span class='hs-comment'>-- By Note [Flattening] invariant (F2),</span>
<a name="line-1276"></a>             <span class='hs-comment'>-- typeKind(xi) = typeKind(ty). But, it's possible that xi will be</span>
<a name="line-1277"></a>             <span class='hs-comment'>-- used as an argument to a function whose kind is different, if</span>
<a name="line-1278"></a>             <span class='hs-comment'>-- earlier arguments have been flattened to new types. We thus</span>
<a name="line-1279"></a>             <span class='hs-comment'>-- need a coercion (kind_co :: old_kind ~ new_kind).</span>
<a name="line-1280"></a>             <span class='hs-comment'>--</span>
<a name="line-1281"></a>             <span class='hs-comment'>-- The bangs here have been observed to improve performance</span>
<a name="line-1282"></a>             <span class='hs-comment'>-- significantly in optimized builds.</span>
<a name="line-1283"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>kind_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-varop'>$</span>
<a name="line-1284"></a>                   <span class='hs-varid'>liftCoSubst</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>lc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyBinderType</span> <span class='hs-varid'>binder</span><span class='hs-layout'>)</span>
<a name="line-1285"></a>                 <span class='hs-varop'>!</span><span class='hs-varid'>casted_xi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi</span> <span class='hs-varop'>`mkCastTy`</span> <span class='hs-varid'>kind_co</span>
<a name="line-1286"></a>                 <span class='hs-varid'>casted_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co</span> <span class='hs-varop'>`mkTcCoherenceLeftCo`</span> <span class='hs-varid'>kind_co</span>
<a name="line-1287"></a>
<a name="line-1288"></a>             <span class='hs-comment'>-- now, extend the lifting context with the new binding</span>
<a name="line-1289"></a>                 <span class='hs-varop'>!</span><span class='hs-varid'>new_lc</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyBinderVar_maybe</span> <span class='hs-varid'>binder</span>
<a name="line-1290"></a>                         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendLiftingContextAndInScope</span> <span class='hs-varid'>lc</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>casted_co</span>
<a name="line-1291"></a>                         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1292"></a>                         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lc</span>
<a name="line-1293"></a>
<a name="line-1294"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>casted_xi</span> <span class='hs-conop'>:</span> <span class='hs-varid'>acc_xis</span><span class='hs-layout'>)</span>
<a name="line-1295"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>casted_co</span> <span class='hs-conop'>:</span> <span class='hs-varid'>acc_cos</span><span class='hs-layout'>)</span>
<a name="line-1296"></a>                <span class='hs-varid'>new_lc</span>
<a name="line-1297"></a>                <span class='hs-varid'>binders</span>
<a name="line-1298"></a>                <span class='hs-varid'>inner_ki</span>
<a name="line-1299"></a>                <span class='hs-varid'>roles</span>
<a name="line-1300"></a>                <span class='hs-varid'>tys</span>
<a name="line-1301"></a>           <span class='hs-layout'>}</span>
<a name="line-1302"></a>
<a name="line-1303"></a>      <span class='hs-comment'>-- See Note [Last case in flatten_args]</span>
<a name="line-1304"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>acc_xis</span> <span class='hs-varid'>acc_cos</span> <span class='hs-varid'>lc</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>inner_ki</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span>
<a name="line-1305"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>k</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>inner_ki</span>
<a name="line-1306"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>co1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftCoSubstTyVar</span> <span class='hs-varid'>lc</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>k</span>
<a name="line-1307"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co1_kind</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionKind</span> <span class='hs-varid'>co1</span>
<a name="line-1308"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>arg_cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_co</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decomposePiCos</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co1_kind</span> <span class='hs-varid'>tys</span>
<a name="line-1309"></a>                 <span class='hs-varid'>casted_tys</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>equalLength</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>arg_cos</span>
<a name="line-1310"></a>                                                <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg_cos</span> <span class='hs-layout'>)</span>
<a name="line-1311"></a>                                         <span class='hs-varid'>zipWith</span> <span class='hs-varid'>mkCastTy</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>arg_cos</span>
<a name="line-1312"></a>                    <span class='hs-comment'>-- In general decomposePiCos can return fewer cos than tys,</span>
<a name="line-1313"></a>                    <span class='hs-comment'>-- but not here; see "If we're at all well-typed..."</span>
<a name="line-1314"></a>                    <span class='hs-comment'>-- in Note [Last case in flatten_args].  Hence the ASSERT.</span>
<a name="line-1315"></a>                 <span class='hs-varid'>zapped_lc</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapLiftingContext</span> <span class='hs-varid'>lc</span>
<a name="line-1316"></a>                 <span class='hs-conid'>Pair</span> <span class='hs-varid'>flattened_kind</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co1_kind</span>
<a name="line-1317"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_inner</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitPiTys</span> <span class='hs-varid'>flattened_kind</span>
<a name="line-1318"></a>
<a name="line-1319"></a>           <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis_out</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos_out</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_co_out</span><span class='hs-layout'>)</span>
<a name="line-1320"></a>               <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>acc_xis</span> <span class='hs-varid'>acc_cos</span> <span class='hs-varid'>zapped_lc</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>new_inner</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>casted_tys</span>
<a name="line-1321"></a>           <span class='hs-comment'>-- cos_out :: xis_out ~ casted_tys</span>
<a name="line-1322"></a>           <span class='hs-comment'>-- we need to return cos :: xis_out ~ tys</span>
<a name="line-1323"></a>           <span class='hs-comment'>--</span>
<a name="line-1324"></a>           <span class='hs-comment'>-- zipWith has the map first because it will fuse.</span>
<a name="line-1325"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>cos</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>flip</span> <span class='hs-varid'>mkTcCoherenceRightCo</span><span class='hs-layout'>)</span>
<a name="line-1326"></a>                               <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>arg_cos</span><span class='hs-layout'>)</span>
<a name="line-1327"></a>                               <span class='hs-varid'>cos_out</span>
<a name="line-1328"></a>
<a name="line-1329"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis_out</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_co_out</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>res_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1330"></a>
<a name="line-1331"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span>
<a name="line-1332"></a>        <span class='hs-str'>"flatten_args wandered into deeper water than usual"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-1333"></a>           <span class='hs-comment'>-- This debug information is commented out because leaving it in</span>
<a name="line-1334"></a>           <span class='hs-comment'>-- causes a ~2% increase in allocations in T9872d.</span>
<a name="line-1335"></a>           <span class='hs-comment'>-- That's independent of the analagous case in flatten_args_fast:</span>
<a name="line-1336"></a>           <span class='hs-comment'>-- each of these causes a 2% increase on its own, so commenting them</span>
<a name="line-1337"></a>           <span class='hs-comment'>-- both out gives a 4% decrease in T9872d.</span>
<a name="line-1338"></a>           <span class='hs-comment'>{-
<a name="line-1339"></a>
<a name="line-1340"></a>             (vcat [ppr orig_binders,
<a name="line-1341"></a>                    ppr orig_inner_ki,
<a name="line-1342"></a>                    ppr (take 10 orig_roles), -- often infinite!
<a name="line-1343"></a>                    ppr orig_tys])
<a name="line-1344"></a>           -}</span>
<a name="line-1345"></a>
<a name="line-1346"></a><a name="flatten_one"></a><span class='hs-comment'>------------------</span>
<a name="line-1347"></a><span class='hs-definition'>flatten_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1348"></a><span class='hs-comment'>-- Flatten a type to get rid of type function applications, returning</span>
<a name="line-1349"></a><span class='hs-comment'>-- the new type-function-free type, and a collection of new equality</span>
<a name="line-1350"></a><span class='hs-comment'>-- constraints.  See Note [Flattening] for more detail.</span>
<a name="line-1351"></a><span class='hs-comment'>--</span>
<a name="line-1352"></a><span class='hs-comment'>-- Postcondition: Coercion :: Xi ~ TcType</span>
<a name="line-1353"></a><span class='hs-comment'>-- The role on the result coercion matches the EqRel in the FlattenEnv</span>
<a name="line-1354"></a>
<a name="line-1355"></a><span class='hs-definition'>flatten_one</span> <span class='hs-varid'>xi</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1356"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-1357"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>xi</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1358"></a>
<a name="line-1359"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-1360"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flattenTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-1361"></a>
<a name="line-1362"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-1363"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten_app_tys</span> <span class='hs-varid'>ty1</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ty2</span><span class='hs-keyglyph'>]</span>
<a name="line-1364"></a>
<a name="line-1365"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1366"></a>  <span class='hs-comment'>-- Expand type synonyms that mention type families</span>
<a name="line-1367"></a>  <span class='hs-comment'>-- on the RHS; see Note [Flattening synonyms]</span>
<a name="line-1368"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tenv</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>expandSynTyCon_maybe</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1369"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>expanded_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkAppTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTvSubstPrs</span> <span class='hs-varid'>tenv</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys'</span>
<a name="line-1370"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mode</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getMode</span>
<a name="line-1371"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mode</span> <span class='hs-keyword'>of</span>
<a name="line-1372"></a>           <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isFamFreeTyCon</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-1373"></a>                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>expanded_ty</span>
<a name="line-1374"></a>           <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_ty_con_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>}</span>
<a name="line-1375"></a>
<a name="line-1376"></a>  <span class='hs-comment'>-- Otherwise, it's a type function application, and we have to</span>
<a name="line-1377"></a>  <span class='hs-comment'>-- flatten it away as well, and generate a new given equality constraint</span>
<a name="line-1378"></a>  <span class='hs-comment'>-- between the application and a newly generated flattening skolem variable.</span>
<a name="line-1379"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-1380"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten_fam_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1381"></a>
<a name="line-1382"></a>  <span class='hs-comment'>-- For * a normal data type application</span>
<a name="line-1383"></a>  <span class='hs-comment'>--     * data family application</span>
<a name="line-1384"></a>  <span class='hs-comment'>-- we just recursively flatten the arguments.</span>
<a name="line-1385"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1386"></a><span class='hs-comment'>-- FM_Avoid stuff commented out; see Note [Lazy flattening]</span>
<a name="line-1387"></a><span class='hs-comment'>--  , let fmode' = case fmode of  -- Switch off the flat_top bit in FM_Avoid</span>
<a name="line-1388"></a><span class='hs-comment'>--                   FE { fe_mode = FM_Avoid tv _ }</span>
<a name="line-1389"></a><span class='hs-comment'>--                     -&gt; fmode { fe_mode = FM_Avoid tv False }</span>
<a name="line-1390"></a><span class='hs-comment'>--                   _ -&gt; fmode</span>
<a name="line-1391"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten_ty_con_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1392"></a>
<a name="line-1393"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-1394"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span><span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty1</span>
<a name="line-1395"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2</span><span class='hs-layout'>,</span><span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty2</span>
<a name="line-1396"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-1397"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkFunTy</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkFunCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1398"></a>
<a name="line-1399"></a><span class='hs-definition'>flatten_one</span> <span class='hs-varid'>ty</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1400"></a><span class='hs-comment'>-- TODO (RAE): This is inadequate, as it doesn't flatten the kind of</span>
<a name="line-1401"></a><span class='hs-comment'>-- the bound tyvar. Doing so will require carrying around a substitution</span>
<a name="line-1402"></a><span class='hs-comment'>-- and the usual substTyVarBndr-like silliness. Argh.</span>
<a name="line-1403"></a>
<a name="line-1404"></a><span class='hs-comment'>-- We allow for-alls when, but only when, no type function</span>
<a name="line-1405"></a><span class='hs-comment'>-- applications inside the forall involve the bound type variables.</span>
<a name="line-1406"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rho</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitForAllTyVarBndrs</span> <span class='hs-varid'>ty</span>
<a name="line-1407"></a>             <span class='hs-varid'>tvs</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>binderVars</span> <span class='hs-varid'>bndrs</span>
<a name="line-1408"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rho'</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setMode</span> <span class='hs-conid'>FM_SubstOnly</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>rho</span>
<a name="line-1409"></a>                         <span class='hs-comment'>-- Substitute only under a forall</span>
<a name="line-1410"></a>                         <span class='hs-comment'>-- See Note [Flattening under a forall]</span>
<a name="line-1411"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkForAllTys</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rho'</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkHomoForAllCos</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1412"></a>
<a name="line-1413"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastTy</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
<a name="line-1414"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty</span>
<a name="line-1415"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>g'</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_co</span> <span class='hs-varid'>g</span>
<a name="line-1416"></a>
<a name="line-1417"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCastTy</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>g'</span><span class='hs-layout'>,</span> <span class='hs-varid'>castCoercionKind</span> <span class='hs-varid'>co</span> <span class='hs-varid'>g'</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1418"></a>
<a name="line-1419"></a><span class='hs-definition'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoercionTy</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>first</span> <span class='hs-varid'>mkCoercionTy</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>flatten_co</span> <span class='hs-varid'>co</span>
<a name="line-1420"></a>
<a name="line-1421"></a><a name="flatten_co"></a><span class='hs-comment'>-- | "Flatten" a coercion. Really, just zonk it so we can uphold</span>
<a name="line-1422"></a><span class='hs-comment'>-- (F1) of Note [Flattening]</span>
<a name="line-1423"></a><span class='hs-definition'>flatten_co</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1424"></a><span class='hs-definition'>flatten_co</span> <span class='hs-varid'>co</span>
<a name="line-1425"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zonkCo</span> <span class='hs-varid'>co</span>
<a name="line-1426"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>env_role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-1427"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcReflCo</span> <span class='hs-varid'>env_role</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCoercionTy</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1428"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>co'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1429"></a>
<a name="line-1430"></a><a name="flatten_app_tys"></a><span class='hs-comment'>-- flatten (nested) AppTys</span>
<a name="line-1431"></a><span class='hs-definition'>flatten_app_tys</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1432"></a><span class='hs-comment'>-- commoning up nested applications allows us to look up the function's kind</span>
<a name="line-1433"></a><span class='hs-comment'>-- only once. Without commoning up like this, we would spend a quadratic amount</span>
<a name="line-1434"></a><span class='hs-comment'>-- of time looking up functions' types</span>
<a name="line-1435"></a><span class='hs-definition'>flatten_app_tys</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten_app_tys</span> <span class='hs-varid'>ty1</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty2</span><span class='hs-conop'>:</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1436"></a><span class='hs-definition'>flatten_app_tys</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>arg_tys</span>
<a name="line-1437"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>fun_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>fun_ty</span>
<a name="line-1438"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>flatten_app_ty_args</span> <span class='hs-varid'>fun_xi</span> <span class='hs-varid'>fun_co</span> <span class='hs-varid'>arg_tys</span> <span class='hs-layout'>}</span>
<a name="line-1439"></a>
<a name="line-1440"></a><a name="flatten_app_ty_args"></a><span class='hs-comment'>-- Given a flattened function (with the coercion produced by flattening) and</span>
<a name="line-1441"></a><span class='hs-comment'>-- a bunch of unflattened arguments, flatten the arguments and apply</span>
<a name="line-1442"></a><span class='hs-comment'>--</span>
<a name="line-1443"></a><span class='hs-comment'>-- The bang patterns used here were observed to improve performance. If you</span>
<a name="line-1444"></a><span class='hs-comment'>-- wish to remove them, be sure to check for regeressions in allocations.</span>
<a name="line-1445"></a><span class='hs-definition'>flatten_app_ty_args</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Xi</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1446"></a><span class='hs-definition'>flatten_app_ty_args</span> <span class='hs-varid'>fun_xi</span> <span class='hs-varid'>fun_co</span> <span class='hs-conid'>[]</span>
<a name="line-1447"></a>  <span class='hs-comment'>-- this will be a common case when called from flatten_fam_app, so shortcut</span>
<a name="line-1448"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>fun_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_co</span><span class='hs-layout'>)</span>
<a name="line-1449"></a><span class='hs-definition'>flatten_app_ty_args</span> <span class='hs-varid'>fun_xi</span> <span class='hs-varid'>fun_co</span> <span class='hs-varid'>arg_tys</span>
<a name="line-1450"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tcSplitTyConApp_maybe</span> <span class='hs-varid'>fun_xi</span> <span class='hs-keyword'>of</span>
<a name="line-1451"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>xis</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1452"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tc_roles</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConRolesRepresentational</span> <span class='hs-varid'>tc</span>
<a name="line-1453"></a>                      <span class='hs-varid'>arg_roles</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropList</span> <span class='hs-varid'>xis</span> <span class='hs-varid'>tc_roles</span>
<a name="line-1454"></a>                <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span>
<a name="line-1455"></a>                    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_vector</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeKind</span> <span class='hs-varid'>fun_xi</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_roles</span> <span class='hs-varid'>arg_tys</span>
<a name="line-1456"></a>
<a name="line-1457"></a>                  <span class='hs-comment'>-- Here, we have fun_co :: T xi1 xi2 ~ ty</span>
<a name="line-1458"></a>                  <span class='hs-comment'>-- and we need to apply fun_co to the arg_cos. The problem is</span>
<a name="line-1459"></a>                  <span class='hs-comment'>-- that using mkAppCo is wrong because that function expects</span>
<a name="line-1460"></a>                  <span class='hs-comment'>-- its second coercion to be Nominal, and the arg_cos might</span>
<a name="line-1461"></a>                  <span class='hs-comment'>-- not be. The solution is to use transitivity:</span>
<a name="line-1462"></a>                  <span class='hs-comment'>-- T &lt;xi1&gt; &lt;xi2&gt; arg_cos ;; fun_co &lt;arg_tys&gt;</span>
<a name="line-1463"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getEqRel</span>
<a name="line-1464"></a>                <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>app_xi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span> <span class='hs-varop'>++</span> <span class='hs-varid'>arg_xis</span><span class='hs-layout'>)</span>
<a name="line-1465"></a>                      <span class='hs-varid'>app_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyword'>of</span>
<a name="line-1466"></a>                        <span class='hs-conid'>NomEq</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkAppCos</span> <span class='hs-varid'>fun_co</span> <span class='hs-varid'>arg_cos</span>
<a name="line-1467"></a>                        <span class='hs-conid'>ReprEq</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>tc</span>
<a name="line-1468"></a>                                    <span class='hs-layout'>(</span><span class='hs-varid'>zipWith</span> <span class='hs-varid'>mkReflCo</span> <span class='hs-varid'>tc_roles</span> <span class='hs-varid'>xis</span> <span class='hs-varop'>++</span> <span class='hs-varid'>arg_cos</span><span class='hs-layout'>)</span>
<a name="line-1469"></a>                                  <span class='hs-varop'>`mkTcTransCo`</span>
<a name="line-1470"></a>                                  <span class='hs-varid'>mkAppCos</span> <span class='hs-varid'>fun_co</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>mkNomReflCo</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>)</span>
<a name="line-1471"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>app_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>app_co</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1472"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1473"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span>
<a name="line-1474"></a>                    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_vector</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeKind</span> <span class='hs-varid'>fun_xi</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>repeat</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_tys</span>
<a name="line-1475"></a>                <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_xi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkAppTys</span> <span class='hs-varid'>fun_xi</span> <span class='hs-varid'>arg_xis</span>
<a name="line-1476"></a>                      <span class='hs-varid'>arg_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkAppCos</span> <span class='hs-varid'>fun_co</span> <span class='hs-varid'>arg_cos</span>
<a name="line-1477"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_co</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1478"></a>
<a name="line-1479"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>homogenise_result</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>co</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1480"></a>
<a name="line-1481"></a><a name="flatten_ty_con_app"></a><span class='hs-definition'>flatten_ty_con_app</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1482"></a><span class='hs-definition'>flatten_ty_con_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1483"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-1484"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_args_tc</span> <span class='hs-varid'>tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConRolesX</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-1485"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tyconapp_xi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span>
<a name="line-1486"></a>             <span class='hs-varid'>tyconapp_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConAppCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos</span>
<a name="line-1487"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>homogenise_result</span> <span class='hs-varid'>tyconapp_xi</span> <span class='hs-varid'>tyconapp_co</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1488"></a>
<a name="line-1489"></a><a name="homogenise_result"></a><span class='hs-comment'>-- Make the result of flattening homogeneous (Note [Flattening] (F2))</span>
<a name="line-1490"></a><span class='hs-definition'>homogenise_result</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Xi</span>              <span class='hs-comment'>-- a flattened type</span>
<a name="line-1491"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span>        <span class='hs-comment'>-- :: xi ~ original ty</span>
<a name="line-1492"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoercionN</span>       <span class='hs-comment'>-- kind_co :: typeKind(xi) ~N typeKind(ty)</span>
<a name="line-1493"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- (xi |&gt; kind_co, (xi |&gt; kind_co)</span>
<a name="line-1494"></a>                                     <span class='hs-comment'>--   ~ original ty)</span>
<a name="line-1495"></a><span class='hs-definition'>homogenise_result</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>co</span> <span class='hs-varid'>kind_co</span>
<a name="line-1496"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>xi'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi</span> <span class='hs-varop'>`mkCastTy`</span> <span class='hs-varid'>kind_co</span>
<a name="line-1497"></a>        <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co</span> <span class='hs-varop'>`mkTcCoherenceLeftCo`</span> <span class='hs-varid'>kind_co</span>
<a name="line-1498"></a>    <span class='hs-keyword'>in</span>  <span class='hs-layout'>(</span><span class='hs-varid'>xi'</span><span class='hs-layout'>,</span> <span class='hs-varid'>co'</span><span class='hs-layout'>)</span>
<a name="line-1499"></a><span class='hs-comment'>{-# INLINE homogenise_result #-}</span>
<a name="line-1500"></a>
<a name="line-1501"></a><a name="flatten_vector"></a><span class='hs-comment'>-- Flatten a vector (list of arguments).</span>
<a name="line-1502"></a><span class='hs-definition'>flatten_vector</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Kind</span>   <span class='hs-comment'>-- of the function being applied to these arguments</span>
<a name="line-1503"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- If we're flatten w.r.t. ReprEq, what roles do the</span>
<a name="line-1504"></a>                         <span class='hs-comment'>-- args have?</span>
<a name="line-1505"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- the args to flatten</span>
<a name="line-1506"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoercionN</span><span class='hs-layout'>)</span>
<a name="line-1507"></a><span class='hs-definition'>flatten_vector</span> <span class='hs-varid'>ki</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span>
<a name="line-1508"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getEqRel</span>
<a name="line-1509"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyword'>of</span>
<a name="line-1510"></a>           <span class='hs-conid'>NomEq</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_args</span> <span class='hs-varid'>bndrs</span>
<a name="line-1511"></a>                                  <span class='hs-varid'>any_named_bndrs</span>
<a name="line-1512"></a>                                  <span class='hs-varid'>inner_ki</span>
<a name="line-1513"></a>                                  <span class='hs-varid'>fvs</span>
<a name="line-1514"></a>                                  <span class='hs-layout'>(</span><span class='hs-varid'>repeat</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span>
<a name="line-1515"></a>                                  <span class='hs-varid'>tys</span>
<a name="line-1516"></a>           <span class='hs-conid'>ReprEq</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_args</span> <span class='hs-varid'>bndrs</span>
<a name="line-1517"></a>                                  <span class='hs-varid'>any_named_bndrs</span>
<a name="line-1518"></a>                                  <span class='hs-varid'>inner_ki</span>
<a name="line-1519"></a>                                  <span class='hs-varid'>fvs</span>
<a name="line-1520"></a>                                  <span class='hs-varid'>roles</span>
<a name="line-1521"></a>                                  <span class='hs-varid'>tys</span>
<a name="line-1522"></a>       <span class='hs-layout'>}</span>
<a name="line-1523"></a>  <span class='hs-keyword'>where</span>
<a name="line-1524"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>inner_ki</span><span class='hs-layout'>,</span> <span class='hs-varid'>any_named_bndrs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>split_pi_tys'</span> <span class='hs-varid'>ki</span>
<a name="line-1525"></a>    <span class='hs-varid'>fvs</span>                                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfType</span> <span class='hs-varid'>ki</span>
<a name="line-1526"></a><span class='hs-comment'>{-# INLINE flatten_vector #-}</span>
<a name="line-1527"></a>
<a name="line-1528"></a><span class='hs-comment'>{-
<a name="line-1529"></a>Note [Flattening synonyms]
<a name="line-1530"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1531"></a>Not expanding synonyms aggressively improves error messages, and
<a name="line-1532"></a>keeps types smaller. But we need to take care.
<a name="line-1533"></a>
<a name="line-1534"></a>Suppose
<a name="line-1535"></a>   type T a = a -&gt; a
<a name="line-1536"></a>and we want to flatten the type (T (F a)).  Then we can safely flatten
<a name="line-1537"></a>the (F a) to a skolem, and return (T fsk).  We don't need to expand the
<a name="line-1538"></a>synonym.  This works because TcTyConAppCo can deal with synonyms
<a name="line-1539"></a>(unlike TyConAppCo), see Note [TcCoercions] in TcEvidence.
<a name="line-1540"></a>
<a name="line-1541"></a>But (Trac #8979) for
<a name="line-1542"></a>   type T a = (F a, a)    where F is a type function
<a name="line-1543"></a>we must expand the synonym in (say) T Int, to expose the type function
<a name="line-1544"></a>to the flattener.
<a name="line-1545"></a>
<a name="line-1546"></a>
<a name="line-1547"></a>Note [Flattening under a forall]
<a name="line-1548"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1549"></a>Under a forall, we
<a name="line-1550"></a>  (a) MUST apply the inert substitution
<a name="line-1551"></a>  (b) MUST NOT flatten type family applications
<a name="line-1552"></a>Hence FMSubstOnly.
<a name="line-1553"></a>
<a name="line-1554"></a>For (a) consider   c ~ a, a ~ T (forall b. (b, [c]))
<a name="line-1555"></a>If we don't apply the c~a substitution to the second constraint
<a name="line-1556"></a>we won't see the occurs-check error.
<a name="line-1557"></a>
<a name="line-1558"></a>For (b) consider  (a ~ forall b. F a b), we don't want to flatten
<a name="line-1559"></a>to     (a ~ forall b.fsk, F a b ~ fsk)
<a name="line-1560"></a>because now the 'b' has escaped its scope.  We'd have to flatten to
<a name="line-1561"></a>       (a ~ forall b. fsk b, forall b. F a b ~ fsk b)
<a name="line-1562"></a>and we have not begun to think about how to make that work!
<a name="line-1563"></a>
<a name="line-1564"></a>************************************************************************
<a name="line-1565"></a>*                                                                      *
<a name="line-1566"></a>             Flattening a type-family application
<a name="line-1567"></a>*                                                                      *
<a name="line-1568"></a>************************************************************************
<a name="line-1569"></a>-}</span>
<a name="line-1570"></a>
<a name="line-1571"></a><a name="flatten_fam_app"></a><span class='hs-definition'>flatten_fam_app</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1572"></a>  <span class='hs-comment'>--   flatten_fam_app            can be over-saturated</span>
<a name="line-1573"></a>  <span class='hs-comment'>--   flatten_exact_fam_app       is exactly saturated</span>
<a name="line-1574"></a>  <span class='hs-comment'>--   flatten_exact_fam_app_fully lifts out the application to top level</span>
<a name="line-1575"></a>  <span class='hs-comment'>-- Postcondition: Coercion :: Xi ~ F tys</span>
<a name="line-1576"></a><span class='hs-definition'>flatten_fam_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>  <span class='hs-comment'>-- Can be over-saturated</span>
<a name="line-1577"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>tys</span> <span class='hs-varop'>`lengthAtLeast`</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span>
<a name="line-1578"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1579"></a>
<a name="line-1580"></a>      <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mode</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getMode</span>
<a name="line-1581"></a>         <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mode</span> <span class='hs-keyword'>of</span>
<a name="line-1582"></a>             <span class='hs-layout'>{</span> <span class='hs-conid'>FM_SubstOnly</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_ty_con_app</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1583"></a>             <span class='hs-layout'>;</span> <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1584"></a>
<a name="line-1585"></a>                 <span class='hs-comment'>-- Type functions are saturated</span>
<a name="line-1586"></a>                 <span class='hs-comment'>-- The type function might be *over* saturated</span>
<a name="line-1587"></a>                 <span class='hs-comment'>-- in which case the remaining arguments should</span>
<a name="line-1588"></a>                 <span class='hs-comment'>-- be dealt with by AppTys</span>
<a name="line-1589"></a>      <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>tys1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys_rest</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitAt</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-1590"></a>         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_exact_fam_app_fully</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys1</span>
<a name="line-1591"></a>               <span class='hs-comment'>-- co1 :: xi1 ~ F tys1</span>
<a name="line-1592"></a>
<a name="line-1593"></a>         <span class='hs-layout'>;</span> <span class='hs-varid'>flatten_app_ty_args</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>tys_rest</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1594"></a>
<a name="line-1595"></a><a name="flatten_exact_fam_app_fully"></a><span class='hs-comment'>-- the [TcType] exactly saturate the TyCon</span>
<a name="line-1596"></a><span class='hs-definition'>flatten_exact_fam_app_fully</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1597"></a><span class='hs-definition'>flatten_exact_fam_app_fully</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1598"></a>  <span class='hs-comment'>-- See Note [Reduce type family applications eagerly]</span>
<a name="line-1599"></a>     <span class='hs-comment'>-- the following typeKind should never be evaluated, as it's just used in</span>
<a name="line-1600"></a>     <span class='hs-comment'>-- casting, and casts by refl are dropped</span>
<a name="line-1601"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>reduce_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNomReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeKind</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1602"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mOut</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>try_to_reduce_nocache</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>reduce_co</span> <span class='hs-varid'>id</span>
<a name="line-1603"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mOut</span> <span class='hs-keyword'>of</span>
<a name="line-1604"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>out</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>out</span>
<a name="line-1605"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-1606"></a>               <span class='hs-layout'>{</span> <span class='hs-comment'>-- First, flatten the arguments</span>
<a name="line-1607"></a>               <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>,</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span>
<a name="line-1608"></a>                   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEqRel</span> <span class='hs-conid'>NomEq</span> <span class='hs-varop'>$</span>  <span class='hs-comment'>-- just do this once, instead of for</span>
<a name="line-1609"></a>                                        <span class='hs-comment'>-- each arg</span>
<a name="line-1610"></a>                      <span class='hs-varid'>flatten_args_tc</span> <span class='hs-varid'>tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>repeat</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-1611"></a>                      <span class='hs-comment'>-- kind_co :: typeKind(F xis) ~N typeKind(F tys)</span>
<a name="line-1612"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>eq_rel</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getEqRel</span>
<a name="line-1613"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>cur_flav</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFlavour</span>
<a name="line-1614"></a>               <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>role</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span>
<a name="line-1615"></a>                     <span class='hs-varid'>ret_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConAppCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos</span>
<a name="line-1616"></a>                      <span class='hs-comment'>-- ret_co :: F xis ~ F tys; might be heterogeneous</span>
<a name="line-1617"></a>
<a name="line-1618"></a>                <span class='hs-comment'>-- Now, look in the cache</span>
<a name="line-1619"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>lookupFlatCache</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span>
<a name="line-1620"></a>               <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyword'>of</span>
<a name="line-1621"></a>                   <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>flav</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- co :: F xis ~ fsk</span>
<a name="line-1622"></a>                        <span class='hs-comment'>-- flav is [G] or [WD]</span>
<a name="line-1623"></a>                        <span class='hs-comment'>-- See Note [Type family equations] in TcSMonad</span>
<a name="line-1624"></a>                     <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>NotSwapped</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flav</span> <span class='hs-varop'>`funEqCanDischargeF`</span> <span class='hs-varid'>cur_flav</span>
<a name="line-1625"></a>                     <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-comment'>-- Usable hit in the flat-cache</span>
<a name="line-1626"></a>                        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"flatten/flat-cache hit"</span> <span class='hs-varop'>$</span>
<a name="line-1627"></a>                               <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xis</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_ty</span><span class='hs-layout'>)</span>
<a name="line-1628"></a>                           <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsk_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsk_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>rhs_ty</span>
<a name="line-1629"></a>                                  <span class='hs-comment'>-- The fsk may already have been unified, so</span>
<a name="line-1630"></a>                                  <span class='hs-comment'>-- flatten it</span>
<a name="line-1631"></a>                                  <span class='hs-comment'>-- fsk_co :: fsk_xi ~ fsk</span>
<a name="line-1632"></a>                           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>xi</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fsk_xi</span> <span class='hs-varop'>`mkCastTy`</span> <span class='hs-varid'>kind_co</span>
<a name="line-1633"></a>                                 <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsk_co</span> <span class='hs-varop'>`mkTcCoherenceLeftCo`</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span>
<a name="line-1634"></a>                                        <span class='hs-varop'>`mkTransCo`</span>
<a name="line-1635"></a>                                        <span class='hs-varid'>maybeSubCo</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1636"></a>                                        <span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>ret_co</span>
<a name="line-1637"></a>                           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>co'</span><span class='hs-layout'>)</span>
<a name="line-1638"></a>                           <span class='hs-layout'>}</span>
<a name="line-1639"></a>                                            <span class='hs-comment'>-- :: fsk_xi ~ F xis</span>
<a name="line-1640"></a>
<a name="line-1641"></a>                   <span class='hs-comment'>-- Try to reduce the family application right now</span>
<a name="line-1642"></a>                   <span class='hs-comment'>-- See Note [Reduce type family applications eagerly]</span>
<a name="line-1643"></a>                   <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mOut</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>try_to_reduce</span> <span class='hs-varid'>tc</span>
<a name="line-1644"></a>                                                   <span class='hs-varid'>xis</span>
<a name="line-1645"></a>                                                   <span class='hs-varid'>kind_co</span>
<a name="line-1646"></a>                                                   <span class='hs-layout'>(</span><span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>ret_co</span><span class='hs-layout'>)</span>
<a name="line-1647"></a>                           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mOut</span> <span class='hs-keyword'>of</span>
<a name="line-1648"></a>                               <span class='hs-conid'>Just</span> <span class='hs-varid'>out</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>out</span>
<a name="line-1649"></a>                               <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-1650"></a>                                 <span class='hs-layout'>{</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getLoc</span>
<a name="line-1651"></a>                                 <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsk</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span>
<a name="line-1652"></a>                                     <span class='hs-varid'>newFlattenSkolem</span> <span class='hs-varid'>cur_flav</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span>
<a name="line-1653"></a>
<a name="line-1654"></a>                                 <span class='hs-comment'>-- The new constraint (F xis ~ fsk) is not</span>
<a name="line-1655"></a>                                 <span class='hs-comment'>-- necessarily inert (e.g. the LHS may be a</span>
<a name="line-1656"></a>                                 <span class='hs-comment'>-- redex) so we must put it in the work list</span>
<a name="line-1657"></a>                                 <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span>
<a name="line-1658"></a>                                                      <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span>
<a name="line-1659"></a>                                                      <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span>
<a name="line-1660"></a>                                                      <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fsk</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fsk</span> <span class='hs-layout'>}</span>
<a name="line-1661"></a>                                 <span class='hs-layout'>;</span> <span class='hs-varid'>emitFlatWork</span> <span class='hs-varid'>ct</span>
<a name="line-1662"></a>
<a name="line-1663"></a>                                 <span class='hs-layout'>;</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"flatten/flat-cache miss"</span> <span class='hs-varop'>$</span>
<a name="line-1664"></a>                                     <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xis</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fsk</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-1665"></a>
<a name="line-1666"></a>                                 <span class='hs-comment'>-- NB: fsk's kind is already flattend because</span>
<a name="line-1667"></a>                                 <span class='hs-comment'>--     the xis are flattened</span>
<a name="line-1668"></a>                                 <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>xi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>fsk</span> <span class='hs-varop'>`mkCastTy`</span> <span class='hs-varid'>kind_co</span>
<a name="line-1669"></a>                                       <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>maybeSubCo</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1670"></a>                                               <span class='hs-varop'>`mkTcCoherenceLeftCo`</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span>
<a name="line-1671"></a>                                              <span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>ret_co</span>
<a name="line-1672"></a>                                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>co'</span><span class='hs-layout'>)</span>
<a name="line-1673"></a>                                 <span class='hs-layout'>}</span>
<a name="line-1674"></a>                           <span class='hs-layout'>}</span>
<a name="line-1675"></a>               <span class='hs-layout'>}</span>
<a name="line-1676"></a>        <span class='hs-layout'>}</span>
<a name="line-1677"></a>
<a name="line-1678"></a>  <span class='hs-keyword'>where</span>
<a name="line-1679"></a>
<a name="line-1680"></a>    <span class='hs-comment'>-- try_to_reduce and try_to_reduce_nocache (below) could be unified into</span>
<a name="line-1681"></a>    <span class='hs-comment'>-- a more general definition, but it was observed that separating them</span>
<a name="line-1682"></a>    <span class='hs-comment'>-- gives better performance (lower allocation numbers in T9872x).</span>
<a name="line-1683"></a>
<a name="line-1684"></a>    <span class='hs-varid'>try_to_reduce</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span>   <span class='hs-comment'>-- F, family tycon</span>
<a name="line-1685"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- args, not necessarily flattened</span>
<a name="line-1686"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoercionN</span> <span class='hs-comment'>-- kind_co :: typeKind(F args) ~N</span>
<a name="line-1687"></a>                               <span class='hs-comment'>--            typeKind(F orig_args)</span>
<a name="line-1688"></a>                               <span class='hs-comment'>-- where</span>
<a name="line-1689"></a>                               <span class='hs-comment'>-- orig_args is what was passed to the outer</span>
<a name="line-1690"></a>                               <span class='hs-comment'>-- function</span>
<a name="line-1691"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span>   <span class='hs-conid'>Coercion</span>     <span class='hs-comment'>-- :: (xi |&gt; kind_co) ~ F args</span>
<a name="line-1692"></a>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span> <span class='hs-layout'>)</span>   <span class='hs-comment'>-- what to return from outer function</span>
<a name="line-1693"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1694"></a>    <span class='hs-varid'>try_to_reduce</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>kind_co</span> <span class='hs-varid'>update_co</span>
<a name="line-1695"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkStackDepth</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1696"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>mb_match</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>matchFam</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1697"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_match</span> <span class='hs-keyword'>of</span>
<a name="line-1698"></a>                 <span class='hs-comment'>-- NB: norm_co will always be homogeneous. All type families</span>
<a name="line-1699"></a>                 <span class='hs-comment'>-- are homogeneous.</span>
<a name="line-1700"></a>               <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>norm_co</span><span class='hs-layout'>,</span> <span class='hs-varid'>norm_ty</span><span class='hs-layout'>)</span>
<a name="line-1701"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"Eager T.F. reduction success"</span> <span class='hs-varop'>$</span>
<a name="line-1702"></a>                         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>norm_ty</span>
<a name="line-1703"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>norm_co</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span>
<a name="line-1704"></a>                                            <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionKind</span> <span class='hs-varid'>norm_co</span><span class='hs-layout'>)</span>
<a name="line-1705"></a>                              <span class='hs-keyglyph'>]</span>
<a name="line-1706"></a>                       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>final_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bumpDepth</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>norm_ty</span>
<a name="line-1707"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getEqRel</span>
<a name="line-1708"></a>                       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maybeSubCo</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>norm_co</span>
<a name="line-1709"></a>                                   <span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>final_co</span>
<a name="line-1710"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>flavour</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFlavour</span>
<a name="line-1711"></a>                           <span class='hs-comment'>-- NB: only extend cache with nominal equalities</span>
<a name="line-1712"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>eq_rel</span> <span class='hs-varop'>==</span> <span class='hs-conid'>NomEq</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1713"></a>                         <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span>
<a name="line-1714"></a>                         <span class='hs-varid'>extendFlatCache</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>(</span> <span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>flavour</span> <span class='hs-layout'>)</span>
<a name="line-1715"></a>                       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>xi'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi</span> <span class='hs-varop'>`mkCastTy`</span> <span class='hs-varid'>kind_co</span>
<a name="line-1716"></a>                             <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>update_co</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span>
<a name="line-1717"></a>                                                <span class='hs-varop'>`mkTcCoherenceLeftCo`</span> <span class='hs-varid'>kind_co</span>
<a name="line-1718"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi'</span><span class='hs-layout'>,</span> <span class='hs-varid'>co'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1719"></a>               <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>}</span>
<a name="line-1720"></a>
<a name="line-1721"></a>    <span class='hs-varid'>try_to_reduce_nocache</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span>   <span class='hs-comment'>-- F, family tycon</span>
<a name="line-1722"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- args, not necessarily flattened</span>
<a name="line-1723"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoercionN</span> <span class='hs-comment'>-- kind_co :: typeKind(F args)</span>
<a name="line-1724"></a>                                       <span class='hs-comment'>--            ~N typeKind(F orig_args)</span>
<a name="line-1725"></a>                                       <span class='hs-comment'>-- where</span>
<a name="line-1726"></a>                                       <span class='hs-comment'>-- orig_args is what was passed to the</span>
<a name="line-1727"></a>                                       <span class='hs-comment'>-- outer function</span>
<a name="line-1728"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span>   <span class='hs-conid'>Coercion</span>     <span class='hs-comment'>-- :: (xi |&gt; kind_co) ~ F args</span>
<a name="line-1729"></a>                              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span> <span class='hs-layout'>)</span>   <span class='hs-comment'>-- what to return from outer</span>
<a name="line-1730"></a>                                              <span class='hs-comment'>-- function</span>
<a name="line-1731"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1732"></a>    <span class='hs-varid'>try_to_reduce_nocache</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>kind_co</span> <span class='hs-varid'>update_co</span>
<a name="line-1733"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkStackDepth</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1734"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>mb_match</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>matchFam</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-1735"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_match</span> <span class='hs-keyword'>of</span>
<a name="line-1736"></a>                 <span class='hs-comment'>-- NB: norm_co will always be homogeneous. All type families</span>
<a name="line-1737"></a>                 <span class='hs-comment'>-- are homogeneous.</span>
<a name="line-1738"></a>               <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>norm_co</span><span class='hs-layout'>,</span> <span class='hs-varid'>norm_ty</span><span class='hs-layout'>)</span>
<a name="line-1739"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>final_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bumpDepth</span> <span class='hs-varop'>$</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>norm_ty</span>
<a name="line-1740"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getEqRel</span>
<a name="line-1741"></a>                       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maybeSubCo</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>norm_co</span>
<a name="line-1742"></a>                                    <span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>final_co</span>
<a name="line-1743"></a>                             <span class='hs-varid'>xi'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi</span> <span class='hs-varop'>`mkCastTy`</span> <span class='hs-varid'>kind_co</span>
<a name="line-1744"></a>                             <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>update_co</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span>
<a name="line-1745"></a>                                                <span class='hs-varop'>`mkTcCoherenceLeftCo`</span> <span class='hs-varid'>kind_co</span>
<a name="line-1746"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi'</span><span class='hs-layout'>,</span> <span class='hs-varid'>co'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1747"></a>               <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>}</span>
<a name="line-1748"></a>
<a name="line-1749"></a><span class='hs-comment'>{- Note [Reduce type family applications eagerly]
<a name="line-1750"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1751"></a>If we come across a type-family application like (Append (Cons x Nil) t),
<a name="line-1752"></a>then, rather than flattening to a skolem etc, we may as well just reduce
<a name="line-1753"></a>it on the spot to (Cons x t).  This saves a lot of intermediate steps.
<a name="line-1754"></a>Examples that are helped are tests T9872, and T5321Fun.
<a name="line-1755"></a>
<a name="line-1756"></a>Performance testing indicates that it's best to try this *twice*, once
<a name="line-1757"></a>before flattening arguments and once after flattening arguments.
<a name="line-1758"></a>Adding the extra reduction attempt before flattening arguments cut
<a name="line-1759"></a>the allocation amounts for the T9872{a,b,c} tests by half.
<a name="line-1760"></a>
<a name="line-1761"></a>An example of where the early reduction appears helpful:
<a name="line-1762"></a>
<a name="line-1763"></a>  type family Last x where
<a name="line-1764"></a>    Last '[x]     = x
<a name="line-1765"></a>    Last (h ': t) = Last t
<a name="line-1766"></a>
<a name="line-1767"></a>  workitem: (x ~ Last '[1,2,3,4,5,6])
<a name="line-1768"></a>
<a name="line-1769"></a>Flattening the argument never gets us anywhere, but trying to flatten
<a name="line-1770"></a>it at every step is quadratic in the length of the list. Reducing more
<a name="line-1771"></a>eagerly makes simplifying the right-hand type linear in its length.
<a name="line-1772"></a>
<a name="line-1773"></a>Testing also indicated that the early reduction should *not* use the
<a name="line-1774"></a>flat-cache, but that the later reduction *should*. (Although the
<a name="line-1775"></a>effect was not large.)  Hence the Bool argument to try_to_reduce.  To
<a name="line-1776"></a>me (SLPJ) this seems odd; I get that eager reduction usually succeeds;
<a name="line-1777"></a>and if don't use the cache for eager reduction, we will miss most of
<a name="line-1778"></a>the opportunities for using it at all.  More exploration would be good
<a name="line-1779"></a>here.
<a name="line-1780"></a>
<a name="line-1781"></a>At the end, once we've got a flat rhs, we extend the flatten-cache to record
<a name="line-1782"></a>the result. Doing so can save lots of work when the same redex shows up more
<a name="line-1783"></a>than once. Note that we record the link from the redex all the way to its
<a name="line-1784"></a>*final* value, not just the single step reduction. Interestingly, using the
<a name="line-1785"></a>flat-cache for the first reduction resulted in an increase in allocations
<a name="line-1786"></a>of about 3% for the four T9872x tests. However, using the flat-cache in
<a name="line-1787"></a>the later reduction is a similar gain. I (Richard E) don't currently (Dec '14)
<a name="line-1788"></a>have any knowledge as to *why* these facts are true.
<a name="line-1789"></a>
<a name="line-1790"></a>************************************************************************
<a name="line-1791"></a>*                                                                      *
<a name="line-1792"></a>             Flattening a type variable
<a name="line-1793"></a>*                                                                      *
<a name="line-1794"></a>********************************************************************* -}</span>
<a name="line-1795"></a>
<a name="line-1796"></a><a name="FlattenTvResult"></a><span class='hs-comment'>-- | The result of flattening a tyvar "one step".</span>
<a name="line-1797"></a><a name="FlattenTvResult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>FlattenTvResult</span>
<a name="line-1798"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FTRNotFollowed</span>
<a name="line-1799"></a>      <span class='hs-comment'>-- ^ The inert set doesn't make the tyvar equal to anything else</span>
<a name="line-1800"></a>
<a name="line-1801"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FTRFollowed</span> <span class='hs-conid'>TcType</span> <span class='hs-conid'>Coercion</span>
<a name="line-1802"></a>      <span class='hs-comment'>-- ^ The tyvar flattens to a not-necessarily flat other type.</span>
<a name="line-1803"></a>      <span class='hs-comment'>-- co :: new type ~r old type, where the role is determined by</span>
<a name="line-1804"></a>      <span class='hs-comment'>-- the FlattenEnv</span>
<a name="line-1805"></a>
<a name="line-1806"></a><a name="flattenTyVar"></a><span class='hs-definition'>flattenTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1807"></a><span class='hs-definition'>flattenTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-1808"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_yes</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_tyvar1</span> <span class='hs-varid'>tv</span>
<a name="line-1809"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_yes</span> <span class='hs-keyword'>of</span>
<a name="line-1810"></a>           <span class='hs-conid'>FTRFollowed</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>co1</span>  <span class='hs-comment'>-- Recur</span>
<a name="line-1811"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>ty1</span>
<a name="line-1812"></a>                   <span class='hs-comment'>-- ; traceFlat "flattenTyVar2" (ppr tv $$ ppr ty2)</span>
<a name="line-1813"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span> <span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1814"></a>
<a name="line-1815"></a>           <span class='hs-conid'>FTRNotFollowed</span>   <span class='hs-comment'>-- Done, but make sure the kind is zonked</span>
<a name="line-1816"></a>                            <span class='hs-comment'>-- Note [Flattening] invariant (F1)</span>
<a name="line-1817"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tv'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>updateTyVarKindM</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>tv</span>
<a name="line-1818"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-1819"></a>                   <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv'</span>
<a name="line-1820"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1821"></a>
<a name="line-1822"></a><a name="flatten_tyvar1"></a><span class='hs-definition'>flatten_tyvar1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>FlattenTvResult</span>
<a name="line-1823"></a><span class='hs-comment'>-- "Flattening" a type variable means to apply the substitution to it</span>
<a name="line-1824"></a><span class='hs-comment'>-- Specifically, look up the tyvar in</span>
<a name="line-1825"></a><span class='hs-comment'>--   * the internal MetaTyVar box</span>
<a name="line-1826"></a><span class='hs-comment'>--   * the inerts</span>
<a name="line-1827"></a><span class='hs-comment'>-- See also the documentation for FlattenTvResult</span>
<a name="line-1828"></a>
<a name="line-1829"></a><span class='hs-definition'>flatten_tyvar1</span> <span class='hs-varid'>tv</span>
<a name="line-1830"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>isFilledMetaTyVar_maybe</span> <span class='hs-varid'>tv</span>
<a name="line-1831"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyword'>of</span>
<a name="line-1832"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"Following filled tyvar"</span>
<a name="line-1833"></a>                             <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1834"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>role</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRole</span>
<a name="line-1835"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>FTRFollowed</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>;</span>
<a name="line-1836"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"Unfilled tyvar"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-1837"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>fr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFlavourRole</span>
<a name="line-1838"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>flatten_tyvar2</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>fr</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1839"></a>
<a name="line-1840"></a><a name="flatten_tyvar2"></a><span class='hs-definition'>flatten_tyvar2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavourRole</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlatM</span> <span class='hs-conid'>FlattenTvResult</span>
<a name="line-1841"></a><span class='hs-comment'>-- The tyvar is not a filled-in meta-tyvar</span>
<a name="line-1842"></a><span class='hs-comment'>-- Try in the inert equalities</span>
<a name="line-1843"></a><span class='hs-comment'>-- See Definition [Applying a generalised substitution] in TcSMonad</span>
<a name="line-1844"></a><span class='hs-comment'>-- See Note [Stability of flattening] in TcSMonad</span>
<a name="line-1845"></a>
<a name="line-1846"></a><span class='hs-definition'>flatten_tyvar2</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>fr</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span>
<a name="line-1847"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ieqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>liftTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getInertEqs</span>
<a name="line-1848"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mode</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getMode</span>
<a name="line-1849"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupDVarEnv</span> <span class='hs-varid'>ieqs</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>of</span>
<a name="line-1850"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- If the first doesn't work,</span>
<a name="line-1851"></a>                         <span class='hs-comment'>-- the subsequent ones won't either</span>
<a name="line-1852"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span>
<a name="line-1853"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ct_eq_rel</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ct</span>
<a name="line-1854"></a>             <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ct_fr</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvFlavour</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>,</span> <span class='hs-varid'>ct_eq_rel</span><span class='hs-layout'>)</span>
<a name="line-1855"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ct_fr</span> <span class='hs-varop'>`eqCanRewriteFR`</span> <span class='hs-varid'>fr</span>  <span class='hs-comment'>-- This is THE key call of eqCanRewriteFR</span>
<a name="line-1856"></a>             <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceFlat</span> <span class='hs-str'>"Following inert tyvar"</span>
<a name="line-1857"></a>                        <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>mode</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-1858"></a>                         <span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-1859"></a>                         <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-1860"></a>                         <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span>
<a name="line-1861"></a>                    <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rewrite_co1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvCoercion</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span>
<a name="line-1862"></a>                          <span class='hs-varid'>rewrite_co</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct_eq_rel</span><span class='hs-layout'>,</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-1863"></a>                            <span class='hs-layout'>(</span><span class='hs-conid'>ReprEq</span><span class='hs-layout'>,</span> <span class='hs-sel'>_rel</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-sel'>_rel</span> <span class='hs-varop'>==</span> <span class='hs-conid'>ReprEq</span> <span class='hs-layout'>)</span>
<a name="line-1864"></a>                                    <span class='hs-comment'>-- if this ASSERT fails, then</span>
<a name="line-1865"></a>                                    <span class='hs-comment'>-- eqCanRewriteFR answered incorrectly</span>
<a name="line-1866"></a>                                               <span class='hs-varid'>rewrite_co1</span>
<a name="line-1867"></a>                            <span class='hs-layout'>(</span><span class='hs-conid'>NomEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>NomEq</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rewrite_co1</span>
<a name="line-1868"></a>                            <span class='hs-layout'>(</span><span class='hs-conid'>NomEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>ReprEq</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkSubCo</span> <span class='hs-varid'>rewrite_co1</span>
<a name="line-1869"></a>
<a name="line-1870"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>FTRFollowed</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>rewrite_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1871"></a>                    <span class='hs-comment'>-- NB: ct is Derived then fmode must be also, hence</span>
<a name="line-1872"></a>                    <span class='hs-comment'>-- we are not going to touch the returned coercion</span>
<a name="line-1873"></a>                    <span class='hs-comment'>-- so ctEvCoercion is fine.</span>
<a name="line-1874"></a>
<a name="line-1875"></a>           <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>FTRNotFollowed</span> <span class='hs-layout'>}</span>
<a name="line-1876"></a>
<a name="line-1877"></a><span class='hs-comment'>{-
<a name="line-1878"></a>Note [An alternative story for the inert substitution]
<a name="line-1879"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1880"></a>(This entire note is just background, left here in case we ever want
<a name="line-1881"></a> to return the previous state of affairs)
<a name="line-1882"></a>
<a name="line-1883"></a>We used (GHC 7.8) to have this story for the inert substitution inert_eqs
<a name="line-1884"></a>
<a name="line-1885"></a> * 'a' is not in fvs(ty)
<a name="line-1886"></a> * They are *inert* in the weaker sense that there is no infinite chain of
<a name="line-1887"></a>   (i1 `eqCanRewrite` i2), (i2 `eqCanRewrite` i3), etc
<a name="line-1888"></a>
<a name="line-1889"></a>This means that flattening must be recursive, but it does allow
<a name="line-1890"></a>  [G] a ~ [b]
<a name="line-1891"></a>  [G] b ~ Maybe c
<a name="line-1892"></a>
<a name="line-1893"></a>This avoids "saturating" the Givens, which can save a modest amount of work.
<a name="line-1894"></a>It is easy to implement, in TcInteract.kick_out, by only kicking out an inert
<a name="line-1895"></a>only if (a) the work item can rewrite the inert AND
<a name="line-1896"></a>        (b) the inert cannot rewrite the work item
<a name="line-1897"></a>
<a name="line-1898"></a>This is significantly harder to think about. It can save a LOT of work
<a name="line-1899"></a>in occurs-check cases, but we don't care about them much.  Trac #5837
<a name="line-1900"></a>is an example; all the constraints here are Givens
<a name="line-1901"></a>
<a name="line-1902"></a>             [G] a ~ TF (a,Int)
<a name="line-1903"></a>    --&gt;
<a name="line-1904"></a>    work     TF (a,Int) ~ fsk
<a name="line-1905"></a>    inert    fsk ~ a
<a name="line-1906"></a>
<a name="line-1907"></a>    ---&gt;
<a name="line-1908"></a>    work     fsk ~ (TF a, TF Int)
<a name="line-1909"></a>    inert    fsk ~ a
<a name="line-1910"></a>
<a name="line-1911"></a>    ---&gt;
<a name="line-1912"></a>    work     a ~ (TF a, TF Int)
<a name="line-1913"></a>    inert    fsk ~ a
<a name="line-1914"></a>
<a name="line-1915"></a>    ---&gt; (attempting to flatten (TF a) so that it does not mention a
<a name="line-1916"></a>    work     TF a ~ fsk2
<a name="line-1917"></a>    inert    a ~ (fsk2, TF Int)
<a name="line-1918"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1919"></a>
<a name="line-1920"></a>    ---&gt; (substitute for a)
<a name="line-1921"></a>    work     TF (fsk2, TF Int) ~ fsk2
<a name="line-1922"></a>    inert    a ~ (fsk2, TF Int)
<a name="line-1923"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1924"></a>
<a name="line-1925"></a>    ---&gt; (top-level reduction, re-orient)
<a name="line-1926"></a>    work     fsk2 ~ (TF fsk2, TF Int)
<a name="line-1927"></a>    inert    a ~ (fsk2, TF Int)
<a name="line-1928"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1929"></a>
<a name="line-1930"></a>    ---&gt; (attempt to flatten (TF fsk2) to get rid of fsk2
<a name="line-1931"></a>    work     TF fsk2 ~ fsk3
<a name="line-1932"></a>    work     fsk2 ~ (fsk3, TF Int)
<a name="line-1933"></a>    inert    a   ~ (fsk2, TF Int)
<a name="line-1934"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1935"></a>
<a name="line-1936"></a>    ---&gt;
<a name="line-1937"></a>    work     TF fsk2 ~ fsk3
<a name="line-1938"></a>    inert    fsk2 ~ (fsk3, TF Int)
<a name="line-1939"></a>    inert    a   ~ ((fsk3, TF Int), TF Int)
<a name="line-1940"></a>    inert    fsk ~ ((fsk3, TF Int), TF Int)
<a name="line-1941"></a>
<a name="line-1942"></a>Because the incoming given rewrites all the inert givens, we get more and
<a name="line-1943"></a>more duplication in the inert set.  But this really only happens in pathalogical
<a name="line-1944"></a>casee, so we don't care.
<a name="line-1945"></a>
<a name="line-1946"></a>
<a name="line-1947"></a>************************************************************************
<a name="line-1948"></a>*                                                                      *
<a name="line-1949"></a>             Unflattening
<a name="line-1950"></a>*                                                                      *
<a name="line-1951"></a>************************************************************************
<a name="line-1952"></a>
<a name="line-1953"></a>An unflattening example:
<a name="line-1954"></a>    [W] F a ~ alpha
<a name="line-1955"></a>flattens to
<a name="line-1956"></a>    [W] F a ~ fmv   (CFunEqCan)
<a name="line-1957"></a>    [W] fmv ~ alpha (CTyEqCan)
<a name="line-1958"></a>We must solve both!
<a name="line-1959"></a>-}</span>
<a name="line-1960"></a>
<a name="line-1961"></a><a name="unflattenWanteds"></a><span class='hs-definition'>unflattenWanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-1962"></a><span class='hs-definition'>unflattenWanteds</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-varid'>funeqs</span>
<a name="line-1963"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tclvl</span>    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcLevel</span>
<a name="line-1964"></a>
<a name="line-1965"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-varop'>$</span>
<a name="line-1966"></a>        <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Funeqs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprCts</span> <span class='hs-varid'>funeqs</span>
<a name="line-1967"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Tv eqs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprCts</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-keyglyph'>]</span>
<a name="line-1968"></a>
<a name="line-1969"></a>         <span class='hs-comment'>-- Step 1: unflatten the CFunEqCans, except if that causes an occurs check</span>
<a name="line-1970"></a>         <span class='hs-comment'>-- Occurs check: consider  [W] alpha ~ [F alpha]</span>
<a name="line-1971"></a>         <span class='hs-comment'>--                 ==&gt; (flatten) [W] F alpha ~ fmv, [W] alpha ~ [fmv]</span>
<a name="line-1972"></a>         <span class='hs-comment'>--                 ==&gt; (unify)   [W] F [fmv] ~ fmv</span>
<a name="line-1973"></a>         <span class='hs-comment'>-- See Note [Unflatten using funeqs first]</span>
<a name="line-1974"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>funeqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldrBagM</span> <span class='hs-varid'>unflatten_funeq</span> <span class='hs-varid'>emptyCts</span> <span class='hs-varid'>funeqs</span>
<a name="line-1975"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening 1"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>funeqs</span><span class='hs-layout'>)</span>
<a name="line-1976"></a>
<a name="line-1977"></a>          <span class='hs-comment'>-- Step 2: unify the tv_eqs, if possible</span>
<a name="line-1978"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>tv_eqs</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldrBagM</span> <span class='hs-layout'>(</span><span class='hs-varid'>unflatten_eq</span> <span class='hs-varid'>tclvl</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyCts</span> <span class='hs-varid'>tv_eqs</span>
<a name="line-1979"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening 2"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>tv_eqs</span><span class='hs-layout'>)</span>
<a name="line-1980"></a>
<a name="line-1981"></a>          <span class='hs-comment'>-- Step 3: fill any remaining fmvs with fresh unification variables</span>
<a name="line-1982"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>funeqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapBagM</span> <span class='hs-varid'>finalise_funeq</span> <span class='hs-varid'>funeqs</span>
<a name="line-1983"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening 3"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>funeqs</span><span class='hs-layout'>)</span>
<a name="line-1984"></a>
<a name="line-1985"></a>          <span class='hs-comment'>-- Step 4: remove any tv_eqs that look like ty ~ ty</span>
<a name="line-1986"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldrBagM</span> <span class='hs-varid'>finalise_eq</span> <span class='hs-varid'>emptyCts</span> <span class='hs-varid'>tv_eqs</span>
<a name="line-1987"></a>
<a name="line-1988"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>all_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-varop'>`andCts`</span> <span class='hs-varid'>funeqs</span>
<a name="line-1989"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening done"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>all_flat</span><span class='hs-layout'>)</span>
<a name="line-1990"></a>
<a name="line-1991"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>all_flat</span> <span class='hs-layout'>}</span>
<a name="line-1992"></a>  <span class='hs-keyword'>where</span>
<a name="line-1993"></a>    <span class='hs-comment'>----------------</span>
<a name="line-1994"></a>    <span class='hs-varid'>unflatten_funeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-1995"></a>    <span class='hs-varid'>unflatten_funeq</span> <span class='hs-varid'>ct</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span>
<a name="line-1996"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fsk</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest</span>
<a name="line-1997"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>   <span class='hs-comment'>-- fmv should be an un-filled flatten meta-tv;</span>
<a name="line-1998"></a>               <span class='hs-comment'>-- we now fix its final value by filling it, being careful</span>
<a name="line-1999"></a>               <span class='hs-comment'>-- to observe the occurs check.  Zonking will eliminate it</span>
<a name="line-2000"></a>               <span class='hs-comment'>-- altogether in due course</span>
<a name="line-2001"></a>             <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span><span class='hs-layout'>)</span>
<a name="line-2002"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occCheckExpand</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>fmv</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyword'>of</span>
<a name="line-2003"></a>               <span class='hs-conid'>Just</span> <span class='hs-varid'>rhs''</span>    <span class='hs-comment'>-- Normal case: fill the tyvar</span>
<a name="line-2004"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setReflEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NomEq</span> <span class='hs-varid'>rhs''</span>
<a name="line-2005"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>unflattenFmv</span> <span class='hs-varid'>fmv</span> <span class='hs-varid'>rhs''</span>
<a name="line-2006"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>rest</span> <span class='hs-layout'>}</span>
<a name="line-2007"></a>
<a name="line-2008"></a>               <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-comment'>-- Occurs check</span>
<a name="line-2009"></a>                          <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2010"></a>
<a name="line-2011"></a>    <span class='hs-varid'>unflatten_funeq</span> <span class='hs-varid'>other_ct</span> <span class='hs-keyword'>_</span>
<a name="line-2012"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"unflatten_funeq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>other_ct</span><span class='hs-layout'>)</span>
<a name="line-2013"></a>
<a name="line-2014"></a>    <span class='hs-comment'>----------------</span>
<a name="line-2015"></a>    <span class='hs-varid'>finalise_funeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Ct</span>
<a name="line-2016"></a>    <span class='hs-varid'>finalise_funeq</span> <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_fsk</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2017"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>demoteUnfilledFmv</span> <span class='hs-varid'>fmv</span>
<a name="line-2018"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2019"></a>    <span class='hs-varid'>finalise_funeq</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"finalise_funeq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-2020"></a>
<a name="line-2021"></a>    <span class='hs-comment'>----------------</span>
<a name="line-2022"></a>    <span class='hs-varid'>unflatten_eq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcLevel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-2023"></a>    <span class='hs-varid'>unflatten_eq</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>ct</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span>
<a name="line-2024"></a>                                    <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest</span>
<a name="line-2025"></a>
<a name="line-2026"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NomEq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>eq_rel</span> <span class='hs-comment'>-- See Note [Do not unify representational equalities]</span>
<a name="line-2027"></a>                        <span class='hs-comment'>--     in TcInteract</span>
<a name="line-2028"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isFmvTyVar</span> <span class='hs-varid'>tv</span>   <span class='hs-comment'>-- Previously these fmvs were untouchable,</span>
<a name="line-2029"></a>                        <span class='hs-comment'>-- but now they are touchable</span>
<a name="line-2030"></a>                        <span class='hs-comment'>-- NB: unlike unflattenFmv, filling a fmv here /does/</span>
<a name="line-2031"></a>                        <span class='hs-comment'>--     bump the unification count; it is "improvement"</span>
<a name="line-2032"></a>                        <span class='hs-comment'>-- Note [Unflattening can force the solver to iterate]</span>
<a name="line-2033"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span> <span class='hs-layout'>)</span>
<a name="line-2034"></a>           <span class='hs-comment'>-- CTyEqCan invariant should ensure this is true</span>
<a name="line-2035"></a>        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_filled</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isFilledMetaTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-2036"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>elim</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>is_filled</span> <span class='hs-keyword'>of</span>
<a name="line-2037"></a>               <span class='hs-conid'>False</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"unflatten_eq 2"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-2038"></a>                           <span class='hs-layout'>;</span> <span class='hs-varid'>tryFill</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span>
<a name="line-2039"></a>               <span class='hs-conid'>True</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"unflatten_eq 3"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-2040"></a>                           <span class='hs-layout'>;</span> <span class='hs-varid'>try_fill_rhs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span>
<a name="line-2041"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>elim</span>
<a name="line-2042"></a>             <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setReflEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-2043"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>rest</span> <span class='hs-layout'>}</span>
<a name="line-2044"></a>             <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2045"></a>
<a name="line-2046"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2047"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span>
<a name="line-2048"></a>
<a name="line-2049"></a>    <span class='hs-varid'>unflatten_eq</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ct</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"unflatten_irred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-2050"></a>
<a name="line-2051"></a>    <span class='hs-comment'>----------------</span>
<a name="line-2052"></a>    <span class='hs-varid'>try_fill_rhs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>lhs_tv</span> <span class='hs-varid'>rhs</span>
<a name="line-2053"></a>         <span class='hs-comment'>-- Constraint is lhs_tv ~ rhs_tv,</span>
<a name="line-2054"></a>         <span class='hs-comment'>-- and lhs_tv is filled, so try RHS</span>
<a name="line-2055"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getCastedTyVar_maybe</span> <span class='hs-varid'>rhs</span>
<a name="line-2056"></a>                             <span class='hs-comment'>-- co :: kind(rhs_tv) ~ kind(lhs_tv)</span>
<a name="line-2057"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isFmvTyVar</span> <span class='hs-varid'>rhs_tv</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTouchableMetaTyVar</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>rhs_tv</span>
<a name="line-2058"></a>                              <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSigTyVar</span> <span class='hs-varid'>rhs_tv</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2059"></a>                              <span class='hs-comment'>-- LHS is a filled fmv, and so is a type</span>
<a name="line-2060"></a>                              <span class='hs-comment'>-- family application, which a SigTv should</span>
<a name="line-2061"></a>                              <span class='hs-comment'>-- not unify with</span>
<a name="line-2062"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_filled</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isFilledMetaTyVar</span> <span class='hs-varid'>rhs_tv</span>
<a name="line-2063"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>is_filled</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-2064"></a>             <span class='hs-keyword'>else</span> <span class='hs-varid'>tryFill</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>rhs_tv</span>
<a name="line-2065"></a>                          <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>lhs_tv</span> <span class='hs-varop'>`mkCastTy`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2066"></a>
<a name="line-2067"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2068"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-2069"></a>
<a name="line-2070"></a>    <span class='hs-comment'>----------------</span>
<a name="line-2071"></a>    <span class='hs-varid'>finalise_eq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-2072"></a>    <span class='hs-varid'>finalise_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span>
<a name="line-2073"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest</span>
<a name="line-2074"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFmvTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-2075"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ty1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-2076"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>rhs</span>
<a name="line-2077"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>rhs'</span>
<a name="line-2078"></a>             <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setReflEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>rhs'</span>
<a name="line-2079"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>rest</span> <span class='hs-layout'>}</span>
<a name="line-2080"></a>             <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2081"></a>
<a name="line-2082"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2083"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span>
<a name="line-2084"></a>
<a name="line-2085"></a>    <span class='hs-varid'>finalise_eq</span> <span class='hs-varid'>ct</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"finalise_irred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-2086"></a>
<a name="line-2087"></a><a name="tryFill"></a><span class='hs-definition'>tryFill</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Bool</span>
<a name="line-2088"></a><span class='hs-comment'>-- (tryFill tv rhs ev) assumes 'tv' is an /un-filled/ MetaTv</span>
<a name="line-2089"></a><span class='hs-comment'>-- If tv does not appear in 'rhs', it set tv := rhs,</span>
<a name="line-2090"></a><span class='hs-comment'>-- binds the evidence (which should be a CtWanted) to Refl&lt;rhs&gt;</span>
<a name="line-2091"></a><span class='hs-comment'>-- and return True.  Otherwise returns False</span>
<a name="line-2092"></a><span class='hs-definition'>tryFill</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs</span>
<a name="line-2093"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isGiven</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>)</span>
<a name="line-2094"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>rhs</span>
<a name="line-2095"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>of</span>
<a name="line-2096"></a>            <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>rhs'</span>
<a name="line-2097"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tv'</span>   <span class='hs-comment'>-- tv == rhs</span>
<a name="line-2098"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>True</span>
<a name="line-2099"></a>
<a name="line-2100"></a>            <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>rhs''</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>occCheckExpand</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>tv</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>rhs'</span>
<a name="line-2101"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>       <span class='hs-comment'>-- Fill the tyvar</span>
<a name="line-2102"></a>                      <span class='hs-varid'>unifyTyVar</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs''</span>
<a name="line-2103"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-2104"></a>
<a name="line-2105"></a>            <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- Occurs check</span>
<a name="line-2106"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-2107"></a>    <span class='hs-layout'>}</span>
<a name="line-2108"></a>
<a name="line-2109"></a><a name="setReflEvidence"></a><span class='hs-definition'>setReflEvidence</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-2110"></a><span class='hs-definition'>setReflEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>rhs</span>
<a name="line-2111"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setEvBindIfWanted</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>evCoercion</span> <span class='hs-varid'>refl_co</span><span class='hs-layout'>)</span>
<a name="line-2112"></a>  <span class='hs-keyword'>where</span>
<a name="line-2113"></a>    <span class='hs-varid'>refl_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span>
<a name="line-2114"></a>
<a name="line-2115"></a><span class='hs-comment'>{-
<a name="line-2116"></a>Note [Unflatten using funeqs first]
<a name="line-2117"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2118"></a>    [W] G a ~ Int
<a name="line-2119"></a>    [W] F (G a) ~ G a
<a name="line-2120"></a>
<a name="line-2121"></a>do not want to end up with
<a name="line-2122"></a>    [W] F Int ~ Int
<a name="line-2123"></a>because that might actually hold!  Better to end up with the two above
<a name="line-2124"></a>unsolved constraints.  The flat form will be
<a name="line-2125"></a>
<a name="line-2126"></a>    G a ~ fmv1     (CFunEqCan)
<a name="line-2127"></a>    F fmv1 ~ fmv2  (CFunEqCan)
<a name="line-2128"></a>    fmv1 ~ Int     (CTyEqCan)
<a name="line-2129"></a>    fmv1 ~ fmv2    (CTyEqCan)
<a name="line-2130"></a>
<a name="line-2131"></a>Flatten using the fun-eqs first.
<a name="line-2132"></a>-}</span>
<a name="line-2133"></a>
<a name="line-2134"></a><a name="split_pi_tys'"></a><span class='hs-comment'>-- | Like 'splitPiTys'' but comes with a 'Bool' which is 'True' iff there is at</span>
<a name="line-2135"></a><span class='hs-comment'>-- least one named binder.</span>
<a name="line-2136"></a><span class='hs-definition'>split_pi_tys'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyBinder</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span>
<a name="line-2137"></a><span class='hs-definition'>split_pi_tys'</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>split</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>ty</span>
<a name="line-2138"></a>  <span class='hs-keyword'>where</span>
<a name="line-2139"></a>  <span class='hs-varid'>split</span> <span class='hs-varid'>orig_ty</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>coreView</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>split</span> <span class='hs-varid'>orig_ty</span> <span class='hs-varid'>ty'</span>
<a name="line-2140"></a>  <span class='hs-varid'>split</span> <span class='hs-keyword'>_</span>       <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-varid'>b</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>split</span> <span class='hs-varid'>res</span> <span class='hs-varid'>res</span>
<a name="line-2141"></a>                                   <span class='hs-keyword'>in</span>  <span class='hs-layout'>(</span><span class='hs-conid'>Named</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>
<a name="line-2142"></a>  <span class='hs-varid'>split</span> <span class='hs-keyword'>_</span>       <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>named</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>split</span> <span class='hs-varid'>res</span> <span class='hs-varid'>res</span>
<a name="line-2143"></a>                                   <span class='hs-keyword'>in</span>  <span class='hs-layout'>(</span><span class='hs-conid'>Anon</span> <span class='hs-varid'>arg</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>named</span><span class='hs-layout'>)</span>
<a name="line-2144"></a>  <span class='hs-varid'>split</span> <span class='hs-varid'>orig_ty</span> <span class='hs-keyword'>_</span>                <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>orig_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-2145"></a><span class='hs-comment'>{-# INLINE split_pi_tys' #-}</span>
<a name="line-2146"></a>
<a name="line-2147"></a><a name="ty_con_binders_ty_binders'"></a><span class='hs-comment'>-- | Like 'tyConBindersTyBinders' but you also get a 'Bool' which is true iff</span>
<a name="line-2148"></a><span class='hs-comment'>-- there is at least one named binder.</span>
<a name="line-2149"></a><span class='hs-definition'>ty_con_binders_ty_binders'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyConBinder</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyBinder</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span>
<a name="line-2150"></a><span class='hs-definition'>ty_con_binders_ty_binders'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-2151"></a>  <span class='hs-keyword'>where</span>
<a name="line-2152"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TvBndr</span> <span class='hs-varid'>tv</span> <span class='hs-layout'>(</span><span class='hs-conid'>NamedTCB</span> <span class='hs-varid'>vis</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-2153"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Named</span> <span class='hs-layout'>(</span><span class='hs-conid'>TvBndr</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>vis</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>
<a name="line-2154"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TvBndr</span> <span class='hs-varid'>tv</span> <span class='hs-conid'>AnonTCB</span><span class='hs-layout'>)</span>        <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-2155"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Anon</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>   <span class='hs-conop'>:</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-2156"></a>    <span class='hs-comment'>{-# INLINE go #-}</span>
<a name="line-2157"></a><span class='hs-comment'>{-# INLINE ty_con_binders_ty_binders' #-}</span>
</pre></body>
</html>
