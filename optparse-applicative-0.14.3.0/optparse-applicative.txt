-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities and combinators for parsing command line options
--   
--   optparse-applicative is a haskell library for parsing options on the
--   command line, providing a powerful applicative interface for composing
--   these options.
--   
--   optparse-applicative takes care of reading and validating the
--   arguments passed to the command line, handling and reporting errors,
--   generating a usage line, a comprehensive help screen, and enabling
--   context-sensitive bash completions.
--   
--   See the included README for detailed instructions and examples, which
--   is also available on github
--   <a>https://github.com/pcapriotti/optparse-applicative</a>.
@package optparse-applicative
@version 0.14.3.0

module Options.Applicative.Help.Levenshtein

-- | Calculate the Damerau-Levenshtein edit distance between two lists
--   (strings).
--   
--   This is modified from <a>https://wiki.haskell.org/Edit_distance</a>
--   and is originally from Lloyd Allison's paper "Lazy Dynamic-Programming
--   can be Eager"
--   
--   It's been changed though from Levenshtein to Damerau-Levenshtein,
--   which treats transposition of adjacent characters as one change
--   instead of two.
editDistance :: Eq a => [a] -> [a] -> Int

module Options.Applicative.Help.Pretty

-- | <tt>(hPutDoc handle doc)</tt> pretty prints document <tt>doc</tt> to
--   the file handle <tt>handle</tt> with a page width of 80 characters and
--   a ribbon width of 32 characters.
--   
--   <pre>
--   main = do{ handle &lt;- openFile "MyFile" WriteMode
--            ; hPutDoc handle (vcat (map text
--                              ["vertical","text"]))
--            ; hClose handle
--            }
--   </pre>
--   
--   Any ANSI colorisation in <tt>doc</tt> will be output.
hPutDoc :: Handle -> Doc -> IO ()

-- | The action <tt>(putDoc doc)</tt> pretty prints document <tt>doc</tt>
--   to the standard output, with a page width of 80 characters and a
--   ribbon width of 32 characters.
--   
--   <pre>
--   main :: IO ()
--   main = do{ putDoc (text "hello" &lt;+&gt; text "world") }
--   </pre>
--   
--   Which would output
--   
--   <pre>
--   hello world
--   </pre>
--   
--   Any ANSI colorisation in <tt>doc</tt> will be output.
putDoc :: Doc -> IO ()

-- | <tt>(displayIO handle simpleDoc)</tt> writes <tt>simpleDoc</tt> to the
--   file handle <tt>handle</tt>. This function is used for example by
--   <a>hPutDoc</a>:
--   
--   <pre>
--   hPutDoc handle doc  = displayIO handle (renderPretty 0.4 80 doc)
--   </pre>
--   
--   Any ANSI colorisation in <tt>simpleDoc</tt> will be output.
displayIO :: Handle -> SimpleDoc -> IO ()

-- | <tt>(displayS simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a <a>ShowS</a> type (for use
--   in the <a>Show</a> class).
--   
--   <pre>
--   showWidth :: Int -&gt; Doc -&gt; String
--   showWidth w x   = displayS (renderPretty 0.4 w x) ""
--   </pre>
--   
--   ANSI color information will be discarded by this function unless you
--   are running on a Unix-like operating system. This is due to a
--   technical limitation in Windows ANSI support.
displayS :: SimpleDoc -> ShowS

-- | <tt>(renderCompact x)</tt> renders document <tt>x</tt> without adding
--   any indentation. Since no 'pretty' printing is involved, this renderer
--   is very fast. The resulting output contains fewer characters than a
--   pretty printed version and can be used for output that is read by
--   other programs.
--   
--   This rendering function does not add any colorisation information.
renderCompact :: Doc -> SimpleDoc

-- | A slightly smarter rendering algorithm with more lookahead. It
--   provides provide earlier breaking on deeply nested structures For
--   example, consider this python-ish pseudocode:
--   <tt>fun(fun(fun(fun(fun([abcdefg, abcdefg])))))</tt> If we put a
--   softbreak (+ nesting 2) after each open parenthesis, and align the
--   elements of the list to match the opening brackets, this will render
--   with <tt>renderPretty</tt> and a page width of 20 as: <tt>
--   fun(fun(fun(fun(fun([ | abcdef, | abcdef, ] ))))) | </tt> Where the
--   20c. boundary has been marked with |. Because <tt>renderPretty</tt>
--   only uses one-line lookahead, it sees that the first line fits, and is
--   stuck putting the second and third lines after the 20-c mark. In
--   contrast, <tt>renderSmart</tt> will continue to check that the
--   potential document up to the end of the indentation level. Thus, it
--   will format the document as:
--   
--   <pre>
--   fun(                |
--     fun(              |
--       fun(            |
--         fun(          |
--           fun([       |
--                 abcdef,
--                 abcdef,
--               ]       |
--     )))))             |
--   </pre>
--   
--   Which fits within the 20c. boundary.
renderSmart :: Float -> Int -> Doc -> SimpleDoc

-- | This is the default pretty printer which is used by <a>show</a>,
--   <a>putDoc</a> and <a>hPutDoc</a>. <tt>(renderPretty ribbonfrac width
--   x)</tt> renders document <tt>x</tt> with a page width of
--   <tt>width</tt> and a ribbon width of <tt>(ribbonfrac * width)</tt>
--   characters. The ribbon width is the maximal amount of non-indentation
--   characters on a line. The parameter <tt>ribbonfrac</tt> should be
--   between <tt>0.0</tt> and <tt>1.0</tt>. If it is lower or higher, the
--   ribbon width will be 0 or <tt>width</tt> respectively.
renderPretty :: Float -> Int -> Doc -> SimpleDoc

-- | Removes all colorisation, emboldening and underlining from a document
plain :: Doc -> Doc

-- | Displays a document with no underlining
deunderline :: Doc -> Doc

-- | Displays a document with underlining
underline :: Doc -> Doc

-- | Displays a document in the normal font weight
debold :: Doc -> Doc

-- | Displays a document in a heavier font weight
bold :: Doc -> Doc

-- | Displays a document with the dull white backcolor
ondullwhite :: Doc -> Doc

-- | Displays a document with the white backcolor
onwhite :: Doc -> Doc

-- | Displays a document with the dull cyan backcolor
ondullcyan :: Doc -> Doc

-- | Displays a document with the cyan backcolor
oncyan :: Doc -> Doc

-- | Displays a document with the dull magenta backcolor
ondullmagenta :: Doc -> Doc

-- | Displays a document with the magenta backcolor
onmagenta :: Doc -> Doc

-- | Displays a document with the dull blue backcolor
ondullblue :: Doc -> Doc

-- | Displays a document with the blue backcolor
onblue :: Doc -> Doc

-- | Displays a document with the dull yellow backcolor
ondullyellow :: Doc -> Doc

-- | Displays a document with the yellow backcolor
onyellow :: Doc -> Doc

-- | Displays a document with the dull green backcolor
ondullgreen :: Doc -> Doc

-- | Displays a document with the green backcolor
ongreen :: Doc -> Doc

-- | Displays a document with the dull red backcolor
ondullred :: Doc -> Doc

-- | Displays a document with the red backcolor
onred :: Doc -> Doc

-- | Displays a document with the dull black backcolor
ondullblack :: Doc -> Doc

-- | Displays a document with the black backcolor
onblack :: Doc -> Doc

-- | Displays a document with the dull white forecolor
dullwhite :: Doc -> Doc

-- | Displays a document with the white forecolor
white :: Doc -> Doc

-- | Displays a document with the dull cyan forecolor
dullcyan :: Doc -> Doc

-- | Displays a document with the cyan forecolor
cyan :: Doc -> Doc

-- | Displays a document with the dull magenta forecolor
dullmagenta :: Doc -> Doc

-- | Displays a document with the magenta forecolor
magenta :: Doc -> Doc

-- | Displays a document with the dull blue forecolor
dullblue :: Doc -> Doc

-- | Displays a document with the blue forecolor
blue :: Doc -> Doc

-- | Displays a document with the dull yellow forecolor
dullyellow :: Doc -> Doc

-- | Displays a document with the yellow forecolor
yellow :: Doc -> Doc

-- | Displays a document with the dull green forecolor
dullgreen :: Doc -> Doc

-- | Displays a document with the green forecolor
green :: Doc -> Doc

-- | Displays a document with the dull red forecolor
dullred :: Doc -> Doc

-- | Displays a document with the red forecolor
red :: Doc -> Doc

-- | Displays a document with the dull black forecolor
dullblack :: Doc -> Doc

-- | Displays a document with the black forecolor
black :: Doc -> Doc

-- | A document that is normally rendered as the first argument, but when
--   flattened, is rendered as the second document.
flatAlt :: Doc -> Doc -> Doc

-- | The <tt>group</tt> combinator is used to specify alternative layouts.
--   The document <tt>(group x)</tt> undoes all line breaks in document
--   <tt>x</tt>. The resulting line is added to the current line if that
--   fits the page. Otherwise, the document <tt>x</tt> is rendered without
--   any changes.
group :: Doc -> Doc
nesting :: (Int -> Doc) -> Doc
column :: (Int -> Doc) -> Doc

-- | The document <tt>(nest i x)</tt> renders document <tt>x</tt> with the
--   current indentation level increased by i (See also <a>hang</a>,
--   <a>align</a> and <a>indent</a>).
--   
--   <pre>
--   nest 2 (text "hello" &lt;$&gt; text "world") &lt;$&gt; text "!"
--   </pre>
--   
--   outputs as:
--   
--   <pre>
--   hello
--     world
--   !
--   </pre>
nest :: Int -> Doc -> Doc

-- | A linebreak that will never be flattened; it is guaranteed to render
--   as a newline.
hardline :: Doc

-- | The <tt>linebreak</tt> document advances to the next line and indents
--   to the current nesting level. Document <tt>linebreak</tt> behaves like
--   <a>empty</a> if the line break is undone by <a>group</a>.
linebreak :: Doc

-- | The <tt>line</tt> document advances to the next line and indents to
--   the current nesting level. Document <tt>line</tt> behaves like
--   <tt>(text " ")</tt> if the line break is undone by <a>group</a>.
line :: Doc

-- | The document <tt>(text s)</tt> contains the literal string <tt>s</tt>.
--   The string shouldn't contain any newline (<tt>'\n'</tt>) characters.
--   If the string contains newline characters, the function <a>string</a>
--   should be used.
text :: String -> Doc

-- | The document <tt>(char c)</tt> contains the literal character
--   <tt>c</tt>. The character shouldn't be a newline (<tt>'\n'</tt>), the
--   function <a>line</a> should be used for line breaks.
char :: Char -> Doc

-- | The empty document is, indeed, empty. Although <tt>empty</tt> has no
--   content, it does have a 'height' of 1 and behaves exactly like
--   <tt>(text "")</tt> (and is therefore not a unit of
--   <tt>&lt;$&gt;</tt>).
empty :: Doc

-- | The document <tt>(align x)</tt> renders document <tt>x</tt> with the
--   nesting level set to the current column. It is used for example to
--   implement <a>hang</a>.
--   
--   As an example, we will put a document right above another one,
--   regardless of the current nesting level:
--   
--   <pre>
--   x $$ y  = align (x &lt;$&gt; y)
--   </pre>
--   
--   <pre>
--   test    = text "hi" &lt;+&gt; (text "nice" $$ text "world")
--   </pre>
--   
--   which will be layed out as:
--   
--   <pre>
--   hi nice
--      world
--   </pre>
align :: Doc -> Doc

-- | The hang combinator implements hanging indentation. The document
--   <tt>(hang i x)</tt> renders document <tt>x</tt> with a nesting level
--   set to the current column plus <tt>i</tt>. The following example uses
--   hanging indentation for some text:
--   
--   <pre>
--   test  = hang 4 (fillSep (map text
--           (words "the hang combinator indents these words !")))
--   </pre>
--   
--   Which lays out on a page with a width of 20 characters as:
--   
--   <pre>
--   the hang combinator
--       indents these
--       words !
--   </pre>
--   
--   The <tt>hang</tt> combinator is implemented as:
--   
--   <pre>
--   hang i x  = align (nest i x)
--   </pre>
hang :: Int -> Doc -> Doc

-- | The document <tt>(indent i x)</tt> indents document <tt>x</tt> with
--   <tt>i</tt> spaces.
--   
--   <pre>
--   test  = indent 4 (fillSep (map text
--           (words "the indent combinator indents these words !")))
--   </pre>
--   
--   Which lays out with a page width of 20 as:
--   
--   <pre>
--   the indent
--   combinator
--   indents these
--   words !
--   </pre>
indent :: Int -> Doc -> Doc
width :: Doc -> (Int -> Doc) -> Doc

-- | The document <tt>(fill i x)</tt> renders document <tt>x</tt>. It than
--   appends <tt>space</tt>s until the width is equal to <tt>i</tt>. If the
--   width of <tt>x</tt> is already larger, nothing is appended. This
--   combinator is quite useful in practice to output a list of bindings.
--   The following example demonstrates this.
--   
--   <pre>
--   types  = [("empty","Doc")
--            ,("nest","Int -&gt; Doc -&gt; Doc")
--            ,("linebreak","Doc")]
--   
--   ptype (name,tp)
--          = fill 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   
--   test   = text "let" &lt;+&gt; align (vcat (map ptype types))
--   </pre>
--   
--   Which is layed out as:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak :: Doc
--   </pre>
fill :: Int -> Doc -> Doc

-- | The document <tt>(fillBreak i x)</tt> first renders document
--   <tt>x</tt>. It than appends <tt>space</tt>s until the width is equal
--   to <tt>i</tt>. If the width of <tt>x</tt> is already larger than
--   <tt>i</tt>, the nesting level is increased by <tt>i</tt> and a
--   <tt>line</tt> is appended. When we redefine <tt>ptype</tt> in the
--   previous example to use <tt>fillBreak</tt>, we get a useful variation
--   of the previous output:
--   
--   <pre>
--   ptype (name,tp)
--          = fillBreak 6 (text name) &lt;+&gt; text "::" &lt;+&gt; text tp
--   </pre>
--   
--   The output will now be:
--   
--   <pre>
--   let empty  :: Doc
--       nest   :: Int -&gt; Doc -&gt; Doc
--       linebreak
--              :: Doc
--   </pre>
fillBreak :: Int -> Doc -> Doc

-- | The document <tt>(rational r)</tt> shows the literal rational
--   <tt>r</tt> using <a>text</a>.
rational :: Rational -> Doc

-- | The document <tt>(double d)</tt> shows the literal double <tt>d</tt>
--   using <a>text</a>.
double :: Double -> Doc

-- | The document <tt>(float f)</tt> shows the literal float <tt>f</tt>
--   using <a>text</a>.
float :: Float -> Doc

-- | The document <tt>(integer i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
integer :: Integer -> Doc

-- | The document <tt>(int i)</tt> shows the literal integer <tt>i</tt>
--   using <a>text</a>.
int :: Int -> Doc

-- | The document <tt>(bool b)</tt> shows the literal bool <tt>b</tt> using
--   <a>text</a>.
bool :: Bool -> Doc

-- | The document <tt>(string s)</tt> concatenates all characters in
--   <tt>s</tt> using <tt>line</tt> for newline characters and
--   <tt>char</tt> for all other characters. It is used instead of
--   <a>text</a> whenever the text contains newline characters.
string :: String -> Doc

-- | The document <tt>equals</tt> contains an equal sign, "=".
equals :: Doc

-- | The document <tt>backslash</tt> contains a back slash, "\".
backslash :: Doc

-- | The document <tt>dot</tt> contains a single dot, ".".
dot :: Doc

-- | The document <tt>space</tt> contains a single space, " ".
--   
--   <pre>
--   x &lt;+&gt; y   = x &lt;&gt; space &lt;&gt; y
--   </pre>
space :: Doc

-- | The document <tt>comma</tt> contains a comma, ",".
comma :: Doc

-- | The document <tt>colon</tt> contains a colon, ":".
colon :: Doc

-- | The document <tt>semi</tt> contains a semicolon, ";".
semi :: Doc

-- | The document <tt>dquote</tt> contains a double quote, '"'.
dquote :: Doc

-- | The document <tt>squote</tt> contains a single quote, "'".
squote :: Doc

-- | The document <tt>rbracket</tt> contains a right square bracket, "]".
rbracket :: Doc

-- | The document <tt>lbracket</tt> contains a left square bracket, "[".
lbracket :: Doc

-- | The document <tt>rbrace</tt> contains a right brace, "}".
rbrace :: Doc

-- | The document <tt>lbrace</tt> contains a left brace, "{".
lbrace :: Doc

-- | The document <tt>rangle</tt> contains a right angle, "&gt;".
rangle :: Doc

-- | The document <tt>langle</tt> contains a left angle, "&lt;".
langle :: Doc

-- | The document <tt>rparen</tt> contains a right parenthesis, ")".
rparen :: Doc

-- | The document <tt>lparen</tt> contains a left parenthesis, "(".
lparen :: Doc

-- | The document <tt>(enclose l r x)</tt> encloses document <tt>x</tt>
--   between documents <tt>l</tt> and <tt>r</tt> using <tt>(&lt;&gt;)</tt>.
--   
--   <pre>
--   enclose l r x   = l &lt;&gt; x &lt;&gt; r
--   </pre>
enclose :: Doc -> Doc -> Doc -> Doc

-- | Document <tt>(brackets x)</tt> encloses document <tt>x</tt> in square
--   brackets, "[" and "]".
brackets :: Doc -> Doc

-- | Document <tt>(angles x)</tt> encloses document <tt>x</tt> in angles,
--   "&lt;" and "&gt;".
angles :: Doc -> Doc

-- | Document <tt>(parens x)</tt> encloses document <tt>x</tt> in
--   parenthesis, "(" and ")".
parens :: Doc -> Doc

-- | Document <tt>(braces x)</tt> encloses document <tt>x</tt> in braces,
--   "{" and "}".
braces :: Doc -> Doc

-- | Document <tt>(dquotes x)</tt> encloses document <tt>x</tt> with double
--   quotes '"'.
dquotes :: Doc -> Doc

-- | Document <tt>(squotes x)</tt> encloses document <tt>x</tt> with single
--   quotes "'".
squotes :: Doc -> Doc

-- | The document <tt>softbreak</tt> behaves like <a>empty</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softbreak  = group linebreak
--   </pre>
softbreak :: Doc

-- | The document <tt>softline</tt> behaves like <a>space</a> if the
--   resulting output fits the page, otherwise it behaves like <a>line</a>.
--   
--   <pre>
--   softline = group line
--   </pre>
softline :: Doc

-- | The document <tt>(x &lt;$$&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <tt>linebreak</tt> in between.
--   (infixr 5)
(<$$>) :: Doc -> Doc -> Doc
infixr 5 <$$>

-- | The document <tt>(x &lt;//&gt; y)</tt> concatenates document
--   <tt>x</tt> and <tt>y</tt> with a <a>softbreak</a> in between. This
--   effectively puts <tt>x</tt> and <tt>y</tt> either right next to each
--   other or underneath each other. (infixr 5)
(<//>) :: Doc -> Doc -> Doc
infixr 5 <//>

-- | The document <tt>(x &lt;/&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <a>softline</a> in between. This effectively
--   puts <tt>x</tt> and <tt>y</tt> either next to each other (with a
--   <tt>space</tt> in between) or underneath each other. (infixr 5)
(</>) :: Doc -> Doc -> Doc
infixr 5 </>

-- | The document <tt>(x &lt;+&gt; y)</tt> concatenates document <tt>x</tt>
--   and <tt>y</tt> with a <tt>space</tt> in between. (infixr 6)
(<+>) :: Doc -> Doc -> Doc
infixr 6 <+>

-- | The document <tt>(vcat xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vcat</tt>, all documents are directly
--   concatenated.
vcat :: [Doc] -> Doc

-- | The document <tt>(hcat xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt>.
hcat :: [Doc] -> Doc

-- | The document <tt>(fillCat xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;&gt;)</tt> as long as its fits the page,
--   than inserts a <tt>linebreak</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillCat xs  = foldr (&lt;//&gt;) empty xs
--   </pre>
fillCat :: [Doc] -> Doc

-- | The document <tt>(cat xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$$&gt;)</tt>.
--   
--   <pre>
--   cat xs  = group (vcat xs)
--   </pre>
cat :: [Doc] -> Doc

-- | The document <tt>(vsep xs)</tt> concatenates all documents <tt>xs</tt>
--   vertically with <tt>(&lt;$&gt;)</tt>. If a <a>group</a> undoes the
--   line breaks inserted by <tt>vsep</tt>, all documents are separated
--   with a space.
--   
--   <pre>
--   someText = map text (words ("text to lay out"))
--   
--   test     = text "some" &lt;+&gt; vsep someText
--   </pre>
--   
--   This is layed out as:
--   
--   <pre>
--   some text
--   to
--   lay
--   out
--   </pre>
--   
--   The <a>align</a> combinator can be used to align the documents under
--   their first element
--   
--   <pre>
--   test     = text "some" &lt;+&gt; align (vsep someText)
--   </pre>
--   
--   Which is printed as:
--   
--   <pre>
--   some text
--        to
--        lay
--        out
--   </pre>
vsep :: [Doc] -> Doc

-- | The document <tt>(hsep xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt>.
hsep :: [Doc] -> Doc

-- | The document <tt>(fillSep xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt>(&lt;+&gt;)</tt> as long as its fits the page,
--   than inserts a <tt>line</tt> and continues doing that for all
--   documents in <tt>xs</tt>.
--   
--   <pre>
--   fillSep xs  = foldr (&lt;/&gt;) empty xs
--   </pre>
fillSep :: [Doc] -> Doc

-- | The document <tt>(sep xs)</tt> concatenates all documents <tt>xs</tt>
--   either horizontally with <tt>(&lt;+&gt;)</tt>, if it fits the page, or
--   vertically with <tt>(&lt;$&gt;)</tt>.
--   
--   <pre>
--   sep xs  = group (vsep xs)
--   </pre>
sep :: [Doc] -> Doc

-- | <tt>(punctuate p xs)</tt> concatenates all documents in <tt>xs</tt>
--   with document <tt>p</tt> except for the last document.
--   
--   <pre>
--   someText = map text ["words","in","a","tuple"]
--   test     = parens (align (cat (punctuate comma someText)))
--   </pre>
--   
--   This is layed out on a page width of 20 as:
--   
--   <pre>
--   (words,in,a,tuple)
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   (words,
--    in,
--    a,
--    tuple)
--   </pre>
--   
--   (If you want put the commas in front of their elements instead of at
--   the end, you should use <a>tupled</a> or, in general,
--   <a>encloseSep</a>.)
punctuate :: Doc -> [Doc] -> [Doc]

-- | The document <tt>(encloseSep l r sep xs)</tt> concatenates the
--   documents <tt>xs</tt> separated by <tt>sep</tt> and encloses the
--   resulting document by <tt>l</tt> and <tt>r</tt>. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All separators are put in front of the elements.
--   For example, the combinator <a>list</a> can be defined with
--   <tt>encloseSep</tt>:
--   
--   <pre>
--   list xs = encloseSep lbracket rbracket comma xs
--   test    = text "list" &lt;+&gt; (list (map int [10,200,3000]))
--   </pre>
--   
--   Which is layed out with a page width of 20 as:
--   
--   <pre>
--   list [10,200,3000]
--   </pre>
--   
--   But when the page width is 15, it is layed out as:
--   
--   <pre>
--   list [10
--        ,200
--        ,3000]
--   </pre>
encloseSep :: Doc -> Doc -> Doc -> [Doc] -> Doc

-- | The document <tt>(semiBraces xs)</tt> separates the documents
--   <tt>xs</tt> with semicolons and encloses them in braces. The documents
--   are rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All semicolons are put in front of the elements.
semiBraces :: [Doc] -> Doc

-- | The document <tt>(tupled xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in parenthesis. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
tupled :: [Doc] -> Doc

-- | The document <tt>(list xs)</tt> comma separates the documents
--   <tt>xs</tt> and encloses them in square brackets. The documents are
--   rendered horizontally if that fits the page. Otherwise they are
--   aligned vertically. All comma separators are put in front of the
--   elements.
list :: [Doc] -> Doc

-- | The member <tt>prettyList</tt> is only used to define the <tt>instance
--   Pretty a =&gt; Pretty [a]</tt>. In normal circumstances only the
--   <tt>pretty</tt> function is used.
class Pretty a
pretty :: Pretty a => a -> Doc
prettyList :: Pretty a => [a] -> Doc

-- | The abstract data type <tt>Doc</tt> represents pretty documents.
--   
--   More specifically, a value of type <tt>Doc</tt> represents a non-empty
--   set of possible renderings of a document. The rendering functions
--   select one of these possibilities.
--   
--   <tt>Doc</tt> is an instance of the <a>Show</a> class. <tt>(show
--   doc)</tt> pretty prints document <tt>doc</tt> with a page width of 80
--   characters and a ribbon width of 32 characters.
--   
--   <pre>
--   show (text "hello" &lt;$&gt; text "world")
--   </pre>
--   
--   Which would return the string "hello\nworld", i.e.
--   
--   <pre>
--   hello
--   world
--   </pre>
data Doc

-- | The data type <tt>SimpleDoc</tt> represents rendered documents and is
--   used by the display functions.
--   
--   Whereas values of the data type <a>Doc</a> represent non-empty sets of
--   possible renderings of a document, values of the data type
--   <tt>SimpleDoc</tt> represent single renderings of a document.
--   
--   The <tt>Int</tt> in <tt>SText</tt> contains the length of the string.
--   The <tt>Int</tt> in <tt>SLine</tt> contains the indentation for that
--   line. The library provides two default display functions
--   <a>displayS</a> and <a>displayIO</a>. You can provide your own display
--   function by writing a function from a <tt>SimpleDoc</tt> to your own
--   output format.
data SimpleDoc
SFail :: SimpleDoc
SEmpty :: SimpleDoc
SChar :: Char -> SimpleDoc -> SimpleDoc
SText :: !Int -> String -> SimpleDoc -> SimpleDoc
SLine :: !Int -> SimpleDoc -> SimpleDoc
SSGR :: [SGR] -> SimpleDoc -> SimpleDoc
(.$.) :: Doc -> Doc -> Doc

module Options.Applicative.Help.Chunk
mappendWith :: Monoid a => a -> a -> a -> a

-- | The free monoid on a semigroup <tt>a</tt>.
newtype Chunk a
Chunk :: Maybe a -> Chunk a
[unChunk] :: Chunk a -> Maybe a

-- | Given a semigroup structure on <tt>a</tt>, return a monoid structure
--   on 'Chunk a'.
--   
--   Note that this is <i>not</i> the same as <a>liftA2</a>.
chunked :: (a -> a -> a) -> Chunk a -> Chunk a -> Chunk a

-- | Concatenate a list into a Chunk. <a>listToChunk</a> satisfies:
--   
--   <pre>
--   isEmpty . listToChunk = null
--   listToChunk = mconcat . fmap pure
--   </pre>
listToChunk :: Monoid a => [a] -> Chunk a

-- | Concatenate two <a>Chunk</a>s with a space in between. If one is
--   empty, this just returns the other one.
--   
--   Unlike <a>&lt;+&gt;</a> for <a>Doc</a>, this operation has a unit
--   element, namely the empty <a>Chunk</a>.
(<<+>>) :: Chunk Doc -> Chunk Doc -> Chunk Doc

-- | Concatenate two <a>Chunk</a>s with a softline in between. This is
--   exactly like <a>&lt;&lt;+&gt;&gt;</a>, but uses a softline instead of
--   a space.
(<</>>) :: Chunk Doc -> Chunk Doc -> Chunk Doc

-- | Concatenate <a>Chunk</a>s vertically.
vcatChunks :: [Chunk Doc] -> Chunk Doc

-- | Concatenate <a>Chunk</a>s vertically separated by empty lines.
vsepChunks :: [Chunk Doc] -> Chunk Doc

-- | Whether a <a>Chunk</a> is empty. Note that something like 'pure
--   mempty' is not considered an empty chunk, even though the underlying
--   <a>Doc</a> is empty.
isEmpty :: Chunk a -> Bool

-- | Convert a <a>String</a> into a <a>Chunk</a>. This satisfies:
--   
--   <pre>
--   isEmpty . stringChunk = null
--   extractChunk . stringChunk = string
--   </pre>
stringChunk :: String -> Chunk Doc

-- | Convert a paragraph into a <a>Chunk</a>. The resulting chunk is
--   composed by the words of the original paragraph separated by
--   softlines, so it will be automatically word-wrapped when rendering the
--   underlying document.
--   
--   This satisfies:
--   
--   <pre>
--   isEmpty . paragraph = null . words
--   </pre>
paragraph :: String -> Chunk Doc

-- | Part of a constrained comonad instance.
--   
--   This is the counit of the adjunction between <a>Chunk</a> and the
--   forgetful functor from monoids to semigroups. It satisfies:
--   
--   <pre>
--   extractChunk . pure = id
--   extractChunk . fmap pure = id
--   </pre>
extractChunk :: Monoid a => Chunk a -> a

-- | Display pairs of strings in a table.
tabulate :: [(Doc, Doc)] -> Chunk Doc
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Base.Functor Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Applicative Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Alternative Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Monad Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Monoid a => GHC.Base.Semigroup (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Base.MonadPlus Options.Applicative.Help.Chunk.Chunk

module Options.Applicative.Help.Types
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc

-- | Convert a help text to <a>String</a>.
renderHelp :: Int -> ParserHelp -> String
instance GHC.Show.Show Options.Applicative.Help.Types.ParserHelp
instance GHC.Base.Monoid Options.Applicative.Help.Types.ParserHelp
instance GHC.Base.Semigroup Options.Applicative.Help.Types.ParserHelp

module Options.Applicative.Types
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default: True)
[prefBacktrack] :: ParserPrefs -> Bool

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int

-- | A single option of a parser.
data Option a
Option :: OptReader a -> OptProperties -> Option a

-- | reader for this option
[optMain] :: Option a -> OptReader a

-- | properties of this option
[optProps] :: Option a -> OptProperties
data OptName
OptShort :: !Char -> OptName
OptLong :: !String -> OptName

-- | An <a>OptReader</a> defines whether an option matches an command line
--   argument.
data OptReader a

-- | option reader
OptReader :: [OptName] -> CReader a -> (String -> ParseError) -> OptReader a

-- | flag reader
FlagReader :: [OptName] -> !a -> OptReader a

-- | argument reader
ArgReader :: CReader a -> OptReader a

-- | command reader
CmdReader :: Maybe String -> [String] -> (String -> Maybe (ParserInfo a)) -> OptReader a

-- | Specification for an individual parser option.
data OptProperties
OptProperties :: OptVisibility -> Chunk Doc -> String -> Maybe String -> Maybe (Doc -> Doc) -> OptProperties

-- | whether this flag is shown is the brief description
[propVisibility] :: OptProperties -> OptVisibility

-- | help text for this option
[propHelp] :: OptProperties -> Chunk Doc

-- | metavariable for this option
[propMetaVar] :: OptProperties -> String

-- | what to show in the help text as the default
[propShowDefault] :: OptProperties -> Maybe String

-- | a function to run over the brief description
[propDescMod] :: OptProperties -> Maybe (Doc -> Doc)

-- | Visibility of an option in the help text.
data OptVisibility

-- | does not appear in the help text at all
Internal :: OptVisibility

-- | only visible in the full description
Hidden :: OptVisibility

-- | visible both in the full and brief descriptions
Visible :: OptVisibility

-- | A newtype over 'ReaderT String Except', used by option readers.
newtype ReadM a
ReadM :: ReaderT String (Except ParseError) a -> ReadM a
[unReadM] :: ReadM a -> ReaderT String (Except ParseError) a

-- | Return the value being read.
readerAsk :: ReadM String

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a
data CReader a
CReader :: Completer -> ReadM a -> CReader a
[crCompleter] :: CReader a -> Completer
[crReader] :: CReader a -> ReadM a

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a
NilP :: Maybe a -> Parser a
OptP :: Option a -> Parser a
MultP :: Parser (x -> a) -> Parser x -> Parser a
AltP :: Parser a -> Parser a -> Parser a
BindP :: Parser x -> (x -> Parser a) -> Parser a
newtype ParserM r
ParserM :: (forall x. (r -> Parser x) -> Parser x) -> ParserM r
[runParserM] :: ParserM r -> forall x. (r -> Parser x) -> Parser x

-- | A shell complete function.
newtype Completer
Completer :: (String -> IO [String]) -> Completer
[runCompleter] :: Completer -> String -> IO [String]

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: ParserFailure ParserHelp -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a
type Args = [String]

-- | Policy for how to handle options within the parse
data ArgPolicy

-- | The default policy, options and arguments can be interspersed. A `--`
--   option can be passed to ensure all following commands are treated as
--   arguments.
Intersperse :: ArgPolicy

-- | Options must all come before arguments, once a single positional
--   argument or subcommand is parsed, all remaining arguments are treated
--   as positionals. A `--` option can be passed if the first positional
--   one needs starts with <a>-</a>.
NoIntersperse :: ArgPolicy

-- | No options are parsed at all, all arguments are treated as
--   positionals. Is the policy used after `--` is encountered.
AllPositionals :: ArgPolicy

-- | Options and arguments can be interspersed, but if a given option is
--   not found, it is treated as a positional argument. This is sometimes
--   useful if one is passing through most options to another tool, but are
--   supplying just a few of their own options.
ForwardOptions :: ArgPolicy
data OptHelpInfo
OptHelpInfo :: Bool -> Bool -> Bool -> OptHelpInfo

-- | Whether this is part of a many or some (approximately)
[hinfoMulti] :: OptHelpInfo -> Bool

-- | Whether this option has a default value
[hinfoDefault] :: OptHelpInfo -> Bool

-- | If the result is a positional, if it can't be accessed in the current
--   parser position ( first arg )
[hinfoUnreachableArgs] :: OptHelpInfo -> Bool
data OptTree a
Leaf :: a -> OptTree a
MultNode :: [OptTree a] -> OptTree a
AltNode :: [OptTree a] -> OptTree a
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
data SomeParser
SomeParser :: Parser a -> SomeParser

-- | Subparser context, containing the <tt>name</tt> of the subparser, and
--   its parser info. Used by parserFailure to display relevant usage
--   information when parsing inside a subparser fails.
data Context
Context :: String -> ParserInfo a -> Context
data IsCmdStart
CmdStart :: IsCmdStart
CmdCont :: IsCmdStart
fromM :: ParserM a -> Parser a
oneM :: Parser a -> ParserM a
manyM :: Parser a -> ParserM [a]
someM :: Parser a -> ParserM [a]
optVisibility :: Option a -> OptVisibility
optMetaVar :: Option a -> String
optHelp :: Option a -> Chunk Doc
optShowDefault :: Option a -> Maybe String
optDescMod :: Option a -> Maybe (Doc -> Doc)
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Types.OptTree a)
instance GHC.Show.Show Options.Applicative.Types.OptHelpInfo
instance GHC.Classes.Eq Options.Applicative.Types.OptHelpInfo
instance GHC.Show.Show Options.Applicative.Types.ArgPolicy
instance GHC.Classes.Ord Options.Applicative.Types.ArgPolicy
instance GHC.Classes.Eq Options.Applicative.Types.ArgPolicy
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Types.ParserResult a)
instance GHC.Show.Show Options.Applicative.Types.OptVisibility
instance GHC.Classes.Ord Options.Applicative.Types.OptVisibility
instance GHC.Classes.Eq Options.Applicative.Types.OptVisibility
instance GHC.Show.Show Options.Applicative.Types.OptName
instance GHC.Classes.Ord Options.Applicative.Types.OptName
instance GHC.Classes.Eq Options.Applicative.Types.OptName
instance GHC.Show.Show Options.Applicative.Types.ParserPrefs
instance GHC.Classes.Eq Options.Applicative.Types.ParserPrefs
instance GHC.Show.Show Options.Applicative.Types.IsCmdStart
instance GHC.Base.Monad Options.Applicative.Types.ParserM
instance GHC.Base.Functor Options.Applicative.Types.ParserM
instance GHC.Base.Applicative Options.Applicative.Types.ParserM
instance GHC.Base.Monoid Options.Applicative.Types.ParseError
instance GHC.Base.Semigroup Options.Applicative.Types.ParseError
instance GHC.Base.Functor Options.Applicative.Types.ParserInfo
instance GHC.Show.Show (Options.Applicative.Types.Option a)
instance GHC.Base.Functor Options.Applicative.Types.Option
instance GHC.Base.Functor Options.Applicative.Types.ReadM
instance GHC.Base.Applicative Options.Applicative.Types.ReadM
instance GHC.Base.Alternative Options.Applicative.Types.ReadM
instance GHC.Base.Monad Options.Applicative.Types.ReadM
instance Control.Monad.Fail.MonadFail Options.Applicative.Types.ReadM
instance GHC.Base.MonadPlus Options.Applicative.Types.ReadM
instance GHC.Base.Functor Options.Applicative.Types.CReader
instance GHC.Base.Functor Options.Applicative.Types.OptReader
instance GHC.Base.Functor Options.Applicative.Types.Parser
instance GHC.Base.Applicative Options.Applicative.Types.Parser
instance GHC.Base.Alternative Options.Applicative.Types.Parser
instance GHC.Base.Functor Options.Applicative.Types.ParserResult
instance GHC.Base.Applicative Options.Applicative.Types.ParserResult
instance GHC.Base.Monad Options.Applicative.Types.ParserResult
instance GHC.Show.Show h => GHC.Show.Show (Options.Applicative.Types.ParserFailure h)
instance GHC.Base.Functor Options.Applicative.Types.ParserFailure
instance GHC.Show.Show Options.Applicative.Types.CompletionResult
instance GHC.Base.Semigroup Options.Applicative.Types.Completer
instance GHC.Base.Monoid Options.Applicative.Types.Completer
instance GHC.Show.Show Options.Applicative.Types.OptProperties

module Options.Applicative.Internal
data P a
class (Alternative m, MonadPlus m) => MonadP m
enterContext :: MonadP m => String -> ParserInfo a -> m ()
exitContext :: MonadP m => m ()
getPrefs :: MonadP m => m ParserPrefs
missingArgP :: MonadP m => ParseError -> Completer -> m a
errorP :: MonadP m => ParseError -> m a
exitP :: MonadP m => IsCmdStart -> ArgPolicy -> Parser b -> Maybe a -> m a
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError
uncons :: [a] -> Maybe (a, [a])
hoistMaybe :: MonadPlus m => Maybe a -> m a
hoistEither :: MonadP m => Either ParseError a -> m a
runReadM :: MonadP m => ReadM a -> String -> m a
withReadM :: (String -> String) -> ReadM a -> ReadM a
runP :: P a -> ParserPrefs -> (Either ParseError a, [Context])
data Completion a
runCompletion :: Completion r -> ParserPrefs -> Maybe (Either (SomeParser, ArgPolicy) Completer)
contextNames :: [Context] -> [String]
data ListT m a
takeListT :: Monad m => Int -> ListT m a -> ListT m a
runListT :: Monad m => ListT m a -> m [a]
data NondetT m a
cut :: Monad m => NondetT m ()
(<!>) :: Monad m => NondetT m a -> NondetT m a -> NondetT m a
disamb :: Monad m => Bool -> NondetT m a -> m (Maybe a)
instance GHC.Base.Monad m => GHC.Base.Functor (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Options.Applicative.Internal.NondetT m)
instance Control.Monad.Trans.Class.MonadTrans Options.Applicative.Internal.NondetT
instance GHC.Base.Monad m => GHC.Base.Functor (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Options.Applicative.Internal.ListT m)
instance Control.Monad.Trans.Class.MonadTrans Options.Applicative.Internal.ListT
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Options.Applicative.Internal.ListT m)
instance GHC.Base.Functor Options.Applicative.Internal.Completion
instance GHC.Base.Applicative Options.Applicative.Internal.Completion
instance GHC.Base.Alternative Options.Applicative.Internal.Completion
instance GHC.Base.Monad Options.Applicative.Internal.Completion
instance GHC.Base.MonadPlus Options.Applicative.Internal.Completion
instance Options.Applicative.Internal.MonadP Options.Applicative.Internal.Completion
instance GHC.Base.Functor Options.Applicative.Internal.ComplResult
instance GHC.Base.Applicative Options.Applicative.Internal.ComplResult
instance GHC.Base.Monad Options.Applicative.Internal.ComplResult
instance GHC.Base.Functor Options.Applicative.Internal.P
instance GHC.Base.Applicative Options.Applicative.Internal.P
instance GHC.Base.Alternative Options.Applicative.Internal.P
instance GHC.Base.Monad Options.Applicative.Internal.P
instance GHC.Base.MonadPlus Options.Applicative.Internal.P
instance Options.Applicative.Internal.MonadP Options.Applicative.Internal.P

module Options.Applicative.Common

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a

-- | Create a parser composed of a single option.
liftOpt :: Option a -> Parser a
showOption :: OptName -> String

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default: True)
[prefBacktrack] :: ParserPrefs -> Bool

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int
runParserInfo :: MonadP m => ParserInfo a -> Args -> m a
runParserFully :: MonadP m => ArgPolicy -> Parser a -> Args -> m a

-- | Apply a <a>Parser</a> to a command line, and return a result and
--   leftover arguments. This function returns an error if any parsing
--   error occurs, or if any options are missing and don't have a default
--   value.
runParser :: MonadP m => ArgPolicy -> IsCmdStart -> Parser a -> Args -> m (a, Args)

-- | The default value of a <a>Parser</a>. This function returns an error
--   if any of the options don't have a default value.
evalParser :: Parser a -> Maybe a

-- | Map a polymorphic function over all the options of a parser, and
--   collect the results in a list.
mapParser :: (forall x. OptHelpInfo -> Option x -> b) -> Parser a -> [b]

-- | Like <a>mapParser</a>, but collect the results in a tree structure.
treeMapParser :: (forall x. OptHelpInfo -> Option x -> b) -> Parser a -> OptTree b
optionNames :: OptReader a -> [OptName]

module Options.Applicative.Help.Core

-- | Generate descriptions for commands.
cmdDesc :: Parser a -> [(Maybe String, Chunk Doc)]

-- | Generate a brief help text for a parser.
briefDesc :: ParserPrefs -> Parser a -> Chunk Doc

-- | Generate a brief help text for a parser, only including mandatory
--   options and arguments.
missingDesc :: ParserPrefs -> Parser a -> Chunk Doc
fold_tree :: OptTree (Chunk Doc) -> Chunk Doc

-- | Generate a full help text for a parser.
fullDesc :: ParserPrefs -> Parser a -> Chunk Doc
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
errorHelp :: Chunk Doc -> ParserHelp
headerHelp :: Chunk Doc -> ParserHelp
suggestionsHelp :: Chunk Doc -> ParserHelp
usageHelp :: Chunk Doc -> ParserHelp
bodyHelp :: Chunk Doc -> ParserHelp
footerHelp :: Chunk Doc -> ParserHelp

-- | Generate the help text for a program.
parserHelp :: ParserPrefs -> Parser a -> ParserHelp

-- | Generate option summary.
parserUsage :: ParserPrefs -> Parser a -> String -> Doc

module Options.Applicative.Help

module Options.Applicative.Builder.Internal

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a
Mod :: (f a -> f a) -> DefaultProp a -> (OptProperties -> OptProperties) -> Mod f a
class HasName f
name :: HasName f => OptName -> f a -> f a
class HasCompleter f
modCompleter :: HasCompleter f => (Completer -> Completer) -> f a -> f a
class HasValue f
hasValueDummy :: HasValue f => f a -> ()
class HasMetavar f
hasMetavarDummy :: HasMetavar f => f a -> ()
data OptionFields a
OptionFields :: [OptName] -> Completer -> (String -> ParseError) -> OptionFields a
[optNames] :: OptionFields a -> [OptName]
[optCompleter] :: OptionFields a -> Completer
[optNoArgError] :: OptionFields a -> String -> ParseError
data FlagFields a
FlagFields :: [OptName] -> a -> FlagFields a
[flagNames] :: FlagFields a -> [OptName]
[flagActive] :: FlagFields a -> a
data CommandFields a
CommandFields :: [(String, ParserInfo a)] -> Maybe String -> CommandFields a
[cmdCommands] :: CommandFields a -> [(String, ParserInfo a)]
[cmdGroup] :: CommandFields a -> Maybe String
data ArgumentFields a
ArgumentFields :: Completer -> ArgumentFields a
[argCompleter] :: ArgumentFields a -> Completer
data DefaultProp a
DefaultProp :: Maybe a -> Maybe (a -> String) -> DefaultProp a
optionMod :: (OptProperties -> OptProperties) -> Mod f a
fieldMod :: (f a -> f a) -> Mod f a

-- | Base default properties.
baseProps :: OptProperties
mkCommand :: Mod CommandFields a -> (Maybe String, [String], String -> Maybe (ParserInfo a))
mkParser :: DefaultProp a -> (OptProperties -> OptProperties) -> OptReader a -> Parser a
mkOption :: DefaultProp a -> (OptProperties -> OptProperties) -> OptReader a -> Option a
mkProps :: DefaultProp a -> (OptProperties -> OptProperties) -> OptProperties

-- | Hide this option from the help text
internal :: Mod f a
instance GHC.Base.Monoid (Options.Applicative.Builder.Internal.Mod f a)
instance GHC.Base.Semigroup (Options.Applicative.Builder.Internal.Mod f a)
instance GHC.Base.Monoid (Options.Applicative.Builder.Internal.DefaultProp a)
instance GHC.Base.Semigroup (Options.Applicative.Builder.Internal.DefaultProp a)
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.CommandFields
instance Options.Applicative.Builder.Internal.HasValue Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasValue Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasCompleter Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasCompleter Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasName Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasName Options.Applicative.Builder.Internal.FlagFields

module Options.Applicative.Builder.Completer

-- | A shell complete function.
data Completer

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer

-- | Create a <a>Completer</a> from an IO action
listIOCompleter :: IO [String] -> Completer

-- | Create a <a>Completer</a> from a constant list of strings.
listCompleter :: [String] -> Completer

-- | Run a compgen completion action.
--   
--   Common actions include <tt>file</tt> and <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
bashCompleter :: String -> Completer

module Options.Applicative.Builder

-- | Builder for a command parser. The <a>command</a> modifier can be used
--   to specify individual commands.
subparser :: Mod CommandFields a -> Parser a

-- | Builder for a <a>String</a> argument.
strArgument :: IsString s => Mod ArgumentFields s -> Parser s

-- | Builder for an argument parser.
argument :: ReadM a -> Mod ArgumentFields a -> Parser a

-- | Builder for a flag parser.
--   
--   A flag that switches from a "default value" to an "active value" when
--   encountered. For a simple boolean value, use <a>switch</a> instead.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
flag :: a -> a -> Mod FlagFields a -> Parser a

-- | Builder for a flag parser without a default value.
--   
--   Same as <a>flag</a>, but with no default value. In particular, this
--   flag will never parse successfully by itself.
--   
--   It still makes sense to use it as part of a composite parser. For
--   example
--   
--   <pre>
--   length &lt;$&gt; many (flag' () (short 't'))
--   </pre>
--   
--   is a parser that counts the number of "-t" arguments on the command
--   line, alternatively
--   
--   <pre>
--   flag' True (long "on") &lt;|&gt; flag' False (long "off")
--   </pre>
--   
--   will require the user to enter '--on' or '--off' on the command line.
flag' :: a -> Mod FlagFields a -> Parser a

-- | Builder for a boolean flag.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
--   
--   <pre>
--   switch = flag False True
--   </pre>
switch :: Mod FlagFields Bool -> Parser Bool

-- | An option that always fails.
--   
--   When this option is encountered, the option parser immediately aborts
--   with the given parse error. If you simply want to output a message,
--   use <a>infoOption</a> instead.
abortOption :: ParseError -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | An option that always fails and displays a message.
infoOption :: String -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | Builder for an option taking a <a>String</a> argument.
strOption :: IsString s => Mod OptionFields s -> Parser s

-- | Builder for an option using the given reader.
--   
--   This is a regular option, and should always have either a
--   <tt>long</tt> or <tt>short</tt> name specified in the modifiers (or
--   both).
--   
--   <pre>
--   nameParser = option str ( long "name" &lt;&gt; short 'n' )
--   </pre>
option :: ReadM a -> Mod OptionFields a -> Parser a

-- | Same as <a>option</a>.

-- | <i>Deprecated: Use <a>option</a> instead</i>
nullOption :: ReadM a -> Mod OptionFields a -> Parser a

-- | Specify a short name for an option.
short :: HasName f => Char -> Mod f a

-- | Specify a long name for an option.
long :: HasName f => String -> Mod f a

-- | Specify the help text for an option.
help :: String -> Mod f a

-- | Specify the help text for an option as a <a>Doc</a> value.
helpDoc :: Maybe Doc -> Mod f a

-- | Specify a default value for an option.
--   
--   <i>Note</i>: Because this modifier means the parser will never fail,
--   do not use it with combinators such as <a>some</a> or <a>many</a>, as
--   these combinators continue until a failure occurs. Careless use will
--   thus result in a hang.
--   
--   To display the default value, combine with showDefault or
--   showDefaultWith.
value :: HasValue f => a -> Mod f a

-- | Specify a function to show the default value for an option.
showDefaultWith :: (a -> String) -> Mod f a

-- | Show the default value for this option using its <a>Show</a> instance.
showDefault :: Show a => Mod f a

-- | Specify a metavariable for the argument.
--   
--   Metavariables have no effect on the actual parser, and only serve to
--   specify the symbolic name for an argument to be displayed in the help
--   text.
metavar :: HasMetavar f => String -> Mod f a

-- | Specify the error to display when no argument is provided to this
--   option.
noArgError :: ParseError -> Mod OptionFields a
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError

-- | Hide this option from the brief description.
hidden :: Mod f a

-- | Hide this option from the help text
internal :: Mod f a

-- | Apply a function to the option description in the usage text.
--   
--   <pre>
--   import Options.Applicative.Help
--   flag' () (short 't' &lt;&gt; style bold)
--   </pre>
--   
--   <i>NOTE</i>: This builder is more flexible than its name and example
--   allude. One of the motivating examples for its addition was to used
--   <a>const</a> to completely replace the usage text of an option.
style :: (Doc -> Doc) -> Mod f a

-- | Add a command to a subparser option.
--   
--   Suggested usage for multiple commands is to add them to a single
--   subparser. e.g.
--   
--   <pre>
--   sample :: Parser Sample
--   sample = subparser
--          ( command "hello"
--            (info hello (progDesc "Print greeting"))
--         &lt;&gt; command "goodbye"
--            (info goodbye (progDesc "Say goodbye"))
--          )
--   </pre>
command :: String -> ParserInfo a -> Mod CommandFields a

-- | Add a description to a group of commands.
--   
--   Advanced feature for separating logical groups of commands on the
--   parse line.
--   
--   If using the same <a>metavar</a> for each group of commands, it may
--   yield a more attractive usage text combined with <a>hidden</a> for
--   some groups.
commandGroup :: String -> Mod CommandFields a

-- | Add a list of possible completion values.
completeWith :: HasCompleter f => [String] -> Mod f a

-- | Add a bash completion action. Common actions include <tt>file</tt> and
--   <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
action :: HasCompleter f => String -> Mod f a

-- | Add a completer to an argument.
--   
--   A completer is a function String -&gt; IO String which, given a
--   partial argument, returns all possible completions for that argument.
completer :: HasCompleter f => Completer -> Mod f a

-- | Trivial option modifier.
idm :: Monoid m => m

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | <a>Option</a> reader based on the <a>Read</a> type class.
auto :: Read a => ReadM a

-- | String <a>Option</a> reader.
--   
--   Polymorphic over the <a>IsString</a> type class since 0.14.
str :: IsString s => ReadM s

-- | Convert a function producing a <a>Maybe</a> into a reader.
maybeReader :: (String -> Maybe a) -> ReadM a

-- | Convert a function producing an <a>Either</a> into a reader.
--   
--   As an example, one can create a ReadM from an attoparsec Parser easily
--   with
--   
--   <pre>
--   import qualified Data.Attoparsec.Text as A
--   import qualified Data.Text as T
--   attoparsecReader :: A.Parser a -&gt; ReadM a
--   attoparsecReader p = eitherReader (A.parseOnly p . T.pack)
--   </pre>
eitherReader :: (String -> Either String a) -> ReadM a

-- | Null <a>Option</a> reader. All arguments will fail validation.
disabled :: ReadM a

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a

-- | Modifier for <a>ParserInfo</a>.
data InfoMod a

-- | Show a full description in the help text of this parser.
fullDesc :: InfoMod a

-- | Only show a brief description in the help text of this parser.
briefDesc :: InfoMod a

-- | Specify a header for this parser.
header :: String -> InfoMod a

-- | Specify a header for this parser as a <a>Doc</a> value.
headerDoc :: Maybe Doc -> InfoMod a

-- | Specify a footer for this parser.
footer :: String -> InfoMod a

-- | Specify a footer for this parser as a <a>Doc</a> value.
footerDoc :: Maybe Doc -> InfoMod a

-- | Specify a short program description.
progDesc :: String -> InfoMod a

-- | Specify a short program description as a <a>Doc</a> value.
progDescDoc :: Maybe Doc -> InfoMod a

-- | Specify an exit code if a parse error occurs.
failureCode :: Int -> InfoMod a

-- | Disable parsing of regular options after arguments. After a positional
--   argument is parsed, all remaining options and arguments will be
--   treated as a positional arguments. Not recommended in general as users
--   often expect to be able to freely intersperse regular options and
--   flags within command line options.
noIntersperse :: InfoMod a

-- | Intersperse matched options and arguments normally, but allow
--   unmatched options to be treated as positional arguments. This is
--   sometimes useful if one is wrapping a third party cli tool and needs
--   to pass options through, while also providing a handful of their own
--   options. Not recommended in general as typos by the user may not yield
--   a parse error and cause confusion.
forwardOptions :: InfoMod a

-- | Create a <a>ParserInfo</a> given a <a>Parser</a> and a modifier.
info :: Parser a -> InfoMod a -> ParserInfo a
data PrefsMod

-- | Include a suffix to attach to the metavar when multiple values can be
--   entered.
multiSuffix :: String -> PrefsMod

-- | Turn on disambiguation.
--   
--   See
--   <a>https://github.com/pcapriotti/optparse-applicative#disambiguation</a>
disambiguate :: PrefsMod

-- | Show full help text on any error.
showHelpOnError :: PrefsMod

-- | Show the help text if the user enters only the program name or
--   subcommand.
--   
--   This will suppress a "Missing:" error and show the full usage instead
--   if a user just types the name of the program.
showHelpOnEmpty :: PrefsMod

-- | Turn off backtracking after subcommand is parsed.
noBacktrack :: PrefsMod

-- | Set the maximum width of the generated help text.
columns :: Int -> PrefsMod

-- | Create a <a>ParserPrefs</a> given a modifier
prefs :: PrefsMod -> ParserPrefs

-- | Default preferences.
defaultPrefs :: ParserPrefs

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a

-- | A newtype over 'ReaderT String Except', used by option readers.
data ReadM a
data OptionFields a
data FlagFields a
data ArgumentFields a
data CommandFields a
class HasName f
class HasCompleter f
class HasValue f
class HasMetavar f
instance GHC.Base.Monoid Options.Applicative.Builder.PrefsMod
instance GHC.Base.Semigroup Options.Applicative.Builder.PrefsMod
instance GHC.Base.Monoid (Options.Applicative.Builder.InfoMod a)
instance GHC.Base.Semigroup (Options.Applicative.Builder.InfoMod a)


-- | You don't need to import this module to enable bash completion.
--   
--   See <a>the wiki</a> for more information on bash completion.
module Options.Applicative.BashCompletion
bashCompletionParser :: ParserInfo a -> ParserPrefs -> Parser CompletionResult
instance GHC.Show.Show Options.Applicative.BashCompletion.Richness
instance GHC.Classes.Ord Options.Applicative.BashCompletion.Richness
instance GHC.Classes.Eq Options.Applicative.BashCompletion.Richness

module Options.Applicative.Extra

-- | A hidden "helper" option which always fails.
--   
--   A common usage pattern is to apply this applicatively when creating a
--   <a>ParserInfo</a>
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; helper) mempty
--   </pre>
helper :: Parser (a -> a)

-- | Builder for a command parser with a "helper" option attached. Used in
--   the same way as <a>subparser</a>, but includes a "--help|-h" inside
--   the subcommand.
hsubparser :: Mod CommandFields a -> Parser a

-- | Run a program description.
--   
--   Parse command line arguments. Display help text and exit if any parse
--   error occurs.
execParser :: ParserInfo a -> IO a

-- | Run a program description in pure code.
--   
--   This function behaves like <a>execParser</a>, but can be called from
--   pure code. Note that, in case of errors, no message is displayed, and
--   this function simply returns <a>Nothing</a>.
--   
--   If you need to keep track of error messages, use <a>execParserPure</a>
--   instead.

-- | <i>Deprecated: Use execParserPure together with getParseResult
--   instead</i>
execParserMaybe :: ParserInfo a -> [String] -> Maybe a

-- | Run a program description with custom preferences.
customExecParser :: ParserPrefs -> ParserInfo a -> IO a

-- | Run a program description with custom preferences in pure code.
--   
--   See <a>execParserMaybe</a> for details.

-- | <i>Deprecated: Use execParserPure together with getParseResult
--   instead</i>
customExecParserMaybe :: ParserPrefs -> ParserInfo a -> [String] -> Maybe a

-- | The most general way to run a program description in pure code.
execParserPure :: ParserPrefs -> ParserInfo a -> [String] -> ParserResult a

-- | Extract the actual result from a <a>ParserResult</a> value.
--   
--   This function returns <a>Nothing</a> in case of errors. Possible error
--   messages or completion actions are simply discarded.
--   
--   If you want to display error messages and invoke completion actions
--   appropriately, use <a>handleParseResult</a> instead.
getParseResult :: ParserResult a -> Maybe a

-- | Handle <a>ParserResult</a>.
handleParseResult :: ParserResult a -> IO a

-- | Generate a <a>ParserFailure</a> from a <a>ParseError</a> in a given
--   <a>Context</a>.
--   
--   This function can be used, for example, to show the help text for a
--   parser:
--   
--   <pre>
--   handleParseResult . Failure $ parserFailure pprefs pinfo ShowHelpText mempty
--   </pre>
parserFailure :: ParserPrefs -> ParserInfo a -> ParseError -> [Context] -> ParserFailure ParserHelp
renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: ParserFailure ParserHelp -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default: True)
[prefBacktrack] :: ParserPrefs -> Bool

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String

module Options.Applicative

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a

-- | Builder for a flag parser.
--   
--   A flag that switches from a "default value" to an "active value" when
--   encountered. For a simple boolean value, use <a>switch</a> instead.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
flag :: a -> a -> Mod FlagFields a -> Parser a

-- | Builder for a flag parser without a default value.
--   
--   Same as <a>flag</a>, but with no default value. In particular, this
--   flag will never parse successfully by itself.
--   
--   It still makes sense to use it as part of a composite parser. For
--   example
--   
--   <pre>
--   length &lt;$&gt; many (flag' () (short 't'))
--   </pre>
--   
--   is a parser that counts the number of "-t" arguments on the command
--   line, alternatively
--   
--   <pre>
--   flag' True (long "on") &lt;|&gt; flag' False (long "off")
--   </pre>
--   
--   will require the user to enter '--on' or '--off' on the command line.
flag' :: a -> Mod FlagFields a -> Parser a

-- | Builder for a boolean flag.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
--   
--   <pre>
--   switch = flag False True
--   </pre>
switch :: Mod FlagFields Bool -> Parser Bool

-- | Builder for an option taking a <a>String</a> argument.
strOption :: IsString s => Mod OptionFields s -> Parser s

-- | Builder for an option using the given reader.
--   
--   This is a regular option, and should always have either a
--   <tt>long</tt> or <tt>short</tt> name specified in the modifiers (or
--   both).
--   
--   <pre>
--   nameParser = option str ( long "name" &lt;&gt; short 'n' )
--   </pre>
option :: ReadM a -> Mod OptionFields a -> Parser a

-- | Builder for a <a>String</a> argument.
strArgument :: IsString s => Mod ArgumentFields s -> Parser s

-- | Builder for an argument parser.
argument :: ReadM a -> Mod ArgumentFields a -> Parser a

-- | Builder for a command parser. The <a>command</a> modifier can be used
--   to specify individual commands.
subparser :: Mod CommandFields a -> Parser a

-- | Builder for a command parser with a "helper" option attached. Used in
--   the same way as <a>subparser</a>, but includes a "--help|-h" inside
--   the subcommand.
hsubparser :: Mod CommandFields a -> Parser a

-- | An option that always fails.
--   
--   When this option is encountered, the option parser immediately aborts
--   with the given parse error. If you simply want to output a message,
--   use <a>infoOption</a> instead.
abortOption :: ParseError -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | An option that always fails and displays a message.
infoOption :: String -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | A hidden "helper" option which always fails.
--   
--   A common usage pattern is to apply this applicatively when creating a
--   <a>ParserInfo</a>
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; helper) mempty
--   </pre>
helper :: Parser (a -> a)

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a

-- | Specify a short name for an option.
short :: HasName f => Char -> Mod f a

-- | Specify a long name for an option.
long :: HasName f => String -> Mod f a

-- | Specify the help text for an option.
help :: String -> Mod f a

-- | Specify the help text for an option as a <a>Doc</a> value.
helpDoc :: Maybe Doc -> Mod f a

-- | Specify a default value for an option.
--   
--   <i>Note</i>: Because this modifier means the parser will never fail,
--   do not use it with combinators such as <a>some</a> or <a>many</a>, as
--   these combinators continue until a failure occurs. Careless use will
--   thus result in a hang.
--   
--   To display the default value, combine with showDefault or
--   showDefaultWith.
value :: HasValue f => a -> Mod f a

-- | Specify a function to show the default value for an option.
showDefaultWith :: (a -> String) -> Mod f a

-- | Show the default value for this option using its <a>Show</a> instance.
showDefault :: Show a => Mod f a

-- | Specify a metavariable for the argument.
--   
--   Metavariables have no effect on the actual parser, and only serve to
--   specify the symbolic name for an argument to be displayed in the help
--   text.
metavar :: HasMetavar f => String -> Mod f a

-- | Specify the error to display when no argument is provided to this
--   option.
noArgError :: ParseError -> Mod OptionFields a

-- | Hide this option from the brief description.
hidden :: Mod f a

-- | Hide this option from the help text
internal :: Mod f a

-- | Apply a function to the option description in the usage text.
--   
--   <pre>
--   import Options.Applicative.Help
--   flag' () (short 't' &lt;&gt; style bold)
--   </pre>
--   
--   <i>NOTE</i>: This builder is more flexible than its name and example
--   allude. One of the motivating examples for its addition was to used
--   <a>const</a> to completely replace the usage text of an option.
style :: (Doc -> Doc) -> Mod f a

-- | Add a command to a subparser option.
--   
--   Suggested usage for multiple commands is to add them to a single
--   subparser. e.g.
--   
--   <pre>
--   sample :: Parser Sample
--   sample = subparser
--          ( command "hello"
--            (info hello (progDesc "Print greeting"))
--         &lt;&gt; command "goodbye"
--            (info goodbye (progDesc "Say goodbye"))
--          )
--   </pre>
command :: String -> ParserInfo a -> Mod CommandFields a

-- | Add a description to a group of commands.
--   
--   Advanced feature for separating logical groups of commands on the
--   parse line.
--   
--   If using the same <a>metavar</a> for each group of commands, it may
--   yield a more attractive usage text combined with <a>hidden</a> for
--   some groups.
commandGroup :: String -> Mod CommandFields a

-- | Add a list of possible completion values.
completeWith :: HasCompleter f => [String] -> Mod f a

-- | Add a bash completion action. Common actions include <tt>file</tt> and
--   <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
action :: HasCompleter f => String -> Mod f a

-- | Add a completer to an argument.
--   
--   A completer is a function String -&gt; IO String which, given a
--   partial argument, returns all possible completions for that argument.
completer :: HasCompleter f => Completer -> Mod f a

-- | Trivial option modifier.
idm :: Monoid m => m

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a
data OptionFields a
data FlagFields a
data ArgumentFields a
data CommandFields a
class HasName f
class HasCompleter f
class HasValue f
class HasMetavar f

-- | A newtype over 'ReaderT String Except', used by option readers.
data ReadM a

-- | <a>Option</a> reader based on the <a>Read</a> type class.
auto :: Read a => ReadM a

-- | String <a>Option</a> reader.
--   
--   Polymorphic over the <a>IsString</a> type class since 0.14.
str :: IsString s => ReadM s

-- | Convert a function producing a <a>Maybe</a> into a reader.
maybeReader :: (String -> Maybe a) -> ReadM a

-- | Convert a function producing an <a>Either</a> into a reader.
--   
--   As an example, one can create a ReadM from an attoparsec Parser easily
--   with
--   
--   <pre>
--   import qualified Data.Attoparsec.Text as A
--   import qualified Data.Text as T
--   attoparsecReader :: A.Parser a -&gt; ReadM a
--   attoparsecReader p = eitherReader (A.parseOnly p . T.pack)
--   </pre>
eitherReader :: (String -> Either String a) -> ReadM a

-- | Null <a>Option</a> reader. All arguments will fail validation.
disabled :: ReadM a

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a

-- | Create a <a>ParserInfo</a> given a <a>Parser</a> and a modifier.
info :: Parser a -> InfoMod a -> ParserInfo a

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Modifier for <a>ParserInfo</a>.
data InfoMod a

-- | Show a full description in the help text of this parser.
fullDesc :: InfoMod a

-- | Only show a brief description in the help text of this parser.
briefDesc :: InfoMod a

-- | Specify a header for this parser.
header :: String -> InfoMod a

-- | Specify a header for this parser as a <a>Doc</a> value.
headerDoc :: Maybe Doc -> InfoMod a

-- | Specify a footer for this parser.
footer :: String -> InfoMod a

-- | Specify a footer for this parser as a <a>Doc</a> value.
footerDoc :: Maybe Doc -> InfoMod a

-- | Specify a short program description.
progDesc :: String -> InfoMod a

-- | Specify a short program description as a <a>Doc</a> value.
progDescDoc :: Maybe Doc -> InfoMod a

-- | Specify an exit code if a parse error occurs.
failureCode :: Int -> InfoMod a

-- | Disable parsing of regular options after arguments. After a positional
--   argument is parsed, all remaining options and arguments will be
--   treated as a positional arguments. Not recommended in general as users
--   often expect to be able to freely intersperse regular options and
--   flags within command line options.
noIntersperse :: InfoMod a

-- | Intersperse matched options and arguments normally, but allow
--   unmatched options to be treated as positional arguments. This is
--   sometimes useful if one is wrapping a third party cli tool and needs
--   to pass options through, while also providing a handful of their own
--   options. Not recommended in general as typos by the user may not yield
--   a parse error and cause confusion.
forwardOptions :: InfoMod a

-- | Run a program description.
--   
--   Parse command line arguments. Display help text and exit if any parse
--   error occurs.
execParser :: ParserInfo a -> IO a

-- | Run a program description with custom preferences.
customExecParser :: ParserPrefs -> ParserInfo a -> IO a

-- | The most general way to run a program description in pure code.
execParserPure :: ParserPrefs -> ParserInfo a -> [String] -> ParserResult a

-- | Extract the actual result from a <a>ParserResult</a> value.
--   
--   This function returns <a>Nothing</a> in case of errors. Possible error
--   messages or completion actions are simply discarded.
--   
--   If you want to display error messages and invoke completion actions
--   appropriately, use <a>handleParseResult</a> instead.
getParseResult :: ParserResult a -> Maybe a

-- | Handle <a>ParserResult</a>.
handleParseResult :: ParserResult a -> IO a

-- | Generate a <a>ParserFailure</a> from a <a>ParseError</a> in a given
--   <a>Context</a>.
--   
--   This function can be used, for example, to show the help text for a
--   parser:
--   
--   <pre>
--   handleParseResult . Failure $ parserFailure pprefs pinfo ShowHelpText mempty
--   </pre>
parserFailure :: ParserPrefs -> ParserInfo a -> ParseError -> [Context] -> ParserFailure ParserHelp
renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a

-- | Create a <a>ParserPrefs</a> given a modifier
prefs :: PrefsMod -> ParserPrefs

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default: True)
[prefBacktrack] :: ParserPrefs -> Bool

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int
data PrefsMod

-- | Include a suffix to attach to the metavar when multiple values can be
--   entered.
multiSuffix :: String -> PrefsMod

-- | Turn on disambiguation.
--   
--   See
--   <a>https://github.com/pcapriotti/optparse-applicative#disambiguation</a>
disambiguate :: PrefsMod

-- | Show full help text on any error.
showHelpOnError :: PrefsMod

-- | Show the help text if the user enters only the program name or
--   subcommand.
--   
--   This will suppress a "Missing:" error and show the full usage instead
--   if a user just types the name of the program.
showHelpOnEmpty :: PrefsMod

-- | Turn off backtracking after subcommand is parsed.
noBacktrack :: PrefsMod

-- | Set the maximum width of the generated help text.
columns :: Int -> PrefsMod

-- | Default preferences.
defaultPrefs :: ParserPrefs

-- | A shell complete function.
data Completer

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer

-- | Create a <a>Completer</a> from an IO action
listIOCompleter :: IO [String] -> Completer

-- | Create a <a>Completer</a> from a constant list of strings.
listCompleter :: [String] -> Completer

-- | Run a compgen completion action.
--   
--   Common actions include <tt>file</tt> and <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
bashCompleter :: String -> Completer
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: ParserFailure ParserHelp -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String


-- | This module contains an arrow interface for option parsers, which
--   allows to define and combine parsers using the arrow notation and
--   arrow combinators.
--   
--   The arrow syntax is particularly useful to create parsers of nested
--   structures, or records where the order of fields is different from the
--   order in which the parsers should be applied.
--   
--   For example, an <a>arguments</a> parser often needs to be applied
--   last, and that makes it inconvenient to use it for a field which is
--   not the last one in a record.
--   
--   Using the arrow syntax and the functions in this module, one can
--   write, e.g.:
--   
--   <pre>
--   data Options = Options
--     { optArgs :: [String]
--     , optVerbose :: Bool }
--   
--   opts :: Parser Options
--   opts = runA $ proc () -&gt; do
--     verbose &lt;- asA (switch (short 'v')) -&lt; ()
--     args &lt;- asA (arguments str idm) -&lt; ()
--     returnA -&lt; Options args verbose
--   </pre>
--   
--   Parser arrows, created out of regular <a>Parser</a> values using the
--   <a>asA</a> function, are arrows taking <tt>()</tt> as argument and
--   returning the parsed value.
module Options.Applicative.Arrows

-- | For any <a>Applicative</a> functor <tt>f</tt>, <tt>A f</tt> is the
--   <a>Arrow</a> instance associated to <tt>f</tt>.
--   
--   The <a>A</a> constructor can be used to convert a value of type <tt>f
--   (a -&gt; b)</tt> into an arrow.
newtype A f a b
A :: f (a -> b) -> A f a b
[unA] :: A f a b -> f (a -> b)

-- | Convert a value of type <tt>f a</tt> into an arrow taking <tt>()</tt>
--   as argument.
--   
--   Applied to a value of type <a>Parser</a>, it turns it into an arrow
--   that can be used inside an arrow command, or passed to arrow
--   combinators.
asA :: Applicative f => f a -> A f () a

-- | Convert an arrow back to an applicative value.
--   
--   This function can be used to return a result of type <a>Parser</a>
--   from an arrow command.
runA :: Applicative f => A f () a -> f a

-- | The type of arrows associated to the applicative <a>Parser</a>
--   functor.
type ParserA = A Parser
instance GHC.Base.Applicative f => Control.Category.Category (Options.Applicative.Arrows.A f)
instance GHC.Base.Applicative f => Control.Arrow.Arrow (Options.Applicative.Arrows.A f)
