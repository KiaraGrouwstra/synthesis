-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | typed neural program synthesis
--   
--   code-base for my UvA MSc AI thesis on typed neural program synthesis
@package synthesis
@version 0.0.0

module Synthesis.Configs

-- | max number of levels of nesting for generated types. | high values
--   make for big logs while debugging...
nestLimit :: Int

-- | max number of instantiations to generate for any type containing type
--   variables. | may get less after nub filters out duplicate type
--   instances.
maxInstances :: Int

-- | max number of inputs to generate. | may get less after nub filters out
--   duplicates.
numInputs :: Int

-- | the maximum level of functions to imagine in a wildcard for function
--   generation
maxWildcardDepth :: Int

-- | the maximum number of holes to allow in a generated expression
genMaxHoles :: Int

-- | ratio between the number of samples to use in the training,
--   validation, and test sets, respectively.
split :: (Double, Double, Double)


-- | defined type class instances
module Synthesis.Orphanage
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Exp l)
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Type l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Module l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.ModuleHead l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.ExportSpecList l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.ExportSpec l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.ImportDecl l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.ImportSpecList l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.ImportSpec l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Assoc l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Namespace l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Decl l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.DeclHead l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.InstRule l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.InstHead l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.IPBind l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.InjectivityInfo l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.ResultSig l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.ClassDecl l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.InstDecl l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Deriving l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.DerivStrategy l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.DataOrNew l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.ConDecl l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.FieldDecl l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.QualConDecl l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.GadtDecl l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.BangType l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Unpackedness l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Match l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Rhs l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.GuardedRhs l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Context l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.FunDep l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Asst l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Type l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.TyVarBind l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Promoted l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.TypeEqn l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Exp l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Stmt l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.QualStmt l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.FieldUpdate l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Alt l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.XAttr l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Pat l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.PatField l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.PXAttr l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.RPat l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.RPatOp l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Literal l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.ModuleName l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.QName l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Name l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.QOp l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Op l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.SpecialCon l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.CName l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.IPName l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.XName l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Role l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.MaybePromotedName l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Bracket l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Splice l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Safety l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.CallConv l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.ModulePragma l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.Haskell.Exts.Syntax.Tool
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Overlap l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Rule l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.RuleVar l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Activation l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.Annotation l)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.Haskell.Exts.Syntax.BooleanFormula l)
instance (Data.Text.Prettyprint.Doc.Internal.Pretty k, Data.Text.Prettyprint.Doc.Internal.Pretty v) => Data.Text.Prettyprint.Doc.Internal.Pretty (Data.HashMap.Base.HashMap k v)


-- | utility functions
module Synthesis.Utility

-- | a homogeneous nested list
data Item a
One :: [a] -> Item a
Many :: [Item a] -> Item a

-- | a homogeneous nested tuple
data NestedTuple a
SingleTuple :: (a, a) -> NestedTuple a
DeepTuple :: (a, NestedTuple a) -> NestedTuple a

-- | flatten a nested list
flatten :: Item a -> [a]

-- | randomly pick an item from a list
pick :: [a] -> IO a

-- | map over the keys of a hashmap | deprecated, not in use
mapKeys :: (Hashable k, Eq k, Hashable k_, Eq k_) => (k -> k_) -> HashMap k v -> HashMap k_ v

-- | group a list of k/v pairs by values, essentially inverting the
--   original HashMap
groupByVal :: (Hashable v, Ord v) => [(k, v)] -> HashMap v [k]

-- | create a HashMap by mapping over a list of keys
fromKeys :: (Hashable k, Eq k) => (k -> v) -> [k] -> HashMap k v

-- | create a HashMap by mapping over a list of values | deprecated, not in
--   use
fromVals :: (Hashable k, Eq k) => (v -> k) -> [v] -> HashMap k v

-- | flatten a nested tuple | deprecated, not in use
flattenTuple :: NestedTuple a -> [a]

-- | map over both elements of a tuple | deprecated, not in use
mapTuple :: (a -> b) -> (a, a) -> (b, b)

-- | map over of a 3-element tuple
mapTuple3 :: (a -> b) -> (a, a, a) -> (b, b, b)

-- | convert a list of 3(+) items to a tuple of 3
tuplify3 :: [a] -> (a, a, a)

-- | unpack a tuple into a list
untuple3 :: (a, a, a) -> [a]

-- | while a predicate holds, perform a monadic operation starting from an
--   initial value | deprecated, not in use
while :: Monad m => (a -> Bool) -> (a -> m a) -> a -> m a

-- | shorthand for pretty-printing AST nodes, used for comparisons
pp :: Pretty a => a -> String

-- | shorthand for pretty-printing AST nodes, used in my top-level module
pp_ :: Pretty a => a -> String

-- | pick some keys from a hashmap
pickKeys :: (Hashable k, Eq k) => [k] -> HashMap k v -> HashMap k v

-- | compose two setter functions, as I didn't figure out lenses and their
--   monad instantiations
composeSetters :: (s -> s -> s_) -> (s -> t) -> (t -> b -> s) -> s -> b -> s_

-- | randomly split a dataset into subsets based on the indicated split
--   ratio
randomSplit :: (Double, Double, Double) -> [a] -> ([a], [a], [a])

-- | flip an Ordering | deprecated, not in use
flipOrder :: Ordering -> Ordering

-- | mapped equality check
equating :: Eq a => (b -> a) -> b -> b -> Bool

-- | create a monadic HashMap by mapping over a list of keys
fromKeysM :: (Monad m, Hashable k, Eq k) => (k -> m v) -> [k] -> m (HashMap k v)

-- | create a monadic HashMap by mapping over a list of values
fromValsM :: (Monad m, Hashable k, Eq k) => (v -> m k) -> [v] -> m (HashMap k v)

-- | <a>show</a> drop-in for HashMap with Pretty keys. | deprecated, not in
--   use
ppMap :: (Pretty k, Show v) => HashMap k v -> String

-- | deprecated, not in use
filterHmM :: (Monad m, Hashable k, Eq k) => ((k, v) -> m Bool) -> HashMap k v -> m (HashMap k v)

-- | pick some keys from a hashmap
pickKeysSafe :: (Hashable k, Eq k) => [k] -> HashMap k v -> HashMap k v


-- | utility functions specifically related to types
module Synthesis.Types
type Tp = Type L
type Expr = Exp L
type Hole = SpecialCon L

-- | randomly generate a type TODO: allow generating new type vars
randomType :: Bool -> Bool -> Int -> HashMap String [Tp] -> Int -> IO Tp

-- | randomly generate a function type TODO: ensure each type var is used
--   at least twice
randomFnType :: Bool -> Bool -> Int -> HashMap String [Tp] -> Int -> IO Tp

-- | create a monomorphic type node
tyCon :: String -> Tp

-- | create a polymorphic type node
tyApp :: Tp -> Tp -> Tp

-- | extract the input and output types from a function type | deprecated,
--   not in use TODO: Maybe
fnTypeIO :: Tp -> ([Tp], Tp)

-- | generate a number of concrete types to be used in type variable
--   substitution TODO: move the flatten/nub in
genTypes :: Int -> Int -> IO (Item Tp)

-- | this function takes an explicitly typed hole, returning its type |
--   deprecated, not in use TODO: Maybe
holeType :: Expr -> Tp

-- | create a variable node
var :: String -> Expr

-- | create a type variable node
tyVar :: String -> Tp

-- | create a qname node
qName :: String -> QName L

-- | dummy source span info, because I don't care
l :: L

-- | find the type variables and their occurrences
findTypeVars :: Tp -> HashMap String [Tp]

-- | substitute all type variable occurrences
fillTypeVars :: Tp -> HashMap String Tp -> Tp

-- | star type node: * | deprecated, not in use
star :: Tp

-- | wildcard type node: _
wildcard :: Tp

-- | annotate an expression node with a type signature
expTypeSig :: Expr -> Tp -> Expr

-- | type for a function
tyFun :: Tp -> Tp -> Tp

-- | let-expression
letIn :: HashMap String Expr -> Expr -> Expr

-- | function application
app :: Expr -> Expr -> Expr

-- | parse an expression from a string
parseExpr :: String -> Expr

-- | parse a type from a string
parseType :: String -> Tp

-- | create a typed expression without value, intended for checking types
undef :: Tp -> Expr

-- | tuple of type constraints
cxTuple :: [Asst L] -> Context L

-- | type constraint assertion
classA :: QName L -> [Tp] -> Asst L

-- | type constraint
tyForall :: Maybe [TyVarBind L] -> Maybe (Context L) -> Tp -> Tp
mergeTyVars :: HashMap String [Tp] -> HashMap String [Tp] -> HashMap String [Tp]
unParseResult :: ParseResult a -> Either String a

-- | unit type: ()
unit :: Tp

-- | symbol for use in infix expressions
symbol :: String -> QOp L

-- | variable name as used on the left-hand side of an assignment
pvar :: String -> Pat L

-- | tuple pattern as used on the left-hand side of an assignment
ptuple :: [Pat L] -> Pat L

-- | parenthesized expression
paren :: Expr -> Expr

-- | infix function application
infixApp :: Expr -> QOp L -> Expr -> Expr

-- | $
dollar :: QOp L

-- | .
dot :: QOp L

-- | a list of expressions
list :: [Expr] -> Expr

-- | a tuple of expressions
tuple :: [Expr] -> Expr

-- | Int expression
int :: Integer -> Expr

-- | String expression
string :: String -> Expr

-- | data constructor
con :: String -> Expr

-- | lambda function
lambda :: [Pat L] -> Expr -> Expr

-- | list type
tyList :: Tp -> Tp

-- | extract the input types from a function type
fnInputTypes :: Tp -> [Tp]

-- | check if a type is a function type
isFn :: Tp -> Bool

-- | check if a type contains a function type
hasFn :: Tp -> Bool

-- | filter out duplicate types. note this dedupe will fail for type
--   variable variations...
nubPp :: Pretty a => [a] -> [a]

module Synthesis.Blocks
blockAsts :: HashMap String Expr

-- | building blocks
fnAsts :: HashMap String Expr

-- | non-function blocks
constants :: HashMap String Expr


-- | find holes in an AST
module Synthesis.FindHoles

-- | get the first sub-expression
gtrExpr :: Exp l -> Exp l

-- | set the first sub-expression
strExpr :: Exp l -> Exp l -> Exp l

-- | look for holes in an expression. to simplify extracting type, we will
--   only look for holes as part of an ExpTypeSig, e.g. `_ :: Bool` | I
--   couldn't figure out how to get this to typecheck as a whole lens, so
--   instead I'm taking them as getter/setter pairs...
findHolesExpr :: Exp l1 -> [(Exp l2 -> Exp l2, Exp l3 -> Exp l3 -> Exp l3)]


-- | ast manipulation
module Synthesis.Ast

-- | make a typed hole for a type
skeleton :: Tp -> Expr

-- | check if an expression contains holes
hasHoles :: Expr -> Bool

-- | replace any holes in an expression with undefined, for type-checking
--   purposes
--   
--   hole `_` as an AST Expr
holeExpr :: Expr

-- | number of AST nodes in an Expr
numAstNodes :: Expr -> Int

-- | get the body of a let-in expression
letRes :: Expr -> Expr

-- | generate applied variants of a function, e.g. [<a>id</a>, `id _`]
genBlockVariants :: HashMap String Tp -> [(String, Expr)]

-- | _ :: (_ -&gt; _)
anyFn :: Expr

-- | generate an expression for an n-ary uncurry function, e.g. for n=2: `
--   fn (a, b) -&gt; fn a b`
genUncurry :: Int -> Expr

-- | generate a function type, to then generate functions matching this
--   type | deprecated, not in use
genFnType :: IO Tp

-- | generate a parameter type, to then generate functions taking this
--   input | deprecated, not in use
genFnInType :: IO Tp


-- | utility functions related to the Haskell Interpreter <tt>hint</tt>
module Synthesis.Hint

-- | run an interpreter monad, printing errors, ignoring values |
--   deprecated, replace with <a>interpretUnsafe</a>
runInterpreterMain :: Interpreter () -> IO ()

-- | test an interpreter monad, printing errors, returning values
interpretUnsafe :: Interpreter a -> IO a

-- | run an interpreter monad with imports
interpretSafe :: Interpreter a -> IO (Either InterpreterError a)

-- | print in the Interpreter monad
say :: String -> Interpreter ()

-- | log: debug | deprecated, not in use
debug :: String -> Interpreter ()

-- | log: info | deprecated, not in use
info :: String -> Interpreter ()

-- | log: notice | deprecated, not in use
notice :: String -> Interpreter ()

-- | log: warning
warning :: String -> Interpreter ()

-- | deprecated, not in use
--   
--   log: error
err :: String -> Interpreter ()

-- | log: critical | deprecated, not in use
critical :: String -> Interpreter ()

-- | log: alert | deprecated, not in use
alert :: String -> Interpreter ()

-- | log: emergency | deprecated, not in use
emergency :: String -> Interpreter ()

-- | run-time Language.Haskell.Interpreter compilation error
errorString :: InterpreterError -> String

-- | show a GHC error
showError :: GhcError -> String

-- | interpret a stringified IO command
interpretIO :: String -> Interpreter (Either String String)

-- | get input-output pairs for a function given the inputs (for one
--   concrete input type instantiation). | function application is run
--   trough try-evaluate so as to Either-wrap potential run-time errors for
--   partial functions. | the reason this function needs to be run through
--   the interpreter is I only have the function<i>inputs as
--   AST</i>strings, | meaning I also only know the types at run-time
--   (which is when my programs are constructed).
fnIoPairs :: Int -> Expr -> Expr -> Interpreter String

-- | generate examples given a concrete type | the reason this function
--   needs to be run through the interpreter is Gen wants to know its type
--   at compile-time.
genInputs :: Int -> Tp -> Interpreter [Expr]

-- | get the type of an expression
exprType :: Expr -> Interpreter Tp


-- | generate task functions and sample input/output pairs
module Synthesis.Generation

-- | given sample inputs by type and type instantiations for a function,
--   get its in/out pairs (by type)
fnOutputs :: HashMap Tp [Expr] -> Expr -> [[Tp]] -> Interpreter (HashMap [Tp] String)

-- | generate potential programs filling any holes in a given expression
--   using some building blocks
fillHoles :: Int -> HashMap String Expr -> Set String -> [(String, Expr)] -> Expr -> Interpreter [Expr]

-- | filter building blocks to those matching a hole in the (let-in)
--   expression, and get the results Exprs
fillHole :: HashMap String Expr -> Set String -> [(String, Expr)] -> Expr -> Interpreter ([(Expr, Set String, Expr)], [(Expr, Set String, Expr)])

-- | just directly sample a generated function, and see what types end up
--   coming out.
genFn :: Int -> [(String, Expr)] -> HashMap String Expr -> Interpreter Expr

-- | just directly generate any functions in batch, and see what types end
--   up coming out. | in this approach, further nodes can impose new
--   constraints on the type variables introduced in earlier nodes.
genFns :: Int -> [(String, Expr)] -> HashMap String Expr -> Interpreter [Expr]

-- | generate any combinations of a polymorphic type filled using a list of
--   concrete types
instantiateTypes :: [Tp] -> Tp -> Interpreter [Tp]

-- | instantiate type variables
instantiateTypeVars :: [Tp] -> HashMap String [Tp] -> Interpreter [HashMap String Tp]

-- | check if a type matches the given type constraints. | runs a command
--   like `(undefined :: (Num a, Eq a) =&gt; a -&gt; ()) (undefined ::
--   Bool)`
matchesConstraints :: Tp -> [Tp] -> Interpreter Bool

-- | check if type <tt>a</tt> matches type <tt>b</tt>. | runs a command
--   like `(undefined :: b -&gt; ()) (undefined :: a)`. | without forall `a
--   =&gt;` constraints type variables will always match.
matchesType :: Tp -> Tp -> Interpreter Bool

-- | find how two types relate | deprecated, not in use
typeRelation :: Tp -> Tp -> Interpreter Ordering


-- | main logic
module Synthesis.Program

-- | main function, run program in our interpreter monad
main :: IO ()
