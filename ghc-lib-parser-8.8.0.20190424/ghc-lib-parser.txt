-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The GHC API, decoupled from GHC versions
--   
--   A package equivalent to the <tt>ghc</tt> package, but which can be
--   loaded on many compiler versions.
@package ghc-lib-parser
@version 8.8.0.20190424

module GHC.Exts.Heap.ClosureTypes
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_NOCAF :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
TVAR :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType
SMALL_MUT_ARR_PTRS_CLEAN :: ClosureType
SMALL_MUT_ARR_PTRS_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
COMPACT_NFDATA :: ClosureType
N_CLOSURE_TYPES :: ClosureType

-- | Return the size of the closures header in words
closureTypeHeaderSize :: ClosureType -> Int
instance GHC.Generics.Generic GHC.Exts.Heap.ClosureTypes.ClosureType
instance GHC.Show.Show GHC.Exts.Heap.ClosureTypes.ClosureType
instance GHC.Classes.Ord GHC.Exts.Heap.ClosureTypes.ClosureType
instance GHC.Classes.Eq GHC.Exts.Heap.ClosureTypes.ClosureType
instance GHC.Enum.Enum GHC.Exts.Heap.ClosureTypes.ClosureType

module GHC.Exts.Heap.Constants
wORD_SIZE :: Int
tAG_MASK :: Int
wORD_SIZE_IN_BITS :: Int

module GHC.Exts.Heap.InfoTable.Types

-- | This is a somewhat faithful representation of an info table. See
--   <a>http://ghc.haskell.org/trac/ghc/browser/includes/rts/storage/InfoTables.h</a>
--   for more details on this data structure.
data StgInfoTable
StgInfoTable :: Maybe EntryFunPtr -> HalfWord -> HalfWord -> ClosureType -> HalfWord -> Maybe ItblCodes -> StgInfoTable
[entry] :: StgInfoTable -> Maybe EntryFunPtr
[ptrs] :: StgInfoTable -> HalfWord
[nptrs] :: StgInfoTable -> HalfWord
[tipe] :: StgInfoTable -> ClosureType
[srtlen] :: StgInfoTable -> HalfWord
[code] :: StgInfoTable -> Maybe ItblCodes
type EntryFunPtr = FunPtr (Ptr () -> IO (Ptr ()))
type HalfWord = Word32
type ItblCodes = Either [Word8] [Word32]
instance GHC.Generics.Generic GHC.Exts.Heap.InfoTable.Types.StgInfoTable
instance GHC.Show.Show GHC.Exts.Heap.InfoTable.Types.StgInfoTable

module GHC.Exts.Heap.InfoTable

-- | Size in bytes of a standard InfoTable
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

module GHC.Exts.Heap.InfoTableProf
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

module GHC.Exts.Heap.Closures
type Closure = GenClosure Box

-- | This is the representation of a Haskell value on the heap. It reflects
--   <a>http://ghc.haskell.org/trac/ghc/browser/includes/rts/storage/Closures.h</a>
--   
--   The data type is parametrized by the type to store references in.
--   Usually this is a <a>Box</a> with the type synonym <a>Closure</a>.
--   
--   All Heap objects have the same basic layout. A header containing a
--   pointer to the info table and a payload with various fields. The
--   <tt>info</tt> field below always refers to the info table pointed to
--   by the header. The remaining fields are the payload.
--   
--   See
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects</a>
--   for more information.
data GenClosure b

-- | A data constructor
ConstrClosure :: !StgInfoTable -> ![b] -> ![Word] -> !String -> !String -> !String -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | Package name
[pkg] :: GenClosure b -> !String

-- | Module name
[modl] :: GenClosure b -> !String

-- | Constructor name
[name] :: GenClosure b -> !String

-- | A function
FunClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk, an expression not obviously in head normal form
ThunkClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk which performs a simple selection operation
SelectorClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to the object being selected from
[selectee] :: GenClosure b -> !b

-- | An unsaturated function application
PAPClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A function application
APClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A suspended thunk evaluation
APStackClosure :: !StgInfoTable -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A pointer to another closure, introduced when a thunk is updated to
--   point at its value
IndClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A byte-code object (BCO) which can be interpreted by GHC's byte-code
--   interpreter (e.g. as used by GHCi)
BCOClosure :: !StgInfoTable -> !b -> !b -> !b -> !HalfWord -> !HalfWord -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | A pointer to an ArrWords of instructions
[instrs] :: GenClosure b -> !b

-- | A pointer to an ArrWords of literals
[literals] :: GenClosure b -> !b

-- | A pointer to an ArrWords of byte code objects
[bcoptrs] :: GenClosure b -> !b

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | The size of this BCO in words
[size] :: GenClosure b -> !HalfWord

-- | An StgLargeBitmap describing the pointerhood of its args/free vars
[bitmap] :: GenClosure b -> ![Word]

-- | A thunk under evaluation by another thread
BlackholeClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A <tt>ByteArray#</tt>
ArrWordsClosure :: !StgInfoTable -> !Word -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Size of array in bytes
[bytes] :: GenClosure b -> !Word

-- | Array payload
[arrWords] :: GenClosure b -> ![Word]

-- | A <tt>MutableByteArray#</tt>
MutArrClosure :: !StgInfoTable -> !Word -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | ?? Closures.h vs ClosureMacros.h
[mccSize] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | An <tt>MVar#</tt>, with a queue of thread state objects blocking on
--   them
MVarClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | A <tt>MutVar#</tt>
MutVarClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to contents
[var] :: GenClosure b -> !b

-- | An STM blocking queue.
BlockingQueueClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b

-- | The blackhole closure
[blackHole] :: GenClosure b -> !b

-- | The owning thread state object
[owner] :: GenClosure b -> !b

-- | ??
[queue] :: GenClosure b -> !b

-- | Primitive Int
IntClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[intVal] :: GenClosure b -> !Int

-- | Primitive Word
WordClosure :: PrimType -> !Word -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[wordVal] :: GenClosure b -> !Word

-- | Primitive Int64
Int64Closure :: PrimType -> !Int64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[int64Val] :: GenClosure b -> !Int64

-- | Primitive Word64
Word64Closure :: PrimType -> !Word64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[word64Val] :: GenClosure b -> !Word64

-- | Primitive Addr
AddrClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[addrVal] :: GenClosure b -> !Int

-- | Primitive Float
FloatClosure :: PrimType -> !Float -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[floatVal] :: GenClosure b -> !Float

-- | Primitive Double
DoubleClosure :: PrimType -> !Double -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[doubleVal] :: GenClosure b -> !Double

-- | Another kind of closure
OtherClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[hvalues] :: GenClosure b -> ![b]
[rawWords] :: GenClosure b -> ![Word]
UnsupportedClosure :: !StgInfoTable -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
data PrimType
PInt :: PrimType
PWord :: PrimType
PInt64 :: PrimType
PWord64 :: PrimType
PAddr :: PrimType
PFloat :: PrimType
PDouble :: PrimType

-- | For generic code, this function returns all referenced closures.
allClosures :: GenClosure b -> [b]

-- | An arbitrary Haskell value in a safe Box. The point is that even
--   unevaluated thunks can safely be moved around inside the Box, and when
--   required, e.g. in <tt>getBoxedClosureData</tt>, the function knows how
--   far it has to evaluate the argument.
data Box
Box :: Any -> Box

-- | Boxes can be compared, but this is not pure, as different heap objects
--   can, after garbage collection, become the same object.
areBoxesEqual :: Box -> Box -> IO Bool

-- | This takes an arbitrary value and puts it into a box. Note that calls
--   like
--   
--   <pre>
--   asBox (head list)
--   </pre>
--   
--   will put the thunk "head list" into the box, <i>not</i> the element at
--   the head of the list. For that, use careful case expressions:
--   
--   <pre>
--   case list of x:_ -&gt; asBox x
--   </pre>
asBox :: a -> Box
instance Data.Traversable.Traversable GHC.Exts.Heap.Closures.GenClosure
instance Data.Foldable.Foldable GHC.Exts.Heap.Closures.GenClosure
instance GHC.Base.Functor GHC.Exts.Heap.Closures.GenClosure
instance GHC.Generics.Generic (GHC.Exts.Heap.Closures.GenClosure b)
instance GHC.Show.Show b => GHC.Show.Show (GHC.Exts.Heap.Closures.GenClosure b)
instance GHC.Generics.Generic GHC.Exts.Heap.Closures.PrimType
instance GHC.Show.Show GHC.Exts.Heap.Closures.PrimType
instance GHC.Classes.Eq GHC.Exts.Heap.Closures.PrimType
instance GHC.Show.Show GHC.Exts.Heap.Closures.Box

module GHC.Exts.Heap.Utils
dataConNames :: Ptr StgInfoTable -> IO (String, String, String)


-- | With this module, you can investigate the heap representation of
--   Haskell values, i.e. to investigate sharing and lazy evaluation.
module GHC.Exts.Heap
type Closure = GenClosure Box

-- | This is the representation of a Haskell value on the heap. It reflects
--   <a>http://ghc.haskell.org/trac/ghc/browser/includes/rts/storage/Closures.h</a>
--   
--   The data type is parametrized by the type to store references in.
--   Usually this is a <a>Box</a> with the type synonym <a>Closure</a>.
--   
--   All Heap objects have the same basic layout. A header containing a
--   pointer to the info table and a payload with various fields. The
--   <tt>info</tt> field below always refers to the info table pointed to
--   by the header. The remaining fields are the payload.
--   
--   See
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects</a>
--   for more information.
data GenClosure b

-- | A data constructor
ConstrClosure :: !StgInfoTable -> ![b] -> ![Word] -> !String -> !String -> !String -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | Package name
[pkg] :: GenClosure b -> !String

-- | Module name
[modl] :: GenClosure b -> !String

-- | Constructor name
[name] :: GenClosure b -> !String

-- | A function
FunClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk, an expression not obviously in head normal form
ThunkClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk which performs a simple selection operation
SelectorClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to the object being selected from
[selectee] :: GenClosure b -> !b

-- | An unsaturated function application
PAPClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A function application
APClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A suspended thunk evaluation
APStackClosure :: !StgInfoTable -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A pointer to another closure, introduced when a thunk is updated to
--   point at its value
IndClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A byte-code object (BCO) which can be interpreted by GHC's byte-code
--   interpreter (e.g. as used by GHCi)
BCOClosure :: !StgInfoTable -> !b -> !b -> !b -> !HalfWord -> !HalfWord -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | A pointer to an ArrWords of instructions
[instrs] :: GenClosure b -> !b

-- | A pointer to an ArrWords of literals
[literals] :: GenClosure b -> !b

-- | A pointer to an ArrWords of byte code objects
[bcoptrs] :: GenClosure b -> !b

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | The size of this BCO in words
[size] :: GenClosure b -> !HalfWord

-- | An StgLargeBitmap describing the pointerhood of its args/free vars
[bitmap] :: GenClosure b -> ![Word]

-- | A thunk under evaluation by another thread
BlackholeClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A <tt>ByteArray#</tt>
ArrWordsClosure :: !StgInfoTable -> !Word -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Size of array in bytes
[bytes] :: GenClosure b -> !Word

-- | Array payload
[arrWords] :: GenClosure b -> ![Word]

-- | A <tt>MutableByteArray#</tt>
MutArrClosure :: !StgInfoTable -> !Word -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | ?? Closures.h vs ClosureMacros.h
[mccSize] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | An <tt>MVar#</tt>, with a queue of thread state objects blocking on
--   them
MVarClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | A <tt>MutVar#</tt>
MutVarClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to contents
[var] :: GenClosure b -> !b

-- | An STM blocking queue.
BlockingQueueClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b

-- | The blackhole closure
[blackHole] :: GenClosure b -> !b

-- | The owning thread state object
[owner] :: GenClosure b -> !b

-- | ??
[queue] :: GenClosure b -> !b

-- | Primitive Int
IntClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[intVal] :: GenClosure b -> !Int

-- | Primitive Word
WordClosure :: PrimType -> !Word -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[wordVal] :: GenClosure b -> !Word

-- | Primitive Int64
Int64Closure :: PrimType -> !Int64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[int64Val] :: GenClosure b -> !Int64

-- | Primitive Word64
Word64Closure :: PrimType -> !Word64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[word64Val] :: GenClosure b -> !Word64

-- | Primitive Addr
AddrClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[addrVal] :: GenClosure b -> !Int

-- | Primitive Float
FloatClosure :: PrimType -> !Float -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[floatVal] :: GenClosure b -> !Float

-- | Primitive Double
DoubleClosure :: PrimType -> !Double -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[doubleVal] :: GenClosure b -> !Double

-- | Another kind of closure
OtherClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[hvalues] :: GenClosure b -> ![b]
[rawWords] :: GenClosure b -> ![Word]
UnsupportedClosure :: !StgInfoTable -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_NOCAF :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
TVAR :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType
SMALL_MUT_ARR_PTRS_CLEAN :: ClosureType
SMALL_MUT_ARR_PTRS_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
COMPACT_NFDATA :: ClosureType
N_CLOSURE_TYPES :: ClosureType
data PrimType
PInt :: PrimType
PWord :: PrimType
PInt64 :: PrimType
PWord64 :: PrimType
PAddr :: PrimType
PFloat :: PrimType
PDouble :: PrimType
class HasHeapRep (a :: TYPE rep)
getClosureData :: HasHeapRep a => a -> IO Closure

-- | This is a somewhat faithful representation of an info table. See
--   <a>http://ghc.haskell.org/trac/ghc/browser/includes/rts/storage/InfoTables.h</a>
--   for more details on this data structure.
data StgInfoTable
StgInfoTable :: Maybe EntryFunPtr -> HalfWord -> HalfWord -> ClosureType -> HalfWord -> Maybe ItblCodes -> StgInfoTable
[entry] :: StgInfoTable -> Maybe EntryFunPtr
[ptrs] :: StgInfoTable -> HalfWord
[nptrs] :: StgInfoTable -> HalfWord
[tipe] :: StgInfoTable -> ClosureType
[srtlen] :: StgInfoTable -> HalfWord
[code] :: StgInfoTable -> Maybe ItblCodes
type EntryFunPtr = FunPtr (Ptr () -> IO (Ptr ()))
type HalfWord = Word32
type ItblCodes = Either [Word8] [Word32]

-- | Size in bytes of a standard InfoTable
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

-- | Like <a>getClosureData</a>, but taking a <a>Box</a>, so it is easier
--   to work with.
getBoxedClosureData :: Box -> IO Closure

-- | For generic code, this function returns all referenced closures.
allClosures :: GenClosure b -> [b]

-- | An arbitrary Haskell value in a safe Box. The point is that even
--   unevaluated thunks can safely be moved around inside the Box, and when
--   required, e.g. in <tt>getBoxedClosureData</tt>, the function knows how
--   far it has to evaluate the argument.
data Box
Box :: Any -> Box

-- | This takes an arbitrary value and puts it into a box. Note that calls
--   like
--   
--   <pre>
--   asBox (head list)
--   </pre>
--   
--   will put the thunk "head list" into the box, <i>not</i> the element at
--   the head of the list. For that, use careful case expressions:
--   
--   <pre>
--   case list of x:_ -&gt; asBox x
--   </pre>
asBox :: a -> Box

-- | Boxes can be compared, but this is not pure, as different heap objects
--   can, after garbage collection, become the same object.
areBoxesEqual :: Box -> Box -> IO Bool
instance GHC.Exts.Heap.HasHeapRep a
instance GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Int# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Word# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Int64# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Word64# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Addr# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Float# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Double# Data.Type.Equality.~ a) => GHC.Exts.Heap.HasHeapRep a

module GHC.ForeignSrcLang.Type

-- | Foreign formats supported by GHC via TH
data ForeignSrcLang

-- | C
LangC :: ForeignSrcLang

-- | C++
LangCxx :: ForeignSrcLang

-- | Objective C
LangObjc :: ForeignSrcLang

-- | Objective C++
LangObjcxx :: ForeignSrcLang

-- | Assembly language (.s)
LangAsm :: ForeignSrcLang

-- | Object (.o)
RawObject :: ForeignSrcLang
instance GHC.Generics.Generic GHC.ForeignSrcLang.Type.ForeignSrcLang
instance GHC.Show.Show GHC.ForeignSrcLang.Type.ForeignSrcLang
instance GHC.Classes.Eq GHC.ForeignSrcLang.Type.ForeignSrcLang


-- | See <tt>GHC.LanguageExtensions</tt> for an explanation on why this is
--   needed
module GHC.ForeignSrcLang
instance Data.Binary.Class.Binary GHC.ForeignSrcLang.Type.ForeignSrcLang


-- | A data type defining the language extensions supported by GHC.
module GHC.LanguageExtensions.Type

-- | The language extensions known to GHC.
--   
--   Note that there is an orphan <tt>Binary</tt> instance for this type
--   supplied by the <a>GHC.LanguageExtensions</a> module provided by
--   <tt>ghc-boot</tt>. We can't provide here as this would require adding
--   transitive dependencies to the <tt>template-haskell</tt> package,
--   which must have a minimal dependency set.
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoPatBinds :: Extension
MonoLocalBinds :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
RecordPuns :: Extension
ViewPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
MonadFailDesugaring :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension
instance GHC.Generics.Generic GHC.LanguageExtensions.Type.Extension
instance GHC.Show.Show GHC.LanguageExtensions.Type.Extension
instance GHC.Enum.Enum GHC.LanguageExtensions.Type.Extension
instance GHC.Classes.Eq GHC.LanguageExtensions.Type.Extension


-- | This module re-exports the <a>Extension</a> type along with an orphan
--   <a>Binary</a> instance for it.
--   
--   Note that the <tt>ghc-boot</tt> package has a large set of
--   dependencies; for this reason the <a>Extension</a> type itself is
--   defined in the <a>GHC.LanguageExtensions.Type</a> module provided by
--   the <tt>ghc-boot-th</tt> package, which has no dependencies outside of
--   <tt>base</tt>. For this reason <tt>template-haskell</tt> depends upon
--   <tt>ghc-boot-th</tt>, not <tt>ghc-boot</tt>.
module GHC.LanguageExtensions
instance Data.Binary.Class.Binary GHC.LanguageExtensions.Type.Extension


-- | Functions to evaluate whether or not a string is a valid identifier.
module GHC.Lexeme
startsVarSym :: Char -> Bool
startsVarId :: Char -> Bool
startsConSym :: Char -> Bool
startsConId :: Char -> Bool
startsVarSymASCII :: Char -> Bool
isVarSymChar :: Char -> Bool

-- | Is this character acceptable in a symbol (after the first char)? See
--   alexGetByte in Lexer.x
okSymChar :: Char -> Bool


-- | This module provides the view of GHC's database of registered packages
--   that is shared between GHC the compiler/library, and the ghc-pkg
--   program. It defines the database format that is shared between GHC and
--   ghc-pkg.
--   
--   The database format, and this library are constructed so that GHC does
--   not have to depend on the Cabal library. The ghc-pkg program acts as
--   the gateway between the external package format (which is defined by
--   Cabal) and the internal package format which is specialised just for
--   GHC.
--   
--   GHC the compiler only needs some of the information which is kept
--   about registerd packages, such as module names, various paths etc. On
--   the other hand ghc-pkg has to keep all the information from Cabal
--   packages and be able to regurgitate it for users and other tools.
--   
--   The first trick is that we duplicate some of the information in the
--   package database. We essentially keep two versions of the datbase in
--   one file, one version used only by ghc-pkg which keeps the full
--   information (using the serialised form of the
--   <a>InstalledPackageInfo</a> type defined by the Cabal library); and a
--   second version written by ghc-pkg and read by GHC which has just the
--   subset of information that GHC needs.
--   
--   The second trick is that this module only defines in detail the format
--   of the second version -- the bit GHC uses -- and the part managed by
--   ghc-pkg is kept in the file but here we treat it as an opaque blob of
--   data. That way this library avoids depending on Cabal.
module GHC.PackageDb

-- | This is a subset of Cabal's <a>InstalledPackageInfo</a>, with just the
--   bits that GHC is interested in. See Cabal's documentation for a more
--   detailed description of all of the fields.
data InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod
InstalledPackageInfo :: instunitid -> compid -> [(modulename, mod)] -> srcpkgid -> srcpkgname -> Version -> Maybe srcpkgname -> String -> [instunitid] -> [(instunitid, String)] -> [FilePath] -> [String] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [String] -> [FilePath] -> [String] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [FilePath] -> [(modulename, Maybe mod)] -> [modulename] -> Bool -> Bool -> Bool -> InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod
[unitId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> instunitid
[componentId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> compid
[instantiatedWith] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(modulename, mod)]
[sourcePackageId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> srcpkgid
[packageName] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> srcpkgname
[packageVersion] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Version
[sourceLibName] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Maybe srcpkgname
[abiHash] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> String
[depends] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [instunitid]

-- | Like <a>depends</a>, but each dependency is annotated with the ABI
--   hash we expect the dependency to respect.
[abiDepends] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(instunitid, String)]
[importDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[hsLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[extraLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[extraGHCiLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[libraryDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[libraryDynDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[frameworks] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[frameworkDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[ldOptions] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[ccOptions] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[includes] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[includeDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[haddockInterfaces] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[haddockHTMLs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[exposedModules] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(modulename, Maybe mod)]
[hiddenModules] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [modulename]
[indefinite] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool
[exposed] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool
[trusted] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool

-- | <tt>ghc-boot</tt>'s copy of <tt>Module</tt>, i.e. what is serialized
--   to the database. Use <a>DbUnitIdModuleRep</a> to convert it into an
--   actual <tt>Module</tt>. It has phantom type parameters as this is the
--   most convenient way to avoid undecidable instances.
data DbModule instunitid compid unitid modulename mod
DbModule :: unitid -> modulename -> DbModule instunitid compid unitid modulename mod
[dbModuleUnitId] :: DbModule instunitid compid unitid modulename mod -> unitid
[dbModuleName] :: DbModule instunitid compid unitid modulename mod -> modulename
DbModuleVar :: modulename -> DbModule instunitid compid unitid modulename mod
[dbModuleVarName] :: DbModule instunitid compid unitid modulename mod -> modulename

-- | <tt>ghc-boot</tt>'s copy of <tt>UnitId</tt>, i.e. what is serialized
--   to the database. Use <a>DbUnitIdModuleRep</a> to convert it into an
--   actual <tt>UnitId</tt>. It has phantom type parameters as this is the
--   most convenient way to avoid undecidable instances.
data DbUnitId instunitid compid unitid modulename mod
DbUnitId :: compid -> [(modulename, mod)] -> DbUnitId instunitid compid unitid modulename mod
DbInstalledUnitId :: instunitid -> DbUnitId instunitid compid unitid modulename mod
class BinaryStringRep a
fromStringRep :: BinaryStringRep a => ByteString -> a
toStringRep :: BinaryStringRep a => a -> ByteString

-- | A type-class for the types which can be converted into
--   'DbModule'/'DbUnitId'. There is only one type class because these
--   types are mutually recursive. NB: The functional dependency helps out
--   type inference in cases where types would be ambiguous.
class DbUnitIdModuleRep instunitid compid unitid modulename mod | mod -> unitid, unitid -> mod, mod -> modulename, unitid -> compid, unitid -> instunitid
fromDbModule :: DbUnitIdModuleRep instunitid compid unitid modulename mod => DbModule instunitid compid unitid modulename mod -> mod
toDbModule :: DbUnitIdModuleRep instunitid compid unitid modulename mod => mod -> DbModule instunitid compid unitid modulename mod
fromDbUnitId :: DbUnitIdModuleRep instunitid compid unitid modulename mod => DbUnitId instunitid compid unitid modulename mod -> unitid
toDbUnitId :: DbUnitIdModuleRep instunitid compid unitid modulename mod => unitid -> DbUnitId instunitid compid unitid modulename mod
emptyInstalledPackageInfo :: RepInstalledPackageInfo a b c d e f g => InstalledPackageInfo a b c d e f g

-- | Represents a lock of a package db.
data PackageDbLock

-- | Acquire an exclusive lock related to package DB under given location.
lockPackageDb :: FilePath -> IO PackageDbLock

-- | Release the lock related to package DB.
unlockPackageDb :: PackageDbLock -> IO ()

-- | Mode to open a package db in.
data DbMode
DbReadOnly :: DbMode
DbReadWrite :: DbMode

-- | <a>DbOpenMode</a> holds a value of type <tt>t</tt> but only in
--   <a>DbReadWrite</a> mode. So it is like <a>Maybe</a> but with a type
--   argument for the mode to enforce that the mode is used consistently.
data DbOpenMode (mode :: DbMode) t
[DbOpenReadOnly] :: DbOpenMode  'DbReadOnly t
[DbOpenReadWrite] :: t -> DbOpenMode  'DbReadWrite t
isDbOpenReadMode :: DbOpenMode mode t -> Bool

-- | Read the part of the package DB that GHC is interested in.
readPackageDbForGhc :: RepInstalledPackageInfo a b c d e f g => FilePath -> IO [InstalledPackageInfo a b c d e f g]

-- | Read the part of the package DB that ghc-pkg is interested in
--   
--   Note that the Binary instance for ghc-pkg's representation of packages
--   is not defined in this package. This is because ghc-pkg uses Cabal
--   types (and Binary instances for these) which this package does not
--   depend on.
--   
--   If we open the package db in read only mode, we get its contents.
--   Otherwise we additionally receive a PackageDbLock that represents a
--   lock on the database, so that we can safely update it later.
readPackageDbForGhcPkg :: Binary pkgs => FilePath -> DbOpenMode mode t -> IO (pkgs, DbOpenMode mode PackageDbLock)

-- | Write the whole of the package DB, both parts.
writePackageDb :: (Binary pkgs, RepInstalledPackageInfo a b c d e f g) => FilePath -> [InstalledPackageInfo a b c d e f g] -> pkgs -> IO ()
instance (GHC.Show.Show compid, GHC.Show.Show modulename, GHC.Show.Show mod, GHC.Show.Show instunitid) => GHC.Show.Show (GHC.PackageDb.DbUnitId instunitid compid unitid modulename mod)
instance (GHC.Classes.Eq compid, GHC.Classes.Eq modulename, GHC.Classes.Eq mod, GHC.Classes.Eq instunitid) => GHC.Classes.Eq (GHC.PackageDb.DbUnitId instunitid compid unitid modulename mod)
instance (GHC.Show.Show unitid, GHC.Show.Show modulename) => GHC.Show.Show (GHC.PackageDb.DbModule instunitid compid unitid modulename mod)
instance (GHC.Classes.Eq unitid, GHC.Classes.Eq modulename) => GHC.Classes.Eq (GHC.PackageDb.DbModule instunitid compid unitid modulename mod)
instance (GHC.Show.Show instunitid, GHC.Show.Show compid, GHC.Show.Show modulename, GHC.Show.Show mod, GHC.Show.Show srcpkgid, GHC.Show.Show srcpkgname) => GHC.Show.Show (GHC.PackageDb.InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod)
instance (GHC.Classes.Eq instunitid, GHC.Classes.Eq compid, GHC.Classes.Eq modulename, GHC.Classes.Eq mod, GHC.Classes.Eq srcpkgid, GHC.Classes.Eq srcpkgname) => GHC.Classes.Eq (GHC.PackageDb.InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod)
instance GHC.Base.Functor (GHC.PackageDb.DbOpenMode mode)
instance Data.Foldable.Foldable (GHC.PackageDb.DbOpenMode mode)
instance Data.Traversable.Traversable (GHC.PackageDb.DbOpenMode mode)
instance GHC.PackageDb.RepInstalledPackageInfo a b c d e f g => Data.Binary.Class.Binary (GHC.PackageDb.InstalledPackageInfo a b c d e f g)
instance (GHC.PackageDb.BinaryStringRep modulename, GHC.PackageDb.BinaryStringRep compid, GHC.PackageDb.BinaryStringRep instunitid, GHC.PackageDb.DbUnitIdModuleRep instunitid compid unitid modulename mod) => Data.Binary.Class.Binary (GHC.PackageDb.DbModule instunitid compid unitid modulename mod)
instance (GHC.PackageDb.BinaryStringRep modulename, GHC.PackageDb.BinaryStringRep compid, GHC.PackageDb.BinaryStringRep instunitid, GHC.PackageDb.DbUnitIdModuleRep instunitid compid unitid modulename mod) => Data.Binary.Class.Binary (GHC.PackageDb.DbUnitId instunitid compid unitid modulename mod)

module GHC.Serialized

-- | Represents a serialized value of a particular type. Attempts can be
--   made to deserialize it at certain types
data Serialized
Serialized :: TypeRep -> [Word8] -> Serialized

-- | Put a Typeable value that we are able to actually turn into bytes into
--   a <a>Serialized</a> value ready for deserialization later
toSerialized :: forall a. Typeable a => (a -> [Word8]) -> a -> Serialized

-- | If the <a>Serialized</a> value contains something of the given type,
--   then use the specified deserializer to return <tt>Just</tt> that.
--   Otherwise return <tt>Nothing</tt>.
fromSerialized :: forall a. Typeable a => ([Word8] -> a) -> Serialized -> Maybe a

-- | Use a <a>Data</a> instance to implement a serialization scheme dual to
--   that of <a>deserializeWithData</a>
serializeWithData :: Data a => a -> [Word8]

-- | Use a <a>Data</a> instance to implement a deserialization scheme dual
--   to that of <a>serializeWithData</a>
deserializeWithData :: Data a => [Word8] -> a


-- | Break Arrays
--   
--   An array of bytes, indexed by a breakpoint number (breakpointId in
--   Tickish) There is one of these arrays per module.
--   
--   Each byte is 1 if the corresponding breakpoint is enabled 0 otherwise
module GHCi.BreakArray
data BreakArray
BA :: MutableByteArray# RealWorld -> BreakArray
newBreakArray :: Int -> IO BreakArray
getBreak :: BreakArray -> Int -> IO (Maybe Word8)
setBreakOn :: BreakArray -> Int -> IO Bool
setBreakOff :: BreakArray -> Int -> IO Bool
showBreakArray :: BreakArray -> IO ()

module GHCi.FFI
data FFIType
FFIVoid :: FFIType
FFIPointer :: FFIType
FFIFloat :: FFIType
FFIDouble :: FFIType
FFISInt8 :: FFIType
FFISInt16 :: FFIType
FFISInt32 :: FFIType
FFISInt64 :: FFIType
FFIUInt8 :: FFIType
FFIUInt16 :: FFIType
FFIUInt32 :: FFIType
FFIUInt64 :: FFIType
data FFIConv
FFICCall :: FFIConv
FFIStdCall :: FFIConv
data C_ffi_cif
prepForeignCall :: FFIConv -> [FFIType] -> FFIType -> IO (Ptr C_ffi_cif)
freeForeignCallInfo :: Ptr C_ffi_cif -> IO ()
instance Data.Binary.Class.Binary GHCi.FFI.FFIConv
instance GHC.Generics.Generic GHCi.FFI.FFIConv
instance GHC.Show.Show GHCi.FFI.FFIConv
instance Data.Binary.Class.Binary GHCi.FFI.FFIType
instance GHC.Generics.Generic GHCi.FFI.FFIType
instance GHC.Show.Show GHCi.FFI.FFIType


-- | Types for referring to remote objects in Remote GHCi. For more
--   details, see Note [External GHCi pointers] in
--   compiler<i>ghci</i>GHCi.hs
--   
--   For details on Remote GHCi, see Note [Remote GHCi] in
--   compiler<i>ghci</i>GHCi.hs.
module GHCi.RemoteTypes
newtype RemotePtr a
RemotePtr :: Word64 -> RemotePtr a
toRemotePtr :: Ptr a -> RemotePtr a
fromRemotePtr :: RemotePtr a -> Ptr a
castRemotePtr :: RemotePtr a -> RemotePtr b
newtype HValue
HValue :: Any -> HValue

-- | A reference to a remote value. These are allocated and freed
--   explicitly.
data RemoteRef a

-- | Make a reference to a local value that we can send remotely. This
--   reference will keep the value that it refers to alive until
--   <a>freeRemoteRef</a> is called.
mkRemoteRef :: a -> IO (RemoteRef a)

-- | Convert an HValueRef to an HValue. Should only be used if the HValue
--   originated in this process.
localRef :: RemoteRef a -> IO a

-- | Release an HValueRef that originated in this process
freeRemoteRef :: RemoteRef a -> IO ()
type HValueRef = RemoteRef HValue
toHValueRef :: RemoteRef a -> RemoteRef HValue

-- | An HValueRef with a finalizer
data ForeignRef a

-- | Create a <a>ForeignRef</a> from a <a>RemoteRef</a>. The finalizer
--   should arrange to call <tt>freeHValueRef</tt> on the <a>HValueRef</a>.
--   (since this function needs to be called in the process that created
--   the <a>HValueRef</a>, it cannot be called directly from the
--   finalizer).
mkForeignRef :: RemoteRef a -> IO () -> IO (ForeignRef a)

-- | Use a <a>ForeignHValue</a>
withForeignRef :: ForeignRef a -> (RemoteRef a -> IO b) -> IO b
type ForeignHValue = ForeignRef HValue
unsafeForeignRefToRemoteRef :: ForeignRef a -> RemoteRef a
finalizeForeignRef :: ForeignRef a -> IO ()
instance Data.Binary.Class.Binary (GHCi.RemoteTypes.RemoteRef a)
instance GHC.Show.Show (GHCi.RemoteTypes.RemoteRef a)
instance GHC.Show.Show (GHCi.RemoteTypes.RemotePtr a)
instance Data.Binary.Class.Binary (GHCi.RemoteTypes.RemotePtr a)
instance Control.DeepSeq.NFData (GHCi.RemoteTypes.RemotePtr a)
instance Control.DeepSeq.NFData (GHCi.RemoteTypes.ForeignRef a)
instance GHC.Show.Show GHCi.RemoteTypes.HValue


-- | Custom GHC <a>Prelude</a>
--   
--   This module serves as a replacement for the <a>Prelude</a> module and
--   abstracts over differences between the bootstrapping GHC version, and
--   may also provide a common default vocabulary.
module GhcPrelude

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: () => [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: () => a -> b -> b

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: () => (a -> Bool) -> [a] -> [a]

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
zip :: () => [a] -> [b] -> [(a, b)]

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Extract the first component of a pair.
fst :: () => (a, b) -> a

-- | Extract the second component of a pair.
snd :: () => (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: () => (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>($)</tt> is levity-polymorphic in its result type, so
--   that foo $ True where foo :: Bool -&gt; Int# is well-typed
($) :: () => (a -> b) -> a -> b
infixr 0 $

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   '(+)', '(*)' and <a>exp</a> are customarily expected to define an
--   exponential field and have the following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = @exp a * exp b</li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   '(+)' and '(*)' are customarily expected to define a division ring and
--   have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | fractional division
(/) :: Fractional a => a -> a -> a

-- | reciprocal fraction
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the 'div'/'mod'
--   and 'quot'/'rem' pairs, given suitable Euclidean functions <tt>f</tt>
--   and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (\x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Fail with a message. This operation is not part of the mathematical
--   definition of a monad, but is invoked on pattern-match failure in a
--   <tt>do</tt> expression.
--   
--   As part of the MonadFail proposal (MFP), this function is moved to its
--   own class <tt>MonadFail</tt> (see <a>Control.Monad.Fail</a> for more
--   details). The definition here will be removed in a future release.
fail :: Monad m => String -> m a
infixl 1 >>=
infixl 1 >>

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However, '(+)' and
--   '(*)' are customarily expected to define a ring and have the following
--   properties:
--   
--   <ul>
--   <li><i><b>Associativity of (+)</b></i> <tt>(x + y) + z</tt> = <tt>x +
--   (y + z)</tt></li>
--   <li><i><b>Commutativity of (+)</b></i> <tt>x + y</tt> = <tt>y +
--   x</tt></li>
--   <li><i><b><tt>fromInteger 0</tt> is the additive identity</b></i>
--   <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of (*)</b></i> <tt>(x * y) * z</tt> = <tt>x *
--   (y * z)</tt></li>
--   <li><i><b><tt>fromInteger 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of (*) with respect to (+)</b></i> <tt>a * (b
--   + c)</tt> = <tt>(a * b) + (a * c)</tt> and <tt>(b + c) * a</tt> =
--   <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <tt>Rational</tt> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 +
infixl 7 *
infixl 6 -

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 >
infix 4 <
infix 4 <=

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><tt>uncurry</tt> <a>encodeFloat</a> (<a>decodeFloat</a> x) =
--   x</tt>. <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <tt>&lt;$&gt;</tt> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z <tt>f</tt>
--   x1</tt> in the above example) before applying them to the operator
--   (e.g. to <tt>(<tt>f</tt> x2)</tt>). This results in a thunk chain
--   <tt>O(n)</tt> elements long, which then must be evaluated from the
--   outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>traverse</a> f =
--   <a>traverse</a> (t . f)</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>traverse</a> Identity =
--   Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>traverse</a> (Compose .
--   <a>fmap</a> g . f) = Compose . <a>fmap</a> (<a>traverse</a> g) .
--   <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>sequenceA</a> =
--   <a>sequenceA</a> . <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>sequenceA</a> . <a>fmap</a> Identity
--   = Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>sequenceA</a> . <a>fmap</a>
--   Compose = Compose . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li><pre>t (<a>pure</a> x) = <a>pure</a> x</pre></li>
--   <li><pre>t (x <a>&lt;*&gt;</a> y) = t x <a>&lt;*&gt;</a> t
--   y</pre></li>
--   </ul>
--   
--   and the identity functor <tt>Identity</tt> and composition of functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity a
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Identity where
--     pure x = Identity x
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure x = Compose (pure (pure x))
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> <a>mempty</a> = x</pre></li>
--   <li><pre><a>mempty</a> <a>&lt;&gt;</a> x = x</pre></li>
--   <li><tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a> law)</li>
--   <li><pre><a>mconcat</a> = <a>foldr</a> '(&lt;&gt;)'
--   <a>mempty</a></pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: () => IOError -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <a>fail</a> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <tt>length</tt> function (if we have a <a>String</a>) or the
--   "times-two" function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: () => (a -> c) -> (b -> c) -> Either a b -> c

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: () => Bool -> ReadS a -> ReadS a

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
odd :: Integral a => a -> Bool
even :: Integral a => a -> Bool

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: () => [(a, b, c)] -> ([a], [b], [c])

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: () => [(a, b)] -> ([a], [b])

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: () => (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
zipWith :: () => (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: () => [a] -> [b] -> [c] -> [(a, b, c)]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: () => [a] -> Int -> a
infixl 9 !!

-- | <a>lookup</a> <tt>key assocs</tt> looks up a key in an association
--   list.
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: () => [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: () => (a -> Bool) -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: () => (a -> Bool) -> [a] -> ([a], [a])

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: () => Int -> [a] -> ([a], [a])

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: () => Int -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: () => Int -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: () => (a -> Bool) -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: () => (a -> Bool) -> [a] -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: () => [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: () => Int -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: () => a -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See 'iterate\''
--   for a strict variant of this function.
iterate :: () => (a -> a) -> a -> [a]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: () => (a -> a -> a) -> [a] -> [a]

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: () => (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: () => (a -> a -> a) -> [a] -> [a]

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: () => (b -> a -> b) -> b -> [a] -> [b]

-- | Return all the elements of a list except the last one. The list must
--   be non-empty.
init :: () => [a] -> [a]

-- | Extract the last element of a list, which must be finite and
--   non-empty.
last :: () => [a] -> a

-- | Extract the elements after the head of a list, which must be
--   non-empty.
tail :: () => [a] -> [a]

-- | Extract the first element of a list, which must be non-empty.
head :: () => [a] -> a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <tt>show</tt> to a <tt>Maybe Int</tt>. If we have <tt>Just
--   n</tt>, we want to show the underlying <a>Int</a> <tt>n</tt>. But if
--   we have <a>Nothing</a>, we return the empty string instead of (for
--   example) "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: () => b -> (a -> b) -> Maybe a -> b

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: () => (a -> b -> c) -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: () => ((a, b) -> c) -> a -> b -> c

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: () => a -> a -> a

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: () => (a -> Bool) -> (a -> a) -> a -> a

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: () => (a -> b) -> a -> b
infixr 0 $!

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: () => (a -> b -> c) -> b -> a -> c

-- | Function composition.
(.) :: () => (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: () => a -> b -> a

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: () => a -> a

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: HasCallStack => a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: () => [Char] -> a

-- | <a>error</a> stops execution and displays an error message.
error :: HasCallStack => [Char] -> a

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

module FiniteMap
insertList :: Ord key => [(key, elt)] -> Map key elt -> Map key elt
insertListWith :: Ord key => (elt -> elt -> elt) -> [(key, elt)] -> Map key elt -> Map key elt
deleteList :: Ord key => [key] -> Map key elt -> Map key elt
foldRight :: (elt -> a -> a) -> a -> Map key elt -> a
foldRightWithKey :: (key -> elt -> a -> a) -> a -> Map key elt -> a

module Fingerprint
readHexFingerprint :: String -> Fingerprint
fingerprintByteString :: ByteString -> Fingerprint
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
fingerprint0 :: Fingerprint
fingerprintFingerprints :: [Fingerprint] -> Fingerprint
fingerprintData :: Ptr Word8 -> Int -> IO Fingerprint
fingerprintString :: String -> Fingerprint

-- | Computes the hash of a given file. This function loops over the
--   handle, running in constant memory.
getFileHash :: FilePath -> IO Fingerprint

module FastMutInt
data FastMutInt
newFastMutInt :: IO FastMutInt
readFastMutInt :: FastMutInt -> IO Int
writeFastMutInt :: FastMutInt -> Int -> IO ()
data FastMutPtr
newFastMutPtr :: IO FastMutPtr
readFastMutPtr :: FastMutPtr -> IO (Ptr a)
writeFastMutPtr :: FastMutPtr -> Ptr a -> IO ()

module FastFunctions
inlinePerformIO :: IO a -> a

module Exception

-- | A monad that can catch exceptions. A minimal definition requires a
--   definition of <a>gcatch</a>.
--   
--   Implementations on top of <a>IO</a> should implement <a>gmask</a> to
--   eventually call the primitive <a>mask</a>. These are used for
--   implementations that support asynchronous exceptions. The default
--   implementations of <a>gbracket</a> and <a>gfinally</a> use
--   <a>gmask</a> thus rarely require overriding.
class MonadIO m => ExceptionMonad m

-- | Generalised version of <a>catch</a>, allowing an arbitrary exception
--   handling monad instead of just <a>IO</a>.
gcatch :: (ExceptionMonad m, Exception e) => m a -> (e -> m a) -> m a

-- | Generalised version of <a>mask_</a>, allowing an arbitrary exception
--   handling monad instead of just <a>IO</a>.
gmask :: ExceptionMonad m => ((m a -> m a) -> m b) -> m b

-- | Generalised version of <a>bracket</a>, allowing an arbitrary exception
--   handling monad instead of just <a>IO</a>.
gbracket :: ExceptionMonad m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Generalised version of <a>finally</a>, allowing an arbitrary exception
--   handling monad instead of just <a>IO</a>.
gfinally :: ExceptionMonad m => m a -> m b -> m a
catchIO :: IO a -> (IOException -> IO a) -> IO a
handleIO :: (IOException -> IO a) -> IO a -> IO a
tryIO :: IO a -> IO (Either IOException a)
gtry :: (ExceptionMonad m, Exception e) => m a -> m (Either e a)

-- | Generalised version of <a>handle</a>, allowing an arbitrary exception
--   handling monad instead of just <a>IO</a>.
ghandle :: (ExceptionMonad m, Exception e) => (e -> m a) -> m a -> m a

-- | Always executes the first argument. If this throws an exception the
--   second argument is executed and the exception is raised again.
gonException :: ExceptionMonad m => m a -> m b -> m a
instance Exception.ExceptionMonad GHC.Types.IO


-- | A tiny wrapper around <a>IntSet</a> for representing sets of
--   <a>Enum</a> things.
module EnumSet
data EnumSet a
member :: Enum a => a -> EnumSet a -> Bool
insert :: Enum a => a -> EnumSet a -> EnumSet a
delete :: Enum a => a -> EnumSet a -> EnumSet a
toList :: Enum a => EnumSet a -> [a]
fromList :: Enum a => [a] -> EnumSet a
empty :: EnumSet a

module Encoding
utf8DecodeChar# :: Addr# -> (# Char#, Int# #)
utf8PrevChar :: Ptr Word8 -> IO (Ptr Word8)
utf8CharStart :: Ptr Word8 -> IO (Ptr Word8)
utf8DecodeChar :: Ptr Word8 -> (Char, Int)
utf8DecodeByteString :: ByteString -> [Char]
utf8DecodeStringLazy :: ForeignPtr Word8 -> Int -> Int -> [Char]
utf8EncodeChar :: Char -> Ptr Word8 -> IO (Ptr Word8)
utf8EncodeString :: Ptr Word8 -> String -> IO ()
utf8EncodedLength :: String -> Int
countUTF8Chars :: Ptr Word8 -> Int -> IO Int
zEncodeString :: UserString -> EncodedString
zDecodeString :: EncodedString -> UserString
toBase62 :: Word64 -> String

-- | Converts a 64-bit word into a base-62 string
toBase62Padded :: Word64 -> String

module Config
data IntegerLibrary
IntegerGMP :: IntegerLibrary
IntegerSimple :: IntegerLibrary
cBuildPlatformString :: String
cHostPlatformString :: String
cTargetPlatformString :: String
cProjectName :: String
cProjectGitCommitId :: String
cProjectVersion :: String
cProjectVersionInt :: String
cProjectPatchLevel :: String
cProjectPatchLevel1 :: String
cProjectPatchLevel2 :: String
cBooterVersion :: String
cStage :: String
cIntegerLibrary :: String
cIntegerLibraryType :: IntegerLibrary
cSupportsSplitObjs :: String
cGhcWithInterpreter :: String
cGhcWithNativeCodeGen :: String
cGhcWithSMP :: String
cGhcRTSWays :: String
cGhcEnableTablesNextToCode :: String
cLeadingUnderscore :: String
cGHC_UNLIT_PGM :: String
cGHC_SPLIT_PGM :: String
cLibFFI :: Bool
cGhcThreaded :: Bool
cGhcDebugged :: Bool
cGhcRtsWithLibdw :: Bool
instance GHC.Classes.Eq Config.IntegerLibrary

module Constants
hiVersion :: Integer
mAX_TUPLE_SIZE :: Int
mAX_CTUPLE_SIZE :: Int
mAX_SUM_SIZE :: Int

-- | Default maximum depth for both class instance search and type family
--   reduction. See also Trac #5395.
mAX_REDUCTION_DEPTH :: Int

-- | Default maximum constraint-solver iterations Typically there should be
--   very few
mAX_SOLVER_ITERATIONS :: Int
wORD64_SIZE :: Int
fLOAT_SIZE :: Int
tARGET_MAX_CHAR :: Int


-- | Language extensions known to GHC
module Language.Haskell.TH.LanguageExtensions

-- | The language extensions known to GHC.
--   
--   Note that there is an orphan <tt>Binary</tt> instance for this type
--   supplied by the <a>GHC.LanguageExtensions</a> module provided by
--   <tt>ghc-boot</tt>. We can't provide here as this would require adding
--   transitive dependencies to the <tt>template-haskell</tt> package,
--   which must have a minimal dependency set.
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoPatBinds :: Extension
MonoLocalBinds :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
RecordPuns :: Extension
ViewPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
MonadFailDesugaring :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension

module Language.Haskell.TH.Lib.Map
data Map k a
empty :: Map k a
insert :: Ord k => k -> a -> Map k a -> Map k a
lookup :: Ord k => k -> Map k a -> Maybe a


-- | Abstract syntax definitions for Template Haskell.
module Language.Haskell.TH.Syntax

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type

-- | Annotation target for reifyAnnotations
data AnnLookup
AnnLookupModule :: Module -> AnnLookup
AnnLookupName :: Name -> AnnLookup

-- | Role annotations
data Role

-- | <pre>
--   nominal
--   </pre>
NominalR :: Role

-- | <pre>
--   representational
--   </pre>
RepresentationalR :: Role

-- | <pre>
--   phantom
--   </pre>
PhantomR :: Role

-- | <pre>
--   _
--   </pre>
InferR :: Role
data TyLit

-- | <pre>
--   2
--   </pre>
NumTyLit :: Integer -> TyLit

-- | <pre>
--   "Hello"
--   </pre>
StrTyLit :: String -> TyLit

-- | Injectivity annotation
data InjectivityAnn
InjectivityAnn :: Name -> [Name] -> InjectivityAnn

-- | Type family result signature
data FamilyResultSig

-- | no signature
NoSig :: FamilyResultSig

-- | <pre>
--   k
--   </pre>
KindSig :: Kind -> FamilyResultSig

-- | <pre>
--   = r, = (r :: k)
--   </pre>
TyVarSig :: TyVarBndr -> FamilyResultSig
data TyVarBndr

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> Kind -> TyVarBndr
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; =&gt; &lt;type&gt;
--   </pre>
ForallT :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   T @k t
--   </pre>
AppKindT :: Type -> Kind -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   'T
--   </pre>
PromotedT :: Name -> Type

-- | <pre>
--   T + T
--   </pre>
InfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T + T
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   (T)
--   </pre>
ParensT :: Type -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
TupleT :: Int -> Type

-- | <pre>
--   (#,#), (#,,#), etc.
--   </pre>
UnboxedTupleT :: Int -> Type

-- | <pre>
--   (#|#), (#||#), etc.
--   </pre>
UnboxedSumT :: SumArity -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   ~
--   </pre>
EqualityT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <pre>
--   '(), '(,), '(,,), etc.
--   </pre>
PromotedTupleT :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
PromotedNilT :: Type

-- | <pre>
--   (':)
--   </pre>
PromotedConsT :: Type

-- | <pre>
--   *
--   </pre>
StarT :: Type

-- | <pre>
--   Constraint
--   </pre>
ConstraintT :: Type

-- | <pre>
--   0,1,2, etc.
--   </pre>
LitT :: TyLit -> Type

-- | <pre>
--   _
--   </pre>
WildCardT :: Type

-- | <pre>
--   ?x :: t
--   </pre>
ImplicitParamT :: String -> Type -> Type

-- | A pattern synonym's argument type.
data PatSynArgs

-- | <pre>
--   pattern P {x y z} = p
--   </pre>
PrefixPatSyn :: [Name] -> PatSynArgs

-- | <pre>
--   pattern {x P y} = p
--   </pre>
InfixPatSyn :: Name -> Name -> PatSynArgs

-- | <pre>
--   pattern P { {x,y,z} } = p
--   </pre>
RecordPatSyn :: [Name] -> PatSynArgs

-- | A pattern synonym's directionality.
data PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p
--   </pre>
Unidir :: PatSynDir

-- | <pre>
--   pattern P x {=} p
--   </pre>
ImplBidir :: PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p where P x = e
--   </pre>
ExplBidir :: [Clause] -> PatSynDir

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>VarStrictType</a> has
--   been replaced by <a>VarBangType</a>.
type VarStrictType = VarBangType

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>StrictType</a> has been
--   replaced by <a>BangType</a>.
type StrictType = BangType

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>Strict</a> has been
--   replaced by <a>Bang</a>.
type Strict = Bang
type VarBangType = (Name, Bang, Type)
type BangType = (Bang, Type)
data Bang

-- | <pre>
--   C { {-# UNPACK #-} !}a
--   </pre>
Bang :: SourceUnpackedness -> SourceStrictness -> Bang

-- | A single data constructor.
--   
--   The constructors for <a>Con</a> can roughly be divided up into two
--   categories: those for constructors with "vanilla" syntax
--   (<a>NormalC</a>, <a>RecC</a>, and <a>InfixC</a>), and those for
--   constructors with GADT syntax (<a>GadtC</a> and <a>RecGadtC</a>). The
--   <a>ForallC</a> constructor, which quantifies additional type variables
--   and class contexts, can surround either variety of constructor.
--   However, the type variables that it quantifies are different depending
--   on what constructor syntax is used:
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with vanilla syntax,
--   then the <a>ForallC</a> will only quantify <i>existential</i> type
--   variables. For example:</li>
--   </ul>
--   
--   <pre>
--   data Foo a = forall b. MkFoo a b
--   
--   </pre>
--   
--   In <tt>MkFoo</tt>, <a>ForallC</a> will quantify <tt>b</tt>, but not
--   <tt>a</tt>.
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with GADT syntax, then
--   the <a>ForallC</a> will quantify <i>all</i> type variables used in the
--   constructor. For example:</li>
--   </ul>
--   
--   <pre>
--   data Bar a b where
--     MkBar :: (a ~ b) =&gt; c -&gt; MkBar a b
--   
--   </pre>
--   
--   In <tt>MkBar</tt>, <a>ForallC</a> will quantify <tt>a</tt>,
--   <tt>b</tt>, and <tt>c</tt>.
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [BangType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarBangType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: BangType -> Name -> BangType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr] -> Cxt -> Con -> Con

-- | <pre>
--   C :: a -&gt; b -&gt; T b Int
--   </pre>
GadtC :: [Name] -> [BangType] -> Type -> Con

-- | <pre>
--   C :: { v :: Int } -&gt; T b Int
--   </pre>
RecGadtC :: [Name] -> [VarBangType] -> Type -> Con

-- | Unlike <a>SourceStrictness</a> and <a>SourceUnpackedness</a>,
--   <a>DecidedStrictness</a> refers to the strictness that the compiler
--   chooses for a data constructor field, which may be different from what
--   is written in source code. See <a>reifyConStrictness</a> for more
--   information.
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness
data SourceStrictness

-- | <pre>
--   C a
--   </pre>
NoSourceStrictness :: SourceStrictness

-- | <pre>
--   C {~}a
--   </pre>
SourceLazy :: SourceStrictness

-- | <pre>
--   C {!}a
--   </pre>
SourceStrict :: SourceStrictness
data SourceUnpackedness

-- | <pre>
--   C a
--   </pre>
NoSourceUnpackedness :: SourceUnpackedness

-- | <pre>
--   C { {-# NOUNPACK #-} } a
--   </pre>
SourceNoUnpack :: SourceUnpackedness

-- | <pre>
--   C { {-# UNPACK #-} } a
--   </pre>
SourceUnpack :: SourceUnpackedness

-- | Since the advent of <tt>ConstraintKinds</tt>, constraints are really
--   just types. Equality constraints use the <a>EqualityT</a> constructor.
--   Constraints may also be tuples of other constraints.
type Pred = Type
type Cxt = [Pred] " @(Eq a, Ord b)@"
data AnnTarget
ModuleAnnotation :: AnnTarget
TypeAnnotation :: Name -> AnnTarget
ValueAnnotation :: Name -> AnnTarget
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
SpecialiseP :: Name -> Type -> Maybe Inline -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> Maybe [TyVarBndr] -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
AnnP :: AnnTarget -> Exp -> Pragma
LineP :: Int -> String -> Pragma

-- | <pre>
--   { {-# COMPLETE C_1, ..., C_i [ :: T ] #-} }
--   </pre>
CompleteP :: [Name] -> Maybe Name -> Pragma
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Callconv
CCall :: Callconv
StdCall :: Callconv
CApi :: Callconv
Prim :: Callconv
JavaScript :: Callconv
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data FunDep
FunDep :: [Name] -> [Name] -> FunDep

-- | One equation of a type family instance or closed type family. The
--   arguments are the left-hand-side type and the right-hand-side result.
--   
--   For instance, if you had the following type family:
--   
--   <pre>
--   type family Foo (a :: k) :: k where
--     forall k (a :: k). Foo @k a = a
--   </pre>
--   
--   The <tt>Foo @k a = a</tt> equation would be represented as follows:
--   
--   <pre>
--   <a>TySynEqn</a> (<a>Just</a> [<a>PlainTV</a> k, <a>KindedTV</a> a (<a>VarT</a> k)])
--              (<a>AppT</a> (<a>AppKindT</a> (<a>ConT</a> ''Foo) (<a>VarT</a> k)) (<a>VarT</a> a))
--              (<a>VarT</a> a)
--   </pre>
data TySynEqn
TySynEqn :: Maybe [TyVarBndr] -> Type -> Type -> TySynEqn

-- | Common elements of <a>OpenTypeFamilyD</a> and
--   <a>ClosedTypeFamilyD</a>. By analogy with "head" for type classes and
--   type class instances as defined in <i>Type classes: an exploration of
--   the design space</i>, the <tt>TypeFamilyHead</tt> is defined to be the
--   elements of the declaration between <tt>type family</tt> and
--   <tt>where</tt>.
data TypeFamilyHead
TypeFamilyHead :: Name -> [TyVarBndr] -> FamilyResultSig -> Maybe InjectivityAnn -> TypeFamilyHead

-- | A pattern synonym's type. Note that a pattern synonym's <i>fully</i>
--   specified type has a peculiar shape coming with two forall quantifiers
--   and two constraint contexts. For example, consider the pattern synonym
--   
--   <pre>
--   pattern P x1 x2 ... xn = &lt;some-pattern&gt;
--   </pre>
--   
--   P's complete type is of the following form
--   
--   <pre>
--   pattern P :: forall universals.   required constraints
--             =&gt; forall existentials. provided constraints
--             =&gt; t1 -&gt; t2 -&gt; ... -&gt; tn -&gt; t
--   </pre>
--   
--   consisting of four parts:
--   
--   <ol>
--   <li>the (possibly empty lists of) universally quantified type
--   variables and required constraints on them.</li>
--   <li>the (possibly empty lists of) existentially quantified type
--   variables and the provided constraints on them.</li>
--   <li>the types <tt>t1</tt>, <tt>t2</tt>, .., <tt>tn</tt> of
--   <tt>x1</tt>, <tt>x2</tt>, .., <tt>xn</tt>, respectively</li>
--   <li>the type <tt>t</tt> of <tt>&lt;some-pattern&gt;</tt>, mentioning
--   only universals.</li>
--   </ol>
--   
--   Pattern synonym types interact with TH when (a) reifying a pattern
--   synonym, (b) pretty printing, or (c) specifying a pattern synonym's
--   type signature explicitly:
--   
--   <ul>
--   <li>Reification always returns a pattern synonym's <i>fully</i>
--   specified type in abstract syntax.</li>
--   <li>Pretty printing via <a>pprPatSynType</a> abbreviates a pattern
--   synonym's type unambiguously in concrete syntax: The rule of thumb is
--   to print initial empty universals and the required context as <tt>()
--   =&gt;</tt>, if existentials and a provided context follow. If only
--   universals and their required context, but no existentials are
--   specified, only the universals and their required context are printed.
--   If both or none are specified, so both (or none) are printed.</li>
--   <li>When specifying a pattern synonym's type explicitly with
--   <a>PatSynSigD</a> either one of the universals, the existentials, or
--   their contexts may be left empty.</li>
--   </ul>
--   
--   See the GHC user's guide for more information on pattern synonyms and
--   their types:
--   <a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms</a>.
type PatSynType = Type

-- | What the user explicitly requests when deriving an instance.
data DerivStrategy

-- | A "standard" derived instance
StockStrategy :: DerivStrategy

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: DerivStrategy

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: DerivStrategy

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: Type -> DerivStrategy

-- | A single <tt>deriving</tt> clause at the end of a datatype.
data DerivClause

-- | <pre>
--   { deriving stock (Eq, Ord) }
--   </pre>
DerivClause :: Maybe DerivStrategy -> Cxt -> DerivClause

-- | Varieties of allowed instance overlap.
data Overlap

-- | May be overlapped by more specific instances
Overlappable :: Overlap

-- | May overlap a more general instance
Overlapping :: Overlap

-- | Both <a>Overlapping</a> and <a>Overlappable</a>
Overlaps :: Overlap

-- | Both <a>Overlappable</a> and <a>Overlappable</a>, and pick an
--   arbitrary one if multiple choices are available.
Incoherent :: Overlap
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr] -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W Q)
--          deriving stock Eq }
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr] -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance {-# OVERLAPS #-}
--           Show w =&gt; Show [w] where ds }
--   </pre>
InstanceD :: Maybe Overlap -> Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
ForeignD :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
InfixD :: Fixity -> Name -> Dec

-- | <pre>
--   { {-# INLINE [1] foo #-} }
--   </pre>
PragmaD :: Pragma -> Dec

-- | <pre>
--   { data family T a b c :: * }
--   </pre>
DataFamilyD :: Name -> [TyVarBndr] -> Maybe Kind -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x]
--          = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataInstD :: Cxt -> Maybe [TyVarBndr] -> Type -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x]
--           = A (B x)
--           deriving (Z,W)
--           deriving stock Eq }
--   </pre>
NewtypeInstD :: Cxt -> Maybe [TyVarBndr] -> Type -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type instance ... }
--   </pre>
TySynInstD :: TySynEqn -> Dec

-- | <pre>
--   { type family T a b c = (r :: *) | r -&gt; a b }
--   </pre>
OpenTypeFamilyD :: TypeFamilyHead -> Dec

-- | <pre>
--   { type family F a b = (r :: *) | r -&gt; a where ... }
--   </pre>
ClosedTypeFamilyD :: TypeFamilyHead -> [TySynEqn] -> Dec

-- | <pre>
--   { type role T nominal representational }
--   </pre>
RoleAnnotD :: Name -> [Role] -> Dec

-- | <pre>
--   { deriving stock instance Ord a =&gt; Ord (Foo a) }
--   </pre>
StandaloneDerivD :: Maybe DerivStrategy -> Cxt -> Type -> Dec

-- | <pre>
--   { default size :: Data a =&gt; a -&gt; Int }
--   </pre>
DefaultSigD :: Name -> Type -> Dec

-- | <tt>{ pattern P v1 v2 .. vn &lt;- p }</tt> unidirectional or <tt>{
--   pattern P v1 v2 .. vn = p }</tt> implicit bidirectional or <tt>{
--   pattern P v1 v2 .. vn &lt;- p where P v1 v2 .. vn = e }</tt> explicit
--   bidirectional
--   
--   also, besides prefix pattern synonyms, both infix and record pattern
--   synonyms are supported. See <a>PatSynArgs</a> for details
PatSynD :: Name -> PatSynArgs -> PatSynDir -> Pat -> Dec

-- | A pattern synonym's type signature.
PatSynSigD :: Name -> PatSynType -> Dec

-- | <pre>
--   { ?x = expr }
--   </pre>
--   
--   Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
ImplicitParamBindD :: String -> Exp -> Dec
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Stmt

-- | <pre>
--   p &lt;- e
--   </pre>
BindS :: Pat -> Exp -> Stmt

-- | <pre>
--   { let { x=e1; y=e2 } }
--   </pre>
LetS :: [Dec] -> Stmt

-- | <pre>
--   e
--   </pre>
NoBindS :: Exp -> Stmt

-- | <tt>x &lt;- e1 | s2, s3 | s4</tt> (in <a>CompE</a>)
ParS :: [[Stmt]] -> Stmt

-- | <pre>
--   rec { s1; s2 }
--   </pre>
RecS :: [Stmt] -> Stmt
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
NormalG :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
PatG :: [Stmt] -> Guard
data Body

-- | <pre>
--   f p { | e1 = e2
--         | e3 = e4 }
--    where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body
type FieldExp = (Name, Exp)
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or 'c'}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   { f @Int }
--   </pre>
AppTypeE :: Exp -> Type -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   { \ p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { \case m1; m2 }
--   </pre>
LamCaseE :: [Match] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
TupE :: [Exp] -> Exp

-- | <pre>
--   { (# e1,e2 #) }
--   </pre>
UnboxedTupE :: [Exp] -> Exp

-- | <pre>
--   { (#|e|#) }
--   </pre>
UnboxedSumE :: Exp -> SumAlt -> SumArity -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
MultiIfE :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let { x=e1; y=e2 } in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
DoE :: [Stmt] -> Exp

-- | <pre>
--   { mdo { x &lt;- e1 y; y &lt;- e2 x; } }
--   </pre>
MDoE :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp

-- | <pre>
--   { static e }
--   </pre>
StaticE :: Exp -> Exp

-- | <pre>
--   { _x }
--   </pre>
--   
--   This is used for holes or unresolved identifiers in AST quotes. Note
--   that it could either have a variable name or constructor name.
UnboundVarE :: Name -> Exp

-- | <tt>{ #x }</tt> ( Overloaded label )
LabelE :: String -> Exp

-- | <tt>{ ?x }</tt> ( Implicit parameter )
ImplicitParamVarE :: String -> Exp
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
type FieldPat = (Name, Pat)

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or 'c' }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { (# p1,p2 #) }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   { (#|p|#) }
--   </pre>
UnboxedSumP :: Pat -> SumAlt -> SumArity -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
ConP :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type Addr#
StringPrimL :: [Word8] -> Lit
CharPrimL :: Char -> Lit
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
data Fixity
Fixity :: Int -> FixityDirection -> Fixity

-- | <a>InstanceDec</a> desribes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | In <a>UnboxedSumE</a>, <a>UnboxedSumT</a>, and <a>UnboxedSumP</a>, the
--   total number of <a>SumAlt</a>s. For example, <tt>(#|#)</tt> has a
--   <a>SumArity</a> of 2.
type SumArity = Int

-- | In <a>UnboxedSumE</a> and <a>UnboxedSumP</a>, the number associated
--   with a particular data constructor. <a>SumAlt</a>s are one-indexed and
--   should never exceed the value of its corresponding <a>SumArity</a>.
--   For example:
--   
--   <ul>
--   <li><tt>(#_|#)</tt> has <a>SumAlt</a> 1 (out of a total
--   <a>SumArity</a> of 2)</li>
--   <li><tt>(#|_#)</tt> has <a>SumAlt</a> 2 (out of a total
--   <a>SumArity</a> of 2)</li>
--   </ul>
type SumAlt = Int

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | Obtained from <a>reifyModule</a> in the <a>Q</a> Monad.
data ModuleInfo

-- | Contains the import list of the module.
ModuleInfo :: [Module] -> ModuleInfo

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
ClassI :: Dec -> [InstanceDec] -> Info

-- | A class method
ClassOpI :: Name -> Type -> ParentName -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate. At present,
--   this reified declaration will never have derived instances attached to
--   it (if you wish to check for an instance, see <a>reifyInstances</a>).
TyConI :: Dec -> Info

-- | A type or data family, with a list of its visible instances. A closed
--   type family is returned with 0 instances.
FamilyI :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
PrimTyConI :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
DataConI :: Name -> Type -> ParentName -> Info

-- | A pattern synonym
PatSynI :: Name -> PatSynType -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable - including the RHS of the declaration - or
--   else <tt>Nothing</tt>, in the case where the RHS is unavailable to the
--   compiler. At present, this value is <i>always</i> <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
VarI :: Name -> Type -> Maybe Dec -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
TyVarI :: Name -> Type -> Info
type CharPos = (Int, Int) " Line and character position"
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos
data NameIs
Alone :: NameIs
Applied :: NameIs
Infix :: NameIs
type Uniq = Int
data NameSpace

-- | Variables
VarName :: NameSpace

-- | Data constructors
DataName :: NameSpace

-- | Type constructors and classes; Haskell has them in the same name space
--   for now.
TcClsName :: NameSpace
data NameFlavour

-- | An unqualified name; dynamically bound
NameS :: NameFlavour

-- | A qualified name; dynamically bound
NameQ :: ModName -> NameFlavour

-- | A unique local name
NameU :: !Int -> NameFlavour

-- | Local name bound outside of the TH AST
NameL :: !Int -> NameFlavour

-- | Global name bound outside of the TH AST: An original name (occurrences
--   only, not binders) Need the namespace too to be sure which thing we
--   are naming
NameG :: NameSpace -> PkgName -> ModName -> NameFlavour

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
Name :: OccName -> NameFlavour -> Name
newtype OccName
OccName :: String -> OccName

-- | Obtained from <a>reifyModule</a> and <a>thisModule</a>.
data Module
Module :: PkgName -> ModName -> Module
newtype PkgName
PkgName :: String -> PkgName
newtype ModName
ModName :: String -> ModName

-- | A <a>Lift</a> instance can have any of its values turned into a
--   Template Haskell expression. This is needed when a value used within a
--   Template Haskell quotation is bound outside the Oxford brackets
--   (<tt>[| ... |]</tt>) but not at the top level. As an example:
--   
--   <pre>
--   add1 :: Int -&gt; Q Exp
--   add1 x = [| x + 1 |]
--   </pre>
--   
--   Template Haskell has no way of knowing what value <tt>x</tt> will take
--   on at splice-time, so it requires the type of <tt>x</tt> to be an
--   instance of <a>Lift</a>.
--   
--   A <a>Lift</a> instance must satisfy <tt>$(lift x)  x</tt> for all
--   <tt>x</tt>, where <tt>$(...)</tt> is a Template Haskell splice.
--   
--   <a>Lift</a> instances can be derived automatically by use of the
--   <tt>-XDeriveLift</tt> GHC language extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveLift #-}
--   module Foo where
--   
--   import Language.Haskell.TH.Syntax
--   
--   data Bar a = Bar1 a (Bar a) | Bar2 String
--     deriving Lift
--   </pre>
class Lift t

-- | Turn a value into a Template Haskell expression, suitable for use in a
--   splice.
lift :: Lift t => t -> Q Exp

-- | Turn a value into a Template Haskell expression, suitable for use in a
--   splice.
lift :: (Lift t, Data t) => t -> Q Exp
newtype TExp a
TExp :: Exp -> TExp a
[unType] :: TExp a -> Exp
newtype Q a
Q :: (forall m. Quasi m => m a) -> Q a
[unQ] :: Q a -> forall m. Quasi m => m a
class (MonadIO m, MonadFail m) => Quasi m
qNewName :: Quasi m => String -> m Name
qReport :: Quasi m => Bool -> String -> m ()
qRecover :: Quasi m => m a -> m a -> m a
qLookupName :: Quasi m => Bool -> String -> m (Maybe Name)
qReify :: Quasi m => Name -> m Info
qReifyFixity :: Quasi m => Name -> m (Maybe Fixity)
qReifyInstances :: Quasi m => Name -> [Type] -> m [Dec]
qReifyRoles :: Quasi m => Name -> m [Role]
qReifyAnnotations :: (Quasi m, Data a) => AnnLookup -> m [a]
qReifyModule :: Quasi m => Module -> m ModuleInfo
qReifyConStrictness :: Quasi m => Name -> m [DecidedStrictness]
qLocation :: Quasi m => m Loc
qRunIO :: Quasi m => IO a -> m a
qAddDependentFile :: Quasi m => FilePath -> m ()
qAddTempFile :: Quasi m => String -> m FilePath
qAddTopDecls :: Quasi m => [Dec] -> m ()
qAddForeignFilePath :: Quasi m => ForeignSrcLang -> String -> m ()
qAddModFinalizer :: Quasi m => Q () -> m ()
qAddCorePlugin :: Quasi m => String -> m ()
qGetQ :: (Quasi m, Typeable a) => m (Maybe a)
qPutQ :: (Quasi m, Typeable a) => a -> m ()
qIsExtEnabled :: Quasi m => Extension -> m Bool
qExtsEnabled :: Quasi m => m [Extension]
badIO :: String -> IO a
counter :: IORef Int
runQ :: Quasi m => Q a -> m a
unTypeQ :: Q (TExp a) -> Q Exp
unsafeTExpCoerce :: Q Exp -> Q (TExp a)

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = <a>mkName</a> "x"
--     return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: String -> Q Name

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead</i>
report :: Bool -> String -> Q ()

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a
lookupName :: Bool -> String -> Q (Maybe Name)

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <a>reify</a> looks up information about the <a>Name</a>.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyFixity nm</tt> attempts to find a fixity declaration for
--   <tt>nm</tt>. For example, if the function <tt>foo</tt> has the fixity
--   declaration <tt>infixr 7 foo</tt>, then <tt>reifyFixity 'foo</tt>
--   would return <tt><a>Just</a> (<a>Fixity</a> 7 <a>InfixR</a>)</tt>. If
--   the function <tt>bar</tt> does not have a fixity declaration, then
--   <tt>reifyFixity 'bar</tt> returns <a>Nothing</a>, so you may assume
--   <tt>bar</tt> has <a>defaultFixity</a>.
reifyFixity :: Name -> Q (Maybe Fixity)

-- | <tt>reifyInstances nm tys</tt> returns a list of visible instances of
--   <tt>nm tys</tt>. That is, if <tt>nm</tt> is the name of a type class,
--   then all instances of this class at the types <tt>tys</tt> are
--   returned. Alternatively, if <tt>nm</tt> is the name of a data family
--   or type family, all instances of this family at the types <tt>tys</tt>
--   are returned.
--   
--   Note that this is a "shallow" test; the declarations returned merely
--   have instance heads which unify with <tt>nm tys</tt>, they need not
--   actually be satisfiable.
--   
--   <ul>
--   <li><tt>reifyInstances ''Eq [ <a>TupleT</a> 2 `<a>AppT</a>`
--   <a>ConT</a> ''A `<a>AppT</a>` <a>ConT</a> ''B ]</tt> contains the
--   <tt>instance (Eq a, Eq b) =&gt; Eq (a, b)</tt> regardless of whether
--   <tt>A</tt> and <tt>B</tt> themselves implement <a>Eq</a></li>
--   <li><tt>reifyInstances ''Show [ <a>VarT</a> (<a>mkName</a> "a") ]</tt>
--   produces every available instance of <a>Eq</a></li>
--   </ul>
--   
--   There is one edge case: <tt>reifyInstances ''Typeable tys</tt>
--   currently always produces an empty list (no matter what <tt>tys</tt>
--   are given).
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | <tt>reifyRoles nm</tt> returns the list of roles associated with the
--   parameters of the tycon <tt>nm</tt>. Fails if <tt>nm</tt> cannot be
--   found or is not a tycon. The returned list should never contain
--   <a>InferR</a>.
reifyRoles :: Name -> Q [Role]

-- | <tt>reifyAnnotations target</tt> returns the list of annotations
--   associated with <tt>target</tt>. Only the annotations that are
--   appropriately typed is returned. So if you have <tt>Int</tt> and
--   <tt>String</tt> annotations for the same target, you have to call this
--   function twice.
reifyAnnotations :: Data a => AnnLookup -> Q [a]

-- | <tt>reifyModule mod</tt> looks up information about module
--   <tt>mod</tt>. To look up the current module, call this function with
--   the return value of <a>thisModule</a>.
reifyModule :: Module -> Q ModuleInfo

-- | <tt>reifyConStrictness nm</tt> looks up the strictness information for
--   the fields of the constructor with the name <tt>nm</tt>. Note that the
--   strictness information that <a>reifyConStrictness</a> returns may not
--   correspond to what is written in the source code. For example, in the
--   following data declaration:
--   
--   <pre>
--   data Pair a = Pair a a
--   </pre>
--   
--   <a>reifyConStrictness</a> would return <tt>[<a>DecidedLazy</a>,
--   DecidedLazy]</tt> under most circumstances, but it would return
--   <tt>[<a>DecidedStrict</a>, DecidedStrict]</tt> if the
--   <tt>-XStrictData</tt> language extension was enabled.
reifyConStrictness :: Name -> Q [DecidedStrictness]

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
isInstance :: Name -> [Type] -> Q Bool

-- | The location at which this computation is spliced.
location :: Q Loc

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necessarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | Record external files that runIO is using (dependent upon). The
--   compiler can then recognize that it should re-compile the Haskell file
--   when an external file changes.
--   
--   Expects an absolute file path.
--   
--   Notes:
--   
--   <ul>
--   <li>ghc -M does not know about these dependencies - it does not
--   execute TH.</li>
--   <li>The dependency is based on file content, not a modification
--   time</li>
--   </ul>
addDependentFile :: FilePath -> Q ()

-- | Obtain a temporary file path with the given suffix. The compiler will
--   delete this file after compilation.
addTempFile :: String -> Q FilePath

-- | Add additional top-level declarations. The added declarations will be
--   type checked along with the current declaration group.
addTopDecls :: [Dec] -> Q ()


-- | <i>Deprecated: Use <a>addForeignSource</a> instead</i>
addForeignFile :: ForeignSrcLang -> String -> Q ()

-- | Emit a foreign file which will be compiled and linked to the object
--   for the current module. Currently only languages that can be compiled
--   with the C compiler are supported, and the flags passed as part of
--   -optc will be also applied to the C compiler invocation that will
--   compile them.
--   
--   Note that for non-C languages (for example C++) <tt>extern
--   <a>C</a></tt> directives must be used to get symbols that we can
--   access from Haskell.
--   
--   To get better errors, it is recommended to use #line pragmas when
--   emitting C files, e.g.
--   
--   <pre>
--   {-# LANGUAGE CPP #-}
--   ...
--   addForeignSource LangC $ unlines
--     [ "#line " ++ show (500 + 1) ++ " " ++ show "libraries/template-haskell/Language/Haskell/TH/Syntax.hs"
--     , ...
--     ]
--   </pre>
addForeignSource :: ForeignSrcLang -> String -> Q ()

-- | Same as <a>addForeignSource</a>, but expects to receive a path
--   pointing to the foreign file instead of a <a>String</a> of its
--   contents. Consider using this in conjunction with <a>addTempFile</a>.
--   
--   This is a good alternative to <a>addForeignSource</a> when you are
--   trying to directly link in an object file.
addForeignFilePath :: ForeignSrcLang -> FilePath -> Q ()

-- | Add a finalizer that will run in the Q monad after the current module
--   has been type checked. This only makes sense when run within a
--   top-level splice.
--   
--   The finalizer is given the local type environment at the splice point.
--   Thus <a>reify</a> is able to find the local definitions when executed
--   inside the finalizer.
addModFinalizer :: Q () -> Q ()

-- | Adds a core plugin to the compilation pipeline.
--   
--   <tt>addCorePlugin m</tt> has almost the same effect as passing
--   <tt>-fplugin=m</tt> to ghc in the command line. The major difference
--   is that the plugin module <tt>m</tt> must not belong to the current
--   package. When TH executes, it is too late to tell the compiler that we
--   needed to compile first a plugin module in the current package.
addCorePlugin :: String -> Q ()

-- | Get state from the <a>Q</a> monad. Note that the state is local to the
--   Haskell module in which the Template Haskell expression is executed.
getQ :: Typeable a => Q (Maybe a)

-- | Replace the state in the <a>Q</a> monad. Note that the state is local
--   to the Haskell module in which the Template Haskell expression is
--   executed.
putQ :: Typeable a => a -> Q ()

-- | Determine whether the given language extension is enabled in the
--   <a>Q</a> monad.
isExtEnabled :: Extension -> Q Bool

-- | List all enabled language extensions.
extsEnabled :: Q [Extension]
returnQ :: a -> Q a
bindQ :: Q a -> (a -> Q b) -> Q b
sequenceQ :: [Q a] -> Q [a]
liftString :: String -> Q Exp
trueName :: Name
falseName :: Name
nothingName :: Name
justName :: Name
leftName :: Name
rightName :: Name
nonemptyName :: Name

-- | <a>dataToQa</a> is an internal utility function for constructing
--   generic conversion functions from types with <a>Data</a> instances to
--   various quasi-quoting representations. See the source of
--   <a>dataToExpQ</a> and <a>dataToPatQ</a> for two example usages:
--   <tt>mkCon</tt>, <tt>mkLit</tt> and <tt>appQ</tt> are overloadable to
--   account for different syntax for expressions and patterns;
--   <tt>antiQ</tt> allows you to override type-specific cases, a common
--   usage is just <tt>const Nothing</tt>, which results in no overloading.
dataToQa :: forall a k q. Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (forall b. Data b => b -> Maybe (Q q)) -> a -> Q q

-- | <a>dataToExpQ</a> converts a value to a 'Q Exp' representation of the
--   same value, in the SYB style. It is generalized to take a function
--   override type-specific cases; see <a>liftData</a> for a more commonly
--   used variant.
dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp

-- | <a>liftData</a> is a variant of <a>lift</a> in the <a>Lift</a> type
--   class which works for any type with a <a>Data</a> instance.
liftData :: Data a => a -> Q Exp

-- | <a>dataToPatQ</a> converts a value to a 'Q Pat' representation of the
--   same value, in the SYB style. It takes a function to handle
--   type-specific cases, alternatively, pass <tt>const Nothing</tt> to get
--   default behavior.
dataToPatQ :: Data a => (forall b. Data b => b -> Maybe (Q Pat)) -> a -> Q Pat
mkModName :: String -> ModName
modString :: ModName -> String
mkPkgName :: String -> PkgName
pkgString :: PkgName -> String
mkOccName :: String -> OccName
occString :: OccName -> String

-- | The name without its module prefix.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameBase ''Data.Either.Either
--   "Either"
--   
--   &gt;&gt;&gt; nameBase (mkName "foo")
--   "foo"
--   
--   &gt;&gt;&gt; nameBase (mkName "Module.foo")
--   "foo"
--   </pre>
nameBase :: Name -> String

-- | Module prefix of a name, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameModule ''Data.Either.Either
--   Just "Data.Either"
--   
--   &gt;&gt;&gt; nameModule (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; nameModule (mkName "Module.foo")
--   Just "Module"
--   </pre>
nameModule :: Name -> Maybe String

-- | A name's package, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; namePackage ''Data.Either.Either
--   Just "base"
--   
--   &gt;&gt;&gt; namePackage (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; namePackage (mkName "Module.foo")
--   Nothing
--   </pre>
namePackage :: Name -> Maybe String

-- | Returns whether a name represents an occurrence of a top-level
--   variable (<a>VarName</a>), data constructor (<a>DataName</a>), type
--   constructor, or type class (<a>TcClsName</a>). If we can't be sure, it
--   returns <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameSpace 'Prelude.id
--   Just VarName
--   
--   &gt;&gt;&gt; nameSpace (mkName "id")
--   Nothing -- only works for top-level variable names
--   
--   &gt;&gt;&gt; nameSpace 'Data.Maybe.Just
--   Just DataName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Maybe.Maybe
--   Just TcClsName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Ord.Ord
--   Just TcClsName
--   </pre>
nameSpace :: Name -> Maybe NameSpace

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <a>dyn</a> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | Only used internally
mkNameU :: String -> Uniq -> Name

-- | Only used internally
mkNameL :: String -> Uniq -> Name

-- | Used for 'x etc, but not available to the programmer
mkNameG :: NameSpace -> String -> String -> String -> Name
mkNameS :: String -> Name
mkNameG_v :: String -> String -> String -> Name
mkNameG_tc :: String -> String -> String -> Name
mkNameG_d :: String -> String -> String -> Name
showName :: Name -> String
showName' :: NameIs -> Name -> String

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Tuple type constructor
tupleTypeName :: Int -> Name
mk_tup_name :: Int -> NameSpace -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name
mk_unboxed_tup_name :: Int -> NameSpace -> Name

-- | Unboxed sum data constructor
unboxedSumDataName :: SumAlt -> SumArity -> Name

-- | Unboxed sum type constructor
unboxedSumTypeName :: SumArity -> Name

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity
cmpEq :: Ordering -> Bool
thenCmp :: Ordering -> Ordering -> Ordering

-- | Foreign formats supported by GHC via TH
data ForeignSrcLang

-- | C
LangC :: ForeignSrcLang

-- | C++
LangCxx :: ForeignSrcLang

-- | Objective C
LangObjc :: ForeignSrcLang

-- | Objective C++
LangObjcxx :: ForeignSrcLang

-- | Assembly language (.s)
LangAsm :: ForeignSrcLang

-- | Object (.o)
RawObject :: ForeignSrcLang
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Info
instance Data.Data.Data Language.Haskell.TH.Syntax.Info
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Info
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Info
instance GHC.Show.Show Language.Haskell.TH.Syntax.Info
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Pragma
instance Data.Data.Data Language.Haskell.TH.Syntax.Pragma
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Pragma
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Pragma
instance GHC.Show.Show Language.Haskell.TH.Syntax.Pragma
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Pat
instance Data.Data.Data Language.Haskell.TH.Syntax.Pat
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Pat
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Pat
instance GHC.Show.Show Language.Haskell.TH.Syntax.Pat
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Match
instance Data.Data.Data Language.Haskell.TH.Syntax.Match
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Match
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Match
instance GHC.Show.Show Language.Haskell.TH.Syntax.Match
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Range
instance Data.Data.Data Language.Haskell.TH.Syntax.Range
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Range
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Range
instance GHC.Show.Show Language.Haskell.TH.Syntax.Range
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Exp
instance Data.Data.Data Language.Haskell.TH.Syntax.Exp
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Exp
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Exp
instance GHC.Show.Show Language.Haskell.TH.Syntax.Exp
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Stmt
instance Data.Data.Data Language.Haskell.TH.Syntax.Stmt
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Stmt
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Stmt
instance GHC.Show.Show Language.Haskell.TH.Syntax.Stmt
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Guard
instance Data.Data.Data Language.Haskell.TH.Syntax.Guard
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Guard
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Guard
instance GHC.Show.Show Language.Haskell.TH.Syntax.Guard
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Body
instance Data.Data.Data Language.Haskell.TH.Syntax.Body
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Body
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Body
instance GHC.Show.Show Language.Haskell.TH.Syntax.Body
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Clause
instance Data.Data.Data Language.Haskell.TH.Syntax.Clause
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Clause
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Clause
instance GHC.Show.Show Language.Haskell.TH.Syntax.Clause
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PatSynDir
instance Data.Data.Data Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Show.Show Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Dec
instance Data.Data.Data Language.Haskell.TH.Syntax.Dec
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Dec
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Dec
instance GHC.Show.Show Language.Haskell.TH.Syntax.Dec
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DerivClause
instance Data.Data.Data Language.Haskell.TH.Syntax.DerivClause
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DerivClause
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DerivClause
instance GHC.Show.Show Language.Haskell.TH.Syntax.DerivClause
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DerivStrategy
instance Data.Data.Data Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Show.Show Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TySynEqn
instance Data.Data.Data Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Show.Show Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Foreign
instance Data.Data.Data Language.Haskell.TH.Syntax.Foreign
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Foreign
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Foreign
instance GHC.Show.Show Language.Haskell.TH.Syntax.Foreign
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.RuleBndr
instance Data.Data.Data Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Show.Show Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Con
instance Data.Data.Data Language.Haskell.TH.Syntax.Con
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Con
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Con
instance GHC.Show.Show Language.Haskell.TH.Syntax.Con
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TypeFamilyHead
instance Data.Data.Data Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Show.Show Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FamilyResultSig
instance Data.Data.Data Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Show.Show Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TyVarBndr
instance Data.Data.Data Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Show.Show Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Type
instance Data.Data.Data Language.Haskell.TH.Syntax.Type
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Type
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Type
instance GHC.Show.Show Language.Haskell.TH.Syntax.Type
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.AnnLookup
instance Data.Data.Data Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Show.Show Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Role
instance Data.Data.Data Language.Haskell.TH.Syntax.Role
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Role
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Role
instance GHC.Show.Show Language.Haskell.TH.Syntax.Role
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TyLit
instance Data.Data.Data Language.Haskell.TH.Syntax.TyLit
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TyLit
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TyLit
instance GHC.Show.Show Language.Haskell.TH.Syntax.TyLit
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.InjectivityAnn
instance Data.Data.Data Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Show.Show Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PatSynArgs
instance Data.Data.Data Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Show.Show Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Bang
instance Data.Data.Data Language.Haskell.TH.Syntax.Bang
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Bang
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Bang
instance GHC.Show.Show Language.Haskell.TH.Syntax.Bang
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DecidedStrictness
instance Data.Data.Data Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Show.Show Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.SourceStrictness
instance Data.Data.Data Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Show.Show Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.SourceUnpackedness
instance Data.Data.Data Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Show.Show Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.AnnTarget
instance Data.Data.Data Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Show.Show Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Phases
instance Data.Data.Data Language.Haskell.TH.Syntax.Phases
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Phases
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Phases
instance GHC.Show.Show Language.Haskell.TH.Syntax.Phases
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.RuleMatch
instance Data.Data.Data Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Show.Show Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Inline
instance Data.Data.Data Language.Haskell.TH.Syntax.Inline
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Inline
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Inline
instance GHC.Show.Show Language.Haskell.TH.Syntax.Inline
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Safety
instance Data.Data.Data Language.Haskell.TH.Syntax.Safety
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Safety
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Safety
instance GHC.Show.Show Language.Haskell.TH.Syntax.Safety
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Callconv
instance Data.Data.Data Language.Haskell.TH.Syntax.Callconv
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Callconv
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Callconv
instance GHC.Show.Show Language.Haskell.TH.Syntax.Callconv
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FunDep
instance Data.Data.Data Language.Haskell.TH.Syntax.FunDep
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FunDep
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FunDep
instance GHC.Show.Show Language.Haskell.TH.Syntax.FunDep
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Overlap
instance Data.Data.Data Language.Haskell.TH.Syntax.Overlap
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Overlap
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Overlap
instance GHC.Show.Show Language.Haskell.TH.Syntax.Overlap
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Lit
instance Data.Data.Data Language.Haskell.TH.Syntax.Lit
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Lit
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Lit
instance GHC.Show.Show Language.Haskell.TH.Syntax.Lit
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Fixity
instance Data.Data.Data Language.Haskell.TH.Syntax.Fixity
instance GHC.Show.Show Language.Haskell.TH.Syntax.Fixity
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Fixity
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Fixity
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FixityDirection
instance Data.Data.Data Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Show.Show Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.ModuleInfo
instance Data.Data.Data Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Show.Show Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Loc
instance Data.Data.Data Language.Haskell.TH.Syntax.Loc
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Loc
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Loc
instance GHC.Show.Show Language.Haskell.TH.Syntax.Loc
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Name
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Name
instance Data.Data.Data Language.Haskell.TH.Syntax.Name
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Show.Show Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.NameFlavour
instance Data.Data.Data Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.NameSpace
instance Data.Data.Data Language.Haskell.TH.Syntax.NameSpace
instance GHC.Show.Show Language.Haskell.TH.Syntax.NameSpace
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.NameSpace
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.NameSpace
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.OccName
instance Data.Data.Data Language.Haskell.TH.Syntax.OccName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.OccName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.OccName
instance GHC.Show.Show Language.Haskell.TH.Syntax.OccName
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Module
instance Data.Data.Data Language.Haskell.TH.Syntax.Module
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Module
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Module
instance GHC.Show.Show Language.Haskell.TH.Syntax.Module
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PkgName
instance Data.Data.Data Language.Haskell.TH.Syntax.PkgName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PkgName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PkgName
instance GHC.Show.Show Language.Haskell.TH.Syntax.PkgName
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.ModName
instance Data.Data.Data Language.Haskell.TH.Syntax.ModName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.ModName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.ModName
instance GHC.Show.Show Language.Haskell.TH.Syntax.ModName
instance Language.Haskell.TH.Syntax.Lift GHC.Integer.Type.Integer
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Int
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int8
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int16
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int32
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int64
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Word
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word8
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word16
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word32
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word64
instance Language.Haskell.TH.Syntax.Lift GHC.Natural.Natural
instance GHC.Real.Integral a => Language.Haskell.TH.Syntax.Lift (GHC.Real.Ratio a)
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Float
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Double
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Char
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Bool
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (GHC.Maybe.Maybe a)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (Data.Either.Either a b)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift [a]
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (GHC.Base.NonEmpty a)
instance Language.Haskell.TH.Syntax.Lift Data.Void.Void
instance Language.Haskell.TH.Syntax.Lift ()
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (a, b)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c) => Language.Haskell.TH.Syntax.Lift (a, b, c)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d) => Language.Haskell.TH.Syntax.Lift (a, b, c, d)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e, f)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f, Language.Haskell.TH.Syntax.Lift g) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e, f, g)
instance Language.Haskell.TH.Syntax.Quasi GHC.Types.IO
instance GHC.Base.Monad Language.Haskell.TH.Syntax.Q
instance Control.Monad.Fail.MonadFail Language.Haskell.TH.Syntax.Q
instance GHC.Base.Functor Language.Haskell.TH.Syntax.Q
instance GHC.Base.Applicative Language.Haskell.TH.Syntax.Q
instance Control.Monad.IO.Class.MonadIO Language.Haskell.TH.Syntax.Q
instance Language.Haskell.TH.Syntax.Quasi Language.Haskell.TH.Syntax.Q
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Name
instance GHC.Show.Show Language.Haskell.TH.Syntax.Name


-- | Monadic front-end to Text.PrettyPrint
module Language.Haskell.TH.PprLib
type Doc = PprM Doc
data PprM a

-- | An empty document
empty :: Doc

-- | A ';' character
semi :: Doc

-- | A ',' character
comma :: Doc

-- | A <tt>:</tt> character
colon :: Doc

-- | A "::" string
dcolon :: Doc

-- | A space character
space :: Doc

-- | A '=' character
equals :: Doc

-- | A "-&gt;" string
arrow :: Doc

-- | A '(' character
lparen :: Doc

-- | A ')' character
rparen :: Doc

-- | A '[' character
lbrack :: Doc

-- | A ']' character
rbrack :: Doc

-- | A '{' character
lbrace :: Doc

-- | A '}' character
rbrace :: Doc
text :: String -> Doc
char :: Char -> Doc
ptext :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc

-- | Wrap document in <tt>(...)</tt>
parens :: Doc -> Doc

-- | Wrap document in <tt>[...]</tt>
brackets :: Doc -> Doc

-- | Wrap document in <tt>{...}</tt>
braces :: Doc -> Doc

-- | Wrap document in <tt>'...'</tt>
quotes :: Doc -> Doc

-- | Wrap document in <tt>"..."</tt>
doubleQuotes :: Doc -> Doc

-- | Beside
(<>) :: Doc -> Doc -> Doc
infixl 6 <>

-- | Beside, separated by space
(<+>) :: Doc -> Doc -> Doc
infixl 6 <+>

-- | List version of <a>&lt;&gt;</a>
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>
hsep :: [Doc] -> Doc

-- | Above; if there is no overlap it "dovetails" the two
($$) :: Doc -> Doc -> Doc
infixl 5 $$

-- | Above, without dovetailing.
($+$) :: Doc -> Doc -> Doc
infixl 5 $+$

-- | List version of <a>$$</a>
vcat :: [Doc] -> Doc

-- | Either hsep or vcat
sep :: [Doc] -> Doc

-- | Either hcat or vcat
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of sep
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of cat
fcat :: [Doc] -> Doc

-- | Nested
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> PprM Bool
to_HPJ_Doc :: Doc -> Doc
pprName :: Name -> Doc
pprName' :: NameIs -> Name -> Doc
instance GHC.Show.Show Language.Haskell.TH.PprLib.Doc
instance GHC.Base.Functor Language.Haskell.TH.PprLib.PprM
instance GHC.Base.Applicative Language.Haskell.TH.PprLib.PprM
instance GHC.Base.Monad Language.Haskell.TH.PprLib.PprM


-- | contains a prettyprinter for the Template Haskell datatypes
module Language.Haskell.TH.Ppr
nestDepth :: Int
type Precedence = Int
appPrec :: Precedence
opPrec :: Precedence
unopPrec :: Precedence
sigPrec :: Precedence
noPrec :: Precedence
parensIf :: Bool -> Doc -> Doc
pprint :: Ppr a => a -> String
class Ppr a
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
ppr_sig :: Name -> Type -> Doc
pprFixity :: Name -> Fixity -> Doc

-- | Pretty prints a pattern synonym type signature
pprPatSynSig :: Name -> PatSynType -> Doc

-- | Pretty prints a pattern synonym's type; follows the usual conventions
--   to print a pattern synonym type compactly, yet unambiguously. See the
--   note on <a>PatSynType</a> and the section on pattern synonyms in the
--   GHC user's guide for more information.
pprPatSynType :: PatSynType -> Doc
pprPrefixOcc :: Name -> Doc
isSymOcc :: Name -> Bool
pprInfixExp :: Exp -> Doc
pprExp :: Precedence -> Exp -> Doc
pprFields :: [(Name, Exp)] -> Doc
pprMaybeExp :: Precedence -> Maybe Exp -> Doc
pprMatchPat :: Pat -> Doc
pprGuarded :: Doc -> (Guard, Exp) -> Doc
pprBody :: Bool -> Body -> Doc
pprLit :: Precedence -> Lit -> Doc
bytesToString :: [Word8] -> String
pprString :: String -> Doc
pprPat :: Precedence -> Pat -> Doc
ppr_dec :: Bool -> Dec -> Doc
ppr_deriv_strategy :: DerivStrategy -> Doc
ppr_overlap :: Overlap -> Doc
ppr_data :: Doc -> Cxt -> Maybe Name -> Doc -> Maybe Kind -> [Con] -> [DerivClause] -> Doc
ppr_newtype :: Doc -> Cxt -> Maybe Name -> Doc -> Maybe Kind -> Con -> [DerivClause] -> Doc
ppr_deriv_clause :: DerivClause -> Doc
ppr_tySyn :: Doc -> Maybe Name -> Doc -> Type -> Doc
ppr_tf_head :: TypeFamilyHead -> Doc
ppr_bndrs :: Maybe [TyVarBndr] -> Doc
commaSepApplied :: [Name] -> Doc
pprForall :: [TyVarBndr] -> Cxt -> Doc
pprRecFields :: [(Name, Strict, Type)] -> Type -> Doc
pprGadtRHS :: [(Strict, Type)] -> Type -> Doc
pprVarBangType :: VarBangType -> Doc
pprBangType :: BangType -> Doc

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>VarStrictType</a> has been replaced by <a>VarBangType</a>. Please
--   use <a>pprVarBangType</a> instead.</i>
pprVarStrictType :: (Name, Strict, Type) -> Doc

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>StrictType</a> has been replaced by <a>BangType</a>. Please use
--   <a>pprBangType</a> instead.</i>
pprStrictType :: (Strict, Type) -> Doc
pprParendType :: Type -> Doc
pprUInfixT :: Type -> Doc
pprParendTypeArg :: TypeArg -> Doc
pprTyApp :: (Type, [TypeArg]) -> Doc
pprFunArgType :: Type -> Doc
data TypeArg
TANormal :: Type -> TypeArg
TyArg :: Kind -> TypeArg
split :: Type -> (Type, [TypeArg])
pprTyLit :: TyLit -> Doc
pprCxt :: Cxt -> Doc
ppr_cxt_preds :: Cxt -> Doc
where_clause :: [Dec] -> Doc
showtextl :: Show a => a -> Doc
hashParens :: Doc -> Doc
quoteParens :: Doc -> Doc
commaSep :: Ppr a => [a] -> Doc
commaSepWith :: (a -> Doc) -> [a] -> Doc
semiSep :: Ppr a => [a] -> Doc
unboxedSumBars :: Doc -> SumAlt -> SumArity -> Doc
bar :: Doc
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Ppr.TypeArg
instance Language.Haskell.TH.Ppr.Ppr a => Language.Haskell.TH.Ppr.Ppr [a]
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Name
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Info
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Module
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.ModuleInfo
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Exp
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Stmt
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Match
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Lit
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Pat
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Dec
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.FunDep
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.FamilyResultSig
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.InjectivityAnn
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Foreign
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Pragma
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Inline
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.RuleMatch
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Phases
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.RuleBndr
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Clause
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Con
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.PatSynDir
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.PatSynArgs
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Bang
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.SourceUnpackedness
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.SourceStrictness
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.DecidedStrictness
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Type
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.TyLit
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.TyVarBndr
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Role
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Range
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Loc


-- | Language.Haskell.TH.Lib.Internal exposes some additional functionality
--   that is used internally in GHC's integration with Template Haskell.
--   This is not a part of the public API, and as such, there are no API
--   guarantees for this module from version to version.
module Language.Haskell.TH.Lib.Internal
type InfoQ = Q Info
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type ExpQ = Q Exp
type TExpQ a = Q (TExp a)
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type KindQ = Q Kind
type TyVarBndrQ = Q TyVarBndr
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type DerivClauseQ = Q DerivClause
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type SourceStrictnessQ = Q SourceStrictness
type SourceUnpackednessQ = Q SourceUnpackedness
type BangQ = Q Bang
type BangTypeQ = Q BangType
type VarBangTypeQ = Q VarBangType
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
type PatSynDirQ = Q PatSynDir
type PatSynArgsQ = Q PatSynArgs
type FamilyResultSigQ = Q FamilyResultSig
type DerivStrategyQ = Q DerivStrategy
type Role = Role
type InjectivityAnn = InjectivityAnn
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
charL :: Char -> Lit
charPrimL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
rationalL :: Rational -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
unboxedTupP :: [PatQ] -> PatQ
unboxedSumP :: PatQ -> SumAlt -> SumArity -> PatQ
conP :: Name -> [PatQ] -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
recS :: [StmtQ] -> StmtQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
appTypeE :: ExpQ -> TypeQ -> ExpQ
parensE :: ExpQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
lamCaseE :: [MatchQ] -> ExpQ
tupE :: [ExpQ] -> ExpQ
unboxedTupE :: [ExpQ] -> ExpQ
unboxedSumE :: ExpQ -> SumAlt -> SumArity -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
multiIfE :: [Q (Guard, Exp)] -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
doE :: [StmtQ] -> ExpQ
mdoE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
arithSeqE :: RangeQ -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)

-- | <pre>
--   staticE x = [| static x |]
--   </pre>
staticE :: ExpQ -> ExpQ
unboundVarE :: Name -> ExpQ
labelE :: String -> ExpQ
implicitParamVarE :: String -> ExpQ
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndrQ] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndrQ] -> Maybe KindQ -> [ConQ] -> [DerivClauseQ] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndrQ] -> Maybe KindQ -> ConQ -> [DerivClauseQ] -> DecQ
classD :: CxtQ -> Name -> [TyVarBndrQ] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
instanceWithOverlapD :: Maybe Overlap -> CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
infixLD :: Int -> Name -> DecQ
infixRD :: Int -> Name -> DecQ
infixND :: Int -> Name -> DecQ
pragInlD :: Name -> Inline -> RuleMatch -> Phases -> DecQ
pragSpecD :: Name -> TypeQ -> Phases -> DecQ
pragSpecInlD :: Name -> TypeQ -> Inline -> Phases -> DecQ
pragSpecInstD :: TypeQ -> DecQ
pragRuleD :: String -> Maybe [TyVarBndrQ] -> [RuleBndrQ] -> ExpQ -> ExpQ -> Phases -> DecQ
pragAnnD :: AnnTarget -> ExpQ -> DecQ
pragLineD :: Int -> String -> DecQ
pragCompleteD :: [Name] -> Maybe Name -> DecQ
dataInstD :: CxtQ -> Maybe [TyVarBndrQ] -> TypeQ -> Maybe KindQ -> [ConQ] -> [DerivClauseQ] -> DecQ
newtypeInstD :: CxtQ -> Maybe [TyVarBndrQ] -> TypeQ -> Maybe KindQ -> ConQ -> [DerivClauseQ] -> DecQ
tySynInstD :: TySynEqnQ -> DecQ
dataFamilyD :: Name -> [TyVarBndrQ] -> Maybe KindQ -> DecQ
openTypeFamilyD :: Name -> [TyVarBndrQ] -> FamilyResultSigQ -> Maybe InjectivityAnn -> DecQ
closedTypeFamilyD :: Name -> [TyVarBndrQ] -> FamilyResultSigQ -> Maybe InjectivityAnn -> [TySynEqnQ] -> DecQ
roleAnnotD :: Name -> [Role] -> DecQ
standaloneDerivD :: CxtQ -> TypeQ -> DecQ
standaloneDerivWithStrategyD :: Maybe DerivStrategyQ -> CxtQ -> TypeQ -> DecQ
defaultSigD :: Name -> TypeQ -> DecQ

-- | Pattern synonym declaration
patSynD :: Name -> PatSynArgsQ -> PatSynDirQ -> PatQ -> DecQ

-- | Pattern synonym type signature
patSynSigD :: Name -> TypeQ -> DecQ

-- | Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
implicitParamBindD :: String -> ExpQ -> DecQ
tySynEqn :: Maybe [TyVarBndrQ] -> TypeQ -> TypeQ -> TySynEqnQ
cxt :: [PredQ] -> CxtQ
derivClause :: Maybe DerivStrategyQ -> [PredQ] -> DerivClauseQ
stockStrategy :: DerivStrategyQ
anyclassStrategy :: DerivStrategyQ
newtypeStrategy :: DerivStrategyQ
viaStrategy :: TypeQ -> DerivStrategyQ
normalC :: Name -> [BangTypeQ] -> ConQ
recC :: Name -> [VarBangTypeQ] -> ConQ
infixC :: Q (Bang, Type) -> Name -> Q (Bang, Type) -> ConQ
forallC :: [TyVarBndrQ] -> CxtQ -> ConQ -> ConQ
gadtC :: [Name] -> [StrictTypeQ] -> TypeQ -> ConQ
recGadtC :: [Name] -> [VarStrictTypeQ] -> TypeQ -> ConQ
forallT :: [TyVarBndrQ] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
infixT :: TypeQ -> Name -> TypeQ -> TypeQ
uInfixT :: TypeQ -> Name -> TypeQ -> TypeQ
parensT :: TypeQ -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
appKindT :: TypeQ -> KindQ -> TypeQ
arrowT :: TypeQ
listT :: TypeQ
litT :: TyLitQ -> TypeQ
tupleT :: Int -> TypeQ
unboxedTupleT :: Int -> TypeQ
unboxedSumT :: SumArity -> TypeQ
sigT :: TypeQ -> KindQ -> TypeQ
equalityT :: TypeQ
wildCardT :: TypeQ
implicitParamT :: String -> TypeQ -> TypeQ

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   use <a>conT</a> and <a>appT</a>.</i>
classP :: Name -> [Q Type] -> Q Pred

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   see <a>equalityT</a>.</i>
equalP :: TypeQ -> TypeQ -> PredQ
promotedT :: Name -> TypeQ
promotedTupleT :: Int -> TypeQ
promotedNilT :: TypeQ
promotedConsT :: TypeQ
noSourceUnpackedness :: SourceUnpackednessQ
sourceNoUnpack :: SourceUnpackednessQ
sourceUnpack :: SourceUnpackednessQ
noSourceStrictness :: SourceStrictnessQ
sourceLazy :: SourceStrictnessQ
sourceStrict :: SourceStrictnessQ

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness sourceStrict'</i>
isStrict :: Q Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness noSourceStrictness'</i>
notStrict :: Q Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Migration/8.0</a>. Example
--   usage: 'bang sourceUnpack sourceStrict'</i>
unpacked :: Q Strict
bang :: SourceUnpackednessQ -> SourceStrictnessQ -> BangQ
bangType :: BangQ -> TypeQ -> BangTypeQ
varBangType :: Name -> BangTypeQ -> VarBangTypeQ

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>StrictType</a> has been replaced by <a>BangType</a>. Please use
--   <a>bangType</a> instead.</i>
strictType :: Q Strict -> TypeQ -> StrictTypeQ

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>VarStrictType</a> has been replaced by <a>VarBangType</a>. Please
--   use <a>varBangType</a> instead.</i>
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
numTyLit :: Integer -> TyLitQ
strTyLit :: String -> TyLitQ
plainTV :: Name -> TyVarBndrQ
kindedTV :: Name -> KindQ -> TyVarBndrQ
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: KindQ
constraintK :: KindQ
noSig :: FamilyResultSigQ
kindSig :: KindQ -> FamilyResultSigQ
tyVarSig :: TyVarBndrQ -> FamilyResultSigQ
injectivityAnn :: Name -> [Name] -> InjectivityAnn
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
interruptible :: Safety
funDep :: [Name] -> [Name] -> FunDep
ruleVar :: Name -> RuleBndrQ
typedRuleVar :: Name -> TypeQ -> RuleBndrQ
valueAnnotation :: Name -> AnnTarget
typeAnnotation :: Name -> AnnTarget
moduleAnnotation :: AnnTarget
unidir :: PatSynDirQ
implBidir :: PatSynDirQ
explBidir :: [ClauseQ] -> PatSynDirQ
prefixPatSyn :: [Name] -> PatSynArgsQ
recordPatSyn :: [Name] -> PatSynArgsQ
infixPatSyn :: Name -> Name -> PatSynArgsQ
appsE :: [ExpQ] -> ExpQ

-- | Return the Module at the place of splicing. Can be used as an input
--   for <a>reifyModule</a>.
thisModule :: Q Module


-- | Language.Haskell.TH.Lib contains lots of useful helper functions for
--   generating and manipulating Template Haskell terms
module Language.Haskell.TH.Lib
type InfoQ = Q Info
type ExpQ = Q Exp
type TExpQ a = Q (TExp a)
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type KindQ = Q Kind
type TyVarBndrQ = Q TyVarBndr
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type DerivClauseQ = Q DerivClause
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type SourceStrictnessQ = Q SourceStrictness
type SourceUnpackednessQ = Q SourceUnpackedness
type BangQ = Q Bang
type BangTypeQ = Q BangType
type VarBangTypeQ = Q VarBangType
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
type PatSynDirQ = Q PatSynDir
type PatSynArgsQ = Q PatSynArgs
type FamilyResultSigQ = Q FamilyResultSig
type DerivStrategyQ = Q DerivStrategy
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
rationalL :: Rational -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
charPrimL :: Char -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
unboxedTupP :: [PatQ] -> PatQ
unboxedSumP :: PatQ -> SumAlt -> SumArity -> PatQ
conP :: Name -> [PatQ] -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> ExpQ
varE :: Name -> ExpQ
unboundVarE :: Name -> ExpQ
labelE :: String -> ExpQ
implicitParamVarE :: String -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ

-- | <pre>
--   staticE x = [| static x |]
--   </pre>
staticE :: ExpQ -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
appTypeE :: ExpQ -> TypeQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
parensE :: ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
lamCaseE :: [MatchQ] -> ExpQ
tupE :: [ExpQ] -> ExpQ
unboxedTupE :: [ExpQ] -> ExpQ
unboxedSumE :: ExpQ -> SumAlt -> SumArity -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
multiIfE :: [Q (Guard, Exp)] -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
appsE :: [ExpQ] -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
arithSeqE :: RangeQ -> ExpQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
doE :: [StmtQ] -> ExpQ
mdoE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
recS :: [StmtQ] -> StmtQ
forallT :: [TyVarBndr] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
appKindT :: TypeQ -> KindQ -> TypeQ
arrowT :: TypeQ
infixT :: TypeQ -> Name -> TypeQ -> TypeQ
uInfixT :: TypeQ -> Name -> TypeQ -> TypeQ
parensT :: TypeQ -> TypeQ
equalityT :: TypeQ
listT :: TypeQ
tupleT :: Int -> TypeQ
unboxedTupleT :: Int -> TypeQ
unboxedSumT :: SumArity -> TypeQ
sigT :: TypeQ -> Kind -> TypeQ
litT :: TyLitQ -> TypeQ
wildCardT :: TypeQ
promotedT :: Name -> TypeQ
promotedTupleT :: Int -> TypeQ
promotedNilT :: TypeQ
promotedConsT :: TypeQ
implicitParamT :: String -> TypeQ -> TypeQ
numTyLit :: Integer -> TyLitQ
strTyLit :: String -> TyLitQ
noSourceUnpackedness :: SourceUnpackednessQ
sourceNoUnpack :: SourceUnpackednessQ
sourceUnpack :: SourceUnpackednessQ
noSourceStrictness :: SourceStrictnessQ
sourceLazy :: SourceStrictnessQ
sourceStrict :: SourceStrictnessQ

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness sourceStrict'</i>
isStrict :: Q Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness noSourceStrictness'</i>
notStrict :: Q Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://ghc.haskell.org/trac/ghc/wiki/Migration/8.0</a>. Example
--   usage: 'bang sourceUnpack sourceStrict'</i>
unpacked :: Q Strict
bang :: SourceUnpackednessQ -> SourceStrictnessQ -> BangQ
bangType :: BangQ -> TypeQ -> BangTypeQ
varBangType :: Name -> BangTypeQ -> VarBangTypeQ

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>StrictType</a> has been replaced by <a>BangType</a>. Please use
--   <a>bangType</a> instead.</i>
strictType :: Q Strict -> TypeQ -> StrictTypeQ

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>VarStrictType</a> has been replaced by <a>VarBangType</a>. Please
--   use <a>varBangType</a> instead.</i>
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
cxt :: [PredQ] -> CxtQ

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   use <a>conT</a> and <a>appT</a>.</i>
classP :: Name -> [Q Type] -> Q Pred

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   see <a>equalityT</a>.</i>
equalP :: TypeQ -> TypeQ -> PredQ
normalC :: Name -> [BangTypeQ] -> ConQ
recC :: Name -> [VarBangTypeQ] -> ConQ
infixC :: Q (Bang, Type) -> Name -> Q (Bang, Type) -> ConQ
forallC :: [TyVarBndr] -> CxtQ -> ConQ -> ConQ
gadtC :: [Name] -> [StrictTypeQ] -> TypeQ -> ConQ
recGadtC :: [Name] -> [VarStrictTypeQ] -> TypeQ -> ConQ
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Kind
constraintK :: Kind
plainTV :: Name -> TyVarBndr
kindedTV :: Name -> Kind -> TyVarBndr
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndr] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndr] -> Maybe Kind -> [ConQ] -> [DerivClauseQ] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndr] -> Maybe Kind -> ConQ -> [DerivClauseQ] -> DecQ
derivClause :: Maybe DerivStrategy -> [PredQ] -> DerivClauseQ

-- | A single <tt>deriving</tt> clause at the end of a datatype.
data DerivClause

-- | <pre>
--   { deriving stock (Eq, Ord) }
--   </pre>
DerivClause :: Maybe DerivStrategy -> Cxt -> DerivClause
stockStrategy :: DerivStrategyQ
anyclassStrategy :: DerivStrategyQ
newtypeStrategy :: DerivStrategyQ
viaStrategy :: TypeQ -> DerivStrategyQ

-- | What the user explicitly requests when deriving an instance.
data DerivStrategy

-- | A "standard" derived instance
StockStrategy :: DerivStrategy

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: DerivStrategy

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: DerivStrategy

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: Type -> DerivStrategy
classD :: CxtQ -> Name -> [TyVarBndr] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
instanceWithOverlapD :: Maybe Overlap -> CxtQ -> TypeQ -> [DecQ] -> DecQ

-- | Varieties of allowed instance overlap.
data Overlap

-- | May be overlapped by more specific instances
Overlappable :: Overlap

-- | May overlap a more general instance
Overlapping :: Overlap

-- | Both <a>Overlapping</a> and <a>Overlappable</a>
Overlaps :: Overlap

-- | Both <a>Overlappable</a> and <a>Overlappable</a>, and pick an
--   arbitrary one if multiple choices are available.
Incoherent :: Overlap
sigD :: Name -> TypeQ -> DecQ
standaloneDerivD :: CxtQ -> TypeQ -> DecQ
standaloneDerivWithStrategyD :: Maybe DerivStrategy -> CxtQ -> TypeQ -> DecQ
defaultSigD :: Name -> TypeQ -> DecQ
roleAnnotD :: Name -> [Role] -> DecQ
dataFamilyD :: Name -> [TyVarBndr] -> Maybe Kind -> DecQ
openTypeFamilyD :: Name -> [TyVarBndr] -> FamilyResultSig -> Maybe InjectivityAnn -> DecQ
closedTypeFamilyD :: Name -> [TyVarBndr] -> FamilyResultSig -> Maybe InjectivityAnn -> [TySynEqnQ] -> DecQ
dataInstD :: CxtQ -> Name -> [TypeQ] -> Maybe Kind -> [ConQ] -> [DerivClauseQ] -> DecQ
newtypeInstD :: CxtQ -> Name -> [TypeQ] -> Maybe Kind -> ConQ -> [DerivClauseQ] -> DecQ
tySynInstD :: TySynEqnQ -> DecQ
tySynEqn :: Maybe [TyVarBndr] -> TypeQ -> TypeQ -> TySynEqnQ
injectivityAnn :: Name -> [Name] -> InjectivityAnn
noSig :: FamilyResultSig
kindSig :: Kind -> FamilyResultSig
tyVarSig :: TyVarBndr -> FamilyResultSig
infixLD :: Int -> Name -> DecQ
infixRD :: Int -> Name -> DecQ
infixND :: Int -> Name -> DecQ
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
interruptible :: Safety
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
funDep :: [Name] -> [Name] -> FunDep
ruleVar :: Name -> RuleBndrQ
typedRuleVar :: Name -> TypeQ -> RuleBndrQ
valueAnnotation :: Name -> AnnTarget
typeAnnotation :: Name -> AnnTarget
moduleAnnotation :: AnnTarget
pragInlD :: Name -> Inline -> RuleMatch -> Phases -> DecQ
pragSpecD :: Name -> TypeQ -> Phases -> DecQ
pragSpecInlD :: Name -> TypeQ -> Inline -> Phases -> DecQ
pragSpecInstD :: TypeQ -> DecQ
pragRuleD :: String -> [RuleBndrQ] -> ExpQ -> ExpQ -> Phases -> DecQ
pragAnnD :: AnnTarget -> ExpQ -> DecQ
pragLineD :: Int -> String -> DecQ
pragCompleteD :: [Name] -> Maybe Name -> DecQ

-- | Pattern synonym declaration
patSynD :: Name -> PatSynArgsQ -> PatSynDirQ -> PatQ -> DecQ

-- | Pattern synonym type signature
patSynSigD :: Name -> TypeQ -> DecQ
unidir :: PatSynDirQ
implBidir :: PatSynDirQ
explBidir :: [ClauseQ] -> PatSynDirQ
prefixPatSyn :: [Name] -> PatSynArgsQ
infixPatSyn :: Name -> Name -> PatSynArgsQ
recordPatSyn :: [Name] -> PatSynArgsQ

-- | Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
implicitParamBindD :: String -> ExpQ -> DecQ

-- | Return the Module at the place of splicing. Can be used as an input
--   for <a>reifyModule</a>.
thisModule :: Q Module


-- | The public face of Template Haskell
--   
--   For other documentation, refer to:
--   <a>http://www.haskell.org/haskellwiki/Template_Haskell</a>
module Language.Haskell.TH
data Q a
runQ :: Quasi m => Q a -> m a

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead</i>
report :: Bool -> String -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a

-- | The location at which this computation is spliced.
location :: Q Loc
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necessarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | <a>reify</a> looks up information about the <a>Name</a>.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyModule mod</tt> looks up information about module
--   <tt>mod</tt>. To look up the current module, call this function with
--   the return value of <a>thisModule</a>.
reifyModule :: Module -> Q ModuleInfo

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
ClassI :: Dec -> [InstanceDec] -> Info

-- | A class method
ClassOpI :: Name -> Type -> ParentName -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate. At present,
--   this reified declaration will never have derived instances attached to
--   it (if you wish to check for an instance, see <a>reifyInstances</a>).
TyConI :: Dec -> Info

-- | A type or data family, with a list of its visible instances. A closed
--   type family is returned with 0 instances.
FamilyI :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
PrimTyConI :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
DataConI :: Name -> Type -> ParentName -> Info

-- | A pattern synonym
PatSynI :: Name -> PatSynType -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable - including the RHS of the declaration - or
--   else <tt>Nothing</tt>, in the case where the RHS is unavailable to the
--   compiler. At present, this value is <i>always</i> <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
VarI :: Name -> Type -> Maybe Dec -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
TyVarI :: Name -> Type -> Info

-- | Obtained from <a>reifyModule</a> in the <a>Q</a> Monad.
data ModuleInfo

-- | Contains the import list of the module.
ModuleInfo :: [Module] -> ModuleInfo

-- | <a>InstanceDec</a> desribes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | In <a>UnboxedSumE</a> and <a>UnboxedSumP</a>, the number associated
--   with a particular data constructor. <a>SumAlt</a>s are one-indexed and
--   should never exceed the value of its corresponding <a>SumArity</a>.
--   For example:
--   
--   <ul>
--   <li><tt>(#_|#)</tt> has <a>SumAlt</a> 1 (out of a total
--   <a>SumArity</a> of 2)</li>
--   <li><tt>(#|_#)</tt> has <a>SumAlt</a> 2 (out of a total
--   <a>SumArity</a> of 2)</li>
--   </ul>
type SumAlt = Int

-- | In <a>UnboxedSumE</a>, <a>UnboxedSumT</a>, and <a>UnboxedSumP</a>, the
--   total number of <a>SumAlt</a>s. For example, <tt>(#|#)</tt> has a
--   <a>SumArity</a> of 2.
type SumArity = Int

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | The language extensions known to GHC.
--   
--   Note that there is an orphan <tt>Binary</tt> instance for this type
--   supplied by the <a>GHC.LanguageExtensions</a> module provided by
--   <tt>ghc-boot</tt>. We can't provide here as this would require adding
--   transitive dependencies to the <tt>template-haskell</tt> package,
--   which must have a minimal dependency set.
data Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoPatBinds :: Extension
MonoLocalBinds :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
RecordPuns :: Extension
ViewPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
MonadFailDesugaring :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension

-- | List all enabled language extensions.
extsEnabled :: Q [Extension]

-- | Determine whether the given language extension is enabled in the
--   <a>Q</a> monad.
isExtEnabled :: Extension -> Q Bool

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <tt>reifyFixity nm</tt> attempts to find a fixity declaration for
--   <tt>nm</tt>. For example, if the function <tt>foo</tt> has the fixity
--   declaration <tt>infixr 7 foo</tt>, then <tt>reifyFixity 'foo</tt>
--   would return <tt><a>Just</a> (<a>Fixity</a> 7 <a>InfixR</a>)</tt>. If
--   the function <tt>bar</tt> does not have a fixity declaration, then
--   <tt>reifyFixity 'bar</tt> returns <a>Nothing</a>, so you may assume
--   <tt>bar</tt> has <a>defaultFixity</a>.
reifyFixity :: Name -> Q (Maybe Fixity)

-- | <tt>reifyInstances nm tys</tt> returns a list of visible instances of
--   <tt>nm tys</tt>. That is, if <tt>nm</tt> is the name of a type class,
--   then all instances of this class at the types <tt>tys</tt> are
--   returned. Alternatively, if <tt>nm</tt> is the name of a data family
--   or type family, all instances of this family at the types <tt>tys</tt>
--   are returned.
--   
--   Note that this is a "shallow" test; the declarations returned merely
--   have instance heads which unify with <tt>nm tys</tt>, they need not
--   actually be satisfiable.
--   
--   <ul>
--   <li><tt>reifyInstances ''Eq [ <a>TupleT</a> 2 `<a>AppT</a>`
--   <a>ConT</a> ''A `<a>AppT</a>` <a>ConT</a> ''B ]</tt> contains the
--   <tt>instance (Eq a, Eq b) =&gt; Eq (a, b)</tt> regardless of whether
--   <tt>A</tt> and <tt>B</tt> themselves implement <a>Eq</a></li>
--   <li><tt>reifyInstances ''Show [ <a>VarT</a> (<a>mkName</a> "a") ]</tt>
--   produces every available instance of <a>Eq</a></li>
--   </ul>
--   
--   There is one edge case: <tt>reifyInstances ''Typeable tys</tt>
--   currently always produces an empty list (no matter what <tt>tys</tt>
--   are given).
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
isInstance :: Name -> [Type] -> Q Bool

-- | <tt>reifyRoles nm</tt> returns the list of roles associated with the
--   parameters of the tycon <tt>nm</tt>. Fails if <tt>nm</tt> cannot be
--   found or is not a tycon. The returned list should never contain
--   <a>InferR</a>.
reifyRoles :: Name -> Q [Role]

-- | <tt>reifyAnnotations target</tt> returns the list of annotations
--   associated with <tt>target</tt>. Only the annotations that are
--   appropriately typed is returned. So if you have <tt>Int</tt> and
--   <tt>String</tt> annotations for the same target, you have to call this
--   function twice.
reifyAnnotations :: Data a => AnnLookup -> Q [a]

-- | Annotation target for reifyAnnotations
data AnnLookup
AnnLookupModule :: Module -> AnnLookup
AnnLookupName :: Name -> AnnLookup

-- | <tt>reifyConStrictness nm</tt> looks up the strictness information for
--   the fields of the constructor with the name <tt>nm</tt>. Note that the
--   strictness information that <a>reifyConStrictness</a> returns may not
--   correspond to what is written in the source code. For example, in the
--   following data declaration:
--   
--   <pre>
--   data Pair a = Pair a a
--   </pre>
--   
--   <a>reifyConStrictness</a> would return <tt>[<a>DecidedLazy</a>,
--   DecidedLazy]</tt> under most circumstances, but it would return
--   <tt>[<a>DecidedStrict</a>, DecidedStrict]</tt> if the
--   <tt>-XStrictData</tt> language extension was enabled.
reifyConStrictness :: Name -> Q [DecidedStrictness]
data TExp a
unType :: TExp a -> Exp

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
data NameSpace

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <a>dyn</a> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = <a>mkName</a> "x"
--     return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: String -> Q Name

-- | The name without its module prefix.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameBase ''Data.Either.Either
--   "Either"
--   
--   &gt;&gt;&gt; nameBase (mkName "foo")
--   "foo"
--   
--   &gt;&gt;&gt; nameBase (mkName "Module.foo")
--   "foo"
--   </pre>
nameBase :: Name -> String

-- | Module prefix of a name, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameModule ''Data.Either.Either
--   Just "Data.Either"
--   
--   &gt;&gt;&gt; nameModule (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; nameModule (mkName "Module.foo")
--   Just "Module"
--   </pre>
nameModule :: Name -> Maybe String

-- | A name's package, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; namePackage ''Data.Either.Either
--   Just "base"
--   
--   &gt;&gt;&gt; namePackage (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; namePackage (mkName "Module.foo")
--   Nothing
--   </pre>
namePackage :: Name -> Maybe String

-- | Returns whether a name represents an occurrence of a top-level
--   variable (<a>VarName</a>), data constructor (<a>DataName</a>), type
--   constructor, or type class (<a>TcClsName</a>). If we can't be sure, it
--   returns <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameSpace 'Prelude.id
--   Just VarName
--   
--   &gt;&gt;&gt; nameSpace (mkName "id")
--   Nothing -- only works for top-level variable names
--   
--   &gt;&gt;&gt; nameSpace 'Data.Maybe.Just
--   Just DataName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Maybe.Maybe
--   Just TcClsName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Ord.Ord
--   Just TcClsName
--   </pre>
nameSpace :: Name -> Maybe NameSpace

-- | Tuple type constructor
tupleTypeName :: Int -> Name

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name

-- | Unboxed sum type constructor
unboxedSumTypeName :: SumArity -> Name

-- | Unboxed sum data constructor
unboxedSumDataName :: SumAlt -> SumArity -> Name
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr] -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W Q)
--          deriving stock Eq }
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr] -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance {-# OVERLAPS #-}
--           Show w =&gt; Show [w] where ds }
--   </pre>
InstanceD :: Maybe Overlap -> Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
ForeignD :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
InfixD :: Fixity -> Name -> Dec

-- | <pre>
--   { {-# INLINE [1] foo #-} }
--   </pre>
PragmaD :: Pragma -> Dec

-- | <pre>
--   { data family T a b c :: * }
--   </pre>
DataFamilyD :: Name -> [TyVarBndr] -> Maybe Kind -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x]
--          = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataInstD :: Cxt -> Maybe [TyVarBndr] -> Type -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x]
--           = A (B x)
--           deriving (Z,W)
--           deriving stock Eq }
--   </pre>
NewtypeInstD :: Cxt -> Maybe [TyVarBndr] -> Type -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type instance ... }
--   </pre>
TySynInstD :: TySynEqn -> Dec

-- | <pre>
--   { type family T a b c = (r :: *) | r -&gt; a b }
--   </pre>
OpenTypeFamilyD :: TypeFamilyHead -> Dec

-- | <pre>
--   { type family F a b = (r :: *) | r -&gt; a where ... }
--   </pre>
ClosedTypeFamilyD :: TypeFamilyHead -> [TySynEqn] -> Dec

-- | <pre>
--   { type role T nominal representational }
--   </pre>
RoleAnnotD :: Name -> [Role] -> Dec

-- | <pre>
--   { deriving stock instance Ord a =&gt; Ord (Foo a) }
--   </pre>
StandaloneDerivD :: Maybe DerivStrategy -> Cxt -> Type -> Dec

-- | <pre>
--   { default size :: Data a =&gt; a -&gt; Int }
--   </pre>
DefaultSigD :: Name -> Type -> Dec

-- | <tt>{ pattern P v1 v2 .. vn &lt;- p }</tt> unidirectional or <tt>{
--   pattern P v1 v2 .. vn = p }</tt> implicit bidirectional or <tt>{
--   pattern P v1 v2 .. vn &lt;- p where P v1 v2 .. vn = e }</tt> explicit
--   bidirectional
--   
--   also, besides prefix pattern synonyms, both infix and record pattern
--   synonyms are supported. See <a>PatSynArgs</a> for details
PatSynD :: Name -> PatSynArgs -> PatSynDir -> Pat -> Dec

-- | A pattern synonym's type signature.
PatSynSigD :: Name -> PatSynType -> Dec

-- | <pre>
--   { ?x = expr }
--   </pre>
--   
--   Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
ImplicitParamBindD :: String -> Exp -> Dec

-- | A single data constructor.
--   
--   The constructors for <a>Con</a> can roughly be divided up into two
--   categories: those for constructors with "vanilla" syntax
--   (<a>NormalC</a>, <a>RecC</a>, and <a>InfixC</a>), and those for
--   constructors with GADT syntax (<a>GadtC</a> and <a>RecGadtC</a>). The
--   <a>ForallC</a> constructor, which quantifies additional type variables
--   and class contexts, can surround either variety of constructor.
--   However, the type variables that it quantifies are different depending
--   on what constructor syntax is used:
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with vanilla syntax,
--   then the <a>ForallC</a> will only quantify <i>existential</i> type
--   variables. For example:</li>
--   </ul>
--   
--   <pre>
--   data Foo a = forall b. MkFoo a b
--   
--   </pre>
--   
--   In <tt>MkFoo</tt>, <a>ForallC</a> will quantify <tt>b</tt>, but not
--   <tt>a</tt>.
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with GADT syntax, then
--   the <a>ForallC</a> will quantify <i>all</i> type variables used in the
--   constructor. For example:</li>
--   </ul>
--   
--   <pre>
--   data Bar a b where
--     MkBar :: (a ~ b) =&gt; c -&gt; MkBar a b
--   
--   </pre>
--   
--   In <tt>MkBar</tt>, <a>ForallC</a> will quantify <tt>a</tt>,
--   <tt>b</tt>, and <tt>c</tt>.
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [BangType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarBangType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: BangType -> Name -> BangType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr] -> Cxt -> Con -> Con

-- | <pre>
--   C :: a -&gt; b -&gt; T b Int
--   </pre>
GadtC :: [Name] -> [BangType] -> Type -> Con

-- | <pre>
--   C :: { v :: Int } -&gt; T b Int
--   </pre>
RecGadtC :: [Name] -> [VarBangType] -> Type -> Con
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause
data SourceUnpackedness

-- | <pre>
--   C a
--   </pre>
NoSourceUnpackedness :: SourceUnpackedness

-- | <pre>
--   C { {-# NOUNPACK #-} } a
--   </pre>
SourceNoUnpack :: SourceUnpackedness

-- | <pre>
--   C { {-# UNPACK #-} } a
--   </pre>
SourceUnpack :: SourceUnpackedness
data SourceStrictness

-- | <pre>
--   C a
--   </pre>
NoSourceStrictness :: SourceStrictness

-- | <pre>
--   C {~}a
--   </pre>
SourceLazy :: SourceStrictness

-- | <pre>
--   C {!}a
--   </pre>
SourceStrict :: SourceStrictness

-- | Unlike <a>SourceStrictness</a> and <a>SourceUnpackedness</a>,
--   <a>DecidedStrictness</a> refers to the strictness that the compiler
--   chooses for a data constructor field, which may be different from what
--   is written in source code. See <a>reifyConStrictness</a> for more
--   information.
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness
data Bang

-- | <pre>
--   C { {-# UNPACK #-} !}a
--   </pre>
Bang :: SourceUnpackedness -> SourceStrictness -> Bang

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>Strict</a> has been
--   replaced by <a>Bang</a>.
type Strict = Bang
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
CApi :: Callconv
Prim :: Callconv
JavaScript :: Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
SpecialiseP :: Name -> Type -> Maybe Inline -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> Maybe [TyVarBndr] -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
AnnP :: AnnTarget -> Exp -> Pragma
LineP :: Int -> String -> Pragma

-- | <pre>
--   { {-# COMPLETE C_1, ..., C_i [ :: T ] #-} }
--   </pre>
CompleteP :: [Name] -> Maybe Name -> Pragma
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
data AnnTarget
ModuleAnnotation :: AnnTarget
TypeAnnotation :: Name -> AnnTarget
ValueAnnotation :: Name -> AnnTarget
data FunDep
FunDep :: [Name] -> [Name] -> FunDep

-- | One equation of a type family instance or closed type family. The
--   arguments are the left-hand-side type and the right-hand-side result.
--   
--   For instance, if you had the following type family:
--   
--   <pre>
--   type family Foo (a :: k) :: k where
--     forall k (a :: k). Foo @k a = a
--   </pre>
--   
--   The <tt>Foo @k a = a</tt> equation would be represented as follows:
--   
--   <pre>
--   <a>TySynEqn</a> (<a>Just</a> [<a>PlainTV</a> k, <a>KindedTV</a> a (<a>VarT</a> k)])
--              (<a>AppT</a> (<a>AppKindT</a> (<a>ConT</a> ''Foo) (<a>VarT</a> k)) (<a>VarT</a> a))
--              (<a>VarT</a> a)
--   </pre>
data TySynEqn
TySynEqn :: Maybe [TyVarBndr] -> Type -> Type -> TySynEqn

-- | Common elements of <a>OpenTypeFamilyD</a> and
--   <a>ClosedTypeFamilyD</a>. By analogy with "head" for type classes and
--   type class instances as defined in <i>Type classes: an exploration of
--   the design space</i>, the <tt>TypeFamilyHead</tt> is defined to be the
--   elements of the declaration between <tt>type family</tt> and
--   <tt>where</tt>.
data TypeFamilyHead
TypeFamilyHead :: Name -> [TyVarBndr] -> FamilyResultSig -> Maybe InjectivityAnn -> TypeFamilyHead
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int

-- | A pattern synonym's directionality.
data PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p
--   </pre>
Unidir :: PatSynDir

-- | <pre>
--   pattern P x {=} p
--   </pre>
ImplBidir :: PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p where P x = e
--   </pre>
ExplBidir :: [Clause] -> PatSynDir

-- | A pattern synonym's argument type.
data PatSynArgs

-- | <pre>
--   pattern P {x y z} = p
--   </pre>
PrefixPatSyn :: [Name] -> PatSynArgs

-- | <pre>
--   pattern {x P y} = p
--   </pre>
InfixPatSyn :: Name -> Name -> PatSynArgs

-- | <pre>
--   pattern P { {x,y,z} } = p
--   </pre>
RecordPatSyn :: [Name] -> PatSynArgs
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or 'c'}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   { f @Int }
--   </pre>
AppTypeE :: Exp -> Type -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   { \ p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { \case m1; m2 }
--   </pre>
LamCaseE :: [Match] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
TupE :: [Exp] -> Exp

-- | <pre>
--   { (# e1,e2 #) }
--   </pre>
UnboxedTupE :: [Exp] -> Exp

-- | <pre>
--   { (#|e|#) }
--   </pre>
UnboxedSumE :: Exp -> SumAlt -> SumArity -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
MultiIfE :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let { x=e1; y=e2 } in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
DoE :: [Stmt] -> Exp

-- | <pre>
--   { mdo { x &lt;- e1 y; y &lt;- e2 x; } }
--   </pre>
MDoE :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp

-- | <pre>
--   { static e }
--   </pre>
StaticE :: Exp -> Exp

-- | <pre>
--   { _x }
--   </pre>
--   
--   This is used for holes or unresolved identifiers in AST quotes. Note
--   that it could either have a variable name or constructor name.
UnboundVarE :: Name -> Exp

-- | <tt>{ #x }</tt> ( Overloaded label )
LabelE :: String -> Exp

-- | <tt>{ ?x }</tt> ( Implicit parameter )
ImplicitParamVarE :: String -> Exp
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
data Body

-- | <pre>
--   f p { | e1 = e2
--         | e3 = e4 }
--    where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
NormalG :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
PatG :: [Stmt] -> Guard
data Stmt

-- | <pre>
--   p &lt;- e
--   </pre>
BindS :: Pat -> Exp -> Stmt

-- | <pre>
--   { let { x=e1; y=e2 } }
--   </pre>
LetS :: [Dec] -> Stmt

-- | <pre>
--   e
--   </pre>
NoBindS :: Exp -> Stmt

-- | <tt>x &lt;- e1 | s2, s3 | s4</tt> (in <a>CompE</a>)
ParS :: [[Stmt]] -> Stmt

-- | <pre>
--   rec { s1; s2 }
--   </pre>
RecS :: [Stmt] -> Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type Addr#
StringPrimL :: [Word8] -> Lit
CharPrimL :: Char -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or 'c' }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { (# p1,p2 #) }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   { (#|p|#) }
--   </pre>
UnboxedSumP :: Pat -> SumAlt -> SumArity -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
ConP :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; =&gt; &lt;type&gt;
--   </pre>
ForallT :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   T @k t
--   </pre>
AppKindT :: Type -> Kind -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   'T
--   </pre>
PromotedT :: Name -> Type

-- | <pre>
--   T + T
--   </pre>
InfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T + T
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   (T)
--   </pre>
ParensT :: Type -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
TupleT :: Int -> Type

-- | <pre>
--   (#,#), (#,,#), etc.
--   </pre>
UnboxedTupleT :: Int -> Type

-- | <pre>
--   (#|#), (#||#), etc.
--   </pre>
UnboxedSumT :: SumArity -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   ~
--   </pre>
EqualityT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <pre>
--   '(), '(,), '(,,), etc.
--   </pre>
PromotedTupleT :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
PromotedNilT :: Type

-- | <pre>
--   (':)
--   </pre>
PromotedConsT :: Type

-- | <pre>
--   *
--   </pre>
StarT :: Type

-- | <pre>
--   Constraint
--   </pre>
ConstraintT :: Type

-- | <pre>
--   0,1,2, etc.
--   </pre>
LitT :: TyLit -> Type

-- | <pre>
--   _
--   </pre>
WildCardT :: Type

-- | <pre>
--   ?x :: t
--   </pre>
ImplicitParamT :: String -> Type -> Type
data TyVarBndr

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> Kind -> TyVarBndr
data TyLit

-- | <pre>
--   2
--   </pre>
NumTyLit :: Integer -> TyLit

-- | <pre>
--   "Hello"
--   </pre>
StrTyLit :: String -> TyLit

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type
type Cxt = [Pred] " @(Eq a, Ord b)@"

-- | Since the advent of <tt>ConstraintKinds</tt>, constraints are really
--   just types. Equality constraints use the <a>EqualityT</a> constructor.
--   Constraints may also be tuples of other constraints.
type Pred = Type

-- | Role annotations
data Role

-- | <pre>
--   nominal
--   </pre>
NominalR :: Role

-- | <pre>
--   representational
--   </pre>
RepresentationalR :: Role

-- | <pre>
--   phantom
--   </pre>
PhantomR :: Role

-- | <pre>
--   _
--   </pre>
InferR :: Role

-- | Type family result signature
data FamilyResultSig

-- | no signature
NoSig :: FamilyResultSig

-- | <pre>
--   k
--   </pre>
KindSig :: Kind -> FamilyResultSig

-- | <pre>
--   = r, = (r :: k)
--   </pre>
TyVarSig :: TyVarBndr -> FamilyResultSig

-- | Injectivity annotation
data InjectivityAnn
InjectivityAnn :: Name -> [Name] -> InjectivityAnn

-- | A pattern synonym's type. Note that a pattern synonym's <i>fully</i>
--   specified type has a peculiar shape coming with two forall quantifiers
--   and two constraint contexts. For example, consider the pattern synonym
--   
--   <pre>
--   pattern P x1 x2 ... xn = &lt;some-pattern&gt;
--   </pre>
--   
--   P's complete type is of the following form
--   
--   <pre>
--   pattern P :: forall universals.   required constraints
--             =&gt; forall existentials. provided constraints
--             =&gt; t1 -&gt; t2 -&gt; ... -&gt; tn -&gt; t
--   </pre>
--   
--   consisting of four parts:
--   
--   <ol>
--   <li>the (possibly empty lists of) universally quantified type
--   variables and required constraints on them.</li>
--   <li>the (possibly empty lists of) existentially quantified type
--   variables and the provided constraints on them.</li>
--   <li>the types <tt>t1</tt>, <tt>t2</tt>, .., <tt>tn</tt> of
--   <tt>x1</tt>, <tt>x2</tt>, .., <tt>xn</tt>, respectively</li>
--   <li>the type <tt>t</tt> of <tt>&lt;some-pattern&gt;</tt>, mentioning
--   only universals.</li>
--   </ol>
--   
--   Pattern synonym types interact with TH when (a) reifying a pattern
--   synonym, (b) pretty printing, or (c) specifying a pattern synonym's
--   type signature explicitly:
--   
--   <ul>
--   <li>Reification always returns a pattern synonym's <i>fully</i>
--   specified type in abstract syntax.</li>
--   <li>Pretty printing via <a>pprPatSynType</a> abbreviates a pattern
--   synonym's type unambiguously in concrete syntax: The rule of thumb is
--   to print initial empty universals and the required context as <tt>()
--   =&gt;</tt>, if existentials and a provided context follow. If only
--   universals and their required context, but no existentials are
--   specified, only the universals and their required context are printed.
--   If both or none are specified, so both (or none) are printed.</li>
--   <li>When specifying a pattern synonym's type explicitly with
--   <a>PatSynSigD</a> either one of the universals, the existentials, or
--   their contexts may be left empty.</li>
--   </ul>
--   
--   See the GHC user's guide for more information on pattern synonyms and
--   their types:
--   <a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms</a>.
type PatSynType = Type
class Ppr a
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
pprint :: Ppr a => a -> String
pprExp :: Precedence -> Exp -> Doc
pprLit :: Precedence -> Lit -> Doc
pprPat :: Precedence -> Pat -> Doc
pprParendType :: Type -> Doc

module GHCi.TH.Binary
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Loc
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Name
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.ModName
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.NameFlavour
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.PkgName
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.NameSpace
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Module
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Info
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Type
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.TyLit
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.TyVarBndr
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Role
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Lit
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Range
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Stmt
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Pat
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Exp
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Dec
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Overlap
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.DerivClause
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.DerivStrategy
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Guard
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Body
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Match
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Fixity
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.TySynEqn
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.FunDep
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.AnnTarget
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.RuleBndr
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Phases
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.RuleMatch
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Inline
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Pragma
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Safety
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Callconv
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Foreign
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Bang
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.SourceUnpackedness
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.SourceStrictness
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.DecidedStrictness
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.FixityDirection
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.OccName
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Con
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.AnnLookup
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.ModuleInfo
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.Clause
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.InjectivityAnn
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.FamilyResultSig
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.TypeFamilyHead
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.PatSynDir
instance Data.Binary.Class.Binary Language.Haskell.TH.Syntax.PatSynArgs
instance Data.Binary.Class.Binary GHC.Serialized.Serialized


-- | Remote GHCi message types and serialization.
--   
--   For details on Remote GHCi, see Note [Remote GHCi] in
--   compiler<i>ghci</i>GHCi.hs.
module GHCi.Message

-- | A <tt>Message a</tt> is a message that returns a value of type
--   <tt>a</tt>. These are requests sent from GHC to the server.
data Message a

-- | Exit the iserv process
[Shutdown] :: Message ()
[InitLinker] :: Message ()
[LookupSymbol] :: String -> Message (Maybe (RemotePtr ()))
[LookupClosure] :: String -> Message (Maybe HValueRef)
[LoadDLL] :: String -> Message (Maybe String)
[LoadArchive] :: String -> Message ()
[LoadObj] :: String -> Message ()
[UnloadObj] :: String -> Message ()
[AddLibrarySearchPath] :: String -> Message (RemotePtr ())
[RemoveLibrarySearchPath] :: RemotePtr () -> Message Bool
[ResolveObjs] :: Message Bool
[FindSystemLibrary] :: String -> Message (Maybe String)

-- | Create a set of BCO objects, and return HValueRefs to them Note: Each
--   ByteString contains a Binary-encoded [ResolvedBCO], not a ResolvedBCO.
--   The list is to allow us to serialise the ResolvedBCOs in parallel. See
--   <tt>createBCOs</tt> in compiler<i>ghci</i>GHCi.hsc.
[CreateBCOs] :: [ByteString] -> Message [HValueRef]

-- | Release <a>HValueRef</a>s
[FreeHValueRefs] :: [HValueRef] -> Message ()

-- | Add entries to the Static Pointer Table
[AddSptEntry] :: Fingerprint -> HValueRef -> Message ()

-- | Malloc some data and return a <a>RemotePtr</a> to it
[MallocData] :: ByteString -> Message (RemotePtr ())
[MallocStrings] :: [ByteString] -> Message [RemotePtr ()]

-- | Calls <a>prepareForeignCall</a>
[PrepFFI] :: FFIConv -> [FFIType] -> FFIType -> Message (RemotePtr C_ffi_cif)

-- | Free data previously created by <a>PrepFFI</a>
[FreeFFI] :: RemotePtr C_ffi_cif -> Message ()

-- | Create an info table for a constructor
[MkConInfoTable] :: Int -> Int -> Int -> Int -> [Word8] -> Message (RemotePtr StgInfoTable)

-- | Evaluate a statement
[EvalStmt] :: EvalOpts -> EvalExpr HValueRef -> Message (EvalStatus [HValueRef])

-- | Resume evaluation of a statement after a breakpoint
[ResumeStmt] :: EvalOpts -> RemoteRef (ResumeContext [HValueRef]) -> Message (EvalStatus [HValueRef])

-- | Abandon evaluation of a statement after a breakpoint
[AbandonStmt] :: RemoteRef (ResumeContext [HValueRef]) -> Message ()

-- | Evaluate something of type <tt>IO String</tt>
[EvalString] :: HValueRef -> Message (EvalResult String)

-- | Evaluate something of type <tt>String -&gt; IO String</tt>
[EvalStringToString] :: HValueRef -> String -> Message (EvalResult String)

-- | Evaluate something of type <tt>IO ()</tt>
[EvalIO] :: HValueRef -> Message (EvalResult ())

-- | Create a set of CostCentres with the same module name
[MkCostCentres] :: String -> [(String, String)] -> Message [RemotePtr CostCentre]

-- | Show a <a>CostCentreStack</a> as a <tt>[String]</tt>
[CostCentreStackInfo] :: RemotePtr CostCentreStack -> Message [String]

-- | Create a new array of breakpoint flags
[NewBreakArray] :: Int -> Message (RemoteRef BreakArray)

-- | Enable a breakpoint
[EnableBreakpoint] :: RemoteRef BreakArray -> Int -> Bool -> Message ()

-- | Query the status of a breakpoint (True <a>=</a> enabled)
[BreakpointStatus] :: RemoteRef BreakArray -> Int -> Message Bool

-- | Get a reference to a free variable at a breakpoint
[GetBreakpointVar] :: HValueRef -> Int -> Message (Maybe HValueRef)

-- | Start a new TH module, return a state token that should be
[StartTH] :: Message (RemoteRef (IORef QState))

-- | Evaluate a TH computation.
--   
--   Returns a ByteString, because we have to force the result before
--   returning it to ensure there are no errors lurking in it. The TH types
--   don't have NFData instances, and even if they did, we have to
--   serialize the value anyway, so we might as well serialize it to force
--   it.
[RunTH] :: RemoteRef (IORef QState) -> HValueRef -> THResultType -> Maybe Loc -> Message (QResult ByteString)

-- | Run the given mod finalizers.
[RunModFinalizers] :: RemoteRef (IORef QState) -> [RemoteRef (Q ())] -> Message (QResult ())

-- | Remote interface to GHC.Exts.Heap.getClosureData. This is used by the
--   GHCi debugger to inspect values in the heap for :print and type
--   reconstruction.
[GetClosure] :: HValueRef -> Message (GenClosure HValueRef)

-- | Evaluate something. This is used to support :force in GHCi.
[Seq] :: HValueRef -> Message (EvalResult ())
data Msg
Msg :: Message a -> Msg

-- | Messages sent back to GHC from GHCi.TH, to implement the methods of
--   <tt>Quasi</tt>. For an overview of how TH works with Remote GHCi, see
--   Note [Remote Template Haskell] in GHCi.TH.
data THMessage a
[NewName] :: String -> THMessage (THResult Name)
[Report] :: Bool -> String -> THMessage (THResult ())
[LookupName] :: Bool -> String -> THMessage (THResult (Maybe Name))
[Reify] :: Name -> THMessage (THResult Info)
[ReifyFixity] :: Name -> THMessage (THResult (Maybe Fixity))
[ReifyInstances] :: Name -> [Type] -> THMessage (THResult [Dec])
[ReifyRoles] :: Name -> THMessage (THResult [Role])
[ReifyAnnotations] :: AnnLookup -> TypeRep -> THMessage (THResult [ByteString])
[ReifyModule] :: Module -> THMessage (THResult ModuleInfo)
[ReifyConStrictness] :: Name -> THMessage (THResult [DecidedStrictness])
[AddDependentFile] :: FilePath -> THMessage (THResult ())
[AddTempFile] :: String -> THMessage (THResult FilePath)
[AddModFinalizer] :: RemoteRef (Q ()) -> THMessage (THResult ())
[AddCorePlugin] :: String -> THMessage (THResult ())
[AddTopDecls] :: [Dec] -> THMessage (THResult ())
[AddForeignFilePath] :: ForeignSrcLang -> FilePath -> THMessage (THResult ())
[IsExtEnabled] :: Extension -> THMessage (THResult Bool)
[ExtsEnabled] :: THMessage (THResult [Extension])
[StartRecover] :: THMessage ()
[EndRecover] :: Bool -> THMessage ()
[FailIfErrs] :: THMessage (THResult ())

-- | Indicates that this RunTH is finished, and the next message will be
--   the result of RunTH (a QResult).
[RunTHDone] :: THMessage ()
data THMsg
THMsg :: THMessage a -> THMsg

-- | Template Haskell return values
data QResult a

-- | RunTH finished successfully; return value follows
QDone :: a -> QResult a

-- | RunTH threw an exception
QException :: String -> QResult a

-- | RunTH called <a>fail</a>
QFail :: String -> QResult a
data EvalStatus_ a b
EvalComplete :: Word64 -> EvalResult a -> EvalStatus_ a b
EvalBreak :: Bool -> HValueRef -> Int -> Int -> RemoteRef (ResumeContext b) -> RemotePtr CostCentreStack -> EvalStatus_ a b
type EvalStatus a = EvalStatus_ a a
data EvalResult a
EvalException :: SerializableException -> EvalResult a
EvalSuccess :: a -> EvalResult a
data EvalOpts
EvalOpts :: Bool -> Bool -> Bool -> Bool -> EvalOpts
[useSandboxThread] :: EvalOpts -> Bool
[singleStep] :: EvalOpts -> Bool
[breakOnException] :: EvalOpts -> Bool
[breakOnError] :: EvalOpts -> Bool

-- | We can pass simple expressions to EvalStmt, consisting of values and
--   application. This allows us to wrap the statement to be executed in
--   another function, which is used by GHCi to implement :set args and
--   :set prog. It might be worthwhile to extend this little language in
--   the future.
data EvalExpr a
EvalThis :: a -> EvalExpr a
EvalApp :: EvalExpr a -> EvalExpr a -> EvalExpr a
data SerializableException
EUserInterrupt :: SerializableException
EExitCode :: ExitCode -> SerializableException
EOtherException :: String -> SerializableException
toSerializableException :: SomeException -> SerializableException
fromSerializableException :: SerializableException -> SomeException
data THResult a
THException :: String -> THResult a
THComplete :: a -> THResult a
data THResultType
THExp :: THResultType
THPat :: THResultType
THType :: THResultType
THDec :: THResultType
THAnnWrapper :: THResultType
data ResumeContext a
ResumeContext :: MVar () -> MVar (EvalStatus a) -> ThreadId -> ResumeContext a
[resumeBreakMVar] :: ResumeContext a -> MVar ()
[resumeStatusMVar] :: ResumeContext a -> MVar (EvalStatus a)
[resumeThreadId] :: ResumeContext a -> ThreadId

-- | The server-side Template Haskell state. This is created by the StartTH
--   message. A new one is created per module that GHC typechecks.
data QState
QState :: Map TypeRep Dynamic -> Maybe Loc -> Pipe -> QState

-- | persistent data between splices in a module
[qsMap] :: QState -> Map TypeRep Dynamic

-- | location for current splice, if any
[qsLocation] :: QState -> Maybe Loc

-- | pipe to communicate with GHC
[qsPipe] :: QState -> Pipe
getMessage :: Get Msg
putMessage :: Message a -> Put
getTHMessage :: Get THMsg
putTHMessage :: THMessage a -> Put
data Pipe
Pipe :: Handle -> Handle -> IORef (Maybe ByteString) -> Pipe
[pipeRead] :: Pipe -> Handle
[pipeWrite] :: Pipe -> Handle
[pipeLeftovers] :: Pipe -> IORef (Maybe ByteString)
remoteCall :: Binary a => Pipe -> Message a -> IO a
remoteTHCall :: Binary a => Pipe -> THMessage a -> IO a
readPipe :: Pipe -> Get a -> IO a
writePipe :: Pipe -> Put -> IO ()
instance GHC.Generics.Generic GHCi.Message.THResultType
instance GHC.Show.Show GHCi.Message.THResultType
instance GHC.Enum.Enum GHCi.Message.THResultType
instance GHC.Show.Show a => GHC.Show.Show (GHCi.Message.THResult a)
instance GHC.Generics.Generic (GHCi.Message.THResult a)
instance GHC.Show.Show a => GHC.Show.Show (GHCi.Message.EvalStatus_ a b)
instance GHC.Generics.Generic (GHCi.Message.EvalStatus_ a b)
instance GHC.Show.Show a => GHC.Show.Show (GHCi.Message.EvalResult a)
instance GHC.Generics.Generic (GHCi.Message.EvalResult a)
instance GHC.Show.Show GHCi.Message.SerializableException
instance GHC.Generics.Generic GHCi.Message.SerializableException
instance GHC.Show.Show a => GHC.Show.Show (GHCi.Message.EvalExpr a)
instance GHC.Generics.Generic (GHCi.Message.EvalExpr a)
instance GHC.Show.Show GHCi.Message.EvalOpts
instance GHC.Generics.Generic GHCi.Message.EvalOpts
instance GHC.Show.Show a => GHC.Show.Show (GHCi.Message.QResult a)
instance GHC.Generics.Generic (GHCi.Message.QResult a)
instance GHC.Show.Show (GHCi.Message.Message a)
instance GHC.Show.Show (GHCi.Message.THMessage a)
instance GHC.Show.Show GHCi.Message.QState
instance Data.Binary.Class.Binary GHCi.Message.THResultType
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHCi.Message.THResult a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHCi.Message.EvalStatus_ a b)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHCi.Message.EvalResult a)
instance Data.Binary.Class.Binary GHCi.Message.SerializableException
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHCi.Message.EvalExpr a)
instance Data.Binary.Class.Binary GHCi.Message.EvalOpts
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHCi.Message.QResult a)
instance Data.Binary.Class.Binary GHC.IO.Exception.ExitCode
instance Data.Binary.Class.Binary (GHC.Ptr.Ptr a)
instance Data.Binary.Class.Binary (GHC.Ptr.FunPtr a)
instance Data.Binary.Class.Binary GHC.Exts.Heap.InfoTable.Types.StgInfoTable
instance Data.Binary.Class.Binary GHC.Exts.Heap.ClosureTypes.ClosureType
instance Data.Binary.Class.Binary GHC.Exts.Heap.Closures.PrimType
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (GHC.Exts.Heap.Closures.GenClosure a)


-- | Utilities related to Monad and Applicative classes Mostly for
--   backwards compatibility.
module MonadUtils

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <tt>&lt;$&gt;</tt> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Monads having fixed points with a 'knot-tying' semantics. Instances of
--   <a>MonadFix</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i><i>purity</i></i> <tt><a>mfix</a> (<tt>return</tt> . h) =
--   <tt>return</tt> (<a>fix</a> h)</tt></li>
--   <li><i><i>left shrinking</i> (or <i>tightening</i>)</i>
--   <tt><a>mfix</a> (\x -&gt; a &gt;&gt;= \y -&gt; f x y) = a &gt;&gt;= \y
--   -&gt; <a>mfix</a> (\x -&gt; f x y)</tt></li>
--   <li><i><i>sliding</i></i> <tt><a>mfix</a> (<a>liftM</a> h . f) =
--   <a>liftM</a> h (<a>mfix</a> (f . h))</tt>, for strict <tt>h</tt>.</li>
--   <li><i><i>nesting</i></i> <tt><a>mfix</a> (\x -&gt; <a>mfix</a> (\y
--   -&gt; f x y)) = <a>mfix</a> (\x -&gt; f x x)</tt></li>
--   </ul>
--   
--   This class is used in the translation of the recursive <tt>do</tt>
--   notation supported by GHC and Hugs.
class Monad m => MonadFix (m :: Type -> Type)

-- | The fixed point of a monadic computation. <tt><a>mfix</a> f</tt>
--   executes the action <tt>f</tt> only once, with the eventual output fed
--   back as the input. Hence <tt>f</tt> should not be strict, for then
--   <tt><a>mfix</a> f</tt> would diverge.
mfix :: MonadFix m => (a -> m a) -> m a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Lift an <a>IO</a> operation with 1 argument into another monad
liftIO1 :: MonadIO m => (a -> IO b) -> a -> m b

-- | Lift an <a>IO</a> operation with 2 arguments into another monad
liftIO2 :: MonadIO m => (a -> b -> IO c) -> a -> b -> m c

-- | Lift an <a>IO</a> operation with 3 arguments into another monad
liftIO3 :: MonadIO m => (a -> b -> c -> IO d) -> a -> b -> c -> m d

-- | Lift an <a>IO</a> operation with 4 arguments into another monad
liftIO4 :: MonadIO m => (a -> b -> c -> d -> IO e) -> a -> b -> c -> d -> m e
zipWith3M :: Monad m => (a -> b -> c -> m d) -> [a] -> [b] -> [c] -> m [d]
zipWith3M_ :: Monad m => (a -> b -> c -> m d) -> [a] -> [b] -> [c] -> m ()
zipWith4M :: Monad m => (a -> b -> c -> d -> m e) -> [a] -> [b] -> [c] -> [d] -> m [e]
zipWithAndUnzipM :: Monad m => (a -> b -> m (c, d)) -> [a] -> [b] -> m ([c], [d])

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state-transforming monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | mapAndUnzipM for triples
mapAndUnzip3M :: Monad m => (a -> m (b, c, d)) -> [a] -> m ([b], [c], [d])
mapAndUnzip4M :: Monad m => (a -> m (b, c, d, e)) -> [a] -> m ([b], [c], [d], [e])
mapAndUnzip5M :: Monad m => (a -> m (b, c, d, e, f)) -> [a] -> m ([b], [c], [d], [e], [f])

-- | Monadic version of mapAccumL
mapAccumLM :: Monad m => (acc -> x -> m (acc, y)) -> acc -> [x] -> m (acc, [y])

-- | Monadic version of mapSnd
mapSndM :: Monad m => (b -> m c) -> [(a, b)] -> m [(a, c)]

-- | Monadic version of concatMap
concatMapM :: Monad m => (a -> m [b]) -> [a] -> m [b]

-- | Applicative version of mapMaybe
mapMaybeM :: Applicative m => (a -> m (Maybe b)) -> [a] -> m [b]

-- | Monadic version of fmap
fmapMaybeM :: Monad m => (a -> m b) -> Maybe a -> m (Maybe b)

-- | Monadic version of fmap
fmapEitherM :: Monad m => (a -> m b) -> (c -> m d) -> Either a c -> m (Either b d)

-- | Monadic version of <a>any</a>, aborts the computation at the first
--   <tt>True</tt> value
anyM :: Monad m => (a -> m Bool) -> [a] -> m Bool

-- | Monad version of <a>all</a>, aborts the computation at the first
--   <tt>False</tt> value
allM :: Monad m => (a -> m Bool) -> [a] -> m Bool

-- | Monadic version of or
orM :: Monad m => m Bool -> m Bool -> m Bool

-- | Monadic version of foldl
foldlM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a

-- | Monadic version of foldl that discards its result
foldlM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()

-- | Monadic version of foldr
foldrM :: Monad m => (b -> a -> m a) -> a -> [b] -> m a

-- | Monadic version of fmap specialised for Maybe
maybeMapM :: Monad m => (a -> m b) -> Maybe a -> m (Maybe b)

-- | Monadic version of <tt>when</tt>, taking the condition in the monad
whenM :: Monad m => m Bool -> m () -> m ()

-- | Monadic version of <tt>unless</tt>, taking the condition in the monad
unlessM :: Monad m => m Bool -> m () -> m ()

-- | Like <a>filterM</a>, only it reverses the sense of the test.
filterOutM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

module Panic

-- | GHC's own exception type error messages all take the form:
--   
--   <pre>
--   <a>location</a>: <a>error</a>
--   
--   </pre>
--   
--   If the location is on the command line, or in GHC itself, then
--   <a>location</a>="ghc". All of the error types below correspond to a
--   <a>location</a> of "ghc", except for ProgramError (where the string is
--   assumed to contain a location already, so we don't print one).
data GhcException

-- | Some other fatal signal (SIGHUP,SIGTERM)
Signal :: Int -> GhcException

-- | Prints the short usage msg after the error
UsageError :: String -> GhcException

-- | A problem with the command line arguments, but don't print usage.
CmdLineError :: String -> GhcException

-- | The <tt>impossible</tt> happened.
Panic :: String -> GhcException
PprPanic :: String -> SDoc -> GhcException

-- | The user tickled something that's known not to work yet, but we're not
--   counting it as a bug.
Sorry :: String -> GhcException
PprSorry :: String -> SDoc -> GhcException

-- | An installation problem.
InstallationError :: String -> GhcException

-- | An error in the user's code, probably.
ProgramError :: String -> GhcException
PprProgramError :: String -> SDoc -> GhcException

-- | Append a description of the given exception to this string.
--   
--   Note that this uses <a>unsafeGlobalDynFlags</a>, which may have some
--   uninitialized fields if invoked before <a>initGhcMonad</a> has been
--   called. If the error message to be printed includes a pretty-printer
--   document which forces one of these fields this call may bottom.
showGhcException :: GhcException -> ShowS
throwGhcException :: GhcException -> a
throwGhcExceptionIO :: GhcException -> IO a
handleGhcException :: ExceptionMonad m => (GhcException -> m a) -> m a -> m a

-- | The name of this GHC.
progName :: String

-- | Panics and asserts.
pgmError :: String -> a

-- | Panics and asserts.
panic :: String -> a

-- | Panics and asserts.
sorry :: String -> a

-- | Throw a failed assertion exception for a given filename and line
--   number.
assertPanic :: String -> Int -> a

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   "calling f with x = 123
--   123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: () => String -> a -> a
panicDoc :: String -> SDoc -> a
sorryDoc :: String -> SDoc -> a
pgmErrorDoc :: String -> SDoc -> a
cmdLineError :: String -> a
cmdLineErrorIO :: String -> IO a

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | Show an exception as a string.
showException :: Exception e => e -> String

-- | Show an exception which can possibly throw other exceptions. Used when
--   displaying exception thrown within TH code.
safeShowException :: Exception e => e -> IO String

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised than it will be propogated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | Like try, but pass through UserInterrupt and Panic exceptions. Used
--   when we want soft failures when reading interface files, for example.
--   TODO: I'm not entirely sure if this is catching what we really want to
--   catch
tryMost :: IO a -> IO (Either SomeException a)

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | Temporarily install standard signal handlers for catching ^C, which
--   just throw an exception in the current thread.
withSignalHandlers :: (ExceptionMonad m, MonadIO m) => m a -> m a
instance GHC.Exception.Type.Exception Panic.GhcException
instance GHC.Show.Show Panic.GhcException

module Ctype
is_ident :: Char -> Bool
is_symbol :: Char -> Bool
is_any :: Char -> Bool
is_space :: Char -> Bool
is_lower :: Char -> Bool
is_upper :: Char -> Bool
is_digit :: Char -> Bool
is_alphanum :: Char -> Bool
is_decdigit :: Char -> Bool
is_hexdigit :: Char -> Bool
is_octdigit :: Char -> Bool
is_bindigit :: Char -> Bool
hexDigit :: Char -> Int
octDecDigit :: Char -> Int


-- | A description of the platform we're compiling for.
module Platform

-- | Contains enough information for the native code generator to emit code
--   for this platform.
data Platform
Platform :: Arch -> OS -> {-# UNPACK #-} !Int -> Bool -> Bool -> Bool -> Bool -> Bool -> Platform
[platformArch] :: Platform -> Arch
[platformOS] :: Platform -> OS
[platformWordSize] :: Platform -> {-# UNPACK #-} !Int
[platformUnregisterised] :: Platform -> Bool
[platformHasGnuNonexecStack] :: Platform -> Bool
[platformHasIdentDirective] :: Platform -> Bool
[platformHasSubsectionsViaSymbols] :: Platform -> Bool
[platformIsCrossCompiling] :: Platform -> Bool

-- | Architectures that the native code generator knows about. TODO: It
--   might be nice to extend these constructors with information about what
--   instruction set extensions an architecture might support.
data Arch
ArchUnknown :: Arch
ArchX86 :: Arch
ArchX86_64 :: Arch
ArchPPC :: Arch
ArchPPC_64 :: PPC_64ABI -> Arch
[ppc_64ABI] :: Arch -> PPC_64ABI
ArchSPARC :: Arch
ArchSPARC64 :: Arch
ArchARM :: ArmISA -> [ArmISAExt] -> ArmABI -> Arch
[armISA] :: Arch -> ArmISA
[armISAExt] :: Arch -> [ArmISAExt]
[armABI] :: Arch -> ArmABI
ArchARM64 :: Arch
ArchAlpha :: Arch
ArchMipseb :: Arch
ArchMipsel :: Arch
ArchJavaScript :: Arch

-- | Operating systems that the native code generator knows about. Having
--   OSUnknown should produce a sensible default, but no promises.
data OS
OSUnknown :: OS
OSLinux :: OS
OSDarwin :: OS
OSSolaris2 :: OS
OSMinGW32 :: OS
OSFreeBSD :: OS
OSDragonFly :: OS
OSOpenBSD :: OS
OSNetBSD :: OS
OSKFreeBSD :: OS
OSHaiku :: OS
OSQNXNTO :: OS
OSAIX :: OS
OSHurd :: OS

-- | ARM Instruction Set Architecture, Extensions and ABI
data ArmISA
ARMv5 :: ArmISA
ARMv6 :: ArmISA
ARMv7 :: ArmISA
data ArmISAExt
VFPv2 :: ArmISAExt
VFPv3 :: ArmISAExt
VFPv3D16 :: ArmISAExt
NEON :: ArmISAExt
IWMMX2 :: ArmISAExt
data ArmABI
SOFT :: ArmABI
SOFTFP :: ArmABI
HARD :: ArmABI

-- | PowerPC 64-bit ABI
data PPC_64ABI
ELF_V1 :: PPC_64ABI
ELF_V2 :: PPC_64ABI

-- | This predicate tells us whether the platform is 32-bit.
target32Bit :: Platform -> Bool
isARM :: Arch -> Bool

-- | This predicate tells us whether the OS supports ELF-like shared
--   libraries.
osElfTarget :: OS -> Bool

-- | This predicate tells us whether the OS support Mach-O shared
--   libraries.
osMachOTarget :: OS -> Bool
osSubsectionsViaSymbols :: OS -> Bool
platformUsesFrameworks :: Platform -> Bool
instance GHC.Classes.Eq Platform.Platform
instance GHC.Show.Show Platform.Platform
instance GHC.Read.Read Platform.Platform
instance GHC.Classes.Eq Platform.Arch
instance GHC.Show.Show Platform.Arch
instance GHC.Read.Read Platform.Arch
instance GHC.Classes.Eq Platform.PPC_64ABI
instance GHC.Show.Show Platform.PPC_64ABI
instance GHC.Read.Read Platform.PPC_64ABI
instance GHC.Classes.Eq Platform.ArmABI
instance GHC.Show.Show Platform.ArmABI
instance GHC.Read.Read Platform.ArmABI
instance GHC.Classes.Eq Platform.ArmISAExt
instance GHC.Show.Show Platform.ArmISAExt
instance GHC.Read.Read Platform.ArmISAExt
instance GHC.Classes.Eq Platform.ArmISA
instance GHC.Show.Show Platform.ArmISA
instance GHC.Read.Read Platform.ArmISA
instance GHC.Classes.Eq Platform.OS
instance GHC.Show.Show Platform.OS
instance GHC.Read.Read Platform.OS


-- | Platform constants
--   
--   (c) The University of Glasgow 2013
module PlatformConstants
data PlatformConstants
PlatformConstants :: () -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Bool -> Bool -> Int -> Integer -> Integer -> Integer -> PlatformConstants
[pc_platformConstants] :: PlatformConstants -> ()
[pc_CONTROL_GROUP_CONST_291] :: PlatformConstants -> Int
[pc_STD_HDR_SIZE] :: PlatformConstants -> Int
[pc_PROF_HDR_SIZE] :: PlatformConstants -> Int
[pc_BLOCK_SIZE] :: PlatformConstants -> Int
[pc_BLOCKS_PER_MBLOCK] :: PlatformConstants -> Int
[pc_TICKY_BIN_COUNT] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR7] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR8] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR9] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR10] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rL1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rSp] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rSpLim] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rHp] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rHpLim] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rCCCS] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rCurrentTSO] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rCurrentNursery] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rHpAlloc] :: PlatformConstants -> Int
[pc_OFFSET_stgEagerBlackholeInfo] :: PlatformConstants -> Int
[pc_OFFSET_stgGCEnter1] :: PlatformConstants -> Int
[pc_OFFSET_stgGCFun] :: PlatformConstants -> Int
[pc_OFFSET_Capability_r] :: PlatformConstants -> Int
[pc_OFFSET_bdescr_start] :: PlatformConstants -> Int
[pc_OFFSET_bdescr_free] :: PlatformConstants -> Int
[pc_OFFSET_bdescr_blocks] :: PlatformConstants -> Int
[pc_OFFSET_bdescr_flags] :: PlatformConstants -> Int
[pc_SIZEOF_CostCentreStack] :: PlatformConstants -> Int
[pc_OFFSET_CostCentreStack_mem_alloc] :: PlatformConstants -> Int
[pc_REP_CostCentreStack_mem_alloc] :: PlatformConstants -> Int
[pc_OFFSET_CostCentreStack_scc_count] :: PlatformConstants -> Int
[pc_REP_CostCentreStack_scc_count] :: PlatformConstants -> Int
[pc_OFFSET_StgHeader_ccs] :: PlatformConstants -> Int
[pc_OFFSET_StgHeader_ldvw] :: PlatformConstants -> Int
[pc_SIZEOF_StgSMPThunkHeader] :: PlatformConstants -> Int
[pc_OFFSET_StgEntCounter_allocs] :: PlatformConstants -> Int
[pc_REP_StgEntCounter_allocs] :: PlatformConstants -> Int
[pc_OFFSET_StgEntCounter_allocd] :: PlatformConstants -> Int
[pc_REP_StgEntCounter_allocd] :: PlatformConstants -> Int
[pc_OFFSET_StgEntCounter_registeredp] :: PlatformConstants -> Int
[pc_OFFSET_StgEntCounter_link] :: PlatformConstants -> Int
[pc_OFFSET_StgEntCounter_entry_count] :: PlatformConstants -> Int
[pc_SIZEOF_StgUpdateFrame_NoHdr] :: PlatformConstants -> Int
[pc_SIZEOF_StgMutArrPtrs_NoHdr] :: PlatformConstants -> Int
[pc_OFFSET_StgMutArrPtrs_ptrs] :: PlatformConstants -> Int
[pc_OFFSET_StgMutArrPtrs_size] :: PlatformConstants -> Int
[pc_SIZEOF_StgSmallMutArrPtrs_NoHdr] :: PlatformConstants -> Int
[pc_OFFSET_StgSmallMutArrPtrs_ptrs] :: PlatformConstants -> Int
[pc_SIZEOF_StgArrBytes_NoHdr] :: PlatformConstants -> Int
[pc_OFFSET_StgArrBytes_bytes] :: PlatformConstants -> Int
[pc_OFFSET_StgTSO_alloc_limit] :: PlatformConstants -> Int
[pc_OFFSET_StgTSO_cccs] :: PlatformConstants -> Int
[pc_OFFSET_StgTSO_stackobj] :: PlatformConstants -> Int
[pc_OFFSET_StgStack_sp] :: PlatformConstants -> Int
[pc_OFFSET_StgStack_stack] :: PlatformConstants -> Int
[pc_OFFSET_StgUpdateFrame_updatee] :: PlatformConstants -> Int
[pc_OFFSET_StgFunInfoExtraFwd_arity] :: PlatformConstants -> Int
[pc_REP_StgFunInfoExtraFwd_arity] :: PlatformConstants -> Int
[pc_SIZEOF_StgFunInfoExtraRev] :: PlatformConstants -> Int
[pc_OFFSET_StgFunInfoExtraRev_arity] :: PlatformConstants -> Int
[pc_REP_StgFunInfoExtraRev_arity] :: PlatformConstants -> Int
[pc_MAX_SPEC_SELECTEE_SIZE] :: PlatformConstants -> Int
[pc_MAX_SPEC_AP_SIZE] :: PlatformConstants -> Int
[pc_MIN_PAYLOAD_SIZE] :: PlatformConstants -> Int
[pc_MIN_INTLIKE] :: PlatformConstants -> Int
[pc_MAX_INTLIKE] :: PlatformConstants -> Int
[pc_MIN_CHARLIKE] :: PlatformConstants -> Int
[pc_MAX_CHARLIKE] :: PlatformConstants -> Int
[pc_MUT_ARR_PTRS_CARD_BITS] :: PlatformConstants -> Int
[pc_MAX_Vanilla_REG] :: PlatformConstants -> Int
[pc_MAX_Float_REG] :: PlatformConstants -> Int
[pc_MAX_Double_REG] :: PlatformConstants -> Int
[pc_MAX_Long_REG] :: PlatformConstants -> Int
[pc_MAX_XMM_REG] :: PlatformConstants -> Int
[pc_MAX_Real_Vanilla_REG] :: PlatformConstants -> Int
[pc_MAX_Real_Float_REG] :: PlatformConstants -> Int
[pc_MAX_Real_Double_REG] :: PlatformConstants -> Int
[pc_MAX_Real_XMM_REG] :: PlatformConstants -> Int
[pc_MAX_Real_Long_REG] :: PlatformConstants -> Int
[pc_RESERVED_C_STACK_BYTES] :: PlatformConstants -> Int
[pc_RESERVED_STACK_WORDS] :: PlatformConstants -> Int
[pc_AP_STACK_SPLIM] :: PlatformConstants -> Int
[pc_WORD_SIZE] :: PlatformConstants -> Int
[pc_DOUBLE_SIZE] :: PlatformConstants -> Int
[pc_CINT_SIZE] :: PlatformConstants -> Int
[pc_CLONG_SIZE] :: PlatformConstants -> Int
[pc_CLONG_LONG_SIZE] :: PlatformConstants -> Int
[pc_BITMAP_BITS_SHIFT] :: PlatformConstants -> Int
[pc_TAG_BITS] :: PlatformConstants -> Int
[pc_WORDS_BIGENDIAN] :: PlatformConstants -> Bool
[pc_DYNAMIC_BY_DEFAULT] :: PlatformConstants -> Bool
[pc_LDV_SHIFT] :: PlatformConstants -> Int
[pc_ILDV_CREATE_MASK] :: PlatformConstants -> Integer
[pc_ILDV_STATE_CREATE] :: PlatformConstants -> Integer
[pc_ILDV_STATE_USE] :: PlatformConstants -> Integer
instance GHC.Read.Read PlatformConstants.PlatformConstants

module SizedSeq
data SizedSeq a
SizedSeq :: {-# UNPACK #-} !Word -> [a] -> SizedSeq a
emptySS :: SizedSeq a
addToSS :: SizedSeq a -> a -> SizedSeq a
addListToSS :: SizedSeq a -> [a] -> SizedSeq a
ssElts :: SizedSeq a -> [a]
sizeSS :: SizedSeq a -> Word
instance GHC.Show.Show a => GHC.Show.Show (SizedSeq.SizedSeq a)
instance GHC.Generics.Generic (SizedSeq.SizedSeq a)
instance GHC.Base.Functor SizedSeq.SizedSeq
instance Data.Foldable.Foldable SizedSeq.SizedSeq
instance Data.Traversable.Traversable SizedSeq.SizedSeq
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (SizedSeq.SizedSeq a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (SizedSeq.SizedSeq a)

module SysTools.BaseDir

-- | Expand occurrences of the <tt>$topdir</tt> interpolation in a string.
expandTopDir :: FilePath -> String -> String

-- | Expand occurrences of the <tt>$tooldir</tt> interpolation in a string
--   on Windows, leave the string untouched otherwise.
expandToolDir :: Maybe FilePath -> String -> String

-- | Returns a Unix-format path pointing to TopDir.
findTopDir :: Maybe String -> IO String
findToolDir :: FilePath -> IO (Maybe FilePath)

module SysTools.Terminal

-- | Check if ANSI escape sequences can be used to control color in stderr.
stderrSupportsAnsiColors :: IO Bool


-- | Highly random utility functions
module Util
ghciSupported :: Bool
debugIsOn :: Bool
ncgDebugIsOn :: Bool
ghciTablesNextToCode :: Bool
isWindowsHost :: Bool
isDarwinHost :: Bool
zipEqual :: String -> [a] -> [b] -> [(a, b)]
zipWithEqual :: String -> (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3Equal :: String -> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
zipWith4Equal :: String -> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | <a>zipLazy</a> is a kind of <a>zip</a> that is lazy in the second list
--   (observe the ~)
zipLazy :: [a] -> [b] -> [(a, b)]

-- | <tt>stretchZipWith p z f xs ys</tt> stretches <tt>ys</tt> by inserting
--   <tt>z</tt> in the places where <tt>p</tt> returns <tt>True</tt>
stretchZipWith :: (a -> Bool) -> b -> (a -> b -> c) -> [a] -> [b] -> [c]
zipWithAndUnzip :: (a -> b -> (c, d)) -> [a] -> [b] -> ([c], [d])

-- | This has the effect of making the two lists have equal length by
--   dropping the tail of the longer one.
zipAndUnzip :: [a] -> [b] -> ([a], [b])

-- | <a>zipWithLazy</a> is like <a>zipWith</a> but is lazy in the second
--   list. The length of the output is always the same as the length of the
--   first list.
zipWithLazy :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zipWith3Lazy</a> is like <a>zipWith3</a> but is lazy in the second
--   and third lists. The length of the output is always the same as the
--   length of the first list.
zipWith3Lazy :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>filterByList</a> takes a list of Bools and a list of some elements
--   and filters out these elements for which the corresponding value in
--   the list of Bools is False. This function does not check whether the
--   lists have equal length.
filterByList :: [Bool] -> [a] -> [a]

-- | <a>filterByLists</a> takes a list of Bools and two lists as input, and
--   outputs a new list consisting of elements from the last two input
--   lists. For each Bool in the list, if it is <a>True</a>, then it takes
--   an element from the former list. If it is <a>False</a>, it takes an
--   element from the latter list. The elements taken correspond to the
--   index of the Bool in its list. For example:
--   
--   <pre>
--   filterByLists [True, False, True, False] "abcd" "wxyz" = "axcz"
--   </pre>
--   
--   This function does not check whether the lists have equal length.
filterByLists :: [Bool] -> [a] -> [a] -> [a]

-- | <a>partitionByList</a> takes a list of Bools and a list of some
--   elements and partitions the list according to the list of Bools.
--   Elements corresponding to <a>True</a> go to the left; elements
--   corresponding to <a>False</a> go to the right. For example,
--   <tt>partitionByList [True, False, True] [1,2,3] == ([1,3], [2])</tt>
--   This function does not check whether the lists have equal length.
partitionByList :: [Bool] -> [a] -> ([a], [a])
unzipWith :: (a -> b -> c) -> [(a, b)] -> [c]
mapFst :: (a -> c) -> [(a, b)] -> [(c, b)]
mapSnd :: (b -> c) -> [(a, b)] -> [(a, c)]
chkAppend :: [a] -> [a] -> [a]
mapAndUnzip :: (a -> (b, c)) -> [a] -> ([b], [c])
mapAndUnzip3 :: (a -> (b, c, d)) -> [a] -> ([b], [c], [d])
mapAccumL2 :: (s1 -> s2 -> a -> (s1, s2, b)) -> s1 -> s2 -> [a] -> (s1, s2, [b])
nOfThem :: Int -> a -> [a]

-- | Like filter, only it reverses the sense of the test
filterOut :: (a -> Bool) -> [a] -> [a]

-- | Uses a function to determine which of two output lists an input
--   element should join
partitionWith :: (a -> Either b c) -> [a] -> ([b], [c])
dropWhileEndLE :: (a -> Bool) -> [a] -> [a]

-- | <tt>spanEnd p l == reverse (span p (reverse l))</tt>. The first list
--   returns actually comes after the second list (when you look at the
--   input list).
spanEnd :: (a -> Bool) -> [a] -> ([a], [a])

-- | Get the last two elements in a list. Partial!
last2 :: [a] -> (a, a)

-- | A strict version of <a>foldl1</a>
foldl1' :: () => (a -> a -> a) -> [a] -> a
foldl2 :: (acc -> a -> b -> acc) -> acc -> [a] -> [b] -> acc
count :: (a -> Bool) -> [a] -> Int
countWhile :: (a -> Bool) -> [a] -> Int
all2 :: (a -> b -> Bool) -> [a] -> [b] -> Bool

-- | <pre>
--   (lengthExceeds xs n) = (length xs &gt; n)
--   </pre>
lengthExceeds :: [a] -> Int -> Bool

-- | <pre>
--   (lengthIs xs n) = (length xs == n)
--   </pre>
lengthIs :: [a] -> Int -> Bool

-- | <pre>
--   (lengthIsNot xs n) = (length xs /= n)
--   </pre>
lengthIsNot :: [a] -> Int -> Bool

-- | <pre>
--   (lengthAtLeast xs n) = (length xs &gt;= n)
--   </pre>
lengthAtLeast :: [a] -> Int -> Bool

-- | <pre>
--   (lengthAtMost xs n) = (length xs &lt;= n)
--   </pre>
lengthAtMost :: [a] -> Int -> Bool

-- | <pre>
--   (lengthLessThan xs n) == (length xs &lt; n)
--   </pre>
lengthLessThan :: [a] -> Int -> Bool
listLengthCmp :: [a] -> Int -> Ordering

-- | <tt>atLength atLen atEnd ls n</tt> unravels list <tt>ls</tt> to
--   position <tt>n</tt>. Precisely:
--   
--   <pre>
--   atLength atLenPred atEndPred ls n
--    | n &lt; 0         = atLenPred ls
--    | length ls &lt; n = atEndPred (n - length ls)
--    | otherwise     = atLenPred (drop n ls)
--   </pre>
atLength :: ([a] -> b) -> b -> [a] -> Int -> b

-- | True if length xs == length ys
equalLength :: [a] -> [b] -> Bool

-- | True if length xs /= length ys
neLength :: [a] -> [b] -> Bool
compareLength :: [a] -> [b] -> Ordering

-- | True if length xs &lt;= length ys
leLength :: [a] -> [b] -> Bool

-- | True if length xs &lt; length ys
ltLength :: [a] -> [b] -> Bool
isSingleton :: [a] -> Bool
only :: [a] -> a
singleton :: a -> [a]
notNull :: [a] -> Bool
snocView :: [a] -> Maybe ([a], a)
isIn :: Eq a => String -> a -> [a] -> Bool
isn'tIn :: Eq a => String -> a -> [a] -> Bool

-- | Split a list into chunks of <i>n</i> elements
chunkList :: Int -> [a] -> [[a]]

-- | Replace the last element of a list with another element.
changeLast :: [a] -> a -> [a]
fstOf3 :: (a, b, c) -> a
sndOf3 :: (a, b, c) -> b
thdOf3 :: (a, b, c) -> c
firstM :: Monad m => (a -> m c) -> (a, b) -> m (c, b)
first3M :: Monad m => (a -> m d) -> (a, b, c) -> m (d, b, c)
secondM :: Monad m => (b -> m c) -> (a, b) -> m (a, c)
fst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
snd3 :: (b -> d) -> (a, b, c) -> (a, d, c)
third3 :: (c -> d) -> (a, b, c) -> (a, b, d)
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
liftFst :: (a -> b) -> (a, c) -> (b, c)
liftSnd :: (a -> b) -> (c, a) -> (c, b)
takeList :: [b] -> [a] -> [a]
dropList :: [b] -> [a] -> [a]
splitAtList :: [b] -> [a] -> ([a], [a])
split :: Char -> String -> [String]
dropTail :: Int -> [a] -> [a]

-- | Convert a word to title case by capitalising the first letter
capitalise :: String -> String

-- | Compose a function with itself n times. (nth rather than twice)
nTimes :: Int -> (a -> a) -> a -> a

-- | The <a>sortWith</a> function sorts a list of elements using the user
--   supplied function to project something out of each element
sortWith :: Ord b => (a -> b) -> [a] -> [a]
minWith :: Ord b => (a -> b) -> [a] -> a
nubSort :: Ord a => [a] -> [a]

-- | Remove duplicates but keep elements in order. O(n * log n)
ordNub :: Ord a => [a] -> [a]
isEqual :: Ordering -> Bool
eqListBy :: (a -> a -> Bool) -> [a] -> [a] -> Bool
eqMaybeBy :: (a -> a -> Bool) -> Maybe a -> Maybe a -> Bool
thenCmp :: Ordering -> Ordering -> Ordering
infixr 9 `thenCmp`
cmpList :: (a -> a -> Ordering) -> [a] -> [a] -> Ordering
removeSpaces :: String -> String
(<&&>) :: Applicative f => f Bool -> f Bool -> f Bool
infixr 3 <&&>
(<||>) :: Applicative f => f Bool -> f Bool -> f Bool
infixr 2 <||>
fuzzyMatch :: String -> [String] -> [String]

-- | Search for possible matches to the users input in the given list,
--   returning a small number of ranked results
fuzzyLookup :: String -> [(String, a)] -> [a]
transitiveClosure :: (a -> [a]) -> (a -> a -> Bool) -> [a] -> [a]
seqList :: [a] -> b -> b
looksLikeModuleName :: String -> Bool
looksLikePackageName :: String -> Bool
getCmd :: String -> Either String (String, String)
toCmdArgs :: String -> Either String (String, [String])
toArgs :: String -> Either String [String]
exactLog2 :: Integer -> Maybe Integer
readRational :: String -> Rational
readHexRational :: String -> Rational
maybeRead :: Read a => String -> Maybe a
maybeReadFuzzy :: Read a => String -> Maybe a
doesDirNameExist :: FilePath -> IO Bool
getModificationUTCTime :: FilePath -> IO UTCTime
modificationTimeIfExists :: FilePath -> IO (Maybe UTCTime)
global :: a -> IORef a
consIORef :: IORef [a] -> a -> IO ()
globalM :: IO a -> IORef a
sharedGlobal :: a -> (Ptr (IORef a) -> IO (Ptr (IORef a))) -> IORef a
sharedGlobalM :: IO a -> (Ptr (IORef a) -> IO (Ptr (IORef a))) -> IORef a
type Suffix = String
splitLongestPrefix :: String -> (Char -> Bool) -> (String, String)
escapeSpaces :: String -> String
data Direction
Forwards :: Direction
Backwards :: Direction
reslash :: Direction -> FilePath -> FilePath
makeRelativeTo :: FilePath -> FilePath -> FilePath
abstractConstr :: String -> Constr
abstractDataType :: String -> DataType

-- | Constructs a non-representation for a non-representable type
mkNoRepType :: String -> DataType
charToC :: Word8 -> String

-- | A sample hash function for Strings. We keep multiplying by the golden
--   ratio and adding. The implementation is:
--   
--   <pre>
--   hashString = foldl' f golden
--     where f m c = fromIntegral (ord c) * magic + hashInt32 m
--           magic = 0xdeadbeef
--   </pre>
--   
--   Where hashInt32 works just as hashInt shown above.
--   
--   Knuth argues that repeated multiplication by the golden ratio will
--   minimize gaps in the hash space, and thus it's a good choice for
--   combining together multiple keys to form one.
--   
--   Here we know that individual characters c are often small, and this
--   produces frequent collisions if we use ord c alone. A particular
--   problem are the shorter low ASCII and ISO-8859-1 character strings. We
--   pre-multiply by a magic twiddle factor to obtain a good distribution.
--   In fact, given the following test:
--   
--   <pre>
--   testp :: Int32 -&gt; Int
--   testp k = (n - ) . length . group . sort . map hs . take n $ ls
--     where ls = [] : [c : l | l &lt;- ls, c &lt;- ['\0'..'\xff']]
--           hs = foldl' f golden
--           f m c = fromIntegral (ord c) * k + hashInt32 m
--           n = 100000
--   </pre>
--   
--   We discover that testp magic = 0.
hashString :: String -> Int32

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | A call stack constraint, but only when <tt>isDebugOn</tt>.
type HasDebugCallStack = (() :: Constraint)
data OverridingBool
Auto :: OverridingBool
Always :: OverridingBool
Never :: OverridingBool
overrideWith :: Bool -> OverridingBool -> Bool
instance GHC.Show.Show Util.OverridingBool

module PprColour

-- | A colour/style for use with <tt>coloured</tt>.
newtype PprColour
PprColour :: String -> PprColour
[renderColour] :: PprColour -> String
renderColourAfresh :: PprColour -> String
colCustom :: String -> PprColour
colReset :: PprColour
colBold :: PprColour
colBlackFg :: PprColour
colRedFg :: PprColour
colGreenFg :: PprColour
colYellowFg :: PprColour
colBlueFg :: PprColour
colMagentaFg :: PprColour
colCyanFg :: PprColour
colWhiteFg :: PprColour
data Scheme
Scheme :: PprColour -> PprColour -> PprColour -> PprColour -> PprColour -> PprColour -> Scheme
[sHeader] :: Scheme -> PprColour
[sMessage] :: Scheme -> PprColour
[sWarning] :: Scheme -> PprColour
[sError] :: Scheme -> PprColour
[sFatal] :: Scheme -> PprColour
[sMargin] :: Scheme -> PprColour
defaultScheme :: Scheme

-- | Parse the colour scheme from a string (presumably from the
--   <tt>GHC_COLORS</tt> environment variable).
parseScheme :: String -> (OverridingBool, Scheme) -> (OverridingBool, Scheme)
instance GHC.Base.Semigroup PprColour.PprColour
instance GHC.Base.Monoid PprColour.PprColour

module Maybes
data MaybeErr err val
Succeeded :: val -> MaybeErr err val
Failed :: err -> MaybeErr err val
failME :: err -> MaybeErr err val
isSuccess :: MaybeErr err val -> Bool

-- | Flipped version of <tt>fromMaybe</tt>, useful for chaining.
orElse :: Maybe a -> a -> a
infixr 4 `orElse`
firstJust :: Maybe a -> Maybe a -> Maybe a

-- | Takes a list of <tt>Maybes</tt> and returns the first <tt>Just</tt> if
--   there is one, or <tt>Nothing</tt> otherwise.
firstJusts :: [Maybe a] -> Maybe a
whenIsJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
expectJust :: HasCallStack => String -> Maybe a -> a
rightToMaybe :: Either a b -> Maybe b

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT (m :: Type -> Type) a
MaybeT :: m (Maybe a) -> MaybeT a
[runMaybeT] :: MaybeT a -> m (Maybe a)
liftMaybeT :: Monad m => m a -> MaybeT m a

-- | Try performing an <a>IO</a> action, failing on error.
tryMaybeT :: IO a -> MaybeT IO a
instance GHC.Base.Functor (Maybes.MaybeErr err)
instance GHC.Base.Applicative (Maybes.MaybeErr err)
instance GHC.Base.Monad (Maybes.MaybeErr err)


-- | There are two principal string types used internally by GHC:
--   
--   <ul>
--   <li><i><a>FastString</a></i></li>
--   </ul>
--   
--   <ul>
--   <li>A compact, hash-consed, representation of character strings.</li>
--   <li>Comparison is O(1), and you can get a <a>Unique</a> from
--   them.</li>
--   <li>Generated by <a>fsLit</a>.</li>
--   <li>Turn into <a>SDoc</a> with <a>ftext</a>.</li>
--   </ul>
--   
--   <ul>
--   <li><i><a>PtrString</a></i></li>
--   </ul>
--   
--   <ul>
--   <li>Pointer and size of a Latin-1 encoded string.</li>
--   <li>Practically no operations.</li>
--   <li>Outputing them is fast.</li>
--   <li>Generated by <a>sLit</a>.</li>
--   <li>Turn into <a>SDoc</a> with <a>ptext</a></li>
--   <li>Requires manual memory management. Improper use may lead to memory
--   leaks or dangling pointers.</li>
--   <li>It assumes Latin-1 as the encoding, therefore it cannot represent
--   arbitrary Unicode strings.</li>
--   </ul>
--   
--   Use <a>PtrString</a> unless you want the facilities of
--   <a>FastString</a>.
module FastString
fastStringToByteString :: FastString -> ByteString

-- | Create a <a>FastString</a> from an existing <a>ForeignPtr</a>; the
--   difference between this and <a>mkFastStringBytes</a> is that we don't
--   have to copy the bytes if the string is new to the table.
mkFastStringByteString :: ByteString -> FastString
fastZStringToByteString :: FastZString -> ByteString
unsafeMkByteString :: String -> ByteString
data FastZString
hPutFZS :: Handle -> FastZString -> IO ()
zString :: FastZString -> String
lengthFZS :: FastZString -> Int

-- | A <a>FastString</a> is an array of bytes, hashed to support fast O(1)
--   comparison. It is also associated with a character encoding, so that
--   we know how to convert a <a>FastString</a> to the local encoding, or
--   to the Z-encoding used by the compiler internally.
--   
--   <a>FastString</a>s support a memoized conversion to the Z-encoding via
--   zEncodeFS.
data FastString
FastString :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !ByteString -> {-# UNPACK #-} !IORef (Maybe FastZString) -> FastString
[uniq] :: FastString -> {-# UNPACK #-} !Int
[n_chars] :: FastString -> {-# UNPACK #-} !Int
[fs_bs] :: FastString -> {-# UNPACK #-} !ByteString
[fs_ref] :: FastString -> {-# UNPACK #-} !IORef (Maybe FastZString)
fsLit :: String -> FastString

-- | Creates a UTF-8 encoded <a>FastString</a> from a <a>String</a>
mkFastString :: String -> FastString
mkFastStringBytes :: Ptr Word8 -> Int -> FastString

-- | Creates a <a>FastString</a> from a UTF-8 encoded <tt>[Word8]</tt>
mkFastStringByteList :: [Word8] -> FastString

-- | Create a <a>FastString</a> from an existing <a>ForeignPtr</a>; the
--   difference between this and <a>mkFastStringBytes</a> is that we don't
--   have to copy the bytes if the string is new to the table.
mkFastStringForeignPtr :: Ptr Word8 -> ForeignPtr Word8 -> Int -> IO FastString
mkFastString# :: Addr# -> FastString

-- | Unpacks and decodes the FastString
unpackFS :: FastString -> String

-- | Gives the UTF-8 encoded bytes corresponding to a <a>FastString</a>
bytesFS :: FastString -> [Word8]

-- | Returns a Z-encoded version of a <a>FastString</a>. This might be the
--   original, if it was already Z-encoded. The first time this function is
--   applied to a particular <a>FastString</a>, the results are memoized.
zEncodeFS :: FastString -> FastZString
uniqueOfFS :: FastString -> Int

-- | Returns the length of the <a>FastString</a> in characters
lengthFS :: FastString -> Int

-- | Returns <tt>True</tt> if the <a>FastString</a> is empty
nullFS :: FastString -> Bool
appendFS :: FastString -> FastString -> FastString
headFS :: FastString -> Char
tailFS :: FastString -> FastString
concatFS :: [FastString] -> FastString
consFS :: Char -> FastString -> FastString
nilFS :: FastString
isUnderscoreFS :: FastString -> Bool

-- | Outputs a <a>FastString</a> with <i>no decoding at all</i>, that is,
--   you get the actual bytes in the <a>FastString</a> written to the
--   <a>Handle</a>.
hPutFS :: Handle -> FastString -> IO ()
getFastStringTable :: IO [[[FastString]]]

-- | Returns <tt>True</tt> if this <a>FastString</a> is not Z-encoded but
--   already has a Z-encoding cached (used in producing stats).
hasZEncoding :: FastString -> Bool

-- | A <a>PtrString</a> is a pointer to some array of Latin-1 encoded
--   chars.
data PtrString
PtrString :: !Ptr Word8 -> !Int -> PtrString
sLit :: String -> PtrString

-- | Wrap an unboxed address into a <a>PtrString</a>.
mkPtrString# :: Addr# -> PtrString

-- | Encode a <a>String</a> into a newly allocated <a>PtrString</a> using
--   Latin-1 encoding. The original string must not contain non-Latin-1
--   characters (above codepoint <tt>0xff</tt>).
mkPtrString :: String -> PtrString

-- | Decode a <a>PtrString</a> back into a <a>String</a> using Latin-1
--   encoding. This does not free the memory associated with
--   <a>PtrString</a>.
unpackPtrString :: PtrString -> String

-- | Return the length of a <a>PtrString</a>
lengthPS :: PtrString -> Int
instance Control.DeepSeq.NFData FastString.FastZString
instance GHC.Classes.Eq FastString.FastString
instance GHC.Classes.Ord FastString.FastString
instance Data.String.IsString FastString.FastString
instance GHC.Base.Semigroup FastString.FastString
instance GHC.Base.Monoid FastString.FastString
instance GHC.Show.Show FastString.FastString
instance Data.Data.Data FastString.FastString

module Lexeme
isLexCon :: FastString -> Bool
isLexVar :: FastString -> Bool
isLexId :: FastString -> Bool
isLexSym :: FastString -> Bool
isLexConId :: FastString -> Bool
isLexConSym :: FastString -> Bool
isLexVarId :: FastString -> Bool
isLexVarSym :: FastString -> Bool
startsVarSym :: Char -> Bool
startsVarId :: Char -> Bool
startsConSym :: Char -> Bool
startsConId :: Char -> Bool

-- | Is this an acceptable variable name?
okVarOcc :: String -> Bool

-- | Is this an acceptable constructor name?
okConOcc :: String -> Bool

-- | Is this an acceptable type name?
okTcOcc :: String -> Bool

-- | Is this an acceptable alphanumeric variable name, assuming it starts
--   with an acceptable letter?
okVarIdOcc :: String -> Bool

-- | Is this an acceptable symbolic variable name, assuming it starts with
--   an acceptable character?
okVarSymOcc :: String -> Bool

-- | Is this an acceptable alphanumeric constructor name, assuming it
--   starts with an acceptable letter?
okConIdOcc :: String -> Bool

-- | Is this an acceptable symbolic constructor name, assuming it starts
--   with an acceptable character?
okConSymOcc :: String -> Bool

module BufWrite
data BufHandle
BufHandle :: {-# UNPACK #-} !Ptr Word8 -> {-# UNPACK #-} !FastMutInt -> Handle -> BufHandle
newBufHandle :: Handle -> IO BufHandle
bPutChar :: BufHandle -> Char -> IO ()
bPutStr :: BufHandle -> String -> IO ()
bPutFS :: BufHandle -> FastString -> IO ()
bPutFZS :: BufHandle -> FastZString -> IO ()
bPutPtrString :: BufHandle -> PtrString -> IO ()

-- | Replicate an 8-bit character
bPutReplicate :: BufHandle -> Int -> Char -> IO ()
bFlush :: BufHandle -> IO ()


-- | John Hughes's and Simon Peyton Jones's Pretty Printer Combinators
--   
--   Based on <i>The Design of a Pretty-printing Library</i> in Advanced
--   Functional Programming, Johan Jeuring and Erik Meijer (eds), LNCS 925
--   <a>http://www.cs.chalmers.se/~rjmh/Papers/pretty.ps</a>
module Pretty

-- | The abstract type of documents. A Doc represents a *set* of layouts. A
--   Doc with no occurrences of Union or NoDoc represents just one layout.
data Doc

-- | The TextDetails data type
--   
--   A TextDetails represents a fragment of text that will be output at
--   some point.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails
PStr :: FastString -> TextDetails
ZStr :: FastZString -> TextDetails
LStr :: {-# UNPACK #-} !PtrString -> TextDetails
RStr :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Char -> TextDetails

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc
ftext :: FastString -> Doc
ptext :: PtrString -> Doc
ztext :: FastZString -> Doc

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
hex :: Integer -> Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
quote :: Doc -> Doc
doubleQuotes :: Doc -> Doc

-- | Apply <a>parens</a> to <a>Doc</a> if boolean is true.
maybeParens :: Bool -> Doc -> Doc

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc
infixl 6 <>

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc
infixl 6 <+>

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc] -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc
infixl 5 $$

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc -> Doc -> Doc
infixl 5 $+$

-- | List version of <a>$$</a>.
vcat :: [Doc] -> Doc

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc] -> Doc

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc] -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | Apply <a>hang</a> to the arguments if the first <a>Doc</a> is not
--   empty.
hangNotEmpty :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> Bool

-- | A rendering style.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode
[mode] :: Style -> Mode

-- | Length of line, in chars
[lineLength] :: Style -> Int

-- | Ratio of line length to ribbon length
[ribbonsPerLine] :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc -> String

-- | Rendering mode.
data Mode

-- | Normal
PageMode :: Mode

-- | With zig-zag cuts
ZigZagMode :: Mode

-- | No indentation, infinitely long lines
LeftMode :: Mode

-- | All on one line
OneLineMode :: Mode

-- | The general rendering interface.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a

-- | Default TextDetails printer
txtPrinter :: TextDetails -> String -> String
printDoc :: Mode -> Int -> Handle -> Doc -> IO ()
printDoc_ :: Mode -> Int -> Handle -> Doc -> IO ()
bufLeftRender :: BufHandle -> Doc -> IO ()
instance GHC.Show.Show Pretty.Doc


-- | This module defines classes and functions for pretty-printing. It also
--   exports a number of helpful debugging and other utilities such as
--   <a>trace</a> and <a>panic</a>.
--   
--   The interface to this module is very similar to the standard Hughes-PJ
--   pretty printing module, except that it exports a number of additional
--   functions that are rarely used, and works over the <a>SDoc</a> type.
module Outputable

-- | Class designating that some type has an <a>SDoc</a> representation
class Outputable a
ppr :: Outputable a => a -> SDoc
pprPrec :: Outputable a => Rational -> a -> SDoc

-- | When we print a binder, we often want to print its type too. The
--   <tt>OutputableBndr</tt> class encapsulates this idea.
class Outputable a => OutputableBndr a
pprBndr :: OutputableBndr a => BindingSite -> a -> SDoc
pprPrefixOcc :: OutputableBndr a => a -> SDoc
pprInfixOcc :: OutputableBndr a => a -> SDoc
bndrIsJoin_maybe :: OutputableBndr a => a -> Maybe Int

-- | Represents a pretty-printable document.
--   
--   To display an <a>SDoc</a>, use <a>printSDoc</a>, <a>printSDocLn</a>,
--   <a>bufLeftRenderSDoc</a>, or <a>renderWithStyle</a>. Avoid calling
--   <a>runSDoc</a> directly as it breaks the abstraction layer.
data SDoc
runSDoc :: SDoc -> SDocContext -> Doc
initSDocContext :: DynFlags -> PprStyle -> SDocContext
docToSDoc :: Doc -> SDoc

-- | Returns the separated concatenation of the pretty printed things.
interppSP :: Outputable a => [a] -> SDoc

-- | Returns the comma-separated concatenation of the pretty printed
--   things.
interpp'SP :: Outputable a => [a] -> SDoc

-- | Returns the comma-separated concatenation of the quoted pretty printed
--   things.
--   
--   <pre>
--   [x,y,z]  ==&gt;  `x', `y', `z'
--   </pre>
pprQuotedList :: Outputable a => [a] -> SDoc
pprWithCommas :: (a -> SDoc) -> [a] -> SDoc
quotedListWithOr :: [SDoc] -> SDoc
quotedListWithNor :: [SDoc] -> SDoc
pprWithBars :: (a -> SDoc) -> [a] -> SDoc
empty :: SDoc
isEmpty :: DynFlags -> SDoc -> Bool

-- | Indent <a>SDoc</a> some specified amount
nest :: Int -> SDoc -> SDoc
char :: Char -> SDoc
text :: String -> SDoc
ftext :: FastString -> SDoc
ptext :: PtrString -> SDoc
ztext :: FastZString -> SDoc
int :: Int -> SDoc
intWithCommas :: Integral a => a -> SDoc
integer :: Integer -> SDoc
word :: Integer -> SDoc
float :: Float -> SDoc
double :: Double -> SDoc
rational :: Rational -> SDoc

-- | <tt>doublePrec p n</tt> shows a floating point number <tt>n</tt> with
--   <tt>p</tt> digits of precision after the decimal point.
doublePrec :: Int -> Double -> SDoc
parens :: SDoc -> SDoc
cparen :: Bool -> SDoc -> SDoc
brackets :: SDoc -> SDoc
braces :: SDoc -> SDoc
quotes :: SDoc -> SDoc
quote :: SDoc -> SDoc
doubleQuotes :: SDoc -> SDoc
angleBrackets :: SDoc -> SDoc
semi :: SDoc
comma :: SDoc
colon :: SDoc
dcolon :: SDoc
space :: SDoc
equals :: SDoc
dot :: SDoc
vbar :: SDoc
arrow :: SDoc
larrow :: SDoc
darrow :: SDoc
arrowt :: SDoc
larrowt :: SDoc
arrowtt :: SDoc
larrowtt :: SDoc
lparen :: SDoc
rparen :: SDoc
lbrack :: SDoc
rbrack :: SDoc
lbrace :: SDoc
rbrace :: SDoc
underscore :: SDoc
blankLine :: SDoc
forAllLit :: SDoc
kindType :: SDoc
bullet :: SDoc

-- | Join two <a>SDoc</a> together horizontally without a gap
(<>) :: SDoc -> SDoc -> SDoc

-- | Join two <a>SDoc</a> together horizontally with a gap between them
(<+>) :: SDoc -> SDoc -> SDoc

-- | Concatenate <a>SDoc</a> horizontally
hcat :: [SDoc] -> SDoc

-- | Concatenate <a>SDoc</a> horizontally with a space between each one
hsep :: [SDoc] -> SDoc

-- | Join two <a>SDoc</a> together vertically; if there is no vertical
--   overlap it "dovetails" the two onto one line
($$) :: SDoc -> SDoc -> SDoc

-- | Join two <a>SDoc</a> together vertically
($+$) :: SDoc -> SDoc -> SDoc

-- | Concatenate <a>SDoc</a> vertically with dovetailing
vcat :: [SDoc] -> SDoc

-- | Separate: is either like <a>hsep</a> or like <a>vcat</a>, depending on
--   what fits
sep :: [SDoc] -> SDoc

-- | Catenate: is either like <a>hcat</a> or like <a>vcat</a>, depending on
--   what fits
cat :: [SDoc] -> SDoc

-- | A paragraph-fill combinator. It's much like sep, only it keeps fitting
--   things on one line until it can't fit any more.
fsep :: [SDoc] -> SDoc

-- | This behaves like <a>fsep</a>, but it uses <a>&lt;&gt;</a> for
--   horizontal conposition rather than <a>&lt;+&gt;</a>
fcat :: [SDoc] -> SDoc
hang :: SDoc -> Int -> SDoc -> SDoc

-- | This behaves like <a>hang</a>, but does not indent the second document
--   when the header is empty.
hangNotEmpty :: SDoc -> Int -> SDoc -> SDoc
punctuate :: SDoc -> [SDoc] -> [SDoc]
ppWhen :: Bool -> SDoc -> SDoc
ppUnless :: Bool -> SDoc -> SDoc

-- | Converts an integer to a verbal index:
--   
--   <pre>
--   speakNth 1 = text "first"
--   speakNth 5 = text "fifth"
--   speakNth 21 = text "21st"
--   </pre>
speakNth :: Int -> SDoc

-- | Converts an integer to a verbal multiplicity:
--   
--   <pre>
--   speakN 0 = text "none"
--   speakN 5 = text "five"
--   speakN 10 = text "10"
--   </pre>
speakN :: Int -> SDoc

-- | Converts an integer and object description to a statement about the
--   multiplicity of those objects:
--   
--   <pre>
--   speakNOf 0 (text "melon") = text "no melons"
--   speakNOf 1 (text "melon") = text "one melon"
--   speakNOf 3 (text "melon") = text "three melons"
--   </pre>
speakNOf :: Int -> SDoc -> SDoc

-- | Determines the pluralisation suffix appropriate for the length of a
--   list:
--   
--   <pre>
--   plural [] = char 's'
--   plural ["Hello"] = empty
--   plural ["Hello", "World"] = char 's'
--   </pre>
plural :: [a] -> SDoc

-- | Determines the form of to be appropriate for the length of a list:
--   
--   <pre>
--   isOrAre [] = text "are"
--   isOrAre ["Hello"] = text "is"
--   isOrAre ["Hello", "World"] = text "are"
--   </pre>
isOrAre :: [a] -> SDoc

-- | Determines the form of to do appropriate for the length of a list:
--   
--   <pre>
--   doOrDoes [] = text "do"
--   doOrDoes ["Hello"] = text "does"
--   doOrDoes ["Hello", "World"] = text "do"
--   </pre>
doOrDoes :: [a] -> SDoc
unicodeSyntax :: SDoc -> SDoc -> SDoc

-- | Apply the given colour/style for the argument.
--   
--   Only takes effect if colours are enabled.
coloured :: PprColour -> SDoc -> SDoc
keyword :: SDoc -> SDoc

-- | The analog of <a>printDoc_</a> for <a>SDoc</a>, which tries to make
--   sure the terminal doesn't get screwed up by the ANSI color codes if an
--   exception is thrown during pretty-printing.
printSDoc :: Mode -> DynFlags -> Handle -> PprStyle -> SDoc -> IO ()

-- | Like <a>printSDoc</a> but appends an extra newline.
printSDocLn :: Mode -> DynFlags -> Handle -> PprStyle -> SDoc -> IO ()
printForUser :: DynFlags -> Handle -> PrintUnqualified -> SDoc -> IO ()
printForUserPartWay :: DynFlags -> Handle -> Int -> PrintUnqualified -> SDoc -> IO ()

-- | Like <a>printSDocLn</a> but specialized with <a>LeftMode</a> and
--   <tt><a>PprCode</a> <a>CStyle</a></tt>. This is typically used to
--   output C-- code.
printForC :: DynFlags -> Handle -> SDoc -> IO ()

-- | An efficient variant of <a>printSDoc</a> specialized for
--   <a>LeftMode</a> that outputs to a <a>BufHandle</a>.
bufLeftRenderSDoc :: DynFlags -> BufHandle -> PprStyle -> SDoc -> IO ()
pprCode :: CodeStyle -> SDoc -> SDoc
mkCodeStyle :: CodeStyle -> PprStyle
showSDoc :: DynFlags -> SDoc -> String
showSDocUnsafe :: SDoc -> String
showSDocOneLine :: DynFlags -> SDoc -> String
showSDocForUser :: DynFlags -> PrintUnqualified -> SDoc -> String
showSDocDebug :: DynFlags -> SDoc -> String
showSDocDump :: DynFlags -> SDoc -> String
showSDocDumpOneLine :: DynFlags -> SDoc -> String
showSDocUnqual :: DynFlags -> SDoc -> String
showPpr :: Outputable a => DynFlags -> a -> String
renderWithStyle :: DynFlags -> SDoc -> PprStyle -> String
pprInfixVar :: Bool -> SDoc -> SDoc
pprPrefixVar :: Bool -> SDoc -> SDoc

-- | Special combinator for showing character literals.
pprHsChar :: Char -> SDoc

-- | Special combinator for showing string literals.
pprHsString :: FastString -> SDoc

-- | Special combinator for showing bytestring literals.
pprHsBytes :: ByteString -> SDoc
primFloatSuffix :: SDoc
primCharSuffix :: SDoc
primWordSuffix :: SDoc
primDoubleSuffix :: SDoc
primInt64Suffix :: SDoc
primWord64Suffix :: SDoc
primIntSuffix :: SDoc

-- | Special combinator for showing unboxed literals.
pprPrimChar :: Char -> SDoc
pprPrimInt :: Integer -> SDoc
pprPrimWord :: Integer -> SDoc
pprPrimInt64 :: Integer -> SDoc
pprPrimWord64 :: Integer -> SDoc
pprFastFilePath :: FastString -> SDoc

-- | <a>BindingSite</a> is used to tell the thing that prints binder what
--   language construct is binding the identifier. This can be used to
--   decide how much info to print. Also see Note [Binding-site specific
--   printing] in PprCore
data BindingSite

-- | The x in (x. e)
LambdaBind :: BindingSite

-- | The x in case scrut of x { (y,z) -&gt; ... }
CaseBind :: BindingSite

-- | The y,z in case scrut of x { (y,z) -&gt; ... }
CasePatBind :: BindingSite

-- | The x in (let x = rhs in e)
LetBind :: BindingSite
data PprStyle
data CodeStyle
CStyle :: CodeStyle
AsmStyle :: CodeStyle

-- | When printing code that contains original names, we need to map the
--   original names back to something the user understands. This is the
--   purpose of the triple of functions that gets passed around when
--   rendering <a>SDoc</a>.
data PrintUnqualified
QueryQualify :: QueryQualifyName -> QueryQualifyModule -> QueryQualifyPackage -> PrintUnqualified
[queryQualifyName] :: PrintUnqualified -> QueryQualifyName
[queryQualifyModule] :: PrintUnqualified -> QueryQualifyModule
[queryQualifyPackage] :: PrintUnqualified -> QueryQualifyPackage

-- | Given a <tt>Name</tt>'s <a>Module</a> and <a>OccName</a>, decide
--   whether and how to qualify it.
type QueryQualifyName = Module -> OccName -> QualifyName

-- | For a given module, we need to know whether to print it with a package
--   name to disambiguate it.
type QueryQualifyModule = Module -> Bool

-- | For a given package, we need to know whether to print it with the
--   component id to disambiguate it.
type QueryQualifyPackage = UnitId -> Bool
reallyAlwaysQualify :: PrintUnqualified
reallyAlwaysQualifyNames :: QueryQualifyName
alwaysQualify :: PrintUnqualified

-- | NB: This won't ever show package IDs
alwaysQualifyNames :: QueryQualifyName
alwaysQualifyModules :: QueryQualifyModule
neverQualify :: PrintUnqualified
neverQualifyNames :: QueryQualifyName
neverQualifyModules :: QueryQualifyModule
alwaysQualifyPackages :: QueryQualifyPackage
neverQualifyPackages :: QueryQualifyPackage
data QualifyName
NameUnqual :: QualifyName
NameQual :: ModuleName -> QualifyName
NameNotInScope1 :: QualifyName
NameNotInScope2 :: QualifyName
queryQual :: PprStyle -> PrintUnqualified
sdocWithDynFlags :: (DynFlags -> SDoc) -> SDoc
sdocWithPlatform :: (Platform -> SDoc) -> SDoc
updSDocDynFlags :: (DynFlags -> DynFlags) -> SDoc -> SDoc
getPprStyle :: (PprStyle -> SDoc) -> SDoc
withPprStyle :: PprStyle -> SDoc -> SDoc

-- | This is not a recommended way to render <a>SDoc</a>, since it breaks
--   the abstraction layer of <a>SDoc</a>. Prefer to use <a>printSDoc</a>,
--   <a>printSDocLn</a>, <a>bufLeftRenderSDoc</a>, or
--   <a>renderWithStyle</a> instead.
withPprStyleDoc :: DynFlags -> PprStyle -> SDoc -> Doc
setStyleColoured :: Bool -> PprStyle -> PprStyle
pprDeeper :: SDoc -> SDoc

-- | Truncate a list that is longer than the current depth.
pprDeeperList :: ([SDoc] -> SDoc) -> [SDoc] -> SDoc
pprSetDepth :: Depth -> SDoc -> SDoc
codeStyle :: PprStyle -> Bool
userStyle :: PprStyle -> Bool
debugStyle :: PprStyle -> Bool
dumpStyle :: PprStyle -> Bool
asmStyle :: PprStyle -> Bool
qualName :: PprStyle -> QueryQualifyName
qualModule :: PprStyle -> QueryQualifyModule
qualPackage :: PprStyle -> QueryQualifyPackage

-- | Style for printing error messages
mkErrStyle :: DynFlags -> PrintUnqualified -> PprStyle
defaultErrStyle :: DynFlags -> PprStyle
defaultDumpStyle :: DynFlags -> PprStyle
mkDumpStyle :: DynFlags -> PrintUnqualified -> PprStyle
defaultUserStyle :: DynFlags -> PprStyle
mkUserStyle :: DynFlags -> PrintUnqualified -> Depth -> PprStyle
cmdlineParserStyle :: DynFlags -> PprStyle
data Depth
AllTheWay :: Depth
PartWay :: Int -> Depth

-- | Says what to do with and without -dppr-debug
ifPprDebug :: SDoc -> SDoc -> SDoc

-- | Says what to do with -dppr-debug; without, return empty
whenPprDebug :: SDoc -> SDoc
getPprDebug :: (Bool -> SDoc) -> SDoc

-- | Throw an exception saying "bug in GHC"
pprPanic :: HasCallStack => String -> SDoc -> a

-- | Throw an exception saying "this isn't finished yet"
pprSorry :: String -> SDoc -> a

-- | Panic with an assertation failure, recording the given file and line
--   number. Should typically be accessed with the ASSERT family of macros
assertPprPanic :: HasCallStack => String -> Int -> SDoc -> a

-- | Throw an exception saying "bug in pgm being compiled" (used for
--   unusual program errors)
pprPgmError :: String -> SDoc -> a

-- | If debug output is on, show some <a>SDoc</a> on the screen
pprTrace :: String -> SDoc -> a -> a
pprTraceDebug :: String -> SDoc -> a -> a

-- | <tt>pprTraceIt desc x</tt> is equivalent to <tt>pprTrace desc (ppr x)
--   x</tt>
pprTraceIt :: Outputable a => String -> a -> a

-- | Just warn about an assertion failure, recording the given file and
--   line number. Should typically be accessed with the WARN macros
warnPprTrace :: Bool -> String -> Int -> SDoc -> a -> a

-- | If debug output is on, show some <a>SDoc</a> on the screen along with
--   a call stack when available.
pprSTrace :: HasCallStack => SDoc -> a -> a

-- | <tt>pprTraceException desc x action</tt> runs action, printing a
--   message if it throws an exception.
pprTraceException :: ExceptionMonad m => String -> SDoc -> m a -> m a
pprTraceM :: Applicative f => String -> SDoc -> f ()

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   "calling f with x = 123
--   123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: () => String -> a -> a

-- | Panics and asserts.
pgmError :: String -> a

-- | Panics and asserts.
panic :: String -> a

-- | Panics and asserts.
sorry :: String -> a

-- | Throw a failed assertion exception for a given filename and line
--   number.
assertPanic :: String -> Int -> a
pprDebugAndThen :: DynFlags -> (String -> a) -> SDoc -> SDoc -> a
callStackDoc :: HasCallStack => SDoc
instance Outputable.Outputable Outputable.QualifyName
instance Outputable.Outputable Outputable.PprStyle
instance Outputable.Outputable GHC.Types.Char
instance Outputable.Outputable GHC.Types.Bool
instance Outputable.Outputable GHC.Types.Ordering
instance Outputable.Outputable GHC.Int.Int32
instance Outputable.Outputable GHC.Int.Int64
instance Outputable.Outputable GHC.Types.Int
instance Outputable.Outputable GHC.Integer.Type.Integer
instance Outputable.Outputable GHC.Word.Word16
instance Outputable.Outputable GHC.Word.Word32
instance Outputable.Outputable GHC.Types.Word
instance Outputable.Outputable ()
instance Outputable.Outputable a => Outputable.Outputable [a]
instance Outputable.Outputable a => Outputable.Outputable (Data.Set.Internal.Set a)
instance (Outputable.Outputable a, Outputable.Outputable b) => Outputable.Outputable (a, b)
instance Outputable.Outputable a => Outputable.Outputable (GHC.Maybe.Maybe a)
instance (Outputable.Outputable a, Outputable.Outputable b) => Outputable.Outputable (Data.Either.Either a b)
instance (Outputable.Outputable a, Outputable.Outputable b, Outputable.Outputable c) => Outputable.Outputable (a, b, c)
instance (Outputable.Outputable a, Outputable.Outputable b, Outputable.Outputable c, Outputable.Outputable d) => Outputable.Outputable (a, b, c, d)
instance (Outputable.Outputable a, Outputable.Outputable b, Outputable.Outputable c, Outputable.Outputable d, Outputable.Outputable e) => Outputable.Outputable (a, b, c, d, e)
instance (Outputable.Outputable a, Outputable.Outputable b, Outputable.Outputable c, Outputable.Outputable d, Outputable.Outputable e, Outputable.Outputable f) => Outputable.Outputable (a, b, c, d, e, f)
instance (Outputable.Outputable a, Outputable.Outputable b, Outputable.Outputable c, Outputable.Outputable d, Outputable.Outputable e, Outputable.Outputable f, Outputable.Outputable g) => Outputable.Outputable (a, b, c, d, e, f, g)
instance Outputable.Outputable FastString.FastString
instance (Outputable.Outputable key, Outputable.Outputable elt) => Outputable.Outputable (Data.Map.Internal.Map key elt)
instance Outputable.Outputable elt => Outputable.Outputable (Data.IntMap.Internal.IntMap elt)
instance Outputable.Outputable GHC.Fingerprint.Type.Fingerprint
instance Outputable.Outputable a => Outputable.Outputable (Data.Graph.SCC a)
instance Outputable.Outputable GHC.Serialized.Serialized
instance Outputable.Outputable GHC.LanguageExtensions.Type.Extension
instance Data.String.IsString Outputable.SDoc

module StringBuffer

-- | A StringBuffer is an internal pointer to a sized chunk of bytes. The
--   bytes are intended to be *immutable*. There are pure operations to
--   read the contents of a StringBuffer.
--   
--   A StringBuffer may have a finalizer, depending on how it was obtained.
data StringBuffer
StringBuffer :: {-# UNPACK #-} !ForeignPtr Word8 -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> StringBuffer
[buf] :: StringBuffer -> {-# UNPACK #-} !ForeignPtr Word8
[len] :: StringBuffer -> {-# UNPACK #-} !Int
[cur] :: StringBuffer -> {-# UNPACK #-} !Int

-- | Read a file into a <a>StringBuffer</a>. The resulting buffer is
--   automatically managed by the garbage collector.
hGetStringBuffer :: FilePath -> IO StringBuffer
hGetStringBufferBlock :: Handle -> Int -> IO StringBuffer
appendStringBuffers :: StringBuffer -> StringBuffer -> IO StringBuffer

-- | Encode a <a>String</a> into a <a>StringBuffer</a> as UTF-8. The
--   resulting buffer is automatically managed by the garbage collector.
stringToStringBuffer :: String -> StringBuffer

-- | Return the first UTF-8 character of a nonempty <a>StringBuffer</a> and
--   as well the remaining portion (analogous to <a>uncons</a>).
--   <b>Warning:</b> The behavior is undefined if the <a>StringBuffer</a>
--   is empty. The result shares the same buffer as the original. Similar
--   to <a>utf8DecodeChar</a>, if the character cannot be decoded as UTF-8,
--   <tt>'\0'</tt> is returned.
nextChar :: StringBuffer -> (Char, StringBuffer)

-- | Return the first UTF-8 character of a nonempty <a>StringBuffer</a>
--   (analogous to <a>head</a>). <b>Warning:</b> The behavior is undefined
--   if the <a>StringBuffer</a> is empty. Similar to <a>utf8DecodeChar</a>,
--   if the character cannot be decoded as UTF-8, <tt>'\0'</tt> is
--   returned.
currentChar :: StringBuffer -> Char
prevChar :: StringBuffer -> Char -> Char

-- | Check whether a <a>StringBuffer</a> is empty (analogous to
--   <a>null</a>).
atEnd :: StringBuffer -> Bool

-- | Return a <a>StringBuffer</a> with the first UTF-8 character removed
--   (analogous to <a>tail</a>). <b>Warning:</b> The behavior is undefined
--   if the <a>StringBuffer</a> is empty. The result shares the same buffer
--   as the original.
stepOn :: StringBuffer -> StringBuffer

-- | Return a <a>StringBuffer</a> with the first <tt>n</tt> bytes removed.
--   <b>Warning:</b> If there aren't enough characters, the returned
--   <a>StringBuffer</a> will be invalid and any use of it may lead to
--   undefined behavior. The result shares the same buffer as the original.
offsetBytes :: Int -> StringBuffer -> StringBuffer

-- | Compute the difference in offset between two <a>StringBuffer</a>s that
--   share the same buffer. <b>Warning:</b> The behavior is undefined if
--   the <a>StringBuffer</a>s use separate buffers.
byteDiff :: StringBuffer -> StringBuffer -> Int

-- | Computes a <a>StringBuffer</a> which points to the first character of
--   the wanted line. Lines begin at 1.
atLine :: Int -> StringBuffer -> Maybe StringBuffer

-- | Decode the first <tt>n</tt> bytes of a <a>StringBuffer</a> as UTF-8
--   into a <a>String</a>. Similar to <a>utf8DecodeChar</a>, if the
--   character cannot be decoded as UTF-8, they will be replaced with
--   <tt>'\0'</tt>.
lexemeToString :: StringBuffer -> Int -> String
lexemeToFastString :: StringBuffer -> Int -> FastString

-- | Return the previous <tt>n</tt> characters (or fewer if we are less
--   than <tt>n</tt> characters into the buffer.
decodePrevNChars :: Int -> StringBuffer -> String
parseUnsignedInteger :: StringBuffer -> Int -> Integer -> (Char -> Int) -> Integer
instance GHC.Show.Show StringBuffer.StringBuffer

module Pair
data Pair a
Pair :: a -> a -> Pair a
[pFst] :: Pair a -> a
[pSnd] :: Pair a -> a
unPair :: Pair a -> (a, a)
toPair :: (a, a) -> Pair a
swap :: Pair a -> Pair a
pLiftFst :: (a -> a) -> Pair a -> Pair a
pLiftSnd :: (a -> a) -> Pair a -> Pair a
instance GHC.Base.Functor Pair.Pair
instance GHC.Base.Applicative Pair.Pair
instance Data.Foldable.Foldable Pair.Pair
instance Data.Traversable.Traversable Pair.Pair
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Pair.Pair a)
instance (GHC.Base.Semigroup a, GHC.Base.Monoid a) => GHC.Base.Monoid (Pair.Pair a)
instance Outputable.Outputable a => Outputable.Outputable (Pair.Pair a)

module OrdList
data OrdList a
nilOL :: OrdList a
isNilOL :: OrdList a -> Bool
unitOL :: a -> OrdList a
appOL :: OrdList a -> OrdList a -> OrdList a
infixl 5 `appOL`
consOL :: a -> OrdList a -> OrdList a
infixr 5 `consOL`
snocOL :: OrdList a -> a -> OrdList a
infixl 5 `snocOL`
concatOL :: [OrdList a] -> OrdList a
lastOL :: OrdList a -> a
mapOL :: (a -> b) -> OrdList a -> OrdList b
fromOL :: OrdList a -> [a]
toOL :: [a] -> OrdList a
foldrOL :: (a -> b -> b) -> b -> OrdList a -> b
foldlOL :: (b -> a -> b) -> b -> OrdList a -> b
reverseOL :: OrdList a -> OrdList a
instance Outputable.Outputable a => Outputable.Outputable (OrdList.OrdList a)
instance GHC.Base.Semigroup (OrdList.OrdList a)
instance GHC.Base.Monoid (OrdList.OrdList a)
instance GHC.Base.Functor OrdList.OrdList
instance Data.Foldable.Foldable OrdList.OrdList
instance Data.Traversable.Traversable OrdList.OrdList

module ListSetOps
unionLists :: (Outputable a, Eq a) => [a] -> [a] -> [a]

-- | Calculate the set difference of two lists. This is <i>O((m + n) log
--   n)</i>, where we subtract a list of <i>n</i> elements from a list of
--   <i>m</i> elements.
--   
--   Extremely short cases are handled specially: When <i>m</i> or <i>n</i>
--   is 0, this takes <i>O(1)</i> time. When <i>m</i> is 1, it takes
--   <i>O(n)</i> time.
minusList :: Ord a => [a] -> [a] -> [a]
deleteBys :: (a -> a -> Bool) -> [a] -> [a] -> [a]
type Assoc a b = [(a, b)]
assoc :: Eq a => String -> Assoc a b -> a -> b
assocMaybe :: Eq a => Assoc a b -> a -> Maybe b
assocUsing :: (a -> a -> Bool) -> String -> Assoc a b -> a -> b
assocDefault :: Eq a => b -> Assoc a b -> a -> b
assocDefaultUsing :: (a -> a -> Bool) -> b -> Assoc a b -> a -> b
hasNoDups :: Eq a => [a] -> Bool
removeDups :: (a -> a -> Ordering) -> [a] -> ([a], [NonEmpty a])
findDupsEq :: (a -> a -> Bool) -> [a] -> [NonEmpty a]
equivClasses :: (a -> a -> Ordering) -> [a] -> [NonEmpty a]
getNth :: Outputable a => [a] -> Int -> a

module Json

-- | Simple data type to represent JSON documents.
data JsonDoc
[JSNull] :: JsonDoc
[JSBool] :: Bool -> JsonDoc
[JSInt] :: Int -> JsonDoc
[JSString] :: String -> JsonDoc
[JSArray] :: [JsonDoc] -> JsonDoc
[JSObject] :: [(String, JsonDoc)] -> JsonDoc
renderJSON :: JsonDoc -> SDoc
escapeJsonString :: String -> String
class ToJson a
json :: ToJson a => a -> JsonDoc


-- | This module contains types that relate to the positions of things in
--   source files, and allow tagging of those things with locations
module SrcLoc

-- | Real Source Location
--   
--   Represents a single point within a file
data RealSrcLoc

-- | Source Location
data SrcLoc
RealSrcLoc :: {-# UNPACK #-} !RealSrcLoc -> SrcLoc
UnhelpfulLoc :: FastString -> SrcLoc
mkSrcLoc :: FastString -> Int -> Int -> SrcLoc
mkRealSrcLoc :: FastString -> Int -> Int -> RealSrcLoc

-- | Creates a "bad" <a>RealSrcLoc</a> that has no detailed information
--   about its location
mkGeneralSrcLoc :: FastString -> SrcLoc

-- | Built-in "bad" <a>RealSrcLoc</a> values for particular locations
noSrcLoc :: SrcLoc

-- | Built-in "bad" <a>RealSrcLoc</a> values for particular locations
generatedSrcLoc :: SrcLoc

-- | Built-in "bad" <a>RealSrcLoc</a> values for particular locations
interactiveSrcLoc :: SrcLoc

-- | Move the <a>RealSrcLoc</a> down by one line if the character is a
--   newline, to the next 8-char tabstop if it is a tab, and across by one
--   character in any other case
advanceSrcLoc :: RealSrcLoc -> Char -> RealSrcLoc

-- | Gives the filename of the <a>RealSrcLoc</a>
srcLocFile :: RealSrcLoc -> FastString

-- | Raises an error when used on a "bad" <a>RealSrcLoc</a>
srcLocLine :: RealSrcLoc -> Int

-- | Raises an error when used on a "bad" <a>RealSrcLoc</a>
srcLocCol :: RealSrcLoc -> Int

-- | A <a>RealSrcSpan</a> delimits a portion of a text file. It could be
--   represented by a pair of (line,column) coordinates, but in fact we
--   optimise slightly by using more compact representations for
--   single-line and zero-length spans, both of which are quite common.
--   
--   The end position is defined to be the column <i>after</i> the end of
--   the span. That is, a span of (1,1)-(1,2) is one character long, and a
--   span of (1,1)-(1,1) is zero characters long.
--   
--   Real Source Span
data RealSrcSpan

-- | Source Span
--   
--   A <a>SrcSpan</a> identifies either a specific portion of a text file
--   or a human-readable description of a location.
data SrcSpan
RealSrcSpan :: !RealSrcSpan -> SrcSpan
UnhelpfulSpan :: !FastString -> SrcSpan

-- | Create a "bad" <a>SrcSpan</a> that has not location information
mkGeneralSrcSpan :: FastString -> SrcSpan

-- | Create a <a>SrcSpan</a> between two points in a file
mkSrcSpan :: SrcLoc -> SrcLoc -> SrcSpan

-- | Create a <a>SrcSpan</a> between two points in a file
mkRealSrcSpan :: RealSrcLoc -> RealSrcLoc -> RealSrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
noSrcSpan :: SrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
wiredInSrcSpan :: SrcSpan

-- | Built-in "bad" <a>SrcSpan</a>s for common sources of location
--   uncertainty
interactiveSrcSpan :: SrcSpan

-- | Create a <a>SrcSpan</a> corresponding to a single point
srcLocSpan :: SrcLoc -> SrcSpan
realSrcLocSpan :: RealSrcLoc -> RealSrcSpan

-- | Combines two <a>SrcSpan</a> into one that spans at least all the
--   characters within both spans. Returns UnhelpfulSpan if the files
--   differ.
combineSrcSpans :: SrcSpan -> SrcSpan -> SrcSpan

-- | Convert a SrcSpan into one that represents only its first character
srcSpanFirstCharacter :: SrcSpan -> SrcSpan

-- | Returns the location at the start of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanStart :: SrcSpan -> SrcLoc

-- | Returns the location at the end of the <a>SrcSpan</a> or a "bad"
--   <a>SrcSpan</a> if that is unavailable
srcSpanEnd :: SrcSpan -> SrcLoc
realSrcSpanStart :: RealSrcSpan -> RealSrcLoc
realSrcSpanEnd :: RealSrcSpan -> RealSrcLoc

-- | Obtains the filename for a <a>SrcSpan</a> if it is "good"
srcSpanFileName_maybe :: SrcSpan -> Maybe FastString
pprUserRealSpan :: Bool -> RealSrcSpan -> SDoc
srcSpanFile :: RealSrcSpan -> FastString
srcSpanStartLine :: RealSrcSpan -> Int
srcSpanEndLine :: RealSrcSpan -> Int
srcSpanStartCol :: RealSrcSpan -> Int
srcSpanEndCol :: RealSrcSpan -> Int

-- | Test if a <a>SrcSpan</a> is "good", i.e. has precise location
--   information
isGoodSrcSpan :: SrcSpan -> Bool

-- | True if the span is known to straddle only one line. For "bad"
--   <a>SrcSpan</a>, it returns False
isOneLineSpan :: SrcSpan -> Bool

-- | Tests whether the first span "contains" the other span, meaning that
--   it covers at least as much source code. True where spans are equal.
containsSpan :: RealSrcSpan -> RealSrcSpan -> Bool
type Located = GenLocated SrcSpan
type RealLocated = GenLocated RealSrcSpan

-- | We attach SrcSpans to lots of things, so let's have a datatype for it.
data GenLocated l e
L :: l -> e -> GenLocated l e
noLoc :: HasSrcSpan a => SrcSpanLess a -> a
mkGeneralLocated :: HasSrcSpan e => String -> SrcSpanLess e -> e
getLoc :: HasSrcSpan a => a -> SrcSpan
unLoc :: HasSrcSpan a => a -> SrcSpanLess a
unRealSrcSpan :: RealLocated a -> a
getRealSrcSpan :: RealLocated a -> RealSrcSpan

-- | Tests whether the two located things are equal
eqLocated :: (HasSrcSpan a, Eq (SrcSpanLess a)) => a -> a -> Bool

-- | Tests the ordering of the two located things
cmpLocated :: (HasSrcSpan a, Ord (SrcSpanLess a)) => a -> a -> Ordering
combineLocs :: (HasSrcSpan a, HasSrcSpan b) => a -> b -> SrcSpan

-- | Combine locations from two <a>Located</a> things and add them to a
--   third thing
addCLoc :: (HasSrcSpan a, HasSrcSpan b, HasSrcSpan c) => a -> b -> SrcSpanLess c -> c

-- | Alternative strategies for ordering <a>SrcSpan</a>s
leftmost_smallest :: SrcSpan -> SrcSpan -> Ordering

-- | Alternative strategies for ordering <a>SrcSpan</a>s
leftmost_largest :: SrcSpan -> SrcSpan -> Ordering

-- | Alternative strategies for ordering <a>SrcSpan</a>s
rightmost :: SrcSpan -> SrcSpan -> Ordering

-- | Determines whether a span encloses a given line and column index
spans :: SrcSpan -> (Int, Int) -> Bool

-- | Determines whether a span is enclosed by another one
isSubspanOf :: SrcSpan -> SrcSpan -> Bool
sortLocated :: HasSrcSpan a => [a] -> [a]

-- | A typeclass to set/get SrcSpans
class HasSrcSpan a

-- | Composes a <a>SrcSpan</a> decoration with an undecorated syntactic
--   entity to form its decorated variant
composeSrcSpan :: HasSrcSpan a => Located (SrcSpanLess a) -> a

-- | Decomposes a decorated syntactic entity into its <a>SrcSpan</a>
--   decoration and its undecorated variant
decomposeSrcSpan :: HasSrcSpan a => a -> Located (SrcSpanLess a)

-- | Determines the type of undecorated syntactic entities For most
--   syntactic entities <tt>E</tt>, where source location spans are
--   introduced by a wrapper construtor of the same syntactic entity, we
--   have `SrcSpanLess E = E`. However, some syntactic entities have a
--   different type compared to a syntactic entity `e :: E` may have the
--   type `Located E` when decorated by wrapping it with `L sp e` for a
--   source span <tt>sp</tt>.
type family SrcSpanLess a

-- | An abbreviated form of decomposeSrcSpan, mainly to be used in
--   ViewPatterns
dL :: HasSrcSpan a => a -> Located (SrcSpanLess a)

-- | An abbreviated form of composeSrcSpan, mainly to replace the hardcoded
--   <a>L</a>
cL :: HasSrcSpan a => SrcSpan -> SrcSpanLess a -> a

-- | A Pattern Synonym to Set/Get SrcSpans
pattern LL :: HasSrcSpan a => SrcSpan -> SrcSpanLess a -> a

-- | Lifts a function of undecorated entities to one of decorated ones
onHasSrcSpan :: (HasSrcSpan a, HasSrcSpan b) => (SrcSpanLess a -> SrcSpanLess b) -> a -> b
liftL :: (HasSrcSpan a, HasSrcSpan b, Monad m) => (SrcSpanLess a -> m (SrcSpanLess b)) -> a -> m b
instance Data.Traversable.Traversable (SrcLoc.GenLocated l)
instance Data.Foldable.Foldable (SrcLoc.GenLocated l)
instance GHC.Base.Functor (SrcLoc.GenLocated l)
instance (Data.Data.Data l, Data.Data.Data e) => Data.Data.Data (SrcLoc.GenLocated l e)
instance (GHC.Classes.Ord l, GHC.Classes.Ord e) => GHC.Classes.Ord (SrcLoc.GenLocated l e)
instance (GHC.Classes.Eq l, GHC.Classes.Eq e) => GHC.Classes.Eq (SrcLoc.GenLocated l e)
instance GHC.Show.Show SrcLoc.SrcSpan
instance GHC.Classes.Ord SrcLoc.SrcSpan
instance GHC.Classes.Eq SrcLoc.SrcSpan
instance GHC.Classes.Eq SrcLoc.RealSrcSpan
instance GHC.Show.Show SrcLoc.SrcLoc
instance GHC.Classes.Ord SrcLoc.SrcLoc
instance GHC.Classes.Eq SrcLoc.SrcLoc
instance GHC.Classes.Ord SrcLoc.RealSrcLoc
instance GHC.Classes.Eq SrcLoc.RealSrcLoc
instance SrcLoc.HasSrcSpan (SrcLoc.Located a)
instance (Outputable.Outputable l, Outputable.Outputable e) => Outputable.Outputable (SrcLoc.GenLocated l e)
instance Data.Data.Data SrcLoc.SrcSpan
instance Json.ToJson SrcLoc.SrcSpan
instance Control.DeepSeq.NFData SrcLoc.SrcSpan
instance Outputable.Outputable SrcLoc.SrcSpan
instance Data.Data.Data SrcLoc.RealSrcSpan
instance Json.ToJson SrcLoc.RealSrcSpan
instance GHC.Classes.Ord SrcLoc.RealSrcSpan
instance GHC.Show.Show SrcLoc.RealSrcSpan
instance Outputable.Outputable SrcLoc.RealSrcSpan
instance Outputable.Outputable SrcLoc.SrcLoc
instance Outputable.Outputable SrcLoc.RealSrcLoc
instance GHC.Show.Show SrcLoc.RealSrcLoc

module BasicTypes
type Version = Int
bumpVersion :: Version -> Version
initialVersion :: Version
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight
pickLR :: LeftOrRight -> (a, a) -> a

-- | Constructor Tag
--   
--   Type of the tags associated with each constructor possibility or
--   superclass selector
type ConTag = Int

-- | A *zero-indexed* constructor tag
type ConTagZ = Int

-- | Tags are allocated from here for real constructors or for superclass
--   selectors
fIRST_TAG :: ConTag

-- | The number of value arguments that can be applied to a value before it
--   does "real work". So: fib 100 has arity 0 x -&gt; fib x has arity 1
--   See also Note [Definition of arity] in CoreArity
type Arity = Int

-- | Representation Arity
--   
--   The number of represented arguments that can be applied to a value
--   before it does "real work". So: fib 100 has representation arity 0 x
--   -&gt; fib x has representation arity 1 () -&gt; fib (x + y) has
--   representation arity 2
type RepArity = Int

-- | The number of arguments that a join point takes. Unlike the arity of a
--   function, this is a purely syntactic property and is fixed when the
--   join point is created (or converted from a value). Both type and value
--   arguments are counted.
type JoinArity = Int
type Alignment = Int

-- | Is a TyCon a promoted data constructor or just a normal type
--   constructor?
data PromotionFlag
NotPromoted :: PromotionFlag
IsPromoted :: PromotionFlag
isPromoted :: PromotionFlag -> Bool
data FunctionOrData
IsFunction :: FunctionOrData
IsData :: FunctionOrData

-- | Warning Text
--   
--   reason/explanation from a WARNING or DEPRECATED pragma
data WarningTxt
WarningTxt :: Located SourceText -> [Located StringLiteral] -> WarningTxt
DeprecatedTxt :: Located SourceText -> [Located StringLiteral] -> WarningTxt
pprWarningTxtForMsg :: WarningTxt -> SDoc

-- | A String Literal in the source, including its original raw format for
--   use by source to source manipulation tools.
data StringLiteral
StringLiteral :: SourceText -> FastString -> StringLiteral
[sl_st] :: StringLiteral -> SourceText
[sl_fs] :: StringLiteral -> FastString
data Fixity
Fixity :: SourceText -> Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
defaultFixity :: Fixity
maxPrecedence :: Int
minPrecedence :: Int
negateFixity :: Fixity
funTyFixity :: Fixity
compareFixity :: Fixity -> Fixity -> (Bool, Bool)

-- | Captures the fixity of declarations as they are parsed. This is not
--   necessarily the same as the fixity declaration, as the normal fixity
--   may be overridden using parens or backticks.
data LexicalFixity
Prefix :: LexicalFixity
Infix :: LexicalFixity

-- | Recursivity Flag
data RecFlag
Recursive :: RecFlag
NonRecursive :: RecFlag
isRec :: RecFlag -> Bool
isNonRec :: RecFlag -> Bool
boolToRecFlag :: Bool -> RecFlag
data Origin
FromSource :: Origin
Generated :: Origin
isGenerated :: Origin -> Bool
type RuleName = FastString
pprRuleName :: RuleName -> SDoc
data TopLevelFlag
TopLevel :: TopLevelFlag
NotTopLevel :: TopLevelFlag
isTopLevel :: TopLevelFlag -> Bool
isNotTopLevel :: TopLevelFlag -> Bool

-- | The semantics allowed for overlapping instances for a particular
--   instance. See Note [Safe Haskell isSafeOverlap] (in <a>hs</a>) for a
--   explanation of the <a>isSafeOverlap</a> field.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# OVERLAPPABLE'</tt>
--   or <tt>'{-# OVERLAPPING'</tt> or <tt>'{-# OVERLAPS'</tt> or <tt>'{-#
--   INCOHERENT'</tt>, <a>AnnClose</a> <tt>`#-}`</tt>,</li>
--   </ul>
data OverlapFlag
OverlapFlag :: OverlapMode -> Bool -> OverlapFlag
[overlapMode] :: OverlapFlag -> OverlapMode
[isSafeOverlap] :: OverlapFlag -> Bool
data OverlapMode

-- | This instance must not overlap another <a>NoOverlap</a> instance.
--   However, it may be overlapped by <a>Overlapping</a> instances, and it
--   may overlap <a>Overlappable</a> instances.
NoOverlap :: SourceText -> OverlapMode

-- | Silently ignore this instance if you find a more specific one that
--   matches the constraint you are trying to resolve
--   
--   Example: constraint (Foo [Int]) instance Foo [Int] instance {--} Foo
--   [a]
--   
--   Since the second instance has the Overlappable flag, the first
--   instance will be chosen (otherwise its ambiguous which to choose)
Overlappable :: SourceText -> OverlapMode

-- | Silently ignore any more general instances that may be used to solve
--   the constraint.
--   
--   Example: constraint (Foo [Int]) instance {--} Foo [Int] instance Foo
--   [a]
--   
--   Since the first instance has the Overlapping flag, the second---more
--   general---instance will be ignored (otherwise it is ambiguous which to
--   choose)
Overlapping :: SourceText -> OverlapMode

-- | Equivalent to having both <a>Overlapping</a> and <a>Overlappable</a>
--   flags.
Overlaps :: SourceText -> OverlapMode

-- | Behave like Overlappable and Overlapping, and in addition pick an an
--   arbitrary one if there are multiple matching candidates, and don't
--   worry about later instantiation
--   
--   Example: constraint (Foo [b]) instance {-# INCOHERENT -} Foo [Int]
--   instance Foo [a] Without the Incoherent flag, we'd complain that
--   instantiating <tt>b</tt> would change which instance was chosen. See
--   also note [Incoherent instances] in InstEnv
Incoherent :: SourceText -> OverlapMode
setOverlapModeMaybe :: OverlapFlag -> Maybe OverlapMode -> OverlapFlag
hasOverlappingFlag :: OverlapMode -> Bool
hasOverlappableFlag :: OverlapMode -> Bool
hasIncoherentFlag :: OverlapMode -> Bool
data Boxity
Boxed :: Boxity
Unboxed :: Boxity
isBoxed :: Boxity -> Bool

-- | A general-purpose pretty-printing precedence type.
newtype PprPrec
PprPrec :: Int -> PprPrec
topPrec :: PprPrec
sigPrec :: PprPrec
opPrec :: PprPrec
funPrec :: PprPrec
appPrec :: PprPrec
maybeParen :: PprPrec -> PprPrec -> SDoc -> SDoc
data TupleSort
BoxedTuple :: TupleSort
UnboxedTuple :: TupleSort
ConstraintTuple :: TupleSort
tupleSortBoxity :: TupleSort -> Boxity
boxityTupleSort :: Boxity -> TupleSort
tupleParens :: TupleSort -> SDoc -> SDoc
sumParens :: SDoc -> SDoc

-- | Pretty print an alternative in an unboxed sum e.g. "| a | |".
pprAlternative :: (a -> SDoc) -> a -> ConTag -> Arity -> SDoc

-- | If the <tt>Id</tt> is a lambda-bound variable then it may have
--   lambda-bound variable info. Sometimes we know whether the lambda
--   binding this variable is a "one-shot" lambda; that is, whether it is
--   applied at most once.
--   
--   This information may be useful in optimisation, as computations may
--   safely be floated inside such a lambda without risk of duplicating
--   work.
data OneShotInfo

-- | No information
NoOneShotInfo :: OneShotInfo

-- | The lambda is applied at most once.
OneShotLam :: OneShotInfo

-- | It is always safe to assume that an <tt>Id</tt> has no lambda-bound
--   variable information
noOneShotInfo :: OneShotInfo
hasNoOneShotInfo :: OneShotInfo -> Bool
isOneShotInfo :: OneShotInfo -> Bool
bestOneShot :: OneShotInfo -> OneShotInfo -> OneShotInfo
worstOneShot :: OneShotInfo -> OneShotInfo -> OneShotInfo

-- | identifier Occurrence Information
data OccInfo

-- | There are many occurrences, or unknown occurrences
ManyOccs :: !TailCallInfo -> OccInfo
[occ_tail] :: OccInfo -> !TailCallInfo

-- | Marks unused variables. Sometimes useful for lambda and case-bound
--   variables.
IAmDead :: OccInfo

-- | Occurs exactly once (per branch), not inside a rule
OneOcc :: !InsideLam -> !OneBranch -> !InterestingCxt -> !TailCallInfo -> OccInfo
[occ_in_lam] :: OccInfo -> !InsideLam
[occ_one_br] :: OccInfo -> !OneBranch
[occ_int_cxt] :: OccInfo -> !InterestingCxt
[occ_tail] :: OccInfo -> !TailCallInfo

-- | This identifier breaks a loop of mutually recursive functions. The
--   field marks whether it is only a loop breaker due to a reference in a
--   rule
IAmALoopBreaker :: !RulesOnly -> !TailCallInfo -> OccInfo
[occ_rules_only] :: OccInfo -> !RulesOnly
[occ_tail] :: OccInfo -> !TailCallInfo
noOccInfo :: OccInfo
seqOccInfo :: OccInfo -> ()
zapFragileOcc :: OccInfo -> OccInfo
isOneOcc :: OccInfo -> Bool
isDeadOcc :: OccInfo -> Bool
isStrongLoopBreaker :: OccInfo -> Bool
isWeakLoopBreaker :: OccInfo -> Bool
isManyOccs :: OccInfo -> Bool
strongLoopBreaker :: OccInfo
weakLoopBreaker :: OccInfo

-- | Inside Lambda
type InsideLam = Bool
insideLam :: InsideLam
notInsideLam :: InsideLam
type OneBranch = Bool
oneBranch :: OneBranch
notOneBranch :: OneBranch

-- | Interesting Context
type InterestingCxt = Bool
data TailCallInfo
AlwaysTailCalled :: JoinArity -> TailCallInfo
NoTailCallInfo :: TailCallInfo
tailCallInfo :: OccInfo -> TailCallInfo
zapOccTailCallInfo :: OccInfo -> OccInfo
isAlwaysTailCalled :: OccInfo -> Bool

-- | Embedding Projection pair
data EP a
EP :: a -> a -> EP a
[fromEP] :: EP a -> a
[toEP] :: EP a -> a

-- | Default Method Specification
data DefMethSpec ty
VanillaDM :: DefMethSpec ty
GenericDM :: ty -> DefMethSpec ty
data SwapFlag
NotSwapped :: SwapFlag
IsSwapped :: SwapFlag
flipSwap :: SwapFlag -> SwapFlag
unSwap :: SwapFlag -> (a -> a -> b) -> a -> a -> b
isSwapped :: SwapFlag -> Bool
data CompilerPhase
Phase :: PhaseNum -> CompilerPhase
InitialPhase :: CompilerPhase

-- | Phase Number
type PhaseNum = Int
data Activation
NeverActive :: Activation
AlwaysActive :: Activation
ActiveBefore :: SourceText -> PhaseNum -> Activation
ActiveAfter :: SourceText -> PhaseNum -> Activation
isActive :: CompilerPhase -> Activation -> Bool
isActiveIn :: PhaseNum -> Activation -> Bool
competesWith :: Activation -> Activation -> Bool
isNeverActive :: Activation -> Bool
isAlwaysActive :: Activation -> Bool
isEarlyActive :: Activation -> Bool
activeAfterInitial :: Activation
activeDuringFinal :: Activation

-- | Rule Match Information
data RuleMatchInfo
ConLike :: RuleMatchInfo
FunLike :: RuleMatchInfo
isConLike :: RuleMatchInfo -> Bool
isFunLike :: RuleMatchInfo -> Bool

-- | Inline Specification
data InlineSpec
Inline :: InlineSpec
Inlinable :: InlineSpec
NoInline :: InlineSpec
NoUserInline :: InlineSpec
noUserInlineSpec :: InlineSpec -> Bool
data InlinePragma
InlinePragma :: SourceText -> InlineSpec -> Maybe Arity -> Activation -> RuleMatchInfo -> InlinePragma
[inl_src] :: InlinePragma -> SourceText
[inl_inline] :: InlinePragma -> InlineSpec
[inl_sat] :: InlinePragma -> Maybe Arity
[inl_act] :: InlinePragma -> Activation
[inl_rule] :: InlinePragma -> RuleMatchInfo
defaultInlinePragma :: InlinePragma
alwaysInlinePragma :: InlinePragma
neverInlinePragma :: InlinePragma
dfunInlinePragma :: InlinePragma
isDefaultInlinePragma :: InlinePragma -> Bool
isInlinePragma :: InlinePragma -> Bool
isInlinablePragma :: InlinePragma -> Bool
isAnyInlinePragma :: InlinePragma -> Bool
inlinePragmaSpec :: InlinePragma -> InlineSpec
inlinePragmaSat :: InlinePragma -> Maybe Arity
inlinePragmaActivation :: InlinePragma -> Activation
inlinePragmaRuleMatchInfo :: InlinePragma -> RuleMatchInfo
setInlinePragmaActivation :: InlinePragma -> Activation -> InlinePragma
setInlinePragmaRuleMatchInfo :: InlinePragma -> RuleMatchInfo -> InlinePragma
pprInline :: InlinePragma -> SDoc
pprInlineDebug :: InlinePragma -> SDoc
data SuccessFlag
Succeeded :: SuccessFlag
Failed :: SuccessFlag
succeeded :: SuccessFlag -> Bool
failed :: SuccessFlag -> Bool
successIf :: Bool -> SuccessFlag

-- | Integral Literal
--   
--   Used (instead of Integer) to represent negative zegative zero which is
--   required for NegativeLiterals extension to correctly parse
--   `-0::Double` as negative zero. See also #13211.
data IntegralLit
IL :: SourceText -> Bool -> Integer -> IntegralLit
[il_text] :: IntegralLit -> SourceText
[il_neg] :: IntegralLit -> Bool
[il_value] :: IntegralLit -> Integer

-- | Fractional Literal
--   
--   Used (instead of Rational) to represent exactly the floating point
--   literal that we encountered in the user's source program. This allows
--   us to pretty-print exactly what the user wrote, which is important
--   e.g. for floating point numbers that can't represented as Doubles (we
--   used to via Double for pretty-printing). See also #2245.
data FractionalLit
FL :: SourceText -> Bool -> Rational -> FractionalLit
[fl_text] :: FractionalLit -> SourceText
[fl_neg] :: FractionalLit -> Bool
[fl_value] :: FractionalLit -> Rational
negateIntegralLit :: IntegralLit -> IntegralLit
negateFractionalLit :: FractionalLit -> FractionalLit
mkIntegralLit :: Integral a => a -> IntegralLit
mkFractionalLit :: Real a => a -> FractionalLit
integralFractionalLit :: Bool -> Integer -> FractionalLit
data SourceText
SourceText :: String -> SourceText

-- | For when code is generated, e.g. TH, deriving. The pretty printer will
--   then make its own representation of the item.
NoSourceText :: SourceText

-- | Special combinator for showing string literals.
pprWithSourceText :: SourceText -> SDoc -> SDoc

-- | An integer or infinity
data IntWithInf

-- | A representation of infinity
infinity :: IntWithInf

-- | Turn a positive number into an <a>IntWithInf</a>, where 0 represents
--   infinity
treatZeroAsInf :: Int -> IntWithInf

-- | Inject any integer into an <a>IntWithInf</a>
mkIntWithInf :: Int -> IntWithInf
intGtLimit :: Int -> IntWithInf -> Bool
data SpliceExplicitFlag

-- | <a>=</a> $(f x y)
ExplicitSplice :: SpliceExplicitFlag

-- | <a>=</a> f x y, i.e. a naked top level expression
ImplicitSplice :: SpliceExplicitFlag
instance Data.Data.Data BasicTypes.SpliceExplicitFlag
instance GHC.Classes.Eq BasicTypes.IntWithInf
instance GHC.Show.Show BasicTypes.FractionalLit
instance Data.Data.Data BasicTypes.FractionalLit
instance GHC.Show.Show BasicTypes.IntegralLit
instance Data.Data.Data BasicTypes.IntegralLit
instance Data.Data.Data BasicTypes.InlinePragma
instance GHC.Classes.Eq BasicTypes.InlinePragma
instance GHC.Show.Show BasicTypes.InlineSpec
instance Data.Data.Data BasicTypes.InlineSpec
instance GHC.Classes.Eq BasicTypes.InlineSpec
instance GHC.Show.Show BasicTypes.RuleMatchInfo
instance Data.Data.Data BasicTypes.RuleMatchInfo
instance GHC.Classes.Eq BasicTypes.RuleMatchInfo
instance Data.Data.Data BasicTypes.Activation
instance GHC.Classes.Eq BasicTypes.Activation
instance Data.Data.Data BasicTypes.WarningTxt
instance GHC.Classes.Eq BasicTypes.WarningTxt
instance Data.Data.Data BasicTypes.StringLiteral
instance Data.Data.Data BasicTypes.Fixity
instance Data.Data.Data BasicTypes.OverlapFlag
instance GHC.Classes.Eq BasicTypes.OverlapFlag
instance Data.Data.Data BasicTypes.OverlapMode
instance GHC.Classes.Eq BasicTypes.OverlapMode
instance GHC.Classes.Eq BasicTypes.SourceText
instance GHC.Show.Show BasicTypes.SourceText
instance Data.Data.Data BasicTypes.SourceText
instance GHC.Classes.Eq BasicTypes.OccInfo
instance GHC.Classes.Eq BasicTypes.TailCallInfo
instance Data.Data.Data BasicTypes.TupleSort
instance GHC.Classes.Eq BasicTypes.TupleSort
instance GHC.Show.Show BasicTypes.PprPrec
instance GHC.Classes.Ord BasicTypes.PprPrec
instance GHC.Classes.Eq BasicTypes.PprPrec
instance Data.Data.Data BasicTypes.Origin
instance GHC.Classes.Eq BasicTypes.Origin
instance Data.Data.Data BasicTypes.RecFlag
instance GHC.Classes.Eq BasicTypes.RecFlag
instance Data.Data.Data BasicTypes.Boxity
instance GHC.Classes.Eq BasicTypes.Boxity
instance GHC.Classes.Eq BasicTypes.LexicalFixity
instance Data.Data.Data BasicTypes.LexicalFixity
instance Data.Data.Data BasicTypes.FixityDirection
instance GHC.Classes.Eq BasicTypes.FixityDirection
instance Data.Data.Data BasicTypes.FunctionOrData
instance GHC.Classes.Ord BasicTypes.FunctionOrData
instance GHC.Classes.Eq BasicTypes.FunctionOrData
instance Data.Data.Data BasicTypes.PromotionFlag
instance GHC.Classes.Eq BasicTypes.PromotionFlag
instance GHC.Classes.Eq BasicTypes.OneShotInfo
instance Data.Data.Data BasicTypes.LeftOrRight
instance GHC.Classes.Eq BasicTypes.LeftOrRight
instance GHC.Classes.Ord BasicTypes.IntWithInf
instance Outputable.Outputable BasicTypes.IntWithInf
instance GHC.Num.Num BasicTypes.IntWithInf
instance GHC.Classes.Eq BasicTypes.FractionalLit
instance GHC.Classes.Ord BasicTypes.FractionalLit
instance Outputable.Outputable BasicTypes.FractionalLit
instance GHC.Classes.Eq BasicTypes.IntegralLit
instance GHC.Classes.Ord BasicTypes.IntegralLit
instance Outputable.Outputable BasicTypes.IntegralLit
instance Outputable.Outputable BasicTypes.InlinePragma
instance Outputable.Outputable BasicTypes.InlineSpec
instance Outputable.Outputable BasicTypes.RuleMatchInfo
instance Outputable.Outputable BasicTypes.Activation
instance Outputable.Outputable BasicTypes.CompilerPhase
instance Outputable.Outputable BasicTypes.WarningTxt
instance GHC.Classes.Eq BasicTypes.StringLiteral
instance Outputable.Outputable BasicTypes.StringLiteral
instance Outputable.Outputable BasicTypes.Fixity
instance GHC.Classes.Eq BasicTypes.Fixity
instance Outputable.Outputable BasicTypes.OverlapFlag
instance Outputable.Outputable BasicTypes.OverlapMode
instance Outputable.Outputable BasicTypes.SourceText
instance Outputable.Outputable BasicTypes.SuccessFlag
instance Outputable.Outputable (BasicTypes.DefMethSpec ty)
instance Outputable.Outputable BasicTypes.OccInfo
instance Outputable.Outputable BasicTypes.TailCallInfo
instance Outputable.Outputable BasicTypes.Origin
instance Outputable.Outputable BasicTypes.RecFlag
instance Outputable.Outputable BasicTypes.Boxity
instance Outputable.Outputable BasicTypes.TopLevelFlag
instance Outputable.Outputable BasicTypes.LexicalFixity
instance Outputable.Outputable BasicTypes.FixityDirection
instance Outputable.Outputable BasicTypes.FunctionOrData
instance Outputable.Outputable BasicTypes.SwapFlag
instance Outputable.Outputable BasicTypes.OneShotInfo
instance Outputable.Outputable BasicTypes.LeftOrRight

module Unique

-- | Unique identifier.
--   
--   The type of unique identifiers that are used in many places in GHC for
--   fast ordering and equality tests. You should generate these with the
--   functions from the <tt>UniqSupply</tt> module
--   
--   These are sometimes also referred to as "keys" in comments in GHC.
data Unique

-- | Class of things that we can obtain a <a>Unique</a> from
class Uniquable a
getUnique :: Uniquable a => a -> Unique
uNIQUE_BITS :: Int
hasKey :: Uniquable a => a -> Unique -> Bool
pprUniqueAlways :: Unique -> SDoc
mkUniqueGrimily :: Int -> Unique
getKey :: Unique -> Int
mkUnique :: Char -> Int -> Unique
unpkUnique :: Unique -> (Char, Int)
eqUnique :: Unique -> Unique -> Bool
ltUnique :: Unique -> Unique -> Bool
deriveUnique :: Unique -> Int -> Unique
newTagUnique :: Unique -> Char -> Unique
initTyVarUnique :: Unique
initExitJoinUnique :: Unique
nonDetCmpUnique :: Unique -> Unique -> Ordering

-- | The interface file symbol-table encoding assumes that known-key
--   uniques fit in 30-bits; verify this.
--   
--   See Note [Symbol table representation of names] in BinIface for
--   details.
isValidKnownKeyUnique :: Unique -> Bool
mkAlphaTyVarUnique :: Int -> Unique
mkPrimOpIdUnique :: Int -> Unique
mkPreludeMiscIdUnique :: Int -> Unique
mkPreludeDataConUnique :: Arity -> Unique
mkPreludeTyConUnique :: Int -> Unique
mkPreludeClassUnique :: Int -> Unique
mkCoVarUnique :: Int -> Unique
mkVarOccUnique :: FastString -> Unique
mkDataOccUnique :: FastString -> Unique
mkTvOccUnique :: FastString -> Unique
mkTcOccUnique :: FastString -> Unique
mkRegSingleUnique :: Int -> Unique
mkRegPairUnique :: Int -> Unique
mkRegClassUnique :: Int -> Unique
mkRegSubUnique :: Int -> Unique
mkCostCentreUnique :: Int -> Unique
mkBuiltinUnique :: Int -> Unique
mkPseudoUniqueD :: Int -> Unique
mkPseudoUniqueE :: Int -> Unique
mkPseudoUniqueH :: Int -> Unique
tyConRepNameUnique :: Unique -> Unique
dataConWorkerUnique :: Unique -> Unique
dataConTyRepNameUnique :: Unique -> Unique
instance Unique.Uniquable FastString.FastString
instance Unique.Uniquable GHC.Types.Int
instance Unique.Uniquable Unique.Unique
instance GHC.Classes.Eq Unique.Unique
instance Outputable.Outputable Unique.Unique
instance GHC.Show.Show Unique.Unique

module UniqSupply

-- | Unique Supply
--   
--   A value of type <a>UniqSupply</a> is unique, and it can supply
--   <i>one</i> distinct <a>Unique</a>. Also, from the supply, one can also
--   manufacture an arbitrary number of further <tt>UniqueSupply</tt>
--   values, which will be distinct from the first and from all others.
data UniqSupply

-- | Obtain the <a>Unique</a> from this particular <a>UniqSupply</a>
uniqFromSupply :: UniqSupply -> Unique

-- | Obtain an infinite list of <a>Unique</a> that can be generated by
--   constant splitting of the supply
uniqsFromSupply :: UniqSupply -> [Unique]

-- | Obtain the <a>Unique</a> from this particular <a>UniqSupply</a>, and a
--   new supply
takeUniqFromSupply :: UniqSupply -> (Unique, UniqSupply)

-- | Create a unique supply out of thin air. The character given must be
--   distinct from those of all calls to this function in the compiler for
--   the values generated to be truly unique.
mkSplitUniqSupply :: Char -> IO UniqSupply

-- | Build two <a>UniqSupply</a> from a single one, each of which can
--   supply its own <a>Unique</a>.
splitUniqSupply :: UniqSupply -> (UniqSupply, UniqSupply)

-- | Create an infinite list of <a>UniqSupply</a> from a single one
listSplitUniqSupply :: UniqSupply -> [UniqSupply]

-- | Build three <a>UniqSupply</a> from a single one, each of which can
--   supply its own unique
splitUniqSupply3 :: UniqSupply -> (UniqSupply, UniqSupply, UniqSupply)

-- | Build four <a>UniqSupply</a> from a single one, each of which can
--   supply its own unique
splitUniqSupply4 :: UniqSupply -> (UniqSupply, UniqSupply, UniqSupply, UniqSupply)

-- | A monad which just gives the ability to obtain <a>Unique</a>s
data UniqSM result

-- | A monad for generating unique identifiers
class Monad m => MonadUnique m

-- | Get a new UniqueSupply
getUniqueSupplyM :: MonadUnique m => m UniqSupply

-- | Get a new unique identifier
getUniqueM :: MonadUnique m => m Unique

-- | Get an infinite list of new unique identifiers
getUniquesM :: MonadUnique m => m [Unique]
liftUs :: MonadUnique m => UniqSM a -> m a

-- | Run the <a>UniqSM</a> action, returning the final <a>UniqSupply</a>
initUs :: UniqSupply -> UniqSM a -> (a, UniqSupply)

-- | Run the <a>UniqSM</a> action, discarding the final <a>UniqSupply</a>
initUs_ :: UniqSupply -> UniqSM a -> a
lazyThenUs :: UniqSM a -> (a -> UniqSM b) -> UniqSM b
lazyMapUs :: (a -> UniqSM b) -> [a] -> UniqSM [b]
getUniqueSupplyM3 :: MonadUnique m => m (UniqSupply, UniqSupply, UniqSupply)
initUniqSupply :: Int -> Int -> IO ()
instance UniqSupply.MonadUnique UniqSupply.UniqSM
instance GHC.Base.Monad UniqSupply.UniqSM
instance GHC.Base.Functor UniqSupply.UniqSM
instance GHC.Base.Applicative UniqSupply.UniqSM
instance Control.Monad.Fail.MonadFail UniqSupply.UniqSM
instance Control.Monad.Fix.MonadFix UniqSupply.UniqSM

module UniqFM
data UniqFM ele
emptyUFM :: UniqFM elt
unitUFM :: Uniquable key => key -> elt -> UniqFM elt
unitDirectlyUFM :: Unique -> elt -> UniqFM elt
listToUFM :: Uniquable key => [(key, elt)] -> UniqFM elt
listToUFM_Directly :: [(Unique, elt)] -> UniqFM elt
listToUFM_C :: Uniquable key => (elt -> elt -> elt) -> [(key, elt)] -> UniqFM elt
addToUFM :: Uniquable key => UniqFM elt -> key -> elt -> UniqFM elt
addToUFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqFM elt -> key -> elt -> UniqFM elt
addToUFM_Acc :: Uniquable key => (elt -> elts -> elts) -> (elt -> elts) -> UniqFM elts -> key -> elt -> UniqFM elts
addListToUFM :: Uniquable key => UniqFM elt -> [(key, elt)] -> UniqFM elt
addListToUFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqFM elt -> [(key, elt)] -> UniqFM elt
addToUFM_Directly :: UniqFM elt -> Unique -> elt -> UniqFM elt
addListToUFM_Directly :: UniqFM elt -> [(Unique, elt)] -> UniqFM elt
adjustUFM :: Uniquable key => (elt -> elt) -> UniqFM elt -> key -> UniqFM elt
alterUFM :: Uniquable key => (Maybe elt -> Maybe elt) -> UniqFM elt -> key -> UniqFM elt
adjustUFM_Directly :: (elt -> elt) -> UniqFM elt -> Unique -> UniqFM elt
delFromUFM :: Uniquable key => UniqFM elt -> key -> UniqFM elt
delFromUFM_Directly :: UniqFM elt -> Unique -> UniqFM elt
delListFromUFM :: Uniquable key => UniqFM elt -> [key] -> UniqFM elt
delListFromUFM_Directly :: UniqFM elt -> [Unique] -> UniqFM elt
plusUFM :: UniqFM elt -> UniqFM elt -> UniqFM elt
plusUFM_C :: (elt -> elt -> elt) -> UniqFM elt -> UniqFM elt -> UniqFM elt

-- | `plusUFM_CD f m1 d1 m2 d2` merges the maps using <tt>f</tt> as the
--   combinding function and <tt>d1</tt> resp. <tt>d2</tt> as the default
--   value if there is no entry in <tt>m1</tt> reps. <tt>m2</tt>. The
--   domain is the union of the domains of <tt>m1</tt> and <tt>m2</tt>.
--   
--   Representative example:
--   
--   <pre>
--   plusUFM_CD f {A: 1, B: 2} 23 {B: 3, C: 4} 42
--      == {A: f 1 42, B: f 2 3, C: f 23 4 }
--   </pre>
plusUFM_CD :: (elt -> elt -> elt) -> UniqFM elt -> elt -> UniqFM elt -> elt -> UniqFM elt
plusMaybeUFM_C :: (elt -> elt -> Maybe elt) -> UniqFM elt -> UniqFM elt -> UniqFM elt
plusUFMList :: [UniqFM elt] -> UniqFM elt
minusUFM :: UniqFM elt1 -> UniqFM elt2 -> UniqFM elt1
intersectUFM :: UniqFM elt1 -> UniqFM elt2 -> UniqFM elt1
intersectUFM_C :: (elt1 -> elt2 -> elt3) -> UniqFM elt1 -> UniqFM elt2 -> UniqFM elt3
disjointUFM :: UniqFM elt1 -> UniqFM elt2 -> Bool
equalKeysUFM :: UniqFM a -> UniqFM b -> Bool
nonDetFoldUFM :: (elt -> a -> a) -> a -> UniqFM elt -> a
foldUFM :: (elt -> a -> a) -> a -> UniqFM elt -> a
nonDetFoldUFM_Directly :: (Unique -> elt -> a -> a) -> a -> UniqFM elt -> a
anyUFM :: (elt -> Bool) -> UniqFM elt -> Bool
allUFM :: (elt -> Bool) -> UniqFM elt -> Bool
seqEltsUFM :: ([elt] -> ()) -> UniqFM elt -> ()
mapUFM :: (elt1 -> elt2) -> UniqFM elt1 -> UniqFM elt2
mapUFM_Directly :: (Unique -> elt1 -> elt2) -> UniqFM elt1 -> UniqFM elt2
elemUFM :: Uniquable key => key -> UniqFM elt -> Bool
elemUFM_Directly :: Unique -> UniqFM elt -> Bool
filterUFM :: (elt -> Bool) -> UniqFM elt -> UniqFM elt
filterUFM_Directly :: (Unique -> elt -> Bool) -> UniqFM elt -> UniqFM elt
partitionUFM :: (elt -> Bool) -> UniqFM elt -> (UniqFM elt, UniqFM elt)
sizeUFM :: UniqFM elt -> Int
isNullUFM :: UniqFM elt -> Bool
lookupUFM :: Uniquable key => UniqFM elt -> key -> Maybe elt
lookupUFM_Directly :: UniqFM elt -> Unique -> Maybe elt
lookupWithDefaultUFM :: Uniquable key => UniqFM elt -> elt -> key -> elt
lookupWithDefaultUFM_Directly :: UniqFM elt -> elt -> Unique -> elt
nonDetEltsUFM :: UniqFM elt -> [elt]
eltsUFM :: UniqFM elt -> [elt]
nonDetKeysUFM :: UniqFM elt -> [Unique]
ufmToSet_Directly :: UniqFM elt -> IntSet
nonDetUFMToList :: UniqFM elt -> [(Unique, elt)]
ufmToIntMap :: UniqFM elt -> IntMap elt
pprUniqFM :: (a -> SDoc) -> UniqFM a -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetEltsUFM.
pprUFM :: UniqFM a -> ([a] -> SDoc) -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetUFMToList.
pprUFMWithKeys :: UniqFM a -> ([(Unique, a)] -> SDoc) -> SDoc

-- | Determines the pluralisation suffix appropriate for the length of a
--   set in the same way that plural from Outputable does for lists.
pluralUFM :: UniqFM a -> SDoc
instance GHC.Base.Functor UniqFM.UniqFM
instance GHC.Classes.Eq ele => GHC.Classes.Eq (UniqFM.UniqFM ele)
instance Data.Data.Data ele => Data.Data.Data (UniqFM.UniqFM ele)
instance GHC.Base.Semigroup (UniqFM.UniqFM a)
instance GHC.Base.Monoid (UniqFM.UniqFM a)
instance Outputable.Outputable a => Outputable.Outputable (UniqFM.UniqFM a)

module UniqSet
data UniqSet a
getUniqSet :: UniqSet a -> UniqFM a
pprUniqSet :: (a -> SDoc) -> UniqSet a -> SDoc
emptyUniqSet :: UniqSet a
unitUniqSet :: Uniquable a => a -> UniqSet a
mkUniqSet :: Uniquable a => [a] -> UniqSet a
addOneToUniqSet :: Uniquable a => UniqSet a -> a -> UniqSet a
addListToUniqSet :: Uniquable a => UniqSet a -> [a] -> UniqSet a
delOneFromUniqSet :: Uniquable a => UniqSet a -> a -> UniqSet a
delOneFromUniqSet_Directly :: UniqSet a -> Unique -> UniqSet a
delListFromUniqSet :: Uniquable a => UniqSet a -> [a] -> UniqSet a
delListFromUniqSet_Directly :: UniqSet a -> [Unique] -> UniqSet a
unionUniqSets :: UniqSet a -> UniqSet a -> UniqSet a
unionManyUniqSets :: [UniqSet a] -> UniqSet a
minusUniqSet :: UniqSet a -> UniqSet a -> UniqSet a
uniqSetMinusUFM :: UniqSet a -> UniqFM b -> UniqSet a
intersectUniqSets :: UniqSet a -> UniqSet a -> UniqSet a
restrictUniqSetToUFM :: UniqSet a -> UniqFM b -> UniqSet a
uniqSetAny :: (a -> Bool) -> UniqSet a -> Bool
uniqSetAll :: (a -> Bool) -> UniqSet a -> Bool
elementOfUniqSet :: Uniquable a => a -> UniqSet a -> Bool
elemUniqSet_Directly :: Unique -> UniqSet a -> Bool
filterUniqSet :: (a -> Bool) -> UniqSet a -> UniqSet a
filterUniqSet_Directly :: (Unique -> elt -> Bool) -> UniqSet elt -> UniqSet elt
sizeUniqSet :: UniqSet a -> Int
isEmptyUniqSet :: UniqSet a -> Bool
lookupUniqSet :: Uniquable a => UniqSet b -> a -> Maybe b
lookupUniqSet_Directly :: UniqSet a -> Unique -> Maybe a
partitionUniqSet :: (a -> Bool) -> UniqSet a -> (UniqSet a, UniqSet a)
mapUniqSet :: Uniquable b => (a -> b) -> UniqSet a -> UniqSet b

-- | <a>unsafeUFMToUniqSet</a> converts a <tt><a>UniqFM</a> a</tt> into a
--   <tt><a>UniqSet</a> a</tt> assuming, without checking, that it maps
--   each <a>Unique</a> to a value that has that <a>Unique</a>. See Note
--   [UniqSet invariant].
unsafeUFMToUniqSet :: UniqFM a -> UniqSet a
nonDetEltsUniqSet :: UniqSet elt -> [elt]
nonDetKeysUniqSet :: UniqSet elt -> [Unique]
nonDetFoldUniqSet :: (elt -> a -> a) -> a -> UniqSet elt -> a
nonDetFoldUniqSet_Directly :: (Unique -> elt -> a -> a) -> a -> UniqSet elt -> a
instance GHC.Base.Monoid (UniqSet.UniqSet a)
instance GHC.Base.Semigroup (UniqSet.UniqSet a)
instance Data.Data.Data a => Data.Data.Data (UniqSet.UniqSet a)
instance GHC.Classes.Eq (UniqSet.UniqSet a)
instance Outputable.Outputable a => Outputable.Outputable (UniqSet.UniqSet a)

module UniqDFM

-- | Type of unique deterministic finite maps
data UniqDFM ele
emptyUDFM :: UniqDFM elt
unitUDFM :: Uniquable key => key -> elt -> UniqDFM elt
addToUDFM :: Uniquable key => UniqDFM elt -> key -> elt -> UniqDFM elt
addToUDFM_C :: Uniquable key => (elt -> elt -> elt) -> UniqDFM elt -> key -> elt -> UniqDFM elt
addListToUDFM :: Uniquable key => UniqDFM elt -> [(key, elt)] -> UniqDFM elt
delFromUDFM :: Uniquable key => UniqDFM elt -> key -> UniqDFM elt

-- | Delete a list of elements from a UniqDFM
delListFromUDFM :: Uniquable key => UniqDFM elt -> [key] -> UniqDFM elt

-- | Apply a function to a particular element
adjustUDFM :: Uniquable key => (elt -> elt) -> UniqDFM elt -> key -> UniqDFM elt

-- | The expression (alterUDFM f k map) alters value x at k, or absence
--   thereof. alterUDFM can be used to insert, delete, or update a value in
--   UniqDFM. Use addToUDFM, delFromUDFM or adjustUDFM when possible, they
--   are more efficient.
alterUDFM :: Uniquable key => (Maybe elt -> Maybe elt) -> UniqDFM elt -> key -> UniqDFM elt

-- | Map a function over every value in a UniqDFM
mapUDFM :: (elt1 -> elt2) -> UniqDFM elt1 -> UniqDFM elt2
plusUDFM :: UniqDFM elt -> UniqDFM elt -> UniqDFM elt
plusUDFM_C :: (elt -> elt -> elt) -> UniqDFM elt -> UniqDFM elt -> UniqDFM elt
lookupUDFM :: Uniquable key => UniqDFM elt -> key -> Maybe elt
lookupUDFM_Directly :: UniqDFM elt -> Unique -> Maybe elt
elemUDFM :: Uniquable key => key -> UniqDFM elt -> Bool

-- | Performs a deterministic fold over the UniqDFM. It's O(n log n) while
--   the corresponding function on <a>UniqFM</a> is O(n).
foldUDFM :: (elt -> a -> a) -> a -> UniqDFM elt -> a
eltsUDFM :: UniqDFM elt -> [elt]
filterUDFM :: (elt -> Bool) -> UniqDFM elt -> UniqDFM elt
filterUDFM_Directly :: (Unique -> elt -> Bool) -> UniqDFM elt -> UniqDFM elt
isNullUDFM :: UniqDFM elt -> Bool
sizeUDFM :: UniqDFM elt -> Int
intersectUDFM :: UniqDFM elt -> UniqDFM elt -> UniqDFM elt
udfmIntersectUFM :: UniqDFM elt1 -> UniqFM elt2 -> UniqDFM elt1
intersectsUDFM :: UniqDFM elt -> UniqDFM elt -> Bool
disjointUDFM :: UniqDFM elt -> UniqDFM elt -> Bool
disjointUdfmUfm :: UniqDFM elt -> UniqFM elt2 -> Bool
equalKeysUDFM :: UniqDFM a -> UniqDFM b -> Bool
minusUDFM :: UniqDFM elt1 -> UniqDFM elt2 -> UniqDFM elt1
listToUDFM :: Uniquable key => [(key, elt)] -> UniqDFM elt
udfmMinusUFM :: UniqDFM elt1 -> UniqFM elt2 -> UniqDFM elt1

-- | Partition UniqDFM into two UniqDFMs according to the predicate
partitionUDFM :: (elt -> Bool) -> UniqDFM elt -> (UniqDFM elt, UniqDFM elt)
anyUDFM :: (elt -> Bool) -> UniqDFM elt -> Bool
allUDFM :: (elt -> Bool) -> UniqDFM elt -> Bool
pprUniqDFM :: (a -> SDoc) -> UniqDFM a -> SDoc
pprUDFM :: UniqDFM a -> ([a] -> SDoc) -> SDoc

-- | Converts <a>UniqDFM</a> to a list, with elements in deterministic
--   order. It's O(n log n) while the corresponding function on
--   <a>UniqFM</a> is O(n).
udfmToList :: UniqDFM elt -> [(Unique, elt)]

-- | This allows for lossy conversion from UniqDFM to UniqFM
udfmToUfm :: UniqDFM elt -> UniqFM elt

-- | Performs a nondeterministic fold over the UniqDFM. It's O(n), same as
--   the corresponding function on <a>UniqFM</a>. If you use this please
--   provide a justification why it doesn't introduce nondeterminism.
nonDetFoldUDFM :: (elt -> a -> a) -> a -> UniqDFM elt -> a
alwaysUnsafeUfmToUdfm :: UniqFM elt -> UniqDFM elt
instance GHC.Base.Functor UniqDFM.UniqDFM
instance Data.Data.Data ele => Data.Data.Data (UniqDFM.UniqDFM ele)
instance Data.Data.Data val => Data.Data.Data (UniqDFM.TaggedVal val)
instance GHC.Base.Semigroup (UniqDFM.UniqDFM a)
instance GHC.Base.Monoid (UniqDFM.UniqDFM a)
instance Outputable.Outputable a => Outputable.Outputable (UniqDFM.UniqDFM a)
instance GHC.Classes.Eq val => GHC.Classes.Eq (UniqDFM.TaggedVal val)
instance GHC.Base.Functor UniqDFM.TaggedVal


-- | Specialised deterministic sets, for things with <tt>Uniques</tt>
--   
--   Based on <a>UniqDFM</a>s (as you would expect). See Note
--   [Deterministic UniqFM] in UniqDFM for explanation why we need it.
--   
--   Basically, the things need to be in class <a>Uniquable</a>.
module UniqDSet
data UniqDSet a
getUniqDSet :: UniqDSet a -> UniqDFM a
pprUniqDSet :: (a -> SDoc) -> UniqDSet a -> SDoc
delOneFromUniqDSet :: Uniquable a => UniqDSet a -> a -> UniqDSet a
delListFromUniqDSet :: Uniquable a => UniqDSet a -> [a] -> UniqDSet a
emptyUniqDSet :: UniqDSet a
unitUniqDSet :: Uniquable a => a -> UniqDSet a
mkUniqDSet :: Uniquable a => [a] -> UniqDSet a
addOneToUniqDSet :: Uniquable a => UniqDSet a -> a -> UniqDSet a
addListToUniqDSet :: Uniquable a => UniqDSet a -> [a] -> UniqDSet a
unionUniqDSets :: UniqDSet a -> UniqDSet a -> UniqDSet a
unionManyUniqDSets :: [UniqDSet a] -> UniqDSet a
minusUniqDSet :: UniqDSet a -> UniqDSet a -> UniqDSet a
uniqDSetMinusUniqSet :: UniqDSet a -> UniqSet b -> UniqDSet a
intersectUniqDSets :: UniqDSet a -> UniqDSet a -> UniqDSet a
uniqDSetIntersectUniqSet :: UniqDSet a -> UniqSet b -> UniqDSet a
foldUniqDSet :: (a -> b -> b) -> b -> UniqDSet a -> b
elementOfUniqDSet :: Uniquable a => a -> UniqDSet a -> Bool
filterUniqDSet :: (a -> Bool) -> UniqDSet a -> UniqDSet a
sizeUniqDSet :: UniqDSet a -> Int
isEmptyUniqDSet :: UniqDSet a -> Bool
lookupUniqDSet :: Uniquable a => UniqDSet a -> a -> Maybe a
uniqDSetToList :: UniqDSet a -> [a]
partitionUniqDSet :: (a -> Bool) -> UniqDSet a -> (UniqDSet a, UniqDSet a)
mapUniqDSet :: Uniquable b => (a -> b) -> UniqDSet a -> UniqDSet b
instance GHC.Base.Monoid (UniqDSet.UniqDSet a)
instance GHC.Base.Semigroup (UniqDSet.UniqDSet a)
instance Data.Data.Data a => Data.Data.Data (UniqDSet.UniqDSet a)
instance GHC.Classes.Eq (UniqDSet.UniqDSet a)
instance Outputable.Outputable a => Outputable.Outputable (UniqDSet.UniqDSet a)

module FastStringEnv

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in UniqDFM for explanation why it's not deterministic and why
--   it matters. Use DFastStringEnv if the set eventually gets converted
--   into a list or folded over in a way where the order changes the
--   generated code.
type FastStringEnv a = UniqFM a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a
emptyFsEnv :: FastStringEnv a
unitFsEnv :: FastString -> a -> FastStringEnv a
extendFsEnv_C :: (a -> a -> a) -> FastStringEnv a -> FastString -> a -> FastStringEnv a
extendFsEnv_Acc :: (a -> b -> b) -> (a -> b) -> FastStringEnv b -> FastString -> a -> FastStringEnv b
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
extendFsEnvList :: FastStringEnv a -> [(FastString, a)] -> FastStringEnv a
extendFsEnvList_C :: (a -> a -> a) -> FastStringEnv a -> [(FastString, a)] -> FastStringEnv a
filterFsEnv :: (elt -> Bool) -> FastStringEnv elt -> FastStringEnv elt
plusFsEnv :: FastStringEnv a -> FastStringEnv a -> FastStringEnv a
plusFsEnv_C :: (a -> a -> a) -> FastStringEnv a -> FastStringEnv a -> FastStringEnv a
alterFsEnv :: (Maybe a -> Maybe a) -> FastStringEnv a -> FastString -> FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
lookupFsEnv_NF :: FastStringEnv a -> FastString -> a
delFromFsEnv :: FastStringEnv a -> FastString -> FastStringEnv a
delListFromFsEnv :: FastStringEnv a -> [FastString] -> FastStringEnv a
elemFsEnv :: FastString -> FastStringEnv a -> Bool
mapFsEnv :: (elt1 -> elt2) -> FastStringEnv elt1 -> FastStringEnv elt2
type DFastStringEnv a = UniqDFM a
mkDFsEnv :: [(FastString, a)] -> DFastStringEnv a
emptyDFsEnv :: DFastStringEnv a
dFsEnvElts :: DFastStringEnv a -> [a]
lookupDFsEnv :: DFastStringEnv a -> FastString -> Maybe a

module Binary
data Bin a
class Binary a
put_ :: Binary a => BinHandle -> a -> IO ()
put :: Binary a => BinHandle -> a -> IO (Bin a)
get :: Binary a => BinHandle -> IO a
data BinHandle
type SymbolTable = Array Int Name
type Dictionary = Array Int FastString
openBinMem :: Int -> IO BinHandle
seekBin :: BinHandle -> Bin a -> IO ()
seekBy :: BinHandle -> Int -> IO ()
tellBin :: BinHandle -> IO (Bin a)
castBin :: Bin a -> Bin b
isEOFBin :: BinHandle -> IO Bool

-- | Get access to the underlying buffer.
--   
--   It is quite important that no references to the <a>ByteString</a> leak
--   out of the continuation lest terrible things happen.
withBinBuffer :: BinHandle -> (ByteString -> IO a) -> IO a
writeBinMem :: BinHandle -> FilePath -> IO ()
readBinMem :: FilePath -> IO BinHandle
putAt :: Binary a => BinHandle -> Bin a -> a -> IO ()
getAt :: Binary a => BinHandle -> Bin a -> IO a
putByte :: BinHandle -> Word8 -> IO ()
getByte :: BinHandle -> IO Word8
lazyGet :: Binary a => BinHandle -> IO a
lazyPut :: Binary a => BinHandle -> a -> IO ()

-- | Information we keep around during interface file
--   serialization/deserialization. Namely we keep the functions for
--   serializing and deserializing <a>Name</a>s and <a>FastString</a>s. We
--   do this because we actually use serialization in two distinct
--   settings,
--   
--   <ul>
--   <li>When serializing interface files themselves</li>
--   <li>When computing the fingerprint of an IfaceDecl (which we computing
--   by hashing its Binary serialization)</li>
--   </ul>
--   
--   These two settings have different needs while serializing Names:
--   
--   <ul>
--   <li>Names in interface files are serialized via a symbol table (see
--   Note [Symbol table representation of names] in BinIface).</li>
--   <li>During fingerprinting a binding Name is serialized as the OccName
--   and a non-binding Name is serialized as the fingerprint of the thing
--   they represent. See Note [Fingerprinting IfaceDecls] for further
--   discussion.</li>
--   </ul>
data UserData
UserData :: (BinHandle -> IO Name) -> (BinHandle -> IO FastString) -> (BinHandle -> Name -> IO ()) -> (BinHandle -> Name -> IO ()) -> (BinHandle -> FastString -> IO ()) -> UserData
[ud_get_name] :: UserData -> BinHandle -> IO Name
[ud_get_fs] :: UserData -> BinHandle -> IO FastString

-- | serialize a non-binding <a>Name</a> (e.g. a reference to another
--   binding).
[ud_put_nonbinding_name] :: UserData -> BinHandle -> Name -> IO ()

-- | serialize a binding <a>Name</a> (e.g. the name of an IfaceDecl)
[ud_put_binding_name] :: UserData -> BinHandle -> Name -> IO ()
[ud_put_fs] :: UserData -> BinHandle -> FastString -> IO ()
getUserData :: BinHandle -> UserData
setUserData :: BinHandle -> UserData -> BinHandle
newReadState :: (BinHandle -> IO Name) -> (BinHandle -> IO FastString) -> UserData
newWriteState :: (BinHandle -> Name -> IO ()) -> (BinHandle -> Name -> IO ()) -> (BinHandle -> FastString -> IO ()) -> UserData
putDictionary :: BinHandle -> Int -> UniqFM (Int, FastString) -> IO ()
getDictionary :: BinHandle -> IO Dictionary
putFS :: BinHandle -> FastString -> IO ()
instance forall k (a :: k). GHC.Enum.Bounded (Binary.Bin a)
instance forall k (a :: k). GHC.Show.Show (Binary.Bin a)
instance forall k (a :: k). GHC.Classes.Ord (Binary.Bin a)
instance forall k (a :: k). GHC.Classes.Eq (Binary.Bin a)
instance Binary.Binary GHC.Word.Word8
instance Binary.Binary GHC.Word.Word16
instance Binary.Binary GHC.Word.Word32
instance Binary.Binary GHC.Word.Word64
instance Binary.Binary GHC.Int.Int8
instance Binary.Binary GHC.Int.Int16
instance Binary.Binary GHC.Int.Int32
instance Binary.Binary GHC.Int.Int64
instance Binary.Binary ()
instance Binary.Binary GHC.Types.Bool
instance Binary.Binary GHC.Types.Char
instance Binary.Binary GHC.Types.Int
instance Binary.Binary a => Binary.Binary [a]
instance (GHC.Arr.Ix a, Binary.Binary a, Binary.Binary b) => Binary.Binary (GHC.Arr.Array a b)
instance (Binary.Binary a, Binary.Binary b) => Binary.Binary (a, b)
instance (Binary.Binary a, Binary.Binary b, Binary.Binary c) => Binary.Binary (a, b, c)
instance (Binary.Binary a, Binary.Binary b, Binary.Binary c, Binary.Binary d) => Binary.Binary (a, b, c, d)
instance (Binary.Binary a, Binary.Binary b, Binary.Binary c, Binary.Binary d, Binary.Binary e) => Binary.Binary (a, b, c, d, e)
instance (Binary.Binary a, Binary.Binary b, Binary.Binary c, Binary.Binary d, Binary.Binary e, Binary.Binary f) => Binary.Binary (a, b, c, d, e, f)
instance (Binary.Binary a, Binary.Binary b, Binary.Binary c, Binary.Binary d, Binary.Binary e, Binary.Binary f, Binary.Binary g) => Binary.Binary (a, b, c, d, e, f, g)
instance Binary.Binary a => Binary.Binary (GHC.Maybe.Maybe a)
instance (Binary.Binary a, Binary.Binary b) => Binary.Binary (Data.Either.Either a b)
instance Binary.Binary Data.Time.Clock.Internal.UTCTime.UTCTime
instance Binary.Binary Data.Time.Calendar.Days.Day
instance Binary.Binary Data.Time.Clock.Internal.DiffTime.DiffTime
instance Binary.Binary GHC.Integer.Type.Integer
instance Binary.Binary a => Binary.Binary (GHC.Real.Ratio a)
instance forall k (a :: k). Binary.Binary (Binary.Bin a)
instance Binary.Binary GHC.Types.TyCon
instance Binary.Binary GHC.Types.VecCount
instance Binary.Binary GHC.Types.VecElem
instance Binary.Binary GHC.Types.RuntimeRep
instance Binary.Binary GHC.Types.KindRep
instance Binary.Binary GHC.Types.TypeLitSort
instance forall k (a :: k). Data.Typeable.Internal.Typeable a => Binary.Binary (Data.Typeable.Internal.TypeRep a)
instance Binary.Binary Data.Typeable.Internal.SomeTypeRep
instance Binary.Binary Data.ByteString.Internal.ByteString
instance Binary.Binary FastString.FastString
instance Binary.Binary BasicTypes.LeftOrRight
instance Binary.Binary BasicTypes.PromotionFlag
instance Binary.Binary GHC.Fingerprint.Type.Fingerprint
instance Binary.Binary BasicTypes.FunctionOrData
instance Binary.Binary BasicTypes.TupleSort
instance Binary.Binary BasicTypes.Activation
instance Binary.Binary BasicTypes.InlinePragma
instance Binary.Binary BasicTypes.RuleMatchInfo
instance Binary.Binary BasicTypes.InlineSpec
instance Binary.Binary BasicTypes.RecFlag
instance Binary.Binary BasicTypes.OverlapMode
instance Binary.Binary BasicTypes.OverlapFlag
instance Binary.Binary BasicTypes.FixityDirection
instance Binary.Binary BasicTypes.Fixity
instance Binary.Binary BasicTypes.WarningTxt
instance Binary.Binary BasicTypes.StringLiteral
instance Binary.Binary a => Binary.Binary (SrcLoc.Located a)
instance Binary.Binary SrcLoc.RealSrcSpan
instance Binary.Binary SrcLoc.SrcSpan
instance Binary.Binary GHC.Serialized.Serialized
instance Binary.Binary BasicTypes.SourceText

module Module

-- | A ModuleName is essentially a simple string, e.g. <tt>Data.List</tt>.
data ModuleName
pprModuleName :: ModuleName -> SDoc
moduleNameFS :: ModuleName -> FastString
moduleNameString :: ModuleName -> String

-- | Returns the string version of the module name, with dots replaced by
--   slashes.
moduleNameSlashes :: ModuleName -> String

-- | Returns the string version of the module name, with dots replaced by
--   colons.
moduleNameColons :: ModuleName -> String

-- | Get a string representation of a <a>Module</a> that's unique and
--   stable across recompilations. eg.
--   "$aeson_70dylHtv1FFGeai1IoxcQr$Data.Aeson.Types.Internal"
moduleStableString :: Module -> String

-- | Calculate the free holes of a <a>Module</a>. If this set is non-empty,
--   this module was defined in an indefinite library that had required
--   signatures.
--   
--   If a module has free holes, that means that substitutions can operate
--   on it; if it has no free holes, substituting over a module has no
--   effect.
moduleFreeHoles :: Module -> UniqDSet ModuleName

-- | A <a>Module</a> is definite if it has no free holes.
moduleIsDefinite :: Module -> Bool
mkModuleName :: String -> ModuleName
mkModuleNameFS :: FastString -> ModuleName

-- | Compares module names lexically, rather than by their <a>Unique</a>s
stableModuleNameCmp :: ModuleName -> ModuleName -> Ordering

-- | A <a>ComponentId</a> consists of the package name, package version,
--   component ID, the transitive dependencies of the component, and other
--   information to uniquely identify the source code and build
--   configuration of a component.
--   
--   This used to be known as an <tt>InstalledPackageId</tt>, but a package
--   can contain multiple components and a <a>ComponentId</a> uniquely
--   identifies a component within a package. When a package only has one
--   component, the <a>ComponentId</a> coincides with the
--   <tt>InstalledPackageId</tt>
newtype ComponentId
ComponentId :: FastString -> ComponentId

-- | A unit identifier identifies a (possibly partially) instantiated
--   library. It is primarily used as part of <a>Module</a>, which in turn
--   is used in <tt>Name</tt>, which is used to give names to entities when
--   typechecking.
--   
--   There are two possible forms for a <a>UnitId</a>. It can be a
--   <a>DefiniteUnitId</a>, in which case we just have a string that
--   uniquely identifies some fully compiled, installed library we have on
--   disk. However, when we are typechecking a library with missing holes,
--   we may need to instantiate a library on the fly (in which case we
--   don't have any on-disk representation.) In that case, you have an
--   <a>IndefiniteUnitId</a>, which explicitly records the instantiation,
--   so that we can substitute over it.
data UnitId
IndefiniteUnitId :: {-# UNPACK #-} !IndefUnitId -> UnitId
DefiniteUnitId :: {-# UNPACK #-} !DefUnitId -> UnitId
unitIdFS :: UnitId -> FastString
unitIdKey :: UnitId -> Unique

-- | A unit identifier which identifies an indefinite library (with holes)
--   that has been *on-the-fly* instantiated with a substitution
--   <a>indefUnitIdInsts</a>. In fact, an indefinite unit identifier could
--   have no holes, but we haven't gotten around to compiling the actual
--   library yet.
--   
--   An indefinite unit identifier pretty-prints to something like
--   <tt>p[H=<a>H</a>,A=aimpl:A&gt;]</tt> (<tt>p</tt> is the
--   <a>ComponentId</a>, and the brackets enclose the module substitution).
data IndefUnitId
IndefUnitId :: FastString -> Unique -> !ComponentId -> ![(ModuleName, Module)] -> UniqDSet ModuleName -> IndefUnitId

-- | A private, uniquely identifying representation of a UnitId. This
--   string is completely private to GHC and is just used to get a unique;
--   in particular, we don't use it for symbols (indefinite libraries are
--   not compiled).
[indefUnitIdFS] :: IndefUnitId -> FastString

-- | Cached unique of <a>unitIdFS</a>.
[indefUnitIdKey] :: IndefUnitId -> Unique

-- | The component identity of the indefinite library that is being
--   instantiated.
[indefUnitIdComponentId] :: IndefUnitId -> !ComponentId

-- | The sorted (by <a>ModuleName</a>) instantiations of this library.
[indefUnitIdInsts] :: IndefUnitId -> ![(ModuleName, Module)]

-- | A cache of the free module variables of <tt>unitIdInsts</tt>. This
--   lets us efficiently tell if a <a>UnitId</a> has been fully
--   instantiated (free module variables are empty) and whether or not a
--   substitution can have any effect.
[indefUnitIdFreeHoles] :: IndefUnitId -> UniqDSet ModuleName
data IndefModule
IndefModule :: IndefUnitId -> ModuleName -> IndefModule
[indefModuleUnitId] :: IndefModule -> IndefUnitId
[indefModuleName] :: IndefModule -> ModuleName

-- | Injects an <a>IndefUnitId</a> (indefinite library which was on-the-fly
--   instantiated) to a <a>UnitId</a> (either an indefinite or definite
--   library).
indefUnitIdToUnitId :: DynFlags -> IndefUnitId -> UnitId

-- | Injects an <a>IndefModule</a> to <a>Module</a> (see also
--   <a>indefUnitIdToUnitId</a>.
indefModuleToModule :: DynFlags -> IndefModule -> Module

-- | An installed unit identifier identifies a library which has been
--   installed to the package database. These strings are provided to us
--   via the <tt>-this-unit-id</tt> flag. The library in question may be
--   definite or indefinite; if it is indefinite, none of the holes have
--   been filled (we never install partially instantiated libraries.) Put
--   another way, an installed unit id is either fully instantiated, or not
--   instantiated at all.
--   
--   Installed unit identifiers look something like
--   <tt>p+af23SAj2dZ219</tt>, or maybe just <tt>p</tt> if they don't use
--   Backpack.
newtype InstalledUnitId
InstalledUnitId :: FastString -> InstalledUnitId

-- | The full hashed unit identifier, including the component id and the
--   hash.
[installedUnitIdFS] :: InstalledUnitId -> FastString

-- | Lossy conversion to the on-disk <a>InstalledUnitId</a> for a
--   component.
toInstalledUnitId :: UnitId -> InstalledUnitId

-- | Substitution on module variables, mapping module names to module
--   identifiers.
type ShHoleSubst = ModuleNameEnv Module

-- | A <a>UnitId</a> is definite if it has no free holes.
unitIdIsDefinite :: UnitId -> Bool
unitIdString :: UnitId -> String

-- | Retrieve the set of free holes of a <a>UnitId</a>.
unitIdFreeHoles :: UnitId -> UniqDSet ModuleName

-- | Create a new, un-hashed unit identifier.
newUnitId :: ComponentId -> [(ModuleName, Module)] -> UnitId

-- | Create a new <a>IndefUnitId</a> given an explicit module substitution.
newIndefUnitId :: ComponentId -> [(ModuleName, Module)] -> IndefUnitId

-- | Create a new simple unit identifier (no holes) from a
--   <a>ComponentId</a>.
newSimpleUnitId :: ComponentId -> UnitId

-- | Generate a uniquely identifying <a>FastString</a> for a unit
--   identifier. This is a one-way function. You can rely on one special
--   property: if a unit identifier is in most general form, its
--   <a>FastString</a> coincides with its <a>ComponentId</a>. This hash is
--   completely internal to GHC and is not used for symbol names or file
--   paths.
hashUnitId :: ComponentId -> [(ModuleName, Module)] -> FastString

-- | Create a new simple unit identifier from a <a>FastString</a>.
--   Internally, this is primarily used to specify wired-in unit
--   identifiers.
fsToUnitId :: FastString -> UnitId
stringToUnitId :: String -> UnitId

-- | Compares package ids lexically, rather than by their <a>Unique</a>s
stableUnitIdCmp :: UnitId -> UnitId -> Ordering

-- | Substitutes holes in a <a>UnitId</a>, suitable for renaming when an
--   include occurs; see Note [Representation of module/name variable].
--   
--   <tt>p[A=<a>A</a>]</tt> maps to <tt>p[A=<a>B</a>]</tt> with
--   <tt>A=<a>B</a></tt>.
renameHoleUnitId :: DynFlags -> ShHoleSubst -> UnitId -> UnitId

-- | Substitutes holes in a <a>Module</a>. NOT suitable for being called
--   directly on a <tt>nameModule</tt>, see Note [Representation of
--   module/name variable]. <tt>p[A=<a>A</a>]:B</tt> maps to
--   <tt>p[A=q():A]:B</tt> with <tt>A=q():A</tt>; similarly,
--   <tt><a>A</a></tt> maps to <tt>q():A</tt>.
renameHoleModule :: DynFlags -> ShHoleSubst -> Module -> Module

-- | Like 'renameHoleUnitId, but requires only <a>PackageConfigMap</a> so
--   it can be used by <a>Packages</a>.
renameHoleUnitId' :: PackageConfigMap -> ShHoleSubst -> UnitId -> UnitId

-- | Like <a>renameHoleModule</a>, but requires only
--   <a>PackageConfigMap</a> so it can be used by <a>Packages</a>.
renameHoleModule' :: PackageConfigMap -> ShHoleSubst -> Module -> Module

-- | Given a possibly on-the-fly instantiated module, split it into a
--   <a>Module</a> that we definitely can find on-disk, as well as an
--   instantiation if we need to instantiate it on the fly. If the
--   instantiation is <tt>Nothing</tt> no on-the-fly renaming is needed.
splitModuleInsts :: Module -> (InstalledModule, Maybe IndefModule)

-- | See <a>splitModuleInsts</a>.
splitUnitIdInsts :: UnitId -> (InstalledUnitId, Maybe IndefUnitId)
generalizeIndefUnitId :: IndefUnitId -> IndefUnitId
generalizeIndefModule :: IndefModule -> IndefModule
parseModuleName :: ReadP ModuleName
parseUnitId :: ReadP UnitId
parseComponentId :: ReadP ComponentId
parseModuleId :: ReadP Module
parseModSubst :: ReadP [(ModuleName, Module)]
primUnitId :: UnitId
integerUnitId :: UnitId
baseUnitId :: UnitId
rtsUnitId :: UnitId
thUnitId :: UnitId

-- | This is the package Id for the current program. It is the default
--   package Id if you don't specify a package name. We don't add this
--   prefix to symbol names, since there can be only one main package per
--   program.
mainUnitId :: UnitId
thisGhcUnitId :: UnitId
isHoleModule :: Module -> Bool
interactiveUnitId :: UnitId
isInteractiveModule :: Module -> Bool
wiredInUnitIds :: [UnitId]

-- | A Module is a pair of a <a>UnitId</a> and a <a>ModuleName</a>.
--   
--   Module variables (i.e. <tt><a>H</a></tt>) which can be instantiated to
--   a specific module at some later point in time are represented with
--   <a>moduleUnitId</a> set to <a>holeUnitId</a> (this allows us to avoid
--   having to make <a>moduleUnitId</a> a partial operation.)
data Module
Module :: !UnitId -> !ModuleName -> Module
moduleUnitId :: Module -> UnitId
moduleName :: Module -> ModuleName
pprModule :: Module -> SDoc
mkModule :: UnitId -> ModuleName -> Module

-- | Create a module variable at some <a>ModuleName</a>. See Note
--   [Representation of module/name variables]
mkHoleModule :: ModuleName -> Module

-- | This gives a stable ordering, as opposed to the Ord instance which
--   gives an ordering based on the <a>Unique</a>s of the components, which
--   may not be stable from run to run of the compiler.
stableModuleCmp :: Module -> Module -> Ordering
class HasModule m
getModule :: HasModule m => m Module
class ContainsModule t
extractModule :: ContainsModule t => t -> Module

-- | A <a>InstalledModule</a> is a <a>Module</a> which contains a
--   <a>InstalledUnitId</a>.
data InstalledModule
InstalledModule :: !InstalledUnitId -> !ModuleName -> InstalledModule
[installedModuleUnitId] :: InstalledModule -> !InstalledUnitId
[installedModuleName] :: InstalledModule -> !ModuleName

-- | A map keyed off of <a>InstalledModule</a>
data InstalledModuleEnv elt

-- | Test if a <a>Module</a> corresponds to a given <a>InstalledModule</a>,
--   modulo instantiation.
installedModuleEq :: InstalledModule -> Module -> Bool

-- | Test if a <a>UnitId</a> corresponds to a given <a>InstalledUnitId</a>,
--   modulo instantiation.
installedUnitIdEq :: InstalledUnitId -> UnitId -> Bool
installedUnitIdString :: InstalledUnitId -> String
fsToInstalledUnitId :: FastString -> InstalledUnitId
componentIdToInstalledUnitId :: ComponentId -> InstalledUnitId
stringToInstalledUnitId :: String -> InstalledUnitId
emptyInstalledModuleEnv :: InstalledModuleEnv a
lookupInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> Maybe a
extendInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> a -> InstalledModuleEnv a
filterInstalledModuleEnv :: (InstalledModule -> a -> Bool) -> InstalledModuleEnv a -> InstalledModuleEnv a
delInstalledModuleEnv :: InstalledModuleEnv a -> InstalledModule -> InstalledModuleEnv a

-- | A <a>DefUnitId</a> is an <a>InstalledUnitId</a> with the invariant
--   that it only refers to a definite library; i.e., one we have generated
--   code for.
newtype DefUnitId
DefUnitId :: InstalledUnitId -> DefUnitId
[unDefUnitId] :: DefUnitId -> InstalledUnitId

-- | Module Location
--   
--   Where a module lives on the file system: the actual locations of the
--   .hs, .hi and .o files, if we have them
data ModLocation
ModLocation :: Maybe FilePath -> FilePath -> FilePath -> FilePath -> ModLocation
[ml_hs_file] :: ModLocation -> Maybe FilePath
[ml_hi_file] :: ModLocation -> FilePath
[ml_obj_file] :: ModLocation -> FilePath
[ml_hie_file] :: ModLocation -> FilePath

-- | Add the <tt>-boot</tt> suffix to .hs, .hi and .o files
addBootSuffix :: FilePath -> FilePath

-- | Add the <tt>-boot</tt> suffix if the <tt>Bool</tt> argument is
--   <tt>True</tt>
addBootSuffix_maybe :: Bool -> FilePath -> FilePath

-- | Add the <tt>-boot</tt> suffix to all file paths associated with the
--   module
addBootSuffixLocn :: ModLocation -> ModLocation

-- | Add the <tt>-boot</tt> suffix to all output file paths associated with
--   the module, not including the input file itself
addBootSuffixLocnOut :: ModLocation -> ModLocation

-- | A map keyed off of <a>Module</a>s
data ModuleEnv elt
elemModuleEnv :: Module -> ModuleEnv a -> Bool
extendModuleEnv :: ModuleEnv a -> Module -> a -> ModuleEnv a
extendModuleEnvList :: ModuleEnv a -> [(Module, a)] -> ModuleEnv a
extendModuleEnvList_C :: (a -> a -> a) -> ModuleEnv a -> [(Module, a)] -> ModuleEnv a
plusModuleEnv_C :: (a -> a -> a) -> ModuleEnv a -> ModuleEnv a -> ModuleEnv a
delModuleEnvList :: ModuleEnv a -> [Module] -> ModuleEnv a
delModuleEnv :: ModuleEnv a -> Module -> ModuleEnv a
plusModuleEnv :: ModuleEnv a -> ModuleEnv a -> ModuleEnv a
lookupModuleEnv :: ModuleEnv a -> Module -> Maybe a
lookupWithDefaultModuleEnv :: ModuleEnv a -> a -> Module -> a
mapModuleEnv :: (a -> b) -> ModuleEnv a -> ModuleEnv b
mkModuleEnv :: [(Module, a)] -> ModuleEnv a
emptyModuleEnv :: ModuleEnv a
moduleEnvKeys :: ModuleEnv a -> [Module]
moduleEnvElts :: ModuleEnv a -> [a]
moduleEnvToList :: ModuleEnv a -> [(Module, a)]
unitModuleEnv :: Module -> a -> ModuleEnv a
isEmptyModuleEnv :: ModuleEnv a -> Bool
extendModuleEnvWith :: (a -> a -> a) -> ModuleEnv a -> Module -> a -> ModuleEnv a
filterModuleEnv :: (Module -> a -> Bool) -> ModuleEnv a -> ModuleEnv a

-- | A map keyed off of <a>ModuleName</a>s (actually, their <a>Unique</a>s)
type ModuleNameEnv elt = UniqFM elt

-- | A map keyed off of <a>ModuleName</a>s (actually, their <a>Unique</a>s)
--   Has deterministic folds and can be deterministically converted to a
--   list
type DModuleNameEnv elt = UniqDFM elt

-- | A set of <a>Module</a>s
type ModuleSet = Set NDModule
emptyModuleSet :: ModuleSet
mkModuleSet :: [Module] -> ModuleSet
moduleSetElts :: ModuleSet -> [Module]
extendModuleSet :: ModuleSet -> Module -> ModuleSet
extendModuleSetList :: ModuleSet -> [Module] -> ModuleSet
delModuleSet :: ModuleSet -> Module -> ModuleSet
elemModuleSet :: Module -> ModuleSet -> Bool
intersectModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
minusModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
unionModuleSet :: ModuleSet -> ModuleSet -> ModuleSet
unitModuleSet :: Module -> ModuleSet
instance GHC.Classes.Eq Module.NDModule
instance GHC.Classes.Ord Module.IndefModule
instance GHC.Classes.Eq Module.IndefModule
instance GHC.Classes.Ord Module.Module
instance GHC.Classes.Eq Module.Module
instance GHC.Classes.Ord Module.DefUnitId
instance GHC.Classes.Eq Module.DefUnitId
instance GHC.Classes.Ord Module.InstalledModule
instance GHC.Classes.Eq Module.InstalledModule
instance GHC.Classes.Ord Module.ComponentId
instance GHC.Classes.Eq Module.ComponentId
instance GHC.Show.Show Module.ModLocation
instance GHC.Classes.Ord Module.NDModule
instance Outputable.Outputable Module.IndefModule
instance Unique.Uniquable Module.Module
instance Outputable.Outputable Module.Module
instance Binary.Binary Module.Module
instance Data.Data.Data Module.Module
instance Control.DeepSeq.NFData Module.Module
instance GHC.PackageDb.DbUnitIdModuleRep Module.InstalledUnitId Module.ComponentId Module.UnitId Module.ModuleName Module.Module
instance GHC.Classes.Eq Module.IndefUnitId
instance GHC.Classes.Ord Module.IndefUnitId
instance Binary.Binary Module.IndefUnitId
instance Outputable.Outputable Module.IndefUnitId
instance GHC.Show.Show Module.UnitId
instance GHC.Classes.Eq Module.UnitId
instance Unique.Uniquable Module.UnitId
instance GHC.Classes.Ord Module.UnitId
instance Data.Data.Data Module.UnitId
instance Control.DeepSeq.NFData Module.UnitId
instance Outputable.Outputable Module.UnitId
instance Binary.Binary Module.UnitId
instance Outputable.Outputable Module.DefUnitId
instance Binary.Binary Module.DefUnitId
instance Outputable.Outputable Module.InstalledModule
instance Binary.Binary Module.InstalledUnitId
instance GHC.PackageDb.BinaryStringRep Module.InstalledUnitId
instance GHC.Classes.Eq Module.InstalledUnitId
instance GHC.Classes.Ord Module.InstalledUnitId
instance Unique.Uniquable Module.InstalledUnitId
instance Outputable.Outputable Module.InstalledUnitId
instance GHC.PackageDb.BinaryStringRep Module.ComponentId
instance Unique.Uniquable Module.ComponentId
instance Outputable.Outputable Module.ComponentId
instance Binary.Binary Module.ComponentId
instance Unique.Uniquable Module.ModuleName
instance GHC.Classes.Eq Module.ModuleName
instance GHC.Classes.Ord Module.ModuleName
instance Outputable.Outputable Module.ModuleName
instance Binary.Binary Module.ModuleName
instance GHC.PackageDb.BinaryStringRep Module.ModuleName
instance Data.Data.Data Module.ModuleName
instance Control.DeepSeq.NFData Module.ModuleName
instance Outputable.Outputable Module.ModLocation


-- | Package configuration information: essentially the interface to Cabal,
--   with some utilities
--   
--   (c) The University of Glasgow, 2004
module PackageConfig
packageConfigId :: PackageConfig -> UnitId
expandedPackageConfigId :: PackageConfig -> UnitId
definitePackageConfigId :: PackageConfig -> Maybe DefUnitId

-- | Get the GHC <a>UnitId</a> right out of a Cabalish <a>PackageConfig</a>
installedPackageConfigId :: PackageConfig -> InstalledUnitId
type PackageConfig = InstalledPackageInfo ComponentId SourcePackageId PackageName InstalledUnitId UnitId ModuleName Module

-- | This is a subset of Cabal's <a>InstalledPackageInfo</a>, with just the
--   bits that GHC is interested in. See Cabal's documentation for a more
--   detailed description of all of the fields.
data InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod
InstalledPackageInfo :: instunitid -> compid -> [(modulename, mod)] -> srcpkgid -> srcpkgname -> Version -> Maybe srcpkgname -> String -> [instunitid] -> [(instunitid, String)] -> [FilePath] -> [String] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [String] -> [FilePath] -> [String] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [FilePath] -> [(modulename, Maybe mod)] -> [modulename] -> Bool -> Bool -> Bool -> InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod
[unitId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> instunitid
[componentId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> compid
[instantiatedWith] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(modulename, mod)]
[sourcePackageId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> srcpkgid
[packageName] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> srcpkgname
[packageVersion] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Version
[sourceLibName] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Maybe srcpkgname
[abiHash] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> String
[depends] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [instunitid]

-- | Like <a>depends</a>, but each dependency is annotated with the ABI
--   hash we expect the dependency to respect.
[abiDepends] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(instunitid, String)]
[importDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[hsLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[extraLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[extraGHCiLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[libraryDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[libraryDynDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[frameworks] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[frameworkDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[ldOptions] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[ccOptions] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[includes] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[includeDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[haddockInterfaces] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[haddockHTMLs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[exposedModules] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(modulename, Maybe mod)]
[hiddenModules] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [modulename]
[indefinite] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool
[exposed] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool
[trusted] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool

-- | A <a>ComponentId</a> consists of the package name, package version,
--   component ID, the transitive dependencies of the component, and other
--   information to uniquely identify the source code and build
--   configuration of a component.
--   
--   This used to be known as an <tt>InstalledPackageId</tt>, but a package
--   can contain multiple components and a <a>ComponentId</a> uniquely
--   identifies a component within a package. When a package only has one
--   component, the <a>ComponentId</a> coincides with the
--   <tt>InstalledPackageId</tt>
newtype ComponentId
ComponentId :: FastString -> ComponentId
newtype SourcePackageId
SourcePackageId :: FastString -> SourcePackageId
newtype PackageName
PackageName :: FastString -> PackageName

-- | A <a>Version</a> represents the version of a software entity.
--   
--   An instance of <a>Eq</a> is provided, which implements exact equality
--   modulo reordering of the tags in the <a>versionTags</a> field.
--   
--   An instance of <a>Ord</a> is also provided, which gives lexicographic
--   ordering on the <a>versionBranch</a> fields (i.e. 2.1 &gt; 2.0, 1.2.3
--   &gt; 1.2.2, etc.). This is expected to be sufficient for many uses,
--   but note that you may need to use a more specific ordering for your
--   versioning scheme. For example, some versioning schemes may include
--   pre-releases which have tags <tt>"pre1"</tt>, <tt>"pre2"</tt>, and so
--   on, and these would need to be taken into account when determining
--   ordering. In some cases, date ordering may be more appropriate, so the
--   application would have to look for <tt>date</tt> tags in the
--   <a>versionTags</a> field and compare those. The bottom line is, don't
--   always assume that <a>compare</a> and other <a>Ord</a> operations are
--   the right thing for every <a>Version</a>.
--   
--   Similarly, concrete representations of versions may differ. One
--   possible concrete representation is provided (see <a>showVersion</a>
--   and <a>parseVersion</a>), but depending on the application a different
--   concrete representation may be more appropriate.
data Version
Version :: [Int] -> [String] -> Version

-- | The numeric branch for this version. This reflects the fact that most
--   software versions are tree-structured; there is a main trunk which is
--   tagged with versions at various points (1,2,3...), and the first
--   branch off the trunk after version 3 is 3.1, the second branch off the
--   trunk after version 3 is 3.2, and so on. The tree can be branched
--   arbitrarily, just by adding more digits.
--   
--   We represent the branch as a list of <a>Int</a>, so version 3.2.1
--   becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of
--   <a>Ord</a> for <tt>[Int]</tt>) gives the natural ordering of branches.
[versionBranch] :: Version -> [Int]

-- | A version can be tagged with an arbitrary list of strings. The
--   interpretation of the list of tags is entirely dependent on the entity
--   that this version applies to.
[versionTags] :: Version -> [String]
defaultPackageConfig :: PackageConfig
sourcePackageIdString :: PackageConfig -> String
packageNameString :: PackageConfig -> String
pprPackageConfig :: PackageConfig -> SDoc
instance GHC.Classes.Ord PackageConfig.PackageName
instance GHC.Classes.Eq PackageConfig.PackageName
instance GHC.Classes.Ord PackageConfig.SourcePackageId
instance GHC.Classes.Eq PackageConfig.SourcePackageId
instance GHC.PackageDb.BinaryStringRep PackageConfig.PackageName
instance Unique.Uniquable PackageConfig.PackageName
instance Outputable.Outputable PackageConfig.PackageName
instance GHC.PackageDb.BinaryStringRep PackageConfig.SourcePackageId
instance Unique.Uniquable PackageConfig.SourcePackageId
instance Outputable.Outputable PackageConfig.SourcePackageId

module ForeignCall
newtype ForeignCall
CCall :: CCallSpec -> ForeignCall
isSafeForeignCall :: ForeignCall -> Bool
data Safety
PlaySafe :: Safety
PlayInterruptible :: Safety
PlayRisky :: Safety
playSafe :: Safety -> Bool
playInterruptible :: Safety -> Bool
data CExportSpec
CExportStatic :: SourceText -> CLabelString -> CCallConv -> CExportSpec
type CLabelString = FastString
isCLabelString :: CLabelString -> Bool
pprCLabelString :: CLabelString -> SDoc
data CCallSpec
CCallSpec :: CCallTarget -> CCallConv -> Safety -> CCallSpec

-- | How to call a particular function in C-land.
data CCallTarget
StaticTarget :: SourceText -> CLabelString -> Maybe UnitId -> Bool -> CCallTarget
DynamicTarget :: CCallTarget
isDynamicTarget :: CCallTarget -> Bool
data CCallConv
CCallConv :: CCallConv
CApiConv :: CCallConv
StdCallConv :: CCallConv
PrimCallConv :: CCallConv
JavaScriptCallConv :: CCallConv
defaultCCallConv :: CCallConv
ccallConvToInt :: CCallConv -> Int
ccallConvAttribute :: CCallConv -> SDoc
data Header
Header :: SourceText -> FastString -> Header

-- | A C type, used in CAPI FFI calls
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# CTYPE'</tt>,
--   <a>AnnHeader</a>,<a>AnnVal</a>, <a>AnnClose</a> <tt>'#-}'</tt>,</li>
--   </ul>
data CType
CType :: SourceText -> Maybe Header -> (SourceText, FastString) -> CType
instance Data.Data.Data ForeignCall.CType
instance GHC.Classes.Eq ForeignCall.CType
instance Data.Data.Data ForeignCall.Header
instance GHC.Classes.Eq ForeignCall.Header
instance Data.Data.Data ForeignCall.CExportSpec
instance GHC.Classes.Eq ForeignCall.ForeignCall
instance GHC.Classes.Eq ForeignCall.CCallSpec
instance Data.Data.Data ForeignCall.CCallTarget
instance GHC.Classes.Eq ForeignCall.CCallTarget
instance Data.Data.Data ForeignCall.CCallConv
instance GHC.Classes.Eq ForeignCall.CCallConv
instance Data.Data.Data ForeignCall.Safety
instance GHC.Show.Show ForeignCall.Safety
instance GHC.Classes.Eq ForeignCall.Safety
instance Outputable.Outputable ForeignCall.CType
instance Binary.Binary ForeignCall.CType
instance Outputable.Outputable ForeignCall.Header
instance Binary.Binary ForeignCall.Header
instance Outputable.Outputable ForeignCall.CExportSpec
instance Binary.Binary ForeignCall.CExportSpec
instance Outputable.Outputable ForeignCall.ForeignCall
instance Binary.Binary ForeignCall.ForeignCall
instance Outputable.Outputable ForeignCall.CCallSpec
instance Binary.Binary ForeignCall.CCallSpec
instance Binary.Binary ForeignCall.CCallTarget
instance Outputable.Outputable ForeignCall.CCallConv
instance Binary.Binary ForeignCall.CCallConv
instance Outputable.Outputable ForeignCall.Safety
instance Binary.Binary ForeignCall.Safety

module CostCentreState

-- | Per-module state for tracking cost centre indices.
--   
--   See documentation of <a>cc_flavour</a> for more details.
data CostCentreState

-- | Initialize cost centre state.
newCostCentreState :: CostCentreState

-- | An index into a given cost centre module,name,flavour set
data CostCentreIndex
unCostCentreIndex :: CostCentreIndex -> Int

-- | Get a new index for a given cost centre name.
getCCIndex :: FastString -> CostCentreState -> (CostCentreIndex, CostCentreState)
instance Binary.Binary CostCentreState.CostCentreIndex
instance Data.Data.Data CostCentreState.CostCentreIndex
instance GHC.Classes.Ord CostCentreState.CostCentreIndex
instance GHC.Classes.Eq CostCentreState.CostCentreIndex


-- | Boolean formulas without quantifiers and without negation. Such a
--   formula consists of variables, conjunctions (and), and disjunctions
--   (or).
--   
--   This module is used to represent minimal complete definitions for
--   classes.
module BooleanFormula
data BooleanFormula a
Var :: a -> BooleanFormula a
And :: [LBooleanFormula a] -> BooleanFormula a
Or :: [LBooleanFormula a] -> BooleanFormula a
Parens :: LBooleanFormula a -> BooleanFormula a
type LBooleanFormula a = Located (BooleanFormula a)
mkFalse :: BooleanFormula a
mkTrue :: BooleanFormula a
mkAnd :: Eq a => [LBooleanFormula a] -> BooleanFormula a
mkOr :: Eq a => [LBooleanFormula a] -> BooleanFormula a
mkVar :: a -> BooleanFormula a
isFalse :: BooleanFormula a -> Bool
isTrue :: BooleanFormula a -> Bool
eval :: (a -> Bool) -> BooleanFormula a -> Bool
simplify :: Eq a => (a -> Maybe Bool) -> BooleanFormula a -> BooleanFormula a
isUnsatisfied :: Eq a => (a -> Bool) -> BooleanFormula a -> Maybe (BooleanFormula a)
implies :: Uniquable a => BooleanFormula a -> BooleanFormula a -> Bool
impliesAtom :: Eq a => BooleanFormula a -> a -> Bool
pprBooleanFormula :: (Rational -> a -> SDoc) -> Rational -> BooleanFormula a -> SDoc
pprBooleanFormulaNice :: Outputable a => BooleanFormula a -> SDoc
instance Data.Traversable.Traversable BooleanFormula.BooleanFormula
instance Data.Foldable.Foldable BooleanFormula.BooleanFormula
instance GHC.Base.Functor BooleanFormula.BooleanFormula
instance Data.Data.Data a => Data.Data.Data (BooleanFormula.BooleanFormula a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (BooleanFormula.BooleanFormula a)
instance Outputable.OutputableBndr a => Outputable.Outputable (BooleanFormula.BooleanFormula a)
instance Binary.Binary a => Binary.Binary (BooleanFormula.BooleanFormula a)

module DriverPhases
data HscSource
HsSrcFile :: HscSource
HsBootFile :: HscSource
HsigFile :: HscSource
isHsBootOrSig :: HscSource -> Bool
isHsigFile :: HscSource -> Bool
hscSourceString :: HscSource -> String
data Phase
Unlit :: HscSource -> Phase
Cpp :: HscSource -> Phase
HsPp :: HscSource -> Phase
Hsc :: HscSource -> Phase
Ccxx :: Phase
Cc :: Phase
Cobjc :: Phase
Cobjcxx :: Phase
HCc :: Phase
Splitter :: Phase
SplitAs :: Phase
As :: Bool -> Phase
LlvmOpt :: Phase
LlvmLlc :: Phase
LlvmMangle :: Phase
CmmCpp :: Phase
Cmm :: Phase
MergeForeign :: Phase
StopLn :: Phase
happensBefore :: DynFlags -> Phase -> Phase -> Bool
eqPhase :: Phase -> Phase -> Bool
anyHsc :: Phase
isStopLn :: Phase -> Bool
startPhase :: String -> Phase
phaseInputExt :: Phase -> String
isHaskellishSuffix :: String -> Bool
isHaskellSrcSuffix :: String -> Bool
isBackpackishSuffix :: String -> Bool
isObjectSuffix :: Platform -> String -> Bool
isCishSuffix :: String -> Bool
isDynLibSuffix :: Platform -> String -> Bool
isHaskellUserSrcSuffix :: String -> Bool
isHaskellSigSuffix :: String -> Bool
isSourceSuffix :: String -> Bool

-- | When we are given files (modified by -x arguments) we need to
--   determine if they are Haskellish or not to figure out how we should
--   try to compile it. The rules are:
--   
--   <ol>
--   <li>If no -x flag was specified, we check to see if the file looks
--   like a module name, has no extension, or has a Haskell source
--   extension.</li>
--   <li>If an -x flag was specified, we just make sure the specified
--   suffix is a Haskell one.</li>
--   </ol>
isHaskellishTarget :: (String, Maybe Phase) -> Bool
isHaskellishFilename :: FilePath -> Bool
isHaskellSrcFilename :: FilePath -> Bool
isHaskellSigFilename :: FilePath -> Bool
isObjectFilename :: Platform -> FilePath -> Bool
isCishFilename :: FilePath -> Bool
isDynLibFilename :: Platform -> FilePath -> Bool
isHaskellUserSrcFilename :: FilePath -> Bool
isSourceFilename :: FilePath -> Bool
instance GHC.Show.Show DriverPhases.Phase
instance GHC.Classes.Eq DriverPhases.Phase
instance GHC.Show.Show DriverPhases.HscSource
instance GHC.Classes.Ord DriverPhases.HscSource
instance GHC.Classes.Eq DriverPhases.HscSource
instance Outputable.Outputable DriverPhases.Phase
instance Binary.Binary DriverPhases.HscSource

module Digraph
data Graph node
graphFromEdgedVerticesOrd :: Ord key => [Node key payload] -> Graph (Node key payload)
graphFromEdgedVerticesUniq :: Uniquable key => [Node key payload] -> Graph (Node key payload)

-- | Strongly connected component.
data SCC vertex

-- | A single vertex that is not in any cycle.
AcyclicSCC :: vertex -> SCC vertex

-- | A maximal set of mutually reachable vertices.
CyclicSCC :: [vertex] -> SCC vertex

-- | Representation for nodes of the Graph.
--   
--   <ul>
--   <li>The <tt>payload</tt> is user data, just carried around in this
--   module</li>
--   <li>The <tt>key</tt> is the node identifier. Key has an Ord instance
--   for performance reasons.</li>
--   <li>The <tt>[key]</tt> are the dependencies of the node; it's ok to
--   have extra keys in the dependencies that are not the key of any Node
--   in the graph</li>
--   </ul>
data Node key payload
DigraphNode :: payload -> key -> [key] -> Node key payload

-- | User data
[node_payload] :: Node key payload -> payload

-- | User defined node id
[node_key] :: Node key payload -> key

-- | Dependencies/successors of the node
[node_dependencies] :: Node key payload -> [key]

-- | The vertices of a strongly connected component.
flattenSCC :: () => SCC vertex -> [vertex]

-- | The vertices of a list of strongly connected components.
flattenSCCs :: () => [SCC a] -> [a]
stronglyConnCompG :: Graph node -> [SCC node]
topologicalSortG :: Graph node -> [node]
verticesG :: Graph node -> [node]
edgesG :: Graph node -> [Edge node]
hasVertexG :: Graph node -> node -> Bool
reachableG :: Graph node -> node -> [node]

-- | Given a list of roots return all reachable nodes.
reachablesG :: Graph node -> [node] -> [node]
transposeG :: Graph node -> Graph node
emptyG :: Graph node -> Bool

-- | Find a reasonably short cycle a-&gt;b-&gt;c-&gt;a, in a strongly
--   connected component. The input nodes are presumed to be a SCC, so you
--   can start anywhere.
findCycle :: forall payload key. Ord key => [Node key payload] -> Maybe [payload]
stronglyConnCompFromEdgedVerticesOrd :: Ord key => [Node key payload] -> [SCC payload]
stronglyConnCompFromEdgedVerticesOrdR :: Ord key => [Node key payload] -> [SCC (Node key payload)]
stronglyConnCompFromEdgedVerticesUniq :: Uniquable key => [Node key payload] -> [SCC payload]
stronglyConnCompFromEdgedVerticesUniqR :: Uniquable key => [Node key payload] -> [SCC (Node key payload)]

-- | Edge direction based on DFS Classification
data EdgeType
Forward :: EdgeType
Cross :: EdgeType

-- | Loop back towards the root node. Eg backjumps in loops
Backward :: EdgeType

-- | v -&gt; v
SelfLoop :: EdgeType

-- | Given a start vertex, a way to get successors from a node and a list
--   of (directed) edges classify the types of edges.
classifyEdges :: forall key. Uniquable key => key -> (key -> [key]) -> [(key, key)] -> [((key, key), EdgeType)]
instance Outputable.Outputable Digraph.Time
instance GHC.Num.Num Digraph.Time
instance GHC.Classes.Ord Digraph.Time
instance GHC.Classes.Eq Digraph.Time
instance GHC.Classes.Ord Digraph.EdgeType
instance GHC.Classes.Eq Digraph.EdgeType
instance Outputable.Outputable Digraph.EdgeType
instance Outputable.Outputable node => Outputable.Outputable (Digraph.Graph node)
instance (Outputable.Outputable a, Outputable.Outputable b) => Outputable.Outputable (Digraph.Node a b)
instance Outputable.Outputable node => Outputable.Outputable (Digraph.Edge node)

module Bag
data Bag a
emptyBag :: Bag a
unitBag :: a -> Bag a
unionBags :: Bag a -> Bag a -> Bag a
unionManyBags :: [Bag a] -> Bag a
mapBag :: (a -> b) -> Bag a -> Bag b
elemBag :: Eq a => a -> Bag a -> Bool
lengthBag :: Bag a -> Int
filterBag :: (a -> Bool) -> Bag a -> Bag a
partitionBag :: (a -> Bool) -> Bag a -> (Bag a, Bag a)
partitionBagWith :: (a -> Either b c) -> Bag a -> (Bag b, Bag c)
concatBag :: Bag (Bag a) -> Bag a
catBagMaybes :: Bag (Maybe a) -> Bag a
foldBag :: (r -> r -> r) -> (a -> r) -> r -> Bag a -> r
foldrBag :: (a -> r -> r) -> r -> Bag a -> r
foldlBag :: (r -> a -> r) -> r -> Bag a -> r
isEmptyBag :: Bag a -> Bool
isSingletonBag :: Bag a -> Bool
consBag :: a -> Bag a -> Bag a
infixr 3 `consBag`
snocBag :: Bag a -> a -> Bag a
infixl 3 `snocBag`
anyBag :: (a -> Bool) -> Bag a -> Bool
allBag :: (a -> Bool) -> Bag a -> Bool
listToBag :: [a] -> Bag a
bagToList :: Bag a -> [a]
mapAccumBagL :: (acc -> x -> (acc, y)) -> acc -> Bag x -> (acc, Bag y)
concatMapBag :: (a -> Bag b) -> Bag a -> Bag b
concatMapBagPair :: (a -> (Bag b, Bag c)) -> Bag a -> (Bag b, Bag c)
mapMaybeBag :: (a -> Maybe b) -> Bag a -> Bag b
foldrBagM :: Monad m => (a -> b -> m b) -> b -> Bag a -> m b
foldlBagM :: Monad m => (b -> a -> m b) -> b -> Bag a -> m b
mapBagM :: Monad m => (a -> m b) -> Bag a -> m (Bag b)
mapBagM_ :: Monad m => (a -> m b) -> Bag a -> m ()
flatMapBagM :: Monad m => (a -> m (Bag b)) -> Bag a -> m (Bag b)
flatMapBagPairM :: Monad m => (a -> m (Bag b, Bag c)) -> Bag a -> m (Bag b, Bag c)
mapAndUnzipBagM :: Monad m => (a -> m (b, c)) -> Bag a -> m (Bag b, Bag c)
mapAccumBagLM :: Monad m => (acc -> x -> m (acc, y)) -> acc -> Bag x -> m (acc, Bag y)
anyBagM :: Monad m => (a -> m Bool) -> Bag a -> m Bool
filterBagM :: Monad m => (a -> m Bool) -> Bag a -> m (Bag a)
instance Outputable.Outputable a => Outputable.Outputable (Bag.Bag a)
instance Data.Data.Data a => Data.Data.Data (Bag.Bag a)
instance GHC.Base.Functor Bag.Bag
instance Data.Foldable.Foldable Bag.Bag


-- | Command-line parser
--   
--   This is an abstract command-line parser used by DynFlags.
--   
--   (c) The University of Glasgow 2005
module CmdLineParser
processArgs :: Monad m => [Flag m] -> [Located String] -> m ([Located String], [Err], [Warn])
data OptKind m
NoArg :: EwM m () -> OptKind m
HasArg :: (String -> EwM m ()) -> OptKind m
SepArg :: (String -> EwM m ()) -> OptKind m
Prefix :: (String -> EwM m ()) -> OptKind m
OptPrefix :: (String -> EwM m ()) -> OptKind m
OptIntSuffix :: (Maybe Int -> EwM m ()) -> OptKind m
IntSuffix :: (Int -> EwM m ()) -> OptKind m
FloatSuffix :: (Float -> EwM m ()) -> OptKind m
PassFlag :: (String -> EwM m ()) -> OptKind m
AnySuffix :: (String -> EwM m ()) -> OptKind m

-- | GHC flag modes describing when a flag has an effect.
data GhcFlagMode

-- | The flag only affects the non-interactive GHC
OnlyGhc :: GhcFlagMode

-- | The flag only affects the interactive GHC
OnlyGhci :: GhcFlagMode

-- | The flag affects multiple ghc modes
AllModes :: GhcFlagMode

-- | This flag should not be seen in cli completion
HiddenFlag :: GhcFlagMode
newtype CmdLineP s a
CmdLineP :: (s -> (a, s)) -> CmdLineP s a
[runCmdLine] :: CmdLineP s a -> s -> (a, s)
getCmdLineState :: CmdLineP s s
putCmdLineState :: s -> CmdLineP s ()
data Flag m
Flag :: String -> OptKind m -> GhcFlagMode -> Flag m
[flagName] :: Flag m -> String
[flagOptKind] :: Flag m -> OptKind m
[flagGhcMode] :: Flag m -> GhcFlagMode
defFlag :: String -> OptKind m -> Flag m
defGhcFlag :: String -> OptKind m -> Flag m
defGhciFlag :: String -> OptKind m -> Flag m
defHiddenFlag :: String -> OptKind m -> Flag m
errorsToGhcException :: [(String, String)] -> GhcException

-- | A command-line error message
newtype Err
Err :: Located String -> Err
[errMsg] :: Err -> Located String

-- | A command-line warning message and the reason it arose
data Warn
Warn :: WarnReason -> Located String -> Warn
[warnReason] :: Warn -> WarnReason
[warnMsg] :: Warn -> Located String

-- | Used when filtering warnings: if a reason is given it can be filtered
--   out when displaying.
data WarnReason
NoReason :: WarnReason
ReasonDeprecatedFlag :: WarnReason
ReasonUnrecognisedFlag :: WarnReason
data EwM m a
runEwM :: EwM m a -> m (Errs, Warns, a)
addErr :: Monad m => String -> EwM m ()
addWarn :: Monad m => String -> EwM m ()
addFlagWarn :: Monad m => WarnReason -> String -> EwM m ()
getArg :: Monad m => EwM m String
getCurLoc :: Monad m => EwM m SrcSpan
liftEwM :: Monad m => m a -> EwM m a
deprecate :: Monad m => String -> EwM m ()
instance GHC.Show.Show CmdLineParser.WarnReason
instance GHC.Classes.Eq CmdLineParser.WarnReason
instance GHC.Base.Functor (CmdLineParser.CmdLineP s)
instance GHC.Base.Applicative (CmdLineParser.CmdLineP s)
instance GHC.Base.Monad (CmdLineParser.CmdLineP s)
instance GHC.Base.Monad m => GHC.Base.Functor (CmdLineParser.EwM m)
instance GHC.Base.Monad m => GHC.Base.Applicative (CmdLineParser.EwM m)
instance GHC.Base.Monad m => GHC.Base.Monad (CmdLineParser.EwM m)
instance Outputable.Outputable CmdLineParser.WarnReason
instance Json.ToJson CmdLineParser.WarnReason


-- | Dynamic flags
--   
--   Most flags are dynamic flags, which means they can change from
--   compilation to compilation using <tt>OPTIONS_GHC</tt> pragmas, and in
--   a multi-session GHC each session can be using different dynamic flags.
--   Dynamic flags can also be set at the prompt in GHCi.
--   
--   (c) The University of Glasgow 2005
module DynFlags
data DumpFlag
Opt_D_dump_cmm :: DumpFlag
Opt_D_dump_cmm_from_stg :: DumpFlag
Opt_D_dump_cmm_raw :: DumpFlag
Opt_D_dump_cmm_verbose :: DumpFlag
Opt_D_dump_cmm_cfg :: DumpFlag
Opt_D_dump_cmm_cbe :: DumpFlag
Opt_D_dump_cmm_switch :: DumpFlag
Opt_D_dump_cmm_proc :: DumpFlag
Opt_D_dump_cmm_sp :: DumpFlag
Opt_D_dump_cmm_sink :: DumpFlag
Opt_D_dump_cmm_caf :: DumpFlag
Opt_D_dump_cmm_procmap :: DumpFlag
Opt_D_dump_cmm_split :: DumpFlag
Opt_D_dump_cmm_info :: DumpFlag
Opt_D_dump_cmm_cps :: DumpFlag

-- | Dump the cfg used for block layout.
Opt_D_dump_cfg_weights :: DumpFlag
Opt_D_dump_asm :: DumpFlag
Opt_D_dump_asm_native :: DumpFlag
Opt_D_dump_asm_liveness :: DumpFlag
Opt_D_dump_asm_regalloc :: DumpFlag
Opt_D_dump_asm_regalloc_stages :: DumpFlag
Opt_D_dump_asm_conflicts :: DumpFlag
Opt_D_dump_asm_stats :: DumpFlag
Opt_D_dump_asm_expanded :: DumpFlag
Opt_D_dump_llvm :: DumpFlag
Opt_D_dump_core_stats :: DumpFlag
Opt_D_dump_deriv :: DumpFlag
Opt_D_dump_ds :: DumpFlag
Opt_D_dump_ds_preopt :: DumpFlag
Opt_D_dump_foreign :: DumpFlag
Opt_D_dump_inlinings :: DumpFlag
Opt_D_dump_rule_firings :: DumpFlag
Opt_D_dump_rule_rewrites :: DumpFlag
Opt_D_dump_simpl_trace :: DumpFlag
Opt_D_dump_occur_anal :: DumpFlag
Opt_D_dump_parsed :: DumpFlag
Opt_D_dump_parsed_ast :: DumpFlag
Opt_D_dump_rn :: DumpFlag
Opt_D_dump_rn_ast :: DumpFlag
Opt_D_dump_shape :: DumpFlag
Opt_D_dump_simpl :: DumpFlag
Opt_D_dump_simpl_iterations :: DumpFlag
Opt_D_dump_spec :: DumpFlag
Opt_D_dump_prep :: DumpFlag
Opt_D_dump_stg :: DumpFlag
Opt_D_dump_call_arity :: DumpFlag
Opt_D_dump_exitify :: DumpFlag
Opt_D_dump_stranal :: DumpFlag
Opt_D_dump_str_signatures :: DumpFlag
Opt_D_dump_tc :: DumpFlag
Opt_D_dump_tc_ast :: DumpFlag
Opt_D_dump_types :: DumpFlag
Opt_D_dump_rules :: DumpFlag
Opt_D_dump_cse :: DumpFlag
Opt_D_dump_worker_wrapper :: DumpFlag
Opt_D_dump_rn_trace :: DumpFlag
Opt_D_dump_rn_stats :: DumpFlag
Opt_D_dump_opt_cmm :: DumpFlag
Opt_D_dump_simpl_stats :: DumpFlag
Opt_D_dump_cs_trace :: DumpFlag
Opt_D_dump_tc_trace :: DumpFlag
Opt_D_dump_ec_trace :: DumpFlag
Opt_D_dump_if_trace :: DumpFlag
Opt_D_dump_vt_trace :: DumpFlag
Opt_D_dump_splices :: DumpFlag
Opt_D_th_dec_file :: DumpFlag
Opt_D_dump_BCOs :: DumpFlag
Opt_D_dump_ticked :: DumpFlag
Opt_D_dump_rtti :: DumpFlag
Opt_D_source_stats :: DumpFlag
Opt_D_verbose_stg2stg :: DumpFlag
Opt_D_dump_hi :: DumpFlag
Opt_D_dump_hi_diffs :: DumpFlag
Opt_D_dump_mod_cycles :: DumpFlag
Opt_D_dump_mod_map :: DumpFlag
Opt_D_dump_timings :: DumpFlag
Opt_D_dump_view_pattern_commoning :: DumpFlag
Opt_D_verbose_core2core :: DumpFlag
Opt_D_dump_debug :: DumpFlag
Opt_D_dump_json :: DumpFlag
Opt_D_ppr_debug :: DumpFlag
Opt_D_no_debug_output :: DumpFlag

-- | Enumerates the simple on-or-off dynamic flags
data GeneralFlag

-- | Append dump output to files instead of stdout.
Opt_DumpToFile :: GeneralFlag
Opt_D_faststring_stats :: GeneralFlag
Opt_D_dump_minimal_imports :: GeneralFlag
Opt_DoCoreLinting :: GeneralFlag
Opt_DoStgLinting :: GeneralFlag
Opt_DoCmmLinting :: GeneralFlag
Opt_DoAsmLinting :: GeneralFlag
Opt_DoAnnotationLinting :: GeneralFlag
Opt_NoLlvmMangler :: GeneralFlag
Opt_FastLlvm :: GeneralFlag
Opt_WarnIsError :: GeneralFlag
Opt_ShowWarnGroups :: GeneralFlag
Opt_HideSourcePaths :: GeneralFlag
Opt_PrintExplicitForalls :: GeneralFlag
Opt_PrintExplicitKinds :: GeneralFlag
Opt_PrintExplicitCoercions :: GeneralFlag
Opt_PrintExplicitRuntimeReps :: GeneralFlag
Opt_PrintEqualityRelations :: GeneralFlag
Opt_PrintUnicodeSyntax :: GeneralFlag
Opt_PrintExpandedSynonyms :: GeneralFlag
Opt_PrintPotentialInstances :: GeneralFlag
Opt_PrintTypecheckerElaboration :: GeneralFlag
Opt_CallArity :: GeneralFlag
Opt_Exitification :: GeneralFlag
Opt_Strictness :: GeneralFlag
Opt_LateDmdAnal :: GeneralFlag
Opt_KillAbsence :: GeneralFlag
Opt_KillOneShot :: GeneralFlag
Opt_FullLaziness :: GeneralFlag
Opt_FloatIn :: GeneralFlag
Opt_LateSpecialise :: GeneralFlag
Opt_Specialise :: GeneralFlag
Opt_SpecialiseAggressively :: GeneralFlag
Opt_CrossModuleSpecialise :: GeneralFlag
Opt_StaticArgumentTransformation :: GeneralFlag
Opt_CSE :: GeneralFlag
Opt_StgCSE :: GeneralFlag
Opt_StgLiftLams :: GeneralFlag
Opt_LiberateCase :: GeneralFlag
Opt_SpecConstr :: GeneralFlag
Opt_SpecConstrKeen :: GeneralFlag
Opt_DoLambdaEtaExpansion :: GeneralFlag
Opt_IgnoreAsserts :: GeneralFlag
Opt_DoEtaReduction :: GeneralFlag
Opt_CaseMerge :: GeneralFlag
Opt_CaseFolding :: GeneralFlag
Opt_UnboxStrictFields :: GeneralFlag
Opt_UnboxSmallStrictFields :: GeneralFlag
Opt_DictsCheap :: GeneralFlag
Opt_EnableRewriteRules :: GeneralFlag
Opt_RegsGraph :: GeneralFlag
Opt_RegsIterative :: GeneralFlag
Opt_PedanticBottoms :: GeneralFlag
Opt_LlvmTBAA :: GeneralFlag
Opt_LlvmFillUndefWithGarbage :: GeneralFlag
Opt_IrrefutableTuples :: GeneralFlag
Opt_CmmSink :: GeneralFlag
Opt_CmmElimCommonBlocks :: GeneralFlag
Opt_AsmShortcutting :: GeneralFlag
Opt_OmitYields :: GeneralFlag
Opt_FunToThunk :: GeneralFlag
Opt_DictsStrict :: GeneralFlag
Opt_DmdTxDictSel :: GeneralFlag
Opt_Loopification :: GeneralFlag

-- | Use the cfg based block layout algorithm.
Opt_CfgBlocklayout :: GeneralFlag

-- | Layout based on last instruction per block.
Opt_WeightlessBlocklayout :: GeneralFlag
Opt_CprAnal :: GeneralFlag
Opt_WorkerWrapper :: GeneralFlag
Opt_SolveConstantDicts :: GeneralFlag
Opt_AlignmentSanitisation :: GeneralFlag
Opt_CatchBottoms :: GeneralFlag
Opt_NumConstantFolding :: GeneralFlag
Opt_SimplPreInlining :: GeneralFlag
Opt_IgnoreInterfacePragmas :: GeneralFlag
Opt_OmitInterfacePragmas :: GeneralFlag
Opt_ExposeAllUnfoldings :: GeneralFlag
Opt_WriteInterface :: GeneralFlag
Opt_WriteHie :: GeneralFlag
Opt_AutoSccsOnIndividualCafs :: GeneralFlag
Opt_ProfCountEntries :: GeneralFlag
Opt_Pp :: GeneralFlag
Opt_ForceRecomp :: GeneralFlag
Opt_IgnoreOptimChanges :: GeneralFlag
Opt_IgnoreHpcChanges :: GeneralFlag
Opt_ExcessPrecision :: GeneralFlag
Opt_EagerBlackHoling :: GeneralFlag
Opt_NoHsMain :: GeneralFlag
Opt_SplitObjs :: GeneralFlag
Opt_SplitSections :: GeneralFlag
Opt_StgStats :: GeneralFlag
Opt_HideAllPackages :: GeneralFlag
Opt_HideAllPluginPackages :: GeneralFlag
Opt_PrintBindResult :: GeneralFlag
Opt_Haddock :: GeneralFlag
Opt_HaddockOptions :: GeneralFlag
Opt_BreakOnException :: GeneralFlag
Opt_BreakOnError :: GeneralFlag
Opt_PrintEvldWithShow :: GeneralFlag
Opt_PrintBindContents :: GeneralFlag
Opt_GenManifest :: GeneralFlag
Opt_EmbedManifest :: GeneralFlag
Opt_SharedImplib :: GeneralFlag
Opt_BuildingCabalPackage :: GeneralFlag
Opt_IgnoreDotGhci :: GeneralFlag
Opt_GhciSandbox :: GeneralFlag
Opt_GhciHistory :: GeneralFlag
Opt_GhciLeakCheck :: GeneralFlag
Opt_ValidateHie :: GeneralFlag
Opt_LocalGhciHistory :: GeneralFlag
Opt_NoIt :: GeneralFlag
Opt_HelpfulErrors :: GeneralFlag
Opt_DeferTypeErrors :: GeneralFlag
Opt_DeferTypedHoles :: GeneralFlag
Opt_DeferOutOfScopeVariables :: GeneralFlag

-- | <pre>
--   -fPIC
--   </pre>
Opt_PIC :: GeneralFlag

-- | <pre>
--   -fPIE
--   </pre>
Opt_PIE :: GeneralFlag

-- | <pre>
--   -pie
--   </pre>
Opt_PICExecutable :: GeneralFlag
Opt_ExternalDynamicRefs :: GeneralFlag
Opt_SccProfilingOn :: GeneralFlag
Opt_Ticky :: GeneralFlag
Opt_Ticky_Allocd :: GeneralFlag
Opt_Ticky_LNE :: GeneralFlag
Opt_Ticky_Dyn_Thunk :: GeneralFlag
Opt_RPath :: GeneralFlag
Opt_RelativeDynlibPaths :: GeneralFlag
Opt_Hpc :: GeneralFlag
Opt_FlatCache :: GeneralFlag
Opt_ExternalInterpreter :: GeneralFlag
Opt_OptimalApplicativeDo :: GeneralFlag
Opt_VersionMacros :: GeneralFlag
Opt_WholeArchiveHsLibs :: GeneralFlag
Opt_SingleLibFolder :: GeneralFlag
Opt_KeepCAFs :: GeneralFlag
Opt_ErrorSpans :: GeneralFlag
Opt_DiagnosticsShowCaret :: GeneralFlag
Opt_PprCaseAsLet :: GeneralFlag
Opt_PprShowTicks :: GeneralFlag
Opt_ShowHoleConstraints :: GeneralFlag
Opt_ShowValidHoleFits :: GeneralFlag
Opt_SortValidHoleFits :: GeneralFlag
Opt_SortBySizeHoleFits :: GeneralFlag
Opt_SortBySubsumHoleFits :: GeneralFlag
Opt_AbstractRefHoleFits :: GeneralFlag
Opt_UnclutterValidHoleFits :: GeneralFlag
Opt_ShowTypeAppOfHoleFits :: GeneralFlag
Opt_ShowTypeAppVarsOfHoleFits :: GeneralFlag
Opt_ShowDocsOfHoleFits :: GeneralFlag
Opt_ShowTypeOfHoleFits :: GeneralFlag
Opt_ShowProvOfHoleFits :: GeneralFlag
Opt_ShowMatchesOfHoleFits :: GeneralFlag
Opt_ShowLoadedModules :: GeneralFlag
Opt_HexWordLiterals :: GeneralFlag
Opt_SuppressCoercions :: GeneralFlag
Opt_SuppressVarKinds :: GeneralFlag
Opt_SuppressModulePrefixes :: GeneralFlag
Opt_SuppressTypeApplications :: GeneralFlag
Opt_SuppressIdInfo :: GeneralFlag
Opt_SuppressUnfoldings :: GeneralFlag
Opt_SuppressTypeSignatures :: GeneralFlag
Opt_SuppressUniques :: GeneralFlag
Opt_SuppressStgExts :: GeneralFlag
Opt_SuppressTicks :: GeneralFlag

-- | Suppress timestamps in dumps
Opt_SuppressTimestamps :: GeneralFlag
Opt_AutoLinkPackages :: GeneralFlag
Opt_ImplicitImportQualified :: GeneralFlag
Opt_KeepHscppFiles :: GeneralFlag
Opt_KeepHiDiffs :: GeneralFlag
Opt_KeepHcFiles :: GeneralFlag
Opt_KeepSFiles :: GeneralFlag
Opt_KeepTmpFiles :: GeneralFlag
Opt_KeepRawTokenStream :: GeneralFlag
Opt_KeepLlvmFiles :: GeneralFlag
Opt_KeepHiFiles :: GeneralFlag
Opt_KeepOFiles :: GeneralFlag
Opt_BuildDynamicToo :: GeneralFlag
Opt_DistrustAllPackages :: GeneralFlag
Opt_PackageTrust :: GeneralFlag
Opt_G_NoStateHack :: GeneralFlag
Opt_G_NoOptCoercion :: GeneralFlag
data WarningFlag
Opt_WarnDuplicateExports :: WarningFlag
Opt_WarnDuplicateConstraints :: WarningFlag
Opt_WarnRedundantConstraints :: WarningFlag
Opt_WarnHiShadows :: WarningFlag
Opt_WarnImplicitPrelude :: WarningFlag
Opt_WarnIncompletePatterns :: WarningFlag
Opt_WarnIncompleteUniPatterns :: WarningFlag
Opt_WarnIncompletePatternsRecUpd :: WarningFlag
Opt_WarnOverflowedLiterals :: WarningFlag
Opt_WarnEmptyEnumerations :: WarningFlag
Opt_WarnMissingFields :: WarningFlag
Opt_WarnMissingImportList :: WarningFlag
Opt_WarnMissingMethods :: WarningFlag
Opt_WarnMissingSignatures :: WarningFlag
Opt_WarnMissingLocalSignatures :: WarningFlag
Opt_WarnNameShadowing :: WarningFlag
Opt_WarnOverlappingPatterns :: WarningFlag
Opt_WarnTypeDefaults :: WarningFlag
Opt_WarnMonomorphism :: WarningFlag
Opt_WarnUnusedTopBinds :: WarningFlag
Opt_WarnUnusedLocalBinds :: WarningFlag
Opt_WarnUnusedPatternBinds :: WarningFlag
Opt_WarnUnusedImports :: WarningFlag
Opt_WarnUnusedMatches :: WarningFlag
Opt_WarnUnusedTypePatterns :: WarningFlag
Opt_WarnUnusedForalls :: WarningFlag
Opt_WarnWarningsDeprecations :: WarningFlag
Opt_WarnDeprecatedFlags :: WarningFlag
Opt_WarnMissingMonadFailInstances :: WarningFlag
Opt_WarnSemigroup :: WarningFlag
Opt_WarnDodgyExports :: WarningFlag
Opt_WarnDodgyImports :: WarningFlag
Opt_WarnOrphans :: WarningFlag
Opt_WarnAutoOrphans :: WarningFlag
Opt_WarnIdentities :: WarningFlag
Opt_WarnTabs :: WarningFlag
Opt_WarnUnrecognisedPragmas :: WarningFlag
Opt_WarnDodgyForeignImports :: WarningFlag
Opt_WarnUnusedDoBind :: WarningFlag
Opt_WarnWrongDoBind :: WarningFlag
Opt_WarnAlternativeLayoutRuleTransitional :: WarningFlag
Opt_WarnUnsafe :: WarningFlag
Opt_WarnSafe :: WarningFlag
Opt_WarnTrustworthySafe :: WarningFlag
Opt_WarnMissedSpecs :: WarningFlag
Opt_WarnAllMissedSpecs :: WarningFlag
Opt_WarnUnsupportedCallingConventions :: WarningFlag
Opt_WarnUnsupportedLlvmVersion :: WarningFlag
Opt_WarnMissedExtraSharedLib :: WarningFlag
Opt_WarnInlineRuleShadowing :: WarningFlag
Opt_WarnTypedHoles :: WarningFlag
Opt_WarnPartialTypeSignatures :: WarningFlag
Opt_WarnMissingExportedSignatures :: WarningFlag
Opt_WarnUntickedPromotedConstructors :: WarningFlag
Opt_WarnDerivingTypeable :: WarningFlag
Opt_WarnDeferredTypeErrors :: WarningFlag
Opt_WarnDeferredOutOfScopeVariables :: WarningFlag
Opt_WarnNonCanonicalMonadInstances :: WarningFlag
Opt_WarnNonCanonicalMonadFailInstances :: WarningFlag
Opt_WarnNonCanonicalMonoidInstances :: WarningFlag
Opt_WarnMissingPatternSynonymSignatures :: WarningFlag
Opt_WarnUnrecognisedWarningFlags :: WarningFlag
Opt_WarnSimplifiableClassConstraints :: WarningFlag
Opt_WarnCPPUndef :: WarningFlag
Opt_WarnUnbangedStrictPatterns :: WarningFlag
Opt_WarnMissingHomeModules :: WarningFlag
Opt_WarnPartialFields :: WarningFlag
Opt_WarnMissingExportList :: WarningFlag
Opt_WarnInaccessibleCode :: WarningFlag
Opt_WarnStarIsType :: WarningFlag
Opt_WarnStarBinder :: WarningFlag
Opt_WarnImplicitKindVars :: WarningFlag
Opt_WarnSpaceAfterBang :: WarningFlag
Opt_WarnMissingDerivingStrategies :: WarningFlag

-- | Used when outputting warnings: if a reason is given, it is displayed.
--   If a warning isn't controlled by a flag, this is made explicit at the
--   point of use.
data WarnReason
NoReason :: WarnReason

-- | Warning was enabled with the flag
Reason :: !WarningFlag -> WarnReason

-- | Warning was made an error because of -Werror or -Werror=WarningFlag
ErrReason :: !Maybe WarningFlag -> WarnReason
data Language
Haskell98 :: Language
Haskell2010 :: Language
data PlatformConstants
PlatformConstants :: () -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Bool -> Bool -> Int -> Integer -> Integer -> Integer -> PlatformConstants
[pc_platformConstants] :: PlatformConstants -> ()
[pc_CONTROL_GROUP_CONST_291] :: PlatformConstants -> Int
[pc_STD_HDR_SIZE] :: PlatformConstants -> Int
[pc_PROF_HDR_SIZE] :: PlatformConstants -> Int
[pc_BLOCK_SIZE] :: PlatformConstants -> Int
[pc_BLOCKS_PER_MBLOCK] :: PlatformConstants -> Int
[pc_TICKY_BIN_COUNT] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR7] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR8] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR9] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rR10] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rF6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rD6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rXMM6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rYMM6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM2] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM3] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM4] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM5] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rZMM6] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rL1] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rSp] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rSpLim] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rHp] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rHpLim] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rCCCS] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rCurrentTSO] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rCurrentNursery] :: PlatformConstants -> Int
[pc_OFFSET_StgRegTable_rHpAlloc] :: PlatformConstants -> Int
[pc_OFFSET_stgEagerBlackholeInfo] :: PlatformConstants -> Int
[pc_OFFSET_stgGCEnter1] :: PlatformConstants -> Int
[pc_OFFSET_stgGCFun] :: PlatformConstants -> Int
[pc_OFFSET_Capability_r] :: PlatformConstants -> Int
[pc_OFFSET_bdescr_start] :: PlatformConstants -> Int
[pc_OFFSET_bdescr_free] :: PlatformConstants -> Int
[pc_OFFSET_bdescr_blocks] :: PlatformConstants -> Int
[pc_OFFSET_bdescr_flags] :: PlatformConstants -> Int
[pc_SIZEOF_CostCentreStack] :: PlatformConstants -> Int
[pc_OFFSET_CostCentreStack_mem_alloc] :: PlatformConstants -> Int
[pc_REP_CostCentreStack_mem_alloc] :: PlatformConstants -> Int
[pc_OFFSET_CostCentreStack_scc_count] :: PlatformConstants -> Int
[pc_REP_CostCentreStack_scc_count] :: PlatformConstants -> Int
[pc_OFFSET_StgHeader_ccs] :: PlatformConstants -> Int
[pc_OFFSET_StgHeader_ldvw] :: PlatformConstants -> Int
[pc_SIZEOF_StgSMPThunkHeader] :: PlatformConstants -> Int
[pc_OFFSET_StgEntCounter_allocs] :: PlatformConstants -> Int
[pc_REP_StgEntCounter_allocs] :: PlatformConstants -> Int
[pc_OFFSET_StgEntCounter_allocd] :: PlatformConstants -> Int
[pc_REP_StgEntCounter_allocd] :: PlatformConstants -> Int
[pc_OFFSET_StgEntCounter_registeredp] :: PlatformConstants -> Int
[pc_OFFSET_StgEntCounter_link] :: PlatformConstants -> Int
[pc_OFFSET_StgEntCounter_entry_count] :: PlatformConstants -> Int
[pc_SIZEOF_StgUpdateFrame_NoHdr] :: PlatformConstants -> Int
[pc_SIZEOF_StgMutArrPtrs_NoHdr] :: PlatformConstants -> Int
[pc_OFFSET_StgMutArrPtrs_ptrs] :: PlatformConstants -> Int
[pc_OFFSET_StgMutArrPtrs_size] :: PlatformConstants -> Int
[pc_SIZEOF_StgSmallMutArrPtrs_NoHdr] :: PlatformConstants -> Int
[pc_OFFSET_StgSmallMutArrPtrs_ptrs] :: PlatformConstants -> Int
[pc_SIZEOF_StgArrBytes_NoHdr] :: PlatformConstants -> Int
[pc_OFFSET_StgArrBytes_bytes] :: PlatformConstants -> Int
[pc_OFFSET_StgTSO_alloc_limit] :: PlatformConstants -> Int
[pc_OFFSET_StgTSO_cccs] :: PlatformConstants -> Int
[pc_OFFSET_StgTSO_stackobj] :: PlatformConstants -> Int
[pc_OFFSET_StgStack_sp] :: PlatformConstants -> Int
[pc_OFFSET_StgStack_stack] :: PlatformConstants -> Int
[pc_OFFSET_StgUpdateFrame_updatee] :: PlatformConstants -> Int
[pc_OFFSET_StgFunInfoExtraFwd_arity] :: PlatformConstants -> Int
[pc_REP_StgFunInfoExtraFwd_arity] :: PlatformConstants -> Int
[pc_SIZEOF_StgFunInfoExtraRev] :: PlatformConstants -> Int
[pc_OFFSET_StgFunInfoExtraRev_arity] :: PlatformConstants -> Int
[pc_REP_StgFunInfoExtraRev_arity] :: PlatformConstants -> Int
[pc_MAX_SPEC_SELECTEE_SIZE] :: PlatformConstants -> Int
[pc_MAX_SPEC_AP_SIZE] :: PlatformConstants -> Int
[pc_MIN_PAYLOAD_SIZE] :: PlatformConstants -> Int
[pc_MIN_INTLIKE] :: PlatformConstants -> Int
[pc_MAX_INTLIKE] :: PlatformConstants -> Int
[pc_MIN_CHARLIKE] :: PlatformConstants -> Int
[pc_MAX_CHARLIKE] :: PlatformConstants -> Int
[pc_MUT_ARR_PTRS_CARD_BITS] :: PlatformConstants -> Int
[pc_MAX_Vanilla_REG] :: PlatformConstants -> Int
[pc_MAX_Float_REG] :: PlatformConstants -> Int
[pc_MAX_Double_REG] :: PlatformConstants -> Int
[pc_MAX_Long_REG] :: PlatformConstants -> Int
[pc_MAX_XMM_REG] :: PlatformConstants -> Int
[pc_MAX_Real_Vanilla_REG] :: PlatformConstants -> Int
[pc_MAX_Real_Float_REG] :: PlatformConstants -> Int
[pc_MAX_Real_Double_REG] :: PlatformConstants -> Int
[pc_MAX_Real_XMM_REG] :: PlatformConstants -> Int
[pc_MAX_Real_Long_REG] :: PlatformConstants -> Int
[pc_RESERVED_C_STACK_BYTES] :: PlatformConstants -> Int
[pc_RESERVED_STACK_WORDS] :: PlatformConstants -> Int
[pc_AP_STACK_SPLIM] :: PlatformConstants -> Int
[pc_WORD_SIZE] :: PlatformConstants -> Int
[pc_DOUBLE_SIZE] :: PlatformConstants -> Int
[pc_CINT_SIZE] :: PlatformConstants -> Int
[pc_CLONG_SIZE] :: PlatformConstants -> Int
[pc_CLONG_LONG_SIZE] :: PlatformConstants -> Int
[pc_BITMAP_BITS_SHIFT] :: PlatformConstants -> Int
[pc_TAG_BITS] :: PlatformConstants -> Int
[pc_WORDS_BIGENDIAN] :: PlatformConstants -> Bool
[pc_DYNAMIC_BY_DEFAULT] :: PlatformConstants -> Bool
[pc_LDV_SHIFT] :: PlatformConstants -> Int
[pc_ILDV_CREATE_MASK] :: PlatformConstants -> Integer
[pc_ILDV_STATE_CREATE] :: PlatformConstants -> Integer
[pc_ILDV_STATE_USE] :: PlatformConstants -> Integer
type FatalMessager = String -> IO ()
type LogAction = DynFlags -> WarnReason -> Severity -> SrcSpan -> PprStyle -> MsgDoc -> IO ()
newtype FlushOut
FlushOut :: IO () -> FlushOut
newtype FlushErr
FlushErr :: IO () -> FlushErr
data ProfAuto

-- | no SCC annotations added
NoProfAuto :: ProfAuto

-- | top-level and nested functions are annotated
ProfAutoAll :: ProfAuto

-- | top-level functions annotated only
ProfAutoTop :: ProfAuto

-- | exported functions annotated only
ProfAutoExports :: ProfAuto

-- | annotate call-sites
ProfAutoCalls :: ProfAuto
glasgowExtsFlags :: [Extension]

-- | Warning groups.
--   
--   As all warnings are in the Weverything set, it is ignored when
--   displaying to the user which group a warning is in.
warningGroups :: [(String, [WarningFlag])]

-- | Warning group hierarchies, where there is an explicit inclusion
--   relation.
--   
--   Each inner list is a hierarchy of warning groups, ordered from
--   smallest to largest, where each group is a superset of the one before
--   it.
--   
--   Separating this from <a>warningGroups</a> allows for multiple
--   hierarchies with no inherent relation to be defined.
--   
--   The special-case Weverything group is not included.
warningHierarchies :: [[String]]
hasPprDebug :: DynFlags -> Bool
hasNoDebugOutput :: DynFlags -> Bool
hasNoStateHack :: DynFlags -> Bool
hasNoOptCoercion :: DynFlags -> Bool

-- | Test whether a <a>DumpFlag</a> is set
dopt :: DumpFlag -> DynFlags -> Bool

-- | Set a <a>DumpFlag</a>
dopt_set :: DynFlags -> DumpFlag -> DynFlags

-- | Unset a <a>DumpFlag</a>
dopt_unset :: DynFlags -> DumpFlag -> DynFlags

-- | Test whether a <a>GeneralFlag</a> is set
gopt :: GeneralFlag -> DynFlags -> Bool

-- | Set a <a>GeneralFlag</a>
gopt_set :: DynFlags -> GeneralFlag -> DynFlags

-- | Unset a <a>GeneralFlag</a>
gopt_unset :: DynFlags -> GeneralFlag -> DynFlags
setGeneralFlag' :: GeneralFlag -> DynFlags -> DynFlags
unSetGeneralFlag' :: GeneralFlag -> DynFlags -> DynFlags

-- | Test whether a <a>WarningFlag</a> is set
wopt :: WarningFlag -> DynFlags -> Bool

-- | Set a <a>WarningFlag</a>
wopt_set :: DynFlags -> WarningFlag -> DynFlags

-- | Unset a <a>WarningFlag</a>
wopt_unset :: DynFlags -> WarningFlag -> DynFlags

-- | Test whether a <a>WarningFlag</a> is set as fatal
wopt_fatal :: WarningFlag -> DynFlags -> Bool

-- | Mark a <a>WarningFlag</a> as fatal (do not set the flag)
wopt_set_fatal :: DynFlags -> WarningFlag -> DynFlags

-- | Mark a <a>WarningFlag</a> as not fatal
wopt_unset_fatal :: DynFlags -> WarningFlag -> DynFlags

-- | Test whether a <a>Extension</a> is set
xopt :: Extension -> DynFlags -> Bool

-- | Set a <a>Extension</a>
xopt_set :: DynFlags -> Extension -> DynFlags

-- | Unset a <a>Extension</a>
xopt_unset :: DynFlags -> Extension -> DynFlags

-- | Set or unset a <a>Extension</a>, unless it has been explicitly set or
--   unset before.
xopt_set_unlessExplSpec :: Extension -> (DynFlags -> Extension -> DynFlags) -> DynFlags -> DynFlags
lang_set :: DynFlags -> Maybe Language -> DynFlags

-- | An internal helper to check whether to use unicode syntax for output.
--   
--   Note: You should very likely be using <a>unicodeSyntax</a> instead of
--   this function.
useUnicodeSyntax :: DynFlags -> Bool
useStarIsType :: DynFlags -> Bool
whenGeneratingDynamicToo :: MonadIO m => DynFlags -> m () -> m ()
ifGeneratingDynamicToo :: MonadIO m => DynFlags -> m a -> m a -> m a
whenCannotGenerateDynamicToo :: MonadIO m => DynFlags -> m () -> m ()
dynamicTooMkDynamicDynFlags :: DynFlags -> DynFlags

-- | Contains not only a collection of <a>GeneralFlag</a>s but also a
--   plethora of information relating to the compilation of a single file
--   or GHC session
data DynFlags
DynFlags :: GhcMode -> GhcLink -> HscTarget -> Settings -> IntegerLibrary -> LlvmTargets -> LlvmPasses -> Int -> Int -> Int -> Int -> Int -> Int -> Maybe String -> Maybe String -> [Int] -> Maybe Int -> Bool -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Int -> Int -> Maybe Int -> Maybe Int -> Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Bool -> Maybe Int -> Int -> [FilePath] -> Module -> Maybe String -> IntWithInf -> IntWithInf -> InstalledUnitId -> Maybe ComponentId -> Maybe [(ModuleName, Module)] -> [Way] -> String -> Maybe (String, Int) -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> String -> String -> String -> String -> IORef Bool -> String -> String -> Maybe String -> Maybe String -> Maybe String -> DynLibLoader -> Maybe FilePath -> Maybe FilePath -> [Option] -> IncludeSpecs -> [String] -> [String] -> [String] -> Maybe String -> RtsOptsEnabled -> Bool -> String -> [ModuleName] -> [(ModuleName, String)] -> [String] -> [LoadedPlugin] -> [StaticPlugin] -> Hooks -> FilePath -> Bool -> [ModuleName] -> [String] -> [PackageDBFlag] -> [IgnorePackageFlag] -> [PackageFlag] -> [PackageFlag] -> [TrustFlag] -> Maybe FilePath -> Maybe [(FilePath, [PackageConfig])] -> PackageState -> IORef FilesToClean -> IORef (Map FilePath FilePath) -> IORef Int -> IORef (Set FilePath) -> EnumSet DumpFlag -> EnumSet GeneralFlag -> EnumSet WarningFlag -> EnumSet WarningFlag -> Maybe Language -> SafeHaskellMode -> Bool -> Bool -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> SrcSpan -> [OnOff Extension] -> EnumSet Extension -> Int -> Int -> Int -> Int -> Float -> Int -> Bool -> Int -> Int -> LogAction -> FlushOut -> FlushErr -> Maybe FilePath -> Maybe String -> [String] -> Int -> Int -> Bool -> OverridingBool -> Bool -> Scheme -> ProfAuto -> Maybe String -> IORef (ModuleEnv Int) -> Maybe SseVersion -> Maybe BmiVersion -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> IORef (Maybe LinkerInfo) -> IORef (Maybe CompilerInfo) -> Int -> Int -> Int -> Bool -> Maybe Int -> Int -> Int -> CfgWeights -> DynFlags
[ghcMode] :: DynFlags -> GhcMode
[ghcLink] :: DynFlags -> GhcLink
[hscTarget] :: DynFlags -> HscTarget
[settings] :: DynFlags -> Settings

-- | IntegerGMP or IntegerSimple. Set at configure time, but may be
--   overriden by GHC-API users. See Note [The integer library] in
--   PrelNames
[integerLibrary] :: DynFlags -> IntegerLibrary
[llvmTargets] :: DynFlags -> LlvmTargets
[llvmPasses] :: DynFlags -> LlvmPasses

-- | Verbosity level: see Note [Verbosity levels]
[verbosity] :: DynFlags -> Int

-- | Optimisation level
[optLevel] :: DynFlags -> Int

-- | How much debug information to produce
[debugLevel] :: DynFlags -> Int

-- | Number of simplifier phases
[simplPhases] :: DynFlags -> Int

-- | Max simplifier iterations
[maxSimplIterations] :: DynFlags -> Int

-- | Max no iterations for pm checking
[maxPmCheckIterations] :: DynFlags -> Int
[ruleCheck] :: DynFlags -> Maybe String

-- | A prefix to report inlining decisions about
[inlineCheck] :: DynFlags -> Maybe String

-- | Additional demand analysis
[strictnessBefore] :: DynFlags -> [Int]

-- | The number of modules to compile in parallel in --make mode, where
--   Nothing ==&gt; compile as many in parallel as there are CPUs.
[parMakeCount] :: DynFlags -> Maybe Int

-- | Enable RTS timing statistics?
[enableTimeStats] :: DynFlags -> Bool

-- | The heap size to set.
[ghcHeapSize] :: DynFlags -> Maybe Int

-- | Maximum number of bindings from the type envt to show in type error
--   messages
[maxRelevantBinds] :: DynFlags -> Maybe Int

-- | Maximum number of hole fits to show in typed hole error messages
[maxValidHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of refinement hole fits to show in typed hole error
--   messages
[maxRefHoleFits] :: DynFlags -> Maybe Int

-- | Maximum level of refinement for refinement hole fits in typed hole
--   error messages
[refLevelHoleFits] :: DynFlags -> Maybe Int

-- | Maximum number of unmatched patterns to show in non-exhaustiveness
--   warnings
[maxUncoveredPatterns] :: DynFlags -> Int

-- | Multiplier for simplifier ticks
[simplTickFactor] :: DynFlags -> Int

-- | Threshold for SpecConstr
[specConstrThreshold] :: DynFlags -> Maybe Int

-- | Max number of specialisations for any one function
[specConstrCount] :: DynFlags -> Maybe Int

-- | Max number of specialisations for recursive types Not optional;
--   otherwise ForceSpecConstr can diverge.
[specConstrRecursive] :: DynFlags -> Int

-- | Threshold for LiberateCase
[liberateCaseThreshold] :: DynFlags -> Maybe Int

-- | Arg count for lambda floating See CoreMonad.FloatOutSwitches
[floatLamArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a recursive function.
[liftLamsRecArgs] :: DynFlags -> Maybe Int

-- | Maximum number of arguments after lambda lifting a non-recursive
--   function.
[liftLamsNonRecArgs] :: DynFlags -> Maybe Int

-- | Lambda lift even when this turns a known call into an unknown call.
[liftLamsKnown] :: DynFlags -> Bool

-- | Align Cmm functions at this boundary or use default.
[cmmProcAlignment] :: DynFlags -> Maybe Int

-- | Simplification history size
[historySize] :: DynFlags -> Int
[importPaths] :: DynFlags -> [FilePath]
[mainModIs] :: DynFlags -> Module
[mainFunIs] :: DynFlags -> Maybe String

-- | Typechecker maximum stack depth
[reductionDepth] :: DynFlags -> IntWithInf

-- | Number of iterations in the constraints solver Typically only 1 is
--   needed
[solverIterations] :: DynFlags -> IntWithInf
[thisInstalledUnitId] :: DynFlags -> InstalledUnitId
[thisComponentId_] :: DynFlags -> Maybe ComponentId
[thisUnitIdInsts_] :: DynFlags -> Maybe [(ModuleName, Module)]

-- | Way flags from the command line
[ways] :: DynFlags -> [Way]

-- | The global "way" (e.g. "p" for prof)
[buildTag] :: DynFlags -> String
[splitInfo] :: DynFlags -> Maybe (String, Int)
[objectDir] :: DynFlags -> Maybe String
[dylibInstallName] :: DynFlags -> Maybe String
[hiDir] :: DynFlags -> Maybe String
[hieDir] :: DynFlags -> Maybe String
[stubDir] :: DynFlags -> Maybe String
[dumpDir] :: DynFlags -> Maybe String
[objectSuf] :: DynFlags -> String
[hcSuf] :: DynFlags -> String
[hiSuf] :: DynFlags -> String
[hieSuf] :: DynFlags -> String
[canGenerateDynamicToo] :: DynFlags -> IORef Bool
[dynObjectSuf] :: DynFlags -> String
[dynHiSuf] :: DynFlags -> String
[outputFile] :: DynFlags -> Maybe String
[dynOutputFile] :: DynFlags -> Maybe String
[outputHi] :: DynFlags -> Maybe String
[dynLibLoader] :: DynFlags -> DynLibLoader

-- | This is set by <a>runPipeline</a> based on where its output is going.
[dumpPrefix] :: DynFlags -> Maybe FilePath

-- | Override the <a>dumpPrefix</a> set by <a>runPipeline</a>. Set by
--   <tt>-ddump-file-prefix</tt>
[dumpPrefixForce] :: DynFlags -> Maybe FilePath
[ldInputs] :: DynFlags -> [Option]
[includePaths] :: DynFlags -> IncludeSpecs
[libraryPaths] :: DynFlags -> [String]
[frameworkPaths] :: DynFlags -> [String]
[cmdlineFrameworks] :: DynFlags -> [String]
[rtsOpts] :: DynFlags -> Maybe String
[rtsOptsEnabled] :: DynFlags -> RtsOptsEnabled
[rtsOptsSuggestions] :: DynFlags -> Bool

-- | Path to store the .mix files
[hpcDir] :: DynFlags -> String
[pluginModNames] :: DynFlags -> [ModuleName]
[pluginModNameOpts] :: DynFlags -> [(ModuleName, String)]

-- | the <tt>-ffrontend-opt</tt> flags given on the command line, in
--   *reverse* order that they're specified on the command line.
[frontendPluginOpts] :: DynFlags -> [String]

-- | plugins dynamically loaded after processing arguments. What will be
--   loaded here is directed by pluginModNames. Arguments are loaded from
--   pluginModNameOpts. The purpose of this field is to cache the plugins
--   so they don't have to be loaded each time they are needed. See
--   <a>initializePlugins</a>.
[cachedPlugins] :: DynFlags -> [LoadedPlugin]

-- | staic plugins which do not need dynamic loading. These plugins are
--   intended to be added by GHC API users directly to this list.
--   
--   To add dynamically loaded plugins through the GHC API see
--   <a>addPluginModuleName</a> instead.
[staticPlugins] :: DynFlags -> [StaticPlugin]
[hooks] :: DynFlags -> Hooks
[depMakefile] :: DynFlags -> FilePath
[depIncludePkgDeps] :: DynFlags -> Bool
[depExcludeMods] :: DynFlags -> [ModuleName]
[depSuffixes] :: DynFlags -> [String]

-- | The <tt>-package-db</tt> flags given on the command line, In *reverse*
--   order that they're specified on the command line. This is intended to
--   be applied with the list of "initial" package databases derived from
--   <tt>GHC_PACKAGE_PATH</tt>; see <tt>getPackageConfRefs</tt>.
[packageDBFlags] :: DynFlags -> [PackageDBFlag]

-- | The <tt>-ignore-package</tt> flags from the command line. In *reverse*
--   order that they're specified on the command line.
[ignorePackageFlags] :: DynFlags -> [IgnorePackageFlag]

-- | The <tt>-package</tt> and <tt>-hide-package</tt> flags from the
--   command-line. In *reverse* order that they're specified on the command
--   line.
[packageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-plugin-package-id</tt> flags from command line. In *reverse*
--   order that they're specified on the command line.
[pluginPackageFlags] :: DynFlags -> [PackageFlag]

-- | The <tt>-trust</tt> and <tt>-distrust</tt> flags. In *reverse* order
--   that they're specified on the command line.
[trustFlags] :: DynFlags -> [TrustFlag]

-- | Filepath to the package environment file (if overriding default)
[packageEnv] :: DynFlags -> Maybe FilePath
[pkgDatabase] :: DynFlags -> Maybe [(FilePath, [PackageConfig])]
[pkgState] :: DynFlags -> PackageState
[filesToClean] :: DynFlags -> IORef FilesToClean
[dirsToClean] :: DynFlags -> IORef (Map FilePath FilePath)
[nextTempSuffix] :: DynFlags -> IORef Int
[generatedDumps] :: DynFlags -> IORef (Set FilePath)
[dumpFlags] :: DynFlags -> EnumSet DumpFlag
[generalFlags] :: DynFlags -> EnumSet GeneralFlag
[warningFlags] :: DynFlags -> EnumSet WarningFlag
[fatalWarningFlags] :: DynFlags -> EnumSet WarningFlag
[language] :: DynFlags -> Maybe Language

-- | Safe Haskell mode
[safeHaskell] :: DynFlags -> SafeHaskellMode
[safeInfer] :: DynFlags -> Bool
[safeInferred] :: DynFlags -> Bool
[thOnLoc] :: DynFlags -> SrcSpan
[newDerivOnLoc] :: DynFlags -> SrcSpan
[overlapInstLoc] :: DynFlags -> SrcSpan
[incoherentOnLoc] :: DynFlags -> SrcSpan
[pkgTrustOnLoc] :: DynFlags -> SrcSpan
[warnSafeOnLoc] :: DynFlags -> SrcSpan
[warnUnsafeOnLoc] :: DynFlags -> SrcSpan
[trustworthyOnLoc] :: DynFlags -> SrcSpan
[extensions] :: DynFlags -> [OnOff Extension]
[extensionFlags] :: DynFlags -> EnumSet Extension
[ufCreationThreshold] :: DynFlags -> Int
[ufUseThreshold] :: DynFlags -> Int
[ufFunAppDiscount] :: DynFlags -> Int
[ufDictDiscount] :: DynFlags -> Int
[ufKeenessFactor] :: DynFlags -> Float
[ufDearOp] :: DynFlags -> Int
[ufVeryAggressive] :: DynFlags -> Bool
[maxWorkerArgs] :: DynFlags -> Int
[ghciHistSize] :: DynFlags -> Int

-- | MsgDoc output action: use <a>ErrUtils</a> instead of this if you can
[log_action] :: DynFlags -> LogAction
[flushOut] :: DynFlags -> FlushOut
[flushErr] :: DynFlags -> FlushErr
[ghcVersionFile] :: DynFlags -> Maybe FilePath
[haddockOptions] :: DynFlags -> Maybe String

-- | GHCi scripts specified by -ghci-script, in reverse order
[ghciScripts] :: DynFlags -> [String]
[pprUserLength] :: DynFlags -> Int
[pprCols] :: DynFlags -> Int
[useUnicode] :: DynFlags -> Bool
[useColor] :: DynFlags -> OverridingBool
[canUseColor] :: DynFlags -> Bool
[colScheme] :: DynFlags -> Scheme

-- | what kind of {--} to add automatically
[profAuto] :: DynFlags -> ProfAuto
[interactivePrint] :: DynFlags -> Maybe String
[nextWrapperNum] :: DynFlags -> IORef (ModuleEnv Int)

-- | Machine dependent flags (-m<a>blah</a> stuff)
[sseVersion] :: DynFlags -> Maybe SseVersion
[bmiVersion] :: DynFlags -> Maybe BmiVersion
[avx] :: DynFlags -> Bool
[avx2] :: DynFlags -> Bool
[avx512cd] :: DynFlags -> Bool
[avx512er] :: DynFlags -> Bool
[avx512f] :: DynFlags -> Bool
[avx512pf] :: DynFlags -> Bool

-- | Run-time linker information (what options we need, etc.)
[rtldInfo] :: DynFlags -> IORef (Maybe LinkerInfo)

-- | Run-time compiler information
[rtccInfo] :: DynFlags -> IORef (Maybe CompilerInfo)

-- | Max size, in bytes, of inline array allocations.
[maxInlineAllocSize] :: DynFlags -> Int

-- | Only inline memcpy if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemcpyInsns] :: DynFlags -> Int

-- | Only inline memset if it generates no more than this many pseudo
--   (roughly: Cmm) instructions.
[maxInlineMemsetInsns] :: DynFlags -> Int

-- | Reverse the order of error messages in GHC/GHCi
[reverseErrors] :: DynFlags -> Bool

-- | Limit the maximum number of errors to show
[maxErrors] :: DynFlags -> Maybe Int

-- | Unique supply configuration for testing build determinism
[initialUnique] :: DynFlags -> Int
[uniqueIncrement] :: DynFlags -> Int

-- | Temporary: CFG Edge weights for fast iterations
[cfgWeightInfo] :: DynFlags -> CfgWeights
data FlagSpec flag
FlagSpec :: String -> flag -> (TurnOnFlag -> DynP ()) -> GhcFlagMode -> FlagSpec flag

-- | Flag in string form
[flagSpecName] :: FlagSpec flag -> String

-- | Flag in internal form
[flagSpecFlag] :: FlagSpec flag -> flag

-- | Extra action to run when the flag is found Typically, emit a warning
--   or error
[flagSpecAction] :: FlagSpec flag -> TurnOnFlag -> DynP ()

-- | In which ghc mode the flag has effect
[flagSpecGhcMode] :: FlagSpec flag -> GhcFlagMode
class HasDynFlags m
getDynFlags :: HasDynFlags m => m DynFlags
class ContainsDynFlags t
extractDynFlags :: ContainsDynFlags t => t -> DynFlags
data RtsOptsEnabled
RtsOptsNone :: RtsOptsEnabled
RtsOptsIgnore :: RtsOptsEnabled
RtsOptsIgnoreAll :: RtsOptsEnabled
RtsOptsSafeOnly :: RtsOptsEnabled
RtsOptsAll :: RtsOptsEnabled

-- | The target code type of the compilation (if any).
--   
--   Whenever you change the target, also make sure to set <a>ghcLink</a>
--   to something sensible.
--   
--   <a>HscNothing</a> can be used to avoid generating any output, however,
--   note that:
--   
--   <ul>
--   <li>If a program uses Template Haskell the typechecker may need to run
--   code from an imported module. To facilitate this, code generation is
--   enabled for modules imported by modules that use template haskell. See
--   Note [-fno-code mode].</li>
--   </ul>
data HscTarget

-- | Generate C code.
HscC :: HscTarget

-- | Generate assembly using the native code generator.
HscAsm :: HscTarget

-- | Generate assembly using the llvm code generator.
HscLlvm :: HscTarget

-- | Generate bytecode. (Requires <a>LinkInMemory</a>)
HscInterpreted :: HscTarget

-- | Don't generate any code. See notes above.
HscNothing :: HscTarget

-- | Will this target result in an object file on the disk?
isObjectTarget :: HscTarget -> Bool

-- | The <a>HscTarget</a> value corresponding to the default way to create
--   object files on the current platform.
defaultObjectTarget :: Platform -> HscTarget

-- | Does this target retain *all* top-level bindings for a module, rather
--   than just the exported bindings, in the TypeEnv and compiled code (if
--   any)? In interpreted mode we do this, so that GHCi can call functions
--   inside a module. In HscNothing mode we also do it, so that Haddock can
--   get access to the GlobalRdrEnv for a module after typechecking it.
targetRetainsAllBindings :: HscTarget -> Bool

-- | The <a>GhcMode</a> tells us whether we're doing multi-module
--   compilation (controlled via the <a>GHC</a> API) or one-shot
--   (single-module) compilation. This makes a difference primarily to the
--   <a>Finder</a>: in one-shot mode we look for interface files for
--   imported modules, but in multi-module mode we look for source files in
--   order to check whether they need to be recompiled.
data GhcMode

-- | <tt>--make</tt>, GHCi, etc.
CompManager :: GhcMode

-- | <pre>
--   ghc -c Foo.hs
--   </pre>
OneShot :: GhcMode

-- | <tt>ghc -M</tt>, see <a>Finder</a> for why we need this
MkDepend :: GhcMode
isOneShot :: GhcMode -> Bool

-- | What to do in the link step, if there is one.
data GhcLink

-- | Don't link at all
NoLink :: GhcLink

-- | Link object code into a binary
LinkBinary :: GhcLink

-- | Use the in-memory dynamic linker (works for both bytecode and object
--   code).
LinkInMemory :: GhcLink

-- | Link objects into a dynamic lib (DLL on Windows, DSO on ELF platforms)
LinkDynLib :: GhcLink

-- | Link objects into a static lib
LinkStaticLib :: GhcLink
isNoLink :: GhcLink -> Bool

-- | Flags for manipulating packages visibility.
data PackageFlag

-- | <tt>-package</tt>, <tt>-package-id</tt>
ExposePackage :: String -> PackageArg -> ModRenaming -> PackageFlag

-- | <pre>
--   -hide-package
--   </pre>
HidePackage :: String -> PackageFlag

-- | We accept flags which make packages visible, but how they select the
--   package varies; this data type reflects what selection criterion is
--   used.
data PackageArg

-- | <tt>-package</tt>, by <a>PackageName</a>
PackageArg :: String -> PackageArg

-- | <tt>-package-id</tt>, by <a>UnitId</a>
UnitIdArg :: UnitId -> PackageArg

-- | Represents the renaming that may be associated with an exposed
--   package, e.g. the <tt>rns</tt> part of <tt>-package "foo (rns)"</tt>.
--   
--   Here are some example parsings of the package flags (where a string
--   literal is punned to be a <a>ModuleName</a>:
--   
--   <ul>
--   <li><tt>-package foo</tt> is <tt>ModRenaming True []</tt></li>
--   <li><tt>-package foo ()</tt> is <tt>ModRenaming False []</tt></li>
--   <li><tt>-package foo (A)</tt> is <tt>ModRenaming False [(<a>A</a>,
--   <a>A</a>)]</tt></li>
--   <li><tt>-package foo (A as B)</tt> is <tt>ModRenaming False
--   [(<a>A</a>, <a>B</a>)]</tt></li>
--   <li><tt>-package foo with (A as B)</tt> is <tt>ModRenaming True
--   [(<a>A</a>, <a>B</a>)]</tt></li>
--   </ul>
data ModRenaming
ModRenaming :: Bool -> [(ModuleName, ModuleName)] -> ModRenaming

-- | Bring all exposed modules into scope?
[modRenamingWithImplicit] :: ModRenaming -> Bool

-- | Bring module <tt>m</tt> into scope under name <tt>n</tt>.
[modRenamings] :: ModRenaming -> [(ModuleName, ModuleName)]
packageFlagsChanged :: DynFlags -> DynFlags -> Bool

-- | Flags for manipulating the set of non-broken packages.
newtype IgnorePackageFlag

-- | <pre>
--   -ignore-package
--   </pre>
IgnorePackage :: String -> IgnorePackageFlag

-- | Flags for manipulating package trust.
data TrustFlag

-- | <pre>
--   -trust
--   </pre>
TrustPackage :: String -> TrustFlag

-- | <pre>
--   -distrust
--   </pre>
DistrustPackage :: String -> TrustFlag
data PackageDBFlag
PackageDB :: PkgConfRef -> PackageDBFlag
NoUserPackageDB :: PackageDBFlag
NoGlobalPackageDB :: PackageDBFlag
ClearPackageDBs :: PackageDBFlag
data PkgConfRef
GlobalPkgConf :: PkgConfRef
UserPkgConf :: PkgConfRef
PkgConfFile :: FilePath -> PkgConfRef

-- | When invoking external tools as part of the compilation pipeline, we
--   pass these a sequence of options on the command-line. Rather than just
--   using a list of Strings, we use a type that allows us to distinguish
--   between filepaths and 'other stuff'. The reason for this is that this
--   type gives us a handle on transforming filenames, and filenames only,
--   to whatever format they're expected to be on a particular platform.
data Option
FileOption :: String -> String -> Option
Option :: String -> Option
showOpt :: Option -> String
data DynLibLoader
Deployable :: DynLibLoader
SystemDependent :: DynLibLoader

-- | These <tt>-f&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-fno-&lt;blah&gt;</tt>
fFlags :: [FlagSpec GeneralFlag]

-- | These <tt>-f&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-fno-&lt;blah&gt;</tt>
fLangFlags :: [FlagSpec Extension]

-- | These -X<a>blah</a> flags can all be reversed with -XNo<a>blah</a>
xFlags :: [FlagSpec Extension]

-- | These <tt>-W&lt;blah&gt;</tt> flags can all be reversed with
--   <tt>-Wno-&lt;blah&gt;</tt>
wWarningFlags :: [FlagSpec WarningFlag]

-- | Some modules have dependencies on others through the DynFlags rather
--   than textual imports
dynFlagDependencies :: DynFlags -> [ModuleName]
tablesNextToCode :: DynFlags -> Bool
mkTablesNextToCode :: Bool -> Bool

-- | Resolve any internal inconsistencies in a set of <a>DynFlags</a>.
--   Returns the consistent <a>DynFlags</a> as well as a list of warnings
--   to report to the user.
makeDynFlagsConsistent :: DynFlags -> (DynFlags, [Located String])
shouldUseColor :: DynFlags -> Bool
shouldUseHexWordLiterals :: DynFlags -> Bool

-- | Are we building with <tt>-fPIE</tt> or <tt>-fPIC</tt> enabled?
positionIndependent :: DynFlags -> Bool
optimisationFlags :: EnumSet GeneralFlag
data Way
WayCustom :: String -> Way
WayThreaded :: Way
WayDebug :: Way
WayProf :: Way
WayEventLog :: Way
WayDyn :: Way
mkBuildTag :: [Way] -> String
wayRTSOnly :: Way -> Bool
addWay' :: Way -> DynFlags -> DynFlags
updateWays :: DynFlags -> DynFlags
wayGeneralFlags :: Platform -> Way -> [GeneralFlag]
wayUnsetGeneralFlags :: Platform -> Way -> [GeneralFlag]
thisPackage :: DynFlags -> UnitId
thisComponentId :: DynFlags -> ComponentId
thisUnitIdInsts :: DynFlags -> [(ModuleName, Module)]

-- | Write an error or warning to the <tt>LogOutput</tt>.
putLogMsg :: DynFlags -> WarnReason -> Severity -> SrcSpan -> PprStyle -> MsgDoc -> IO ()

-- | The various Safe Haskell modes
data SafeHaskellMode
Sf_None :: SafeHaskellMode
Sf_Unsafe :: SafeHaskellMode
Sf_Trustworthy :: SafeHaskellMode
Sf_Safe :: SafeHaskellMode
Sf_Ignore :: SafeHaskellMode

-- | Is Safe Haskell on in some way (including inference mode)
safeHaskellOn :: DynFlags -> Bool
safeHaskellModeEnabled :: DynFlags -> Bool

-- | Test if Safe Imports are on in some form
safeImportsOn :: DynFlags -> Bool

-- | Is the Safe Haskell safe language in use
safeLanguageOn :: DynFlags -> Bool

-- | Is the Safe Haskell safe inference mode active
safeInferOn :: DynFlags -> Bool

-- | Is the -fpackage-trust mode on
packageTrustOn :: DynFlags -> Bool

-- | Are all direct imports required to be safe for this Safe Haskell mode?
--   Direct imports are when the code explicitly imports a module
safeDirectImpsReq :: DynFlags -> Bool

-- | Are all implicit imports required to be safe for this Safe Haskell
--   mode? Implicit imports are things in the prelude. e.g System.IO when
--   print is used.
safeImplicitImpsReq :: DynFlags -> Bool

-- | A list of unsafe flags under Safe Haskell. Tuple elements are: * name
--   of the flag * function to get srcspan that enabled the flag * function
--   to test if the flag is on * function to turn the flag off
unsafeFlags :: [(String, DynFlags -> SrcSpan, DynFlags -> Bool, DynFlags -> DynFlags)]

-- | A list of unsafe flags under Safe Haskell. Tuple elements are: * name
--   of the flag * function to get srcspan that enabled the flag * function
--   to test if the flag is on * function to turn the flag off
unsafeFlagsForInfer :: [(String, DynFlags -> SrcSpan, DynFlags -> Bool, DynFlags -> DynFlags)]
data LlvmTarget
LlvmTarget :: String -> String -> [String] -> LlvmTarget
[lDataLayout] :: LlvmTarget -> String
[lCPU] :: LlvmTarget -> String
[lAttributes] :: LlvmTarget -> [String]
type LlvmTargets = [(String, LlvmTarget)]
type LlvmPasses = [(Int, String)]
type LlvmConfig = (LlvmTargets, LlvmPasses)
data Settings
Settings :: Platform -> FilePath -> FilePath -> Maybe FilePath -> FilePath -> String -> String -> String -> [(String, String)] -> [String] -> FilePath -> Bool -> Bool -> Bool -> Bool -> Bool -> String -> (String, [Option]) -> String -> (String, [Option]) -> (String, [Option]) -> (String, [Option]) -> (String, [Option]) -> (String, [Option]) -> String -> String -> String -> String -> String -> (String, [Option]) -> (String, [Option]) -> (String, [Option]) -> String -> [String] -> [String] -> Fingerprint -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> [String] -> PlatformConstants -> Settings
[sTargetPlatform] :: Settings -> Platform
[sGhcUsagePath] :: Settings -> FilePath
[sGhciUsagePath] :: Settings -> FilePath
[sToolDir] :: Settings -> Maybe FilePath
[sTopDir] :: Settings -> FilePath
[sTmpDir] :: Settings -> String
[sProgramName] :: Settings -> String
[sProjectVersion] :: Settings -> String
[sRawSettings] :: Settings -> [(String, String)]
[sExtraGccViaCFlags] :: Settings -> [String]
[sSystemPackageConfig] :: Settings -> FilePath
[sLdSupportsCompactUnwind] :: Settings -> Bool
[sLdSupportsBuildId] :: Settings -> Bool
[sLdSupportsFilelist] :: Settings -> Bool
[sLdIsGnuLd] :: Settings -> Bool
[sGccSupportsNoPie] :: Settings -> Bool
[sPgm_L] :: Settings -> String
[sPgm_P] :: Settings -> (String, [Option])
[sPgm_F] :: Settings -> String
[sPgm_c] :: Settings -> (String, [Option])
[sPgm_s] :: Settings -> (String, [Option])
[sPgm_a] :: Settings -> (String, [Option])
[sPgm_l] :: Settings -> (String, [Option])
[sPgm_dll] :: Settings -> (String, [Option])
[sPgm_T] :: Settings -> String
[sPgm_windres] :: Settings -> String
[sPgm_libtool] :: Settings -> String
[sPgm_ar] :: Settings -> String
[sPgm_ranlib] :: Settings -> String
[sPgm_lo] :: Settings -> (String, [Option])
[sPgm_lc] :: Settings -> (String, [Option])
[sPgm_lcc] :: Settings -> (String, [Option])
[sPgm_i] :: Settings -> String
[sOpt_L] :: Settings -> [String]
[sOpt_P] :: Settings -> [String]
[sOpt_P_fingerprint] :: Settings -> Fingerprint
[sOpt_F] :: Settings -> [String]
[sOpt_c] :: Settings -> [String]
[sOpt_a] :: Settings -> [String]
[sOpt_l] :: Settings -> [String]
[sOpt_windres] :: Settings -> [String]
[sOpt_lo] :: Settings -> [String]
[sOpt_lc] :: Settings -> [String]
[sOpt_lcc] :: Settings -> [String]
[sOpt_i] :: Settings -> [String]
[sPlatformConstants] :: Settings -> PlatformConstants
targetPlatform :: DynFlags -> Platform
programName :: DynFlags -> String
projectVersion :: DynFlags -> String
ghcUsagePath :: DynFlags -> FilePath
ghciUsagePath :: DynFlags -> FilePath
topDir :: DynFlags -> FilePath
tmpDir :: DynFlags -> String
rawSettings :: DynFlags -> [(String, String)]

-- | The directory for this version of ghc in the user's app directory
--   (typically something like <tt>~<i>.ghc</i>x86_64-linux-7.6.3</tt>)
versionedAppDir :: DynFlags -> MaybeT IO FilePath
extraGccViaCFlags :: DynFlags -> [String]
systemPackageConfig :: DynFlags -> FilePath
pgm_L :: DynFlags -> String
pgm_P :: DynFlags -> (String, [Option])
pgm_F :: DynFlags -> String
pgm_c :: DynFlags -> (String, [Option])
pgm_s :: DynFlags -> (String, [Option])
pgm_a :: DynFlags -> (String, [Option])
pgm_l :: DynFlags -> (String, [Option])
pgm_dll :: DynFlags -> (String, [Option])
pgm_T :: DynFlags -> String
pgm_windres :: DynFlags -> String
pgm_libtool :: DynFlags -> String
pgm_ar :: DynFlags -> String
pgm_ranlib :: DynFlags -> String
pgm_lo :: DynFlags -> (String, [Option])
pgm_lc :: DynFlags -> (String, [Option])
pgm_lcc :: DynFlags -> (String, [Option])
pgm_i :: DynFlags -> String
opt_L :: DynFlags -> [String]
opt_P :: DynFlags -> [String]
opt_F :: DynFlags -> [String]
opt_c :: DynFlags -> [String]
opt_a :: DynFlags -> [String]
opt_l :: DynFlags -> [String]
opt_i :: DynFlags -> [String]
opt_P_signature :: DynFlags -> ([String], Fingerprint)
opt_windres :: DynFlags -> [String]
opt_lo :: DynFlags -> [String]
opt_lc :: DynFlags -> [String]
opt_lcc :: DynFlags -> [String]
addPluginModuleName :: String -> DynFlags -> DynFlags

-- | The normal <a>DynFlags</a>. Note that they are not suitable for use in
--   this form and must be fully initialized by <a>runGhc</a> first.
defaultDynFlags :: Settings -> LlvmConfig -> DynFlags
defaultWays :: Settings -> [Way]
interpWays :: [Way]
interpreterProfiled :: DynFlags -> Bool
interpreterDynamic :: DynFlags -> Bool

-- | Used by <a>runGhc</a> to partially initialize a new <a>DynFlags</a>
--   value
initDynFlags :: DynFlags -> IO DynFlags
defaultFatalMessager :: FatalMessager
defaultLogAction :: LogAction

-- | Like <a>defaultLogActionHPutStrDoc</a> but appends an extra newline.
defaultLogActionHPrintDoc :: DynFlags -> Handle -> SDoc -> PprStyle -> IO ()
defaultLogActionHPutStrDoc :: DynFlags -> Handle -> SDoc -> PprStyle -> IO ()
defaultFlushOut :: FlushOut
defaultFlushErr :: FlushErr

-- | Retrieve the options corresponding to a particular <tt>opt_*</tt>
--   field in the correct order
getOpts :: DynFlags -> (DynFlags -> [a]) -> [a]

-- | Gets the verbosity flag for the current verbosity level. This is fed
--   to other tools, so GHC-specific verbosity flags like
--   <tt>-ddump-most</tt> are not included
getVerbFlags :: DynFlags -> [String]

-- | Sets the <a>DynFlags</a> to be appropriate to the optimisation level
updOptLevel :: Int -> DynFlags -> DynFlags
setTmpDir :: FilePath -> DynFlags -> DynFlags
setUnitId :: String -> DynFlags -> DynFlags

-- | Find the package environment (if one exists)
--   
--   We interpret the package environment as a set of package flags; to be
--   specific, if we find a package environment file like
--   
--   <pre>
--   clear-package-db
--   global-package-db
--   package-db blah/package.conf.d
--   package-id id1
--   package-id id2
--   </pre>
--   
--   we interpret this as
--   
--   <pre>
--   [ -hide-all-packages
--   , -clear-package-db
--   , -global-package-db
--   , -package-db blah/package.conf.d
--   , -package-id id1
--   , -package-id id2
--   ]
--   </pre>
--   
--   There's also an older syntax alias for package-id, which is just an
--   unadorned package id
--   
--   <pre>
--   id1
--   id2
--   </pre>
interpretPackageEnv :: DynFlags -> IO DynFlags

-- | Given a <a>ModuleName</a> of a signature in the home library, find out
--   how it is instantiated. E.g., the canonical form of A in
--   <tt>p[A=q[]:A]</tt> is <tt>q[]:A</tt>.
canonicalizeHomeModule :: DynFlags -> ModuleName -> Module
canonicalizeModuleIfHome :: DynFlags -> Module -> Module

-- | Parse dynamic flags from a list of command line arguments. Returns the
--   the parsed <a>DynFlags</a>, the left-over arguments, and a list of
--   warnings. Throws a <a>UsageError</a> if errors occurred during parsing
--   (such as unknown flags or missing arguments).
parseDynamicFlagsCmdLine :: MonadIO m => DynFlags -> [Located String] -> m (DynFlags, [Located String], [Warn])

-- | Like <a>parseDynamicFlagsCmdLine</a> but does not allow the package
--   flags (-package, -hide-package, -ignore-package, -hide-all-packages,
--   -package-db). Used to parse flags set in a modules pragma.
parseDynamicFilePragma :: MonadIO m => DynFlags -> [Located String] -> m (DynFlags, [Located String], [Warn])

-- | Parses the dynamically set flags for GHC. This is the most general
--   form of the dynamic flag parser that the other methods simply wrap. It
--   allows saying which flags are valid flags and indicating if we are
--   parsing arguments from the command line or from a file pragma.
parseDynamicFlagsFull :: MonadIO m => [Flag (CmdLineP DynFlags)] -> Bool -> DynFlags -> [Located String] -> m (DynFlags, [Located String], [Warn])

-- | All dynamic flags option strings without the deprecated ones. These
--   are the user facing strings for enabling and disabling options.
allNonDeprecatedFlags :: [String]
flagsAll :: [Flag (CmdLineP DynFlags)]
flagsDynamic :: [Flag (CmdLineP DynFlags)]
flagsPackage :: [Flag (CmdLineP DynFlags)]

-- | Make a list of flags for shell completion. Filter all available flags
--   into two groups, for interactive GHC vs all other.
flagsForCompletion :: Bool -> [String]
supportedLanguagesAndExtensions :: [String]
languageExtensions :: Maybe Language -> [Extension]
picCCOpts :: DynFlags -> [String]
picPOpts :: DynFlags -> [String]
compilerInfo :: DynFlags -> [(String, String)]

-- | Was the runtime system built with profiling enabled?
rtsIsProfiled :: Bool
dynamicGhc :: Bool
cONTROL_GROUP_CONST_291 :: DynFlags -> Int
sTD_HDR_SIZE :: DynFlags -> Int
pROF_HDR_SIZE :: DynFlags -> Int
bLOCK_SIZE :: DynFlags -> Int
bLOCKS_PER_MBLOCK :: DynFlags -> Int
tICKY_BIN_COUNT :: DynFlags -> Int
oFFSET_StgRegTable_rR1 :: DynFlags -> Int
oFFSET_StgRegTable_rR2 :: DynFlags -> Int
oFFSET_StgRegTable_rR3 :: DynFlags -> Int
oFFSET_StgRegTable_rR4 :: DynFlags -> Int
oFFSET_StgRegTable_rR5 :: DynFlags -> Int
oFFSET_StgRegTable_rR6 :: DynFlags -> Int
oFFSET_StgRegTable_rR7 :: DynFlags -> Int
oFFSET_StgRegTable_rR8 :: DynFlags -> Int
oFFSET_StgRegTable_rR9 :: DynFlags -> Int
oFFSET_StgRegTable_rR10 :: DynFlags -> Int
oFFSET_StgRegTable_rF1 :: DynFlags -> Int
oFFSET_StgRegTable_rF2 :: DynFlags -> Int
oFFSET_StgRegTable_rF3 :: DynFlags -> Int
oFFSET_StgRegTable_rF4 :: DynFlags -> Int
oFFSET_StgRegTable_rF5 :: DynFlags -> Int
oFFSET_StgRegTable_rF6 :: DynFlags -> Int
oFFSET_StgRegTable_rD1 :: DynFlags -> Int
oFFSET_StgRegTable_rD2 :: DynFlags -> Int
oFFSET_StgRegTable_rD3 :: DynFlags -> Int
oFFSET_StgRegTable_rD4 :: DynFlags -> Int
oFFSET_StgRegTable_rD5 :: DynFlags -> Int
oFFSET_StgRegTable_rD6 :: DynFlags -> Int
oFFSET_StgRegTable_rXMM1 :: DynFlags -> Int
oFFSET_StgRegTable_rXMM2 :: DynFlags -> Int
oFFSET_StgRegTable_rXMM3 :: DynFlags -> Int
oFFSET_StgRegTable_rXMM4 :: DynFlags -> Int
oFFSET_StgRegTable_rXMM5 :: DynFlags -> Int
oFFSET_StgRegTable_rXMM6 :: DynFlags -> Int
oFFSET_StgRegTable_rYMM1 :: DynFlags -> Int
oFFSET_StgRegTable_rYMM2 :: DynFlags -> Int
oFFSET_StgRegTable_rYMM3 :: DynFlags -> Int
oFFSET_StgRegTable_rYMM4 :: DynFlags -> Int
oFFSET_StgRegTable_rYMM5 :: DynFlags -> Int
oFFSET_StgRegTable_rYMM6 :: DynFlags -> Int
oFFSET_StgRegTable_rZMM1 :: DynFlags -> Int
oFFSET_StgRegTable_rZMM2 :: DynFlags -> Int
oFFSET_StgRegTable_rZMM3 :: DynFlags -> Int
oFFSET_StgRegTable_rZMM4 :: DynFlags -> Int
oFFSET_StgRegTable_rZMM5 :: DynFlags -> Int
oFFSET_StgRegTable_rZMM6 :: DynFlags -> Int
oFFSET_StgRegTable_rL1 :: DynFlags -> Int
oFFSET_StgRegTable_rSp :: DynFlags -> Int
oFFSET_StgRegTable_rSpLim :: DynFlags -> Int
oFFSET_StgRegTable_rHp :: DynFlags -> Int
oFFSET_StgRegTable_rHpLim :: DynFlags -> Int
oFFSET_StgRegTable_rCCCS :: DynFlags -> Int
oFFSET_StgRegTable_rCurrentTSO :: DynFlags -> Int
oFFSET_StgRegTable_rCurrentNursery :: DynFlags -> Int
oFFSET_StgRegTable_rHpAlloc :: DynFlags -> Int
oFFSET_stgEagerBlackholeInfo :: DynFlags -> Int
oFFSET_stgGCEnter1 :: DynFlags -> Int
oFFSET_stgGCFun :: DynFlags -> Int
oFFSET_Capability_r :: DynFlags -> Int
oFFSET_bdescr_start :: DynFlags -> Int
oFFSET_bdescr_free :: DynFlags -> Int
oFFSET_bdescr_blocks :: DynFlags -> Int
oFFSET_bdescr_flags :: DynFlags -> Int
sIZEOF_CostCentreStack :: DynFlags -> Int
oFFSET_CostCentreStack_mem_alloc :: DynFlags -> Int
oFFSET_CostCentreStack_scc_count :: DynFlags -> Int
oFFSET_StgHeader_ccs :: DynFlags -> Int
oFFSET_StgHeader_ldvw :: DynFlags -> Int
sIZEOF_StgSMPThunkHeader :: DynFlags -> Int
oFFSET_StgEntCounter_allocs :: DynFlags -> Int
oFFSET_StgEntCounter_allocd :: DynFlags -> Int
oFFSET_StgEntCounter_registeredp :: DynFlags -> Int
oFFSET_StgEntCounter_link :: DynFlags -> Int
oFFSET_StgEntCounter_entry_count :: DynFlags -> Int
sIZEOF_StgUpdateFrame_NoHdr :: DynFlags -> Int
sIZEOF_StgMutArrPtrs_NoHdr :: DynFlags -> Int
oFFSET_StgMutArrPtrs_ptrs :: DynFlags -> Int
oFFSET_StgMutArrPtrs_size :: DynFlags -> Int
sIZEOF_StgSmallMutArrPtrs_NoHdr :: DynFlags -> Int
oFFSET_StgSmallMutArrPtrs_ptrs :: DynFlags -> Int
sIZEOF_StgArrBytes_NoHdr :: DynFlags -> Int
oFFSET_StgArrBytes_bytes :: DynFlags -> Int
oFFSET_StgTSO_alloc_limit :: DynFlags -> Int
oFFSET_StgTSO_cccs :: DynFlags -> Int
oFFSET_StgTSO_stackobj :: DynFlags -> Int
oFFSET_StgStack_sp :: DynFlags -> Int
oFFSET_StgStack_stack :: DynFlags -> Int
oFFSET_StgUpdateFrame_updatee :: DynFlags -> Int
oFFSET_StgFunInfoExtraFwd_arity :: DynFlags -> Int
sIZEOF_StgFunInfoExtraRev :: DynFlags -> Int
oFFSET_StgFunInfoExtraRev_arity :: DynFlags -> Int
mAX_SPEC_SELECTEE_SIZE :: DynFlags -> Int
mAX_SPEC_AP_SIZE :: DynFlags -> Int
mIN_PAYLOAD_SIZE :: DynFlags -> Int
mIN_INTLIKE :: DynFlags -> Int
mAX_INTLIKE :: DynFlags -> Int
mIN_CHARLIKE :: DynFlags -> Int
mAX_CHARLIKE :: DynFlags -> Int
mUT_ARR_PTRS_CARD_BITS :: DynFlags -> Int
mAX_Vanilla_REG :: DynFlags -> Int
mAX_Float_REG :: DynFlags -> Int
mAX_Double_REG :: DynFlags -> Int
mAX_Long_REG :: DynFlags -> Int
mAX_XMM_REG :: DynFlags -> Int
mAX_Real_Vanilla_REG :: DynFlags -> Int
mAX_Real_Float_REG :: DynFlags -> Int
mAX_Real_Double_REG :: DynFlags -> Int
mAX_Real_XMM_REG :: DynFlags -> Int
mAX_Real_Long_REG :: DynFlags -> Int
rESERVED_C_STACK_BYTES :: DynFlags -> Int
rESERVED_STACK_WORDS :: DynFlags -> Int
aP_STACK_SPLIM :: DynFlags -> Int
wORD_SIZE :: DynFlags -> Int
dOUBLE_SIZE :: DynFlags -> Int
cINT_SIZE :: DynFlags -> Int
cLONG_SIZE :: DynFlags -> Int
cLONG_LONG_SIZE :: DynFlags -> Int
bITMAP_BITS_SHIFT :: DynFlags -> Int
tAG_BITS :: DynFlags -> Int
wORDS_BIGENDIAN :: DynFlags -> Bool
dYNAMIC_BY_DEFAULT :: DynFlags -> Bool
lDV_SHIFT :: DynFlags -> Int
iLDV_CREATE_MASK :: DynFlags -> Integer
iLDV_STATE_CREATE :: DynFlags -> Integer
iLDV_STATE_USE :: DynFlags -> Integer
bLOCK_SIZE_W :: DynFlags -> Int
wORD_SIZE_IN_BITS :: DynFlags -> Int
tAG_MASK :: DynFlags -> Int
mAX_PTR_TAG :: DynFlags -> Int
tARGET_MIN_INT :: DynFlags -> Integer
tARGET_MAX_INT :: DynFlags -> Integer
tARGET_MAX_WORD :: DynFlags -> Integer
unsafeGlobalDynFlags :: DynFlags
setUnsafeGlobalDynFlags :: DynFlags -> IO ()
isSseEnabled :: DynFlags -> Bool
isSse2Enabled :: DynFlags -> Bool
isSse4_2Enabled :: DynFlags -> Bool
isBmiEnabled :: DynFlags -> Bool
isBmi2Enabled :: DynFlags -> Bool
isAvxEnabled :: DynFlags -> Bool
isAvx2Enabled :: DynFlags -> Bool
isAvx512cdEnabled :: DynFlags -> Bool
isAvx512erEnabled :: DynFlags -> Bool
isAvx512fEnabled :: DynFlags -> Bool
isAvx512pfEnabled :: DynFlags -> Bool
data LinkerInfo
GnuLD :: [Option] -> LinkerInfo
GnuGold :: [Option] -> LinkerInfo
LlvmLLD :: [Option] -> LinkerInfo
DarwinLD :: [Option] -> LinkerInfo
SolarisLD :: [Option] -> LinkerInfo
AixLD :: [Option] -> LinkerInfo
UnknownLD :: LinkerInfo
data CompilerInfo
GCC :: CompilerInfo
Clang :: CompilerInfo
AppleClang :: CompilerInfo
AppleClang51 :: CompilerInfo
UnknownCC :: CompilerInfo

-- | A collection of files that must be deleted before ghc exits. The
--   current collection is stored in an IORef in DynFlags,
--   <a>filesToClean</a>.
data FilesToClean
FilesToClean :: !Set FilePath -> !Set FilePath -> FilesToClean

-- | Files that will be deleted at the end of runGhc(T)
[ftcGhcSession] :: FilesToClean -> !Set FilePath

-- | Files that will be deleted the next time
--   <a>cleanCurrentModuleTempFiles</a> is called, or otherwise at the end
--   of the session.
[ftcCurrentModule] :: FilesToClean -> !Set FilePath

-- | An empty FilesToClean
emptyFilesToClean :: FilesToClean

-- | Used to differentiate the scope an include needs to apply to. We have
--   to split the include paths to avoid accidentally forcing recursive
--   includes since -I overrides the system search paths. See Trac #14312.
data IncludeSpecs
IncludeSpecs :: [String] -> [String] -> IncludeSpecs
[includePathsQuote] :: IncludeSpecs -> [String]
[includePathsGlobal] :: IncludeSpecs -> [String]

-- | Append to the list of includes a path that shall be included using
--   `-I` when the C compiler is called. These paths override system search
--   paths.
addGlobalInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Append to the list of includes a path that shall be included using
--   `-iquote` when the C compiler is called. These paths only apply when
--   quoted includes are used. e.g. #include "foo.h"
addQuoteInclude :: IncludeSpecs -> [String] -> IncludeSpecs

-- | Concatenate and flatten the list of global and quoted includes
--   returning just a flat list of paths.
flattenIncludes :: IncludeSpecs -> [String]

-- | Edge weights to use when generating a CFG from CMM
data CfgWeights
CFGWeights :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> CfgWeights
[uncondWeight] :: CfgWeights -> Int
[condBranchWeight] :: CfgWeights -> Int
[switchWeight] :: CfgWeights -> Int
[callWeight] :: CfgWeights -> Int
[likelyCondWeight] :: CfgWeights -> Int
[unlikelyCondWeight] :: CfgWeights -> Int
[infoTablePenalty] :: CfgWeights -> Int
[backEdgeBonus] :: CfgWeights -> Int
backendMaintainsCfg :: DynFlags -> Bool
instance GHC.Classes.Eq DynFlags.CompilerInfo
instance GHC.Classes.Eq DynFlags.LinkerInfo
instance GHC.Classes.Ord DynFlags.BmiVersion
instance GHC.Classes.Eq DynFlags.BmiVersion
instance GHC.Classes.Ord DynFlags.SseVersion
instance GHC.Classes.Eq DynFlags.SseVersion
instance GHC.Classes.Eq DynFlags.PackageDBFlag
instance GHC.Classes.Eq DynFlags.PkgConfRef
instance GHC.Classes.Ord DynFlags.Deprecation
instance GHC.Classes.Eq DynFlags.Deprecation
instance GHC.Classes.Eq DynFlags.Option
instance GHC.Show.Show a => GHC.Show.Show (DynFlags.OnOff a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (DynFlags.OnOff a)
instance GHC.Show.Show DynFlags.Way
instance GHC.Classes.Ord DynFlags.Way
instance GHC.Classes.Eq DynFlags.Way
instance GHC.Show.Show DynFlags.RtsOptsEnabled
instance GHC.Classes.Eq DynFlags.DynLibLoader
instance GHC.Classes.Eq DynFlags.PackageFlag
instance GHC.Classes.Eq DynFlags.TrustFlag
instance GHC.Classes.Eq DynFlags.IgnorePackageFlag
instance GHC.Classes.Eq DynFlags.ModRenaming
instance GHC.Show.Show DynFlags.PackageArg
instance GHC.Classes.Eq DynFlags.PackageArg
instance GHC.Show.Show DynFlags.GhcLink
instance GHC.Classes.Eq DynFlags.GhcLink
instance GHC.Classes.Eq DynFlags.GhcMode
instance GHC.Show.Show DynFlags.HscTarget
instance GHC.Classes.Eq DynFlags.HscTarget
instance GHC.Enum.Enum DynFlags.ProfAuto
instance GHC.Classes.Eq DynFlags.ProfAuto
instance GHC.Classes.Eq DynFlags.SafeHaskellMode
instance GHC.Show.Show DynFlags.Language
instance GHC.Enum.Enum DynFlags.Language
instance GHC.Classes.Eq DynFlags.Language
instance GHC.Show.Show DynFlags.WarnReason
instance GHC.Enum.Enum DynFlags.WarningFlag
instance GHC.Show.Show DynFlags.WarningFlag
instance GHC.Classes.Eq DynFlags.WarningFlag
instance GHC.Show.Show DynFlags.IncludeSpecs
instance GHC.Enum.Enum DynFlags.GeneralFlag
instance GHC.Show.Show DynFlags.GeneralFlag
instance GHC.Classes.Eq DynFlags.GeneralFlag
instance GHC.Enum.Enum DynFlags.DumpFlag
instance GHC.Show.Show DynFlags.DumpFlag
instance GHC.Classes.Eq DynFlags.DumpFlag
instance (GHC.Base.Monoid a, GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Control.Monad.Trans.Writer.Lazy.WriterT a m)
instance (GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Control.Monad.Trans.Reader.ReaderT a m)
instance (GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Control.Monad.Trans.Maybe.MaybeT m)
instance (GHC.Base.Monad m, DynFlags.HasDynFlags m) => DynFlags.HasDynFlags (Control.Monad.Trans.Except.ExceptT e m)
instance Outputable.Outputable a => Outputable.Outputable (DynFlags.OnOff a)
instance Outputable.Outputable DynFlags.PackageFlag
instance Outputable.Outputable DynFlags.ModRenaming
instance Outputable.Outputable DynFlags.PackageArg
instance Outputable.Outputable DynFlags.GhcMode
instance GHC.Show.Show DynFlags.SafeHaskellMode
instance Outputable.Outputable DynFlags.SafeHaskellMode
instance Outputable.Outputable DynFlags.Language
instance Outputable.Outputable DynFlags.WarnReason
instance Json.ToJson DynFlags.WarnReason


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a> represents names as strings with just a little more
--   information: the "namespace" that the name came from, e.g. the
--   namespace of value, type constructors or data constructors</li>
--   <li><a>RdrName</a>: see <a>RdrName#name_types</a></li>
--   <li><a>Name</a>: see <a>Name#name_types</a></li>
--   <li><a>Id</a>: see <a>Id#name_types</a></li>
--   <li><a>Var</a>: see <a>Var#name_types</a></li>
--   </ul>
module OccName
data NameSpace
nameSpacesRelated :: NameSpace -> NameSpace -> Bool
tcName :: NameSpace
clsName :: NameSpace
tcClsName :: NameSpace
dataName :: NameSpace
varName :: NameSpace
tvName :: NameSpace
srcDataName :: NameSpace
pprNameSpace :: NameSpace -> SDoc
pprNonVarNameSpace :: NameSpace -> SDoc
pprNameSpaceBrief :: NameSpace -> SDoc

-- | Occurrence Name
--   
--   In this context that means: "classified (i.e. as a type name, value
--   name, etc) but not qualified and not yet resolved"
data OccName
pprOccName :: OccName -> SDoc
mkOccName :: NameSpace -> String -> OccName
mkOccNameFS :: NameSpace -> FastString -> OccName
mkVarOcc :: String -> OccName
mkVarOccFS :: FastString -> OccName
mkDataOcc :: String -> OccName
mkDataOccFS :: FastString -> OccName
mkTyVarOcc :: String -> OccName
mkTyVarOccFS :: FastString -> OccName
mkTcOcc :: String -> OccName
mkTcOccFS :: FastString -> OccName
mkClsOcc :: String -> OccName
mkClsOccFS :: FastString -> OccName
mkDFunOcc :: String -> Bool -> OccSet -> OccName
setOccNameSpace :: NameSpace -> OccName -> OccName
demoteOccName :: OccName -> Maybe OccName

-- | Other names in the compiler add additional information to an OccName.
--   This class provides a consistent way to access the underlying OccName.
class HasOccName name
occName :: HasOccName name => name -> OccName

-- | Test for definitions internally generated by GHC. This predicte is
--   used to suppress printing of internal definitions in some debug prints
isDerivedOccName :: OccName -> Bool
mkDataConWrapperOcc :: OccName -> OccName
mkWorkerOcc :: OccName -> OccName
mkMatcherOcc :: OccName -> OccName
mkBuilderOcc :: OccName -> OccName
mkDefaultMethodOcc :: OccName -> OccName
isDefaultMethodOcc :: OccName -> Bool

-- | Is an <a>OccName</a> one of a Typeable <tt>TyCon</tt> or
--   <tt>Module</tt> binding? This is needed as these bindings are renamed
--   differently. See Note [Grand plan for Typeable] in TcTypeable.
isTypeableBindOcc :: OccName -> Bool
mkNewTyCoOcc :: OccName -> OccName
mkClassOpAuxOcc :: OccName -> OccName
mkCon2TagOcc :: OccName -> OccName
mkTag2ConOcc :: OccName -> OccName
mkMaxTagOcc :: OccName -> OccName
mkClassDataConOcc :: OccName -> OccName
mkDictOcc :: OccName -> OccName
mkIPOcc :: OccName -> OccName
mkSpecOcc :: OccName -> OccName
mkForeignExportOcc :: OccName -> OccName
mkRepEqOcc :: OccName -> OccName
mkGenR :: OccName -> OccName
mkGen1R :: OccName -> OccName
mkDataTOcc :: OccName -> OccSet -> OccName
mkDataCOcc :: OccName -> OccSet -> OccName
mkDataConWorkerOcc :: OccName -> OccName
mkSuperDictSelOcc :: Int -> OccName -> OccName
mkSuperDictAuxOcc :: Int -> OccName -> OccName
mkLocalOcc :: Unique -> OccName -> OccName
mkMethodOcc :: OccName -> OccName

-- | Derive a name for the representation type constructor of a
--   <tt>data</tt>/<tt>newtype</tt> instance.
mkInstTyTcOcc :: String -> OccSet -> OccName
mkInstTyCoOcc :: OccName -> OccName
mkEqPredCoOcc :: OccName -> OccName
mkRecFldSelOcc :: String -> OccName
mkTyConRepOcc :: OccName -> OccName
occNameFS :: OccName -> FastString
occNameString :: OccName -> String
occNameSpace :: OccName -> NameSpace
isVarOcc :: OccName -> Bool
isTvOcc :: OccName -> Bool
isTcOcc :: OccName -> Bool
isDataOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is a data constructor that starts with a
--   symbol (e.g. <tt>:</tt>, or <tt>[]</tt>)
isDataSymOcc :: OccName -> Bool

-- | Test if the <a>OccName</a> is that for any operator (whether it is a
--   data constructor or variable or whatever)
isSymOcc :: OccName -> Bool

-- | <i>Value</i> <tt>OccNames</tt>s are those that are either in the
--   variable or data constructor namespaces
isValOcc :: OccName -> Bool

-- | Wrap parens around an operator
parenSymOcc :: OccName -> SDoc -> SDoc

-- | Haskell 98 encourages compilers to suppress warnings about unsed names
--   in a pattern if they start with <tt>_</tt>: this implements that test
startsWithUnderscore :: OccName -> Bool
isTcClsNameSpace :: NameSpace -> Bool
isTvNameSpace :: NameSpace -> Bool
isDataConNameSpace :: NameSpace -> Bool
isVarNameSpace :: NameSpace -> Bool
isValNameSpace :: NameSpace -> Bool
data OccEnv a
emptyOccEnv :: OccEnv a
unitOccEnv :: OccName -> a -> OccEnv a
extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a
mapOccEnv :: (a -> b) -> OccEnv a -> OccEnv b
lookupOccEnv :: OccEnv a -> OccName -> Maybe a
mkOccEnv :: [(OccName, a)] -> OccEnv a
mkOccEnv_C :: (a -> a -> a) -> [(OccName, a)] -> OccEnv a
extendOccEnvList :: OccEnv a -> [(OccName, a)] -> OccEnv a
elemOccEnv :: OccName -> OccEnv a -> Bool
occEnvElts :: OccEnv a -> [a]
foldOccEnv :: (a -> b -> b) -> b -> OccEnv a -> b
plusOccEnv :: OccEnv a -> OccEnv a -> OccEnv a
plusOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccEnv a -> OccEnv a
extendOccEnv_C :: (a -> a -> a) -> OccEnv a -> OccName -> a -> OccEnv a
extendOccEnv_Acc :: (a -> b -> b) -> (a -> b) -> OccEnv b -> OccName -> a -> OccEnv b
filterOccEnv :: (elt -> Bool) -> OccEnv elt -> OccEnv elt
delListFromOccEnv :: OccEnv a -> [OccName] -> OccEnv a
delFromOccEnv :: OccEnv a -> OccName -> OccEnv a
alterOccEnv :: (Maybe elt -> Maybe elt) -> OccEnv elt -> OccName -> OccEnv elt
pprOccEnv :: (a -> SDoc) -> OccEnv a -> SDoc
type OccSet = UniqSet OccName
emptyOccSet :: OccSet
unitOccSet :: OccName -> OccSet
mkOccSet :: [OccName] -> OccSet
extendOccSet :: OccSet -> OccName -> OccSet
extendOccSetList :: OccSet -> [OccName] -> OccSet
unionOccSets :: OccSet -> OccSet -> OccSet
unionManyOccSets :: [OccSet] -> OccSet
minusOccSet :: OccSet -> OccSet -> OccSet
elemOccSet :: OccName -> OccSet -> Bool
isEmptyOccSet :: OccSet -> Bool
intersectOccSet :: OccSet -> OccSet -> OccSet
intersectsOccSet :: OccSet -> OccSet -> Bool
filterOccSet :: (OccName -> Bool) -> OccSet -> OccSet
type TidyOccEnv = UniqFM Int
emptyTidyOccEnv :: TidyOccEnv
initTidyOccEnv :: [OccName] -> TidyOccEnv
tidyOccName :: TidyOccEnv -> OccName -> (TidyOccEnv, OccName)
avoidClashesOccEnv :: TidyOccEnv -> [OccName] -> TidyOccEnv

-- | A non-deterministic set of FastStrings. See Note [Deterministic
--   UniqFM] in UniqDFM for explanation why it's not deterministic and why
--   it matters. Use DFastStringEnv if the set eventually gets converted
--   into a list or folded over in a way where the order changes the
--   generated code.
type FastStringEnv a = UniqFM a
emptyFsEnv :: FastStringEnv a
lookupFsEnv :: FastStringEnv a -> FastString -> Maybe a
extendFsEnv :: FastStringEnv a -> FastString -> a -> FastStringEnv a
mkFsEnv :: [(FastString, a)] -> FastStringEnv a
instance Data.Data.Data a => Data.Data.Data (OccName.OccEnv a)
instance GHC.Classes.Ord OccName.NameSpace
instance GHC.Classes.Eq OccName.NameSpace
instance Outputable.Outputable a => Outputable.Outputable (OccName.OccEnv a)
instance OccName.HasOccName OccName.OccName
instance GHC.Classes.Eq OccName.OccName
instance GHC.Classes.Ord OccName.OccName
instance Data.Data.Data OccName.OccName
instance Control.DeepSeq.NFData OccName.OccName
instance Outputable.Outputable OccName.OccName
instance Outputable.OutputableBndr OccName.OccName
instance Unique.Uniquable OccName.OccName
instance Binary.Binary OccName.OccName
instance Binary.Binary OccName.NameSpace


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see <a>OccName#name_types</a></li>
--   <li><a>RdrName</a>: see <a>RdrName#name_types</a></li>
--   <li><a>Name</a> is the type of names that have had their scoping and
--   binding resolved. They have an <a>OccName</a> but also a <a>Unique</a>
--   that disambiguates Names that have the same <a>OccName</a> and indeed
--   is used for all <a>Name</a> comparison. Names also contain information
--   about where they originated from, see <a>Name#name_sorts</a></li>
--   <li><a>Id</a>: see <a>Id#name_types</a></li>
--   <li><a>Var</a>: see <a>Var#name_types</a></li>
--   </ul>
--   
--   Names are one of:
--   
--   <ul>
--   <li>External, if they name things declared in other modules. Some
--   external Names are wired in, i.e. they name primitives defined in the
--   compiler itself</li>
--   <li>Internal, if they name things in the module being compiled. Some
--   internal Names are system names, if they are names manufactured by the
--   compiler</li>
--   </ul>
module Name

-- | A unique, unambiguous name for something, containing information about
--   where that thing originated.
data Name

-- | BuiltInSyntax is for things like <tt>(:)</tt>, <tt>[]</tt> and tuples,
--   which have special syntactic forms. They aren't in scope as such.
data BuiltInSyntax
BuiltInSyntax :: BuiltInSyntax
UserSyntax :: BuiltInSyntax

-- | Create a name brought into being by the compiler
mkSystemName :: Unique -> OccName -> Name
mkSystemNameAt :: Unique -> OccName -> SrcSpan -> Name

-- | Create a name which is (for now at least) local to the current module
--   and hence does not need a <a>Module</a> to disambiguate it from other
--   <a>Name</a>s
mkInternalName :: Unique -> OccName -> SrcSpan -> Name
mkClonedInternalName :: Unique -> Name -> Name
mkDerivedInternalName :: (OccName -> OccName) -> Unique -> Name -> Name
mkSystemVarName :: Unique -> FastString -> Name
mkSysTvName :: Unique -> FastString -> Name

-- | Make a name for a foreign call
mkFCallName :: Unique -> String -> Name

-- | Create a name which definitely originates in the given module
mkExternalName :: Unique -> Module -> OccName -> SrcSpan -> Name

-- | Create a name which is actually defined by the compiler itself
mkWiredInName :: Module -> OccName -> Unique -> TyThing -> BuiltInSyntax -> Name
nameUnique :: Name -> Unique
setNameUnique :: Name -> Unique -> Name
nameOccName :: Name -> OccName
nameModule :: HasDebugCallStack => Name -> Module
nameModule_maybe :: Name -> Maybe Module
setNameLoc :: Name -> SrcSpan -> Name
tidyNameOcc :: Name -> OccName -> Name

-- | Make the <a>Name</a> into an internal name, regardless of what it was
--   to begin with
localiseName :: Name -> Name
nameSrcLoc :: Name -> SrcLoc
nameSrcSpan :: Name -> SrcSpan
pprNameDefnLoc :: Name -> SDoc
pprDefinedAt :: Name -> SDoc
isSystemName :: Name -> Bool
isInternalName :: Name -> Bool
isExternalName :: Name -> Bool
isTyVarName :: Name -> Bool
isTyConName :: Name -> Bool
isDataConName :: Name -> Bool
isValName :: Name -> Bool
isVarName :: Name -> Bool
isWiredInName :: Name -> Bool
isBuiltInSyntax :: Name -> Bool
isHoleName :: Name -> Bool
wiredInNameTyThing_maybe :: Name -> Maybe TyThing

-- | Returns True if the name is (a) Internal (b) External but from the
--   specified module (c) External but from the <tt>interactive</tt>
--   package
--   
--   The key idea is that False means: the entity is defined in some other
--   module you can find the details (type, fixity, instances) in some
--   interface file those details will be stored in the EPT or HPT
--   
--   True means: the entity is defined in this module or earlier in the
--   GHCi session you can find details (type, fixity, instances) in the
--   TcGblEnv or TcLclEnv
--   
--   The isInteractiveModule part is because successive interactions of a
--   GHCi session each give rise to a fresh module (Ghci1, Ghci2, etc), but
--   they all come from the magic <tt>interactive</tt> package; and all the
--   details are kept in the TcLclEnv, TcGblEnv, NOT in the HPT or EPT. See
--   Note [The interactive package] in HscTypes
nameIsLocalOrFrom :: Module -> Name -> Bool
nameIsHomePackage :: Module -> Name -> Bool
nameIsHomePackageImport :: Module -> Name -> Bool

-- | Returns True if the Name comes from some other package: neither this
--   package nor the interactive package.
nameIsFromExternalPackage :: UnitId -> Name -> Bool

-- | Compare Names lexicographically This only works for Names that
--   originate in the source code or have been tidied.
stableNameCmp :: Name -> Name -> Ordering

-- | A class allowing convenient access to the <a>Name</a> of various
--   datatypes
class NamedThing a
getOccName :: NamedThing a => a -> OccName
getName :: NamedThing a => a -> Name
getSrcLoc :: NamedThing a => a -> SrcLoc
getSrcSpan :: NamedThing a => a -> SrcSpan
getOccString :: NamedThing a => a -> String
getOccFS :: NamedThing a => a -> FastString
pprInfixName :: (Outputable a, NamedThing a) => a -> SDoc
pprPrefixName :: NamedThing a => a -> SDoc
pprModulePrefix :: PprStyle -> Module -> OccName -> SDoc

-- | Print the string of Name unqualifiedly directly.
pprNameUnqualified :: Name -> SDoc

-- | Get a string representation of a <a>Name</a> that's unique and stable
--   across recompilations. Used for deterministic generation of binds for
--   derived instances. eg.
--   "$aeson_70dylHtv1FFGeai1IoxcQr$Data.Aeson.Types.Internal$String"
nameStableString :: Name -> String
instance Name.NamedThing Name.Name
instance Name.NamedThing e => Name.NamedThing (SrcLoc.Located e)
instance Control.DeepSeq.NFData Name.Name
instance OccName.HasOccName Name.Name
instance SrcLoc.HasSrcSpan Name.Name
instance GHC.Classes.Eq Name.Name
instance GHC.Classes.Ord Name.Name
instance Unique.Uniquable Name.Name
instance Data.Data.Data Name.Name
instance Binary.Binary Name.Name
instance Outputable.Outputable Name.Name
instance Outputable.OutputableBndr Name.Name
instance Outputable.Outputable Name.NameSort
instance Control.DeepSeq.NFData Name.NameSort

module NameSet
type NameSet = UniqSet Name
emptyNameSet :: NameSet
unitNameSet :: Name -> NameSet
mkNameSet :: [Name] -> NameSet
unionNameSet :: NameSet -> NameSet -> NameSet
unionNameSets :: [NameSet] -> NameSet
minusNameSet :: NameSet -> NameSet -> NameSet
elemNameSet :: Name -> NameSet -> Bool
extendNameSet :: NameSet -> Name -> NameSet
extendNameSetList :: NameSet -> [Name] -> NameSet
delFromNameSet :: NameSet -> Name -> NameSet
delListFromNameSet :: NameSet -> [Name] -> NameSet
isEmptyNameSet :: NameSet -> Bool
filterNameSet :: (Name -> Bool) -> NameSet -> NameSet

-- | True if there is a non-empty intersection. <tt>s1
--   <a>intersectsNameSet</a> s2</tt> doesn't compute <tt>s2</tt> if
--   <tt>s1</tt> is empty
intersectsNameSet :: NameSet -> NameSet -> Bool
intersectNameSet :: NameSet -> NameSet -> NameSet
nameSetAny :: (Name -> Bool) -> NameSet -> Bool
nameSetAll :: (Name -> Bool) -> NameSet -> Bool

-- | Get the elements of a NameSet with some stable ordering. This only
--   works for Names that originate in the source code or have been tidied.
--   See Note [Deterministic UniqFM] to learn about nondeterminism
nameSetElemsStable :: NameSet -> [Name]
type FreeVars = NameSet
isEmptyFVs :: NameSet -> Bool
emptyFVs :: FreeVars
plusFVs :: [FreeVars] -> FreeVars
plusFV :: FreeVars -> FreeVars -> FreeVars
mkFVs :: [Name] -> FreeVars
addOneFV :: FreeVars -> Name -> FreeVars
unitFV :: Name -> FreeVars
delFV :: Name -> FreeVars -> FreeVars
delFVs :: [Name] -> FreeVars -> FreeVars
intersectFVs :: FreeVars -> FreeVars -> FreeVars

-- | A set of names that are defined somewhere
type Defs = NameSet

-- | A set of names that are used somewhere
type Uses = NameSet

-- | <tt>(Just ds, us) =&gt;</tt> The use of any member of the <tt>ds</tt>
--   implies that all the <tt>us</tt> are used too. Also, <tt>us</tt> may
--   mention <tt>ds</tt>.
--   
--   <tt>Nothing =&gt;</tt> Nothing is defined in this group, but
--   nevertheless all the uses are essential. Used for instance
--   declarations, for example
type DefUse = (Maybe Defs, Uses)

-- | A number of <a>DefUse</a>s in dependency order: earlier <a>Defs</a>
--   scope over later <a>Uses</a> In a single (def, use) pair, the defs
--   also scope over the uses
type DefUses = [DefUse]
emptyDUs :: DefUses
usesOnly :: Uses -> DefUses
mkDUs :: [(Defs, Uses)] -> DefUses
plusDU :: DefUses -> DefUses -> DefUses

-- | Given some <a>DefUses</a> and some <a>Uses</a>, find all the uses,
--   transitively. The result is a superset of the input <a>Uses</a>; and
--   includes things defined in the input <a>DefUses</a> (but only if they
--   are used)
findUses :: DefUses -> Uses -> Uses
duDefs :: DefUses -> Defs

-- | Collect all <a>Uses</a>, regardless of whether the group is itself
--   used, but remove <a>Defs</a> on the way
duUses :: DefUses -> Uses

-- | Just like <a>duUses</a>, but <a>Defs</a> are not eliminated from the
--   <a>Uses</a> returned
allUses :: DefUses -> Uses

module NameEnv

-- | Name Environment
type NameEnv a = UniqFM a
mkNameEnv :: [(Name, a)] -> NameEnv a
emptyNameEnv :: NameEnv a
isEmptyNameEnv :: NameEnv a -> Bool
unitNameEnv :: Name -> a -> NameEnv a
nameEnvElts :: NameEnv a -> [a]
extendNameEnv_C :: (a -> a -> a) -> NameEnv a -> Name -> a -> NameEnv a
extendNameEnv_Acc :: (a -> b -> b) -> (a -> b) -> NameEnv b -> Name -> a -> NameEnv b
extendNameEnv :: NameEnv a -> Name -> a -> NameEnv a
extendNameEnvList :: NameEnv a -> [(Name, a)] -> NameEnv a
extendNameEnvList_C :: (a -> a -> a) -> NameEnv a -> [(Name, a)] -> NameEnv a
filterNameEnv :: (elt -> Bool) -> NameEnv elt -> NameEnv elt
anyNameEnv :: (elt -> Bool) -> NameEnv elt -> Bool
plusNameEnv :: NameEnv a -> NameEnv a -> NameEnv a
plusNameEnv_C :: (a -> a -> a) -> NameEnv a -> NameEnv a -> NameEnv a
alterNameEnv :: (Maybe a -> Maybe a) -> NameEnv a -> Name -> NameEnv a
lookupNameEnv :: NameEnv a -> Name -> Maybe a
lookupNameEnv_NF :: NameEnv a -> Name -> a
delFromNameEnv :: NameEnv a -> Name -> NameEnv a
delListFromNameEnv :: NameEnv a -> [Name] -> NameEnv a
elemNameEnv :: Name -> NameEnv a -> Bool
mapNameEnv :: (elt1 -> elt2) -> NameEnv elt1 -> NameEnv elt2
disjointNameEnv :: NameEnv a -> NameEnv a -> Bool

-- | Deterministic Name Environment
--   
--   See Note [Deterministic UniqFM] in UniqDFM for explanation why we need
--   DNameEnv.
type DNameEnv a = UniqDFM a
emptyDNameEnv :: DNameEnv a
lookupDNameEnv :: DNameEnv a -> Name -> Maybe a
mapDNameEnv :: (a -> b) -> DNameEnv a -> DNameEnv b
alterDNameEnv :: (Maybe a -> Maybe a) -> DNameEnv a -> Name -> DNameEnv a
depAnal :: (node -> [Name]) -> (node -> [Name]) -> [node] -> [SCC node]

module HsDoc

-- | Haskell Documentation String
--   
--   Internally this is a UTF8-Encoded <a>ByteString</a>.
data HsDocString

-- | Located Haskell Documentation String
type LHsDocString = Located HsDocString
mkHsDocString :: String -> HsDocString

-- | Create a <a>HsDocString</a> from a UTF8-encoded <a>ByteString</a>.
mkHsDocStringUtf8ByteString :: ByteString -> HsDocString
unpackHDS :: HsDocString -> String

-- | Return the contents of a <a>HsDocString</a> as a UTF8-encoded
--   <a>ByteString</a>.
hsDocStringToByteString :: HsDocString -> ByteString
ppr_mbDoc :: Maybe LHsDocString -> SDoc

-- | Join two docstrings.
--   
--   Non-empty docstrings are joined with two newlines in between,
--   resulting in separate paragraphs.
appendDocs :: HsDocString -> HsDocString -> HsDocString

-- | Concat docstrings with two newlines in between.
--   
--   Empty docstrings are skipped.
--   
--   If all inputs are empty, <a>Nothing</a> is returned.
concatDocs :: [HsDocString] -> Maybe HsDocString

-- | Docs for declarations: functions, data types, instances, methods etc.
newtype DeclDocMap
DeclDocMap :: Map Name HsDocString -> DeclDocMap
emptyDeclDocMap :: DeclDocMap

-- | Docs for arguments. E.g. function arguments, method arguments.
newtype ArgDocMap
ArgDocMap :: Map Name (Map Int HsDocString) -> ArgDocMap
emptyArgDocMap :: ArgDocMap
instance Data.Data.Data HsDoc.HsDocString
instance GHC.Show.Show HsDoc.HsDocString
instance GHC.Classes.Eq HsDoc.HsDocString
instance Binary.Binary HsDoc.ArgDocMap
instance Outputable.Outputable HsDoc.ArgDocMap
instance Binary.Binary HsDoc.DeclDocMap
instance Outputable.Outputable HsDoc.DeclDocMap
instance Binary.Binary HsDoc.HsDocString
instance Outputable.Outputable HsDoc.HsDocString

module FieldLabel

-- | Field labels are just represented as strings; they are not necessarily
--   unique (even within a module)
type FieldLabelString = FastString

-- | A map from labels to all the auxiliary information
type FieldLabelEnv = DFastStringEnv FieldLabel

-- | Fields in an algebraic record type
data FieldLbl a
FieldLabel :: FieldLabelString -> Bool -> a -> FieldLbl a

-- | User-visible label of the field
[flLabel] :: FieldLbl a -> FieldLabelString

-- | Was DuplicateRecordFields on in the defining module for this datatype?
[flIsOverloaded] :: FieldLbl a -> Bool

-- | Record selector function
[flSelector] :: FieldLbl a -> a
type FieldLabel = FieldLbl Name

-- | Record selector OccNames are built from the underlying field name and
--   the name of the first data constructor of the type, to support
--   duplicate record field names. See Note [Why selector names include
--   data constructors].
mkFieldLabelOccs :: FieldLabelString -> OccName -> Bool -> FieldLbl OccName
instance Data.Traversable.Traversable FieldLabel.FieldLbl
instance Data.Foldable.Foldable FieldLabel.FieldLbl
instance GHC.Base.Functor FieldLabel.FieldLbl
instance GHC.Classes.Eq a => GHC.Classes.Eq (FieldLabel.FieldLbl a)
instance Data.Data.Data a => Data.Data.Data (FieldLabel.FieldLbl a)
instance Outputable.Outputable a => Outputable.Outputable (FieldLabel.FieldLbl a)
instance Binary.Binary a => Binary.Binary (FieldLabel.FieldLbl a)


-- | Computing fingerprints of values serializeable with GHC's
--   <a>Binary</a> module.
module BinFingerprint
fingerprintBinMem :: BinHandle -> IO Fingerprint
computeFingerprint :: Binary a => (BinHandle -> Name -> IO ()) -> a -> IO Fingerprint

-- | Used when we want to fingerprint a structure without depending on the
--   fingerprints of external Names that it refers to.
putNameLiterally :: BinHandle -> Name -> IO ()


-- | Support for source code annotation feature of GHC. That is the ANN
--   pragma.
--   
--   (c) The University of Glasgow 2006 (c) The GRASP/AQUA Project, Glasgow
--   University, 1992-1998
module Annotations

-- | Represents an annotation after it has been sufficiently desugared from
--   it's initial form of <a>AnnDecl</a>
data Annotation
Annotation :: CoreAnnTarget -> AnnPayload -> Annotation

-- | The target of the annotation
[ann_target] :: Annotation -> CoreAnnTarget
[ann_value] :: Annotation -> AnnPayload
type AnnPayload = Serialized " The "payload" of an annotation allows recovery of its value at a given type, and can be persisted to an interface file"

-- | An annotation target
data AnnTarget name

-- | We are annotating something with a name: a type or identifier
NamedTarget :: name -> AnnTarget name

-- | We are annotating a particular module
ModuleTarget :: Module -> AnnTarget name

-- | The kind of annotation target found in the middle end of the compiler
type CoreAnnTarget = AnnTarget Name

-- | Get the <tt>name</tt> of an annotation target if it exists.
getAnnTargetName_maybe :: AnnTarget name -> Maybe name

-- | A collection of annotations Can't use a type synonym or we hit bug
--   #2412 due to source import
data AnnEnv

-- | Construct a new annotation environment that contains the list of
--   annotations provided.
mkAnnEnv :: [Annotation] -> AnnEnv

-- | Add the given annotation to the environment.
extendAnnEnvList :: AnnEnv -> [Annotation] -> AnnEnv

-- | Union two annotation environments.
plusAnnEnv :: AnnEnv -> AnnEnv -> AnnEnv

-- | An empty annotation environment.
emptyAnnEnv :: AnnEnv

-- | Find the annotations attached to the given target as <a>Typeable</a>
--   values of your choice. If no deserializer is specified, only transient
--   annotations will be returned.
findAnns :: Typeable a => ([Word8] -> a) -> AnnEnv -> CoreAnnTarget -> [a]

-- | Find the annotations attached to the given target as <a>Typeable</a>
--   values of your choice. If no deserializer is specified, only transient
--   annotations will be returned.
findAnnsByTypeRep :: AnnEnv -> CoreAnnTarget -> TypeRep -> [[Word8]]

-- | Deserialize all annotations of a given type. This happens lazily, that
--   is no deserialization will take place until the [a] is actually
--   demanded and the [a] can also be empty (the UniqFM is not filtered).
deserializeAnns :: Typeable a => ([Word8] -> a) -> AnnEnv -> UniqFM [a]
instance Outputable.Outputable Annotations.Annotation
instance GHC.Base.Functor Annotations.AnnTarget
instance Unique.Uniquable name => Unique.Uniquable (Annotations.AnnTarget name)
instance Outputable.Outputable name => Outputable.Outputable (Annotations.AnnTarget name)
instance Binary.Binary name => Binary.Binary (Annotations.AnnTarget name)

module IOEnv
data IOEnv env a
failM :: IOEnv env a
failWithM :: String -> IOEnv env a
data IOEnvFailure
IOEnvFailure :: IOEnvFailure
getEnv :: IOEnv env env

-- | Perform a computation with a different environment
setEnv :: env' -> IOEnv env' a -> IOEnv env a

-- | Perform a computation with an altered environment
updEnv :: (env -> env') -> IOEnv env' a -> IOEnv env a
runIOEnv :: env -> IOEnv env a -> IO a
unsafeInterleaveM :: IOEnv env a -> IOEnv env a
uninterruptibleMaskM_ :: IOEnv env a -> IOEnv env a
tryM :: IOEnv env r -> IOEnv env (Either IOEnvFailure r)
tryAllM :: IOEnv env r -> IOEnv env (Either SomeException r)
tryMostM :: IOEnv env r -> IOEnv env (Either SomeException r)
fixM :: (a -> IOEnv env a) -> IOEnv env a

-- | A mutable variable in the <a>IO</a> monad
data IORef a
newMutVar :: a -> IOEnv env (IORef a)
readMutVar :: IORef a -> IOEnv env a
writeMutVar :: IORef a -> a -> IOEnv env ()
updMutVar :: IORef a -> (a -> a) -> IOEnv env ()

-- | Atomically update the reference. Does not force the evaluation of the
--   new variable contents. For strict update, use <a>atomicUpdMutVar'</a>.
atomicUpdMutVar :: IORef a -> (a -> (a, b)) -> IOEnv env b

-- | Strict variant of <a>atomicUpdMutVar</a>.
atomicUpdMutVar' :: IORef a -> (a -> (a, b)) -> IOEnv env b
instance GHC.Show.Show IOEnv.IOEnvFailure
instance GHC.Exception.Type.Exception IOEnv.IOEnvFailure
instance GHC.Base.Monad (IOEnv.IOEnv m)
instance Control.Monad.Fail.MonadFail (IOEnv.IOEnv m)
instance GHC.Base.Applicative (IOEnv.IOEnv m)
instance GHC.Base.Functor (IOEnv.IOEnv m)
instance Exception.ExceptionMonad (IOEnv.IOEnv a)
instance DynFlags.ContainsDynFlags env => DynFlags.HasDynFlags (IOEnv.IOEnv env)
instance Module.ContainsModule env => Module.HasModule (IOEnv.IOEnv env)
instance GHC.Base.Alternative (IOEnv.IOEnv env)
instance GHC.Base.MonadPlus (IOEnv.IOEnv env)
instance Control.Monad.IO.Class.MonadIO (IOEnv.IOEnv env)

module ErrUtils
data Validity

-- | Everything is fine
IsValid :: Validity

-- | A problem, and some indication of why
NotValid :: MsgDoc -> Validity
andValid :: Validity -> Validity -> Validity

-- | If they aren't all valid, return the first
allValid :: [Validity] -> Validity
isValid :: Validity -> Bool
getInvalids :: [Validity] -> [MsgDoc]
orValid :: Validity -> Validity -> Validity
data Severity
SevOutput :: Severity
SevFatal :: Severity
SevInteractive :: Severity

-- | Log message intended for compiler developers No file<i>line</i>column
--   stuff
SevDump :: Severity

-- | Log messages intended for end users. No file<i>line</i>column stuff.
SevInfo :: Severity
SevWarning :: Severity

-- | SevWarning and SevError are used for warnings and errors o The message
--   has a file<i>line</i>column heading, plus "warning:" or "error:",
--   added by mkLocMessags o Output is intended for end users
SevError :: Severity
data ErrMsg
errMsgDoc :: ErrMsg -> ErrDoc
errMsgSeverity :: ErrMsg -> Severity
errMsgReason :: ErrMsg -> WarnReason

-- | Categorise error msgs by their importance. This is so each section can
--   be rendered visually distinct. See Note [Error report] for where these
--   come from.
data ErrDoc
errDoc :: [MsgDoc] -> [MsgDoc] -> [MsgDoc] -> ErrDoc

-- | Primary error msg.
errDocImportant :: ErrDoc -> [MsgDoc]

-- | Context e.g. "In the second argument of ...".
errDocContext :: ErrDoc -> [MsgDoc]

-- | Supplementary information, e.g. "Relevant bindings include ...".
errDocSupplementary :: ErrDoc -> [MsgDoc]
type WarnMsg = ErrMsg
type MsgDoc = SDoc
type Messages = (WarningMessages, ErrorMessages)
type ErrorMessages = Bag ErrMsg
type WarningMessages = Bag WarnMsg
unionMessages :: Messages -> Messages -> Messages
errMsgSpan :: ErrMsg -> SrcSpan
errMsgContext :: ErrMsg -> PrintUnqualified
errorsFound :: DynFlags -> Messages -> Bool
isEmptyMessages :: Messages -> Bool

-- | Checks if given <a>WarnMsg</a> is a fatal warning.
isWarnMsgFatal :: DynFlags -> WarnMsg -> Maybe (Maybe WarningFlag)
pprMessageBag :: Bag MsgDoc -> SDoc
pprErrMsgBagWithLoc :: Bag ErrMsg -> [SDoc]
pprLocErrMsg :: ErrMsg -> SDoc
printBagOfErrors :: DynFlags -> Bag ErrMsg -> IO ()
formatErrDoc :: DynFlags -> ErrDoc -> SDoc
emptyMessages :: Messages

-- | Make an unannotated error message with location info.
mkLocMessage :: Severity -> SrcSpan -> MsgDoc -> MsgDoc

-- | Make a possibly annotated error message with location info.
mkLocMessageAnn :: Maybe String -> Severity -> SrcSpan -> MsgDoc -> MsgDoc
makeIntoWarning :: WarnReason -> ErrMsg -> ErrMsg

-- | A short (one-line) error message
mkErrMsg :: DynFlags -> SrcSpan -> PrintUnqualified -> MsgDoc -> ErrMsg

-- | Variant that doesn't care about qualified/unqualified names
mkPlainErrMsg :: DynFlags -> SrcSpan -> MsgDoc -> ErrMsg
mkErrDoc :: DynFlags -> SrcSpan -> PrintUnqualified -> ErrDoc -> ErrMsg

-- | A long (multi-line) error message
mkLongErrMsg :: DynFlags -> SrcSpan -> PrintUnqualified -> MsgDoc -> MsgDoc -> ErrMsg

-- | A short (one-line) error message
mkWarnMsg :: DynFlags -> SrcSpan -> PrintUnqualified -> MsgDoc -> ErrMsg

-- | Variant that doesn't care about qualified/unqualified names
mkPlainWarnMsg :: DynFlags -> SrcSpan -> MsgDoc -> ErrMsg

-- | A long (multi-line) error message
mkLongWarnMsg :: DynFlags -> SrcSpan -> PrintUnqualified -> MsgDoc -> MsgDoc -> ErrMsg
doIfSet :: Bool -> IO () -> IO ()
doIfSet_dyn :: DynFlags -> GeneralFlag -> IO () -> IO ()
getCaretDiagnostic :: Severity -> SrcSpan -> IO MsgDoc
dumpIfSet :: DynFlags -> Bool -> String -> SDoc -> IO ()

-- | a wrapper around <a>dumpSDoc</a>. First check whether the dump flag is
--   set Do nothing if it is unset
dumpIfSet_dyn :: DynFlags -> DumpFlag -> String -> SDoc -> IO ()

-- | a wrapper around <a>dumpSDoc</a>. First check whether the dump flag is
--   set Do nothing if it is unset
--   
--   Unlike <a>dumpIfSet_dyn</a>, has a printer argument but no header
--   argument
dumpIfSet_dyn_printer :: PrintUnqualified -> DynFlags -> DumpFlag -> SDoc -> IO ()
mkDumpDoc :: String -> SDoc -> SDoc

-- | A wrapper around <a>dumpSDocWithStyle</a> which uses <tt>PprDump</tt>
--   style.
dumpSDoc :: DynFlags -> PrintUnqualified -> DumpFlag -> String -> SDoc -> IO ()

-- | A wrapper around <a>dumpSDocWithStyle</a> which uses <tt>PprUser</tt>
--   style.
dumpSDocForUser :: DynFlags -> PrintUnqualified -> DumpFlag -> String -> SDoc -> IO ()

-- | Write out a dump. If --dump-to-file is set then this goes to a file.
--   otherwise emit to stdout.
--   
--   When <tt>hdr</tt> is empty, we print in a more compact format (no
--   separators and blank lines)
--   
--   The <a>DumpFlag</a> is used only to choose the filename to use if
--   <tt>--dump-to-file</tt> is used; it is not used to decide whether to
--   dump the output
dumpSDocWithStyle :: PprStyle -> DynFlags -> DumpFlag -> String -> SDoc -> IO ()
putMsg :: DynFlags -> MsgDoc -> IO ()
printInfoForUser :: DynFlags -> PrintUnqualified -> MsgDoc -> IO ()
printOutputForUser :: DynFlags -> PrintUnqualified -> MsgDoc -> IO ()
logInfo :: DynFlags -> PprStyle -> MsgDoc -> IO ()

-- | Like <a>logInfo</a> but with <a>SevOutput</a> rather then
--   <a>SevInfo</a>
logOutput :: DynFlags -> PprStyle -> MsgDoc -> IO ()
errorMsg :: DynFlags -> MsgDoc -> IO ()
warningMsg :: DynFlags -> MsgDoc -> IO ()
fatalErrorMsg :: DynFlags -> MsgDoc -> IO ()
fatalErrorMsg'' :: FatalMessager -> String -> IO ()
compilationProgressMsg :: DynFlags -> String -> IO ()
showPass :: DynFlags -> String -> IO ()

-- | Time a compilation phase.
--   
--   When timings are enabled (e.g. with the <tt>-v2</tt> flag), the
--   allocations and CPU time used by the phase will be reported to stderr.
--   Consider a typical usage: <tt>withTiming getDynFlags (text "simplify")
--   force pass</tt>. When timings are enabled the following costs are
--   included in the produced accounting,
--   
--   <ul>
--   <li>The cost of executing <tt>pass</tt> to a result <tt>r</tt> in
--   WHNF</li>
--   <li>The cost of evaluating <tt>force r</tt> to WHNF (e.g.
--   <tt>()</tt>)</li>
--   </ul>
--   
--   The choice of the <tt>force</tt> function depends upon the amount of
--   forcing desired; the goal here is to ensure that the cost of
--   evaluating the result is, to the greatest extent possible, included in
--   the accounting provided by <a>withTiming</a>. Often the pass already
--   sufficiently forces its result during construction; in this case
--   <tt>const ()</tt> is a reasonable choice. In other cases, it is
--   necessary to evaluate the result to normal form, in which case
--   something like <tt>Control.DeepSeq.rnf</tt> is appropriate.
--   
--   To avoid adversely affecting compiler performance when timings are not
--   requested, the result is only forced when timings are enabled.
withTiming :: MonadIO m => m DynFlags -> SDoc -> (a -> ()) -> m a -> m a
debugTraceMsg :: DynFlags -> Int -> MsgDoc -> IO ()
ghcExit :: DynFlags -> Int -> IO ()
prettyPrintGhcErrors :: ExceptionMonad m => DynFlags -> m a -> m a
traceCmd :: DynFlags -> String -> String -> IO a -> IO a
instance GHC.Show.Show ErrUtils.Severity
instance GHC.Show.Show ErrUtils.ErrMsg
instance Json.ToJson ErrUtils.Severity


-- | Package manipulation
module Packages
data PackageState

-- | <a>UniqFM</a> map from <a>UnitId</a> to <a>PackageConfig</a>, plus the
--   transitive closure of preload packages.
data PackageConfigMap
emptyPackageState :: PackageState

-- | Call this after <a>parseDynFlags</a>. It reads the package database
--   files, and sets up various internal tables of package information,
--   according to the package-related flags on the command-line
--   (<tt>-package</tt>, <tt>-hide-package</tt> etc.)
--   
--   Returns a list of packages to link in if we're doing dynamic linking.
--   This list contains the packages that the user explicitly mentioned
--   with <tt>-package</tt> flags.
--   
--   <a>initPackages</a> can be called again subsequently after updating
--   the <a>packageFlags</a> field of the <a>DynFlags</a>, and it will
--   update the <a>pkgState</a> in <a>DynFlags</a> and return a list of
--   packages to link in.
initPackages :: DynFlags -> IO (DynFlags, [PreloadUnitId])
readPackageConfigs :: DynFlags -> IO [(FilePath, [PackageConfig])]
getPackageConfRefs :: DynFlags -> IO [PkgConfRef]
resolvePackageConfig :: DynFlags -> PkgConfRef -> IO (Maybe FilePath)
readPackageConfig :: DynFlags -> FilePath -> IO (FilePath, [PackageConfig])

-- | Get a list of entries from the package database. NB: be careful with
--   this function, although all packages in this map are "visible", this
--   does not imply that the exposed-modules of the package are available
--   (they may have been thinned or renamed).
listPackageConfigMap :: DynFlags -> [PackageConfig]

-- | Find the package we know about with the given unit id, if any
lookupPackage :: DynFlags -> UnitId -> Maybe PackageConfig

-- | A more specialized interface, which takes a boolean specifying whether
--   or not to look for on-the-fly renamed interfaces, and just a
--   <a>PackageConfigMap</a> rather than a <a>DynFlags</a> (so it can be
--   used while we're initializing <a>DynFlags</a>
lookupPackage' :: Bool -> PackageConfigMap -> UnitId -> Maybe PackageConfig
lookupInstalledPackage :: DynFlags -> InstalledUnitId -> Maybe PackageConfig

-- | Find the package we know about with the given package name (e.g.
--   <tt>foo</tt>), if any (NB: there might be a locally defined unit name
--   which overrides this)
lookupPackageName :: DynFlags -> PackageName -> Maybe ComponentId

-- | Given a fully instantiated <a>UnitId</a>, improve it into a
--   <a>InstalledUnitId</a> if we can find it in the package database.
improveUnitId :: PackageConfigMap -> UnitId -> UnitId

-- | Search for packages with a given package ID (e.g. "foo-0.1")
searchPackageId :: DynFlags -> SourcePackageId -> [PackageConfig]

-- | Looks up the package with the given id in the package state, panicing
--   if it is not found
getPackageDetails :: DynFlags -> UnitId -> PackageConfig
getInstalledPackageDetails :: DynFlags -> InstalledUnitId -> PackageConfig
componentIdString :: DynFlags -> ComponentId -> Maybe String
displayInstalledUnitId :: DynFlags -> InstalledUnitId -> Maybe String
listVisibleModuleNames :: DynFlags -> [ModuleName]

-- | Takes a <a>ModuleName</a>, and if the module is in any package returns
--   list of modules which take that name.
lookupModuleInAllPackages :: DynFlags -> ModuleName -> [(Module, PackageConfig)]
lookupModuleWithSuggestions :: DynFlags -> ModuleName -> Maybe FastString -> LookupResult
lookupPluginModuleWithSuggestions :: DynFlags -> ModuleName -> Maybe FastString -> LookupResult

-- | The result of performing a lookup
data LookupResult

-- | Found the module uniquely, nothing else to do
LookupFound :: Module -> PackageConfig -> LookupResult

-- | Multiple modules with the same name in scope
LookupMultiple :: [(Module, ModuleOrigin)] -> LookupResult

-- | No modules found, but there were some hidden ones with an exact name
--   match. First is due to package hidden, second is due to module being
--   hidden
LookupHidden :: [(Module, ModuleOrigin)] -> [(Module, ModuleOrigin)] -> LookupResult

-- | No modules found, but there were some unusable ones with an exact name
--   match
LookupUnusable :: [(Module, ModuleOrigin)] -> LookupResult

-- | Nothing found, here are some suggested different names
LookupNotFound :: [ModuleSuggestion] -> LookupResult
data ModuleSuggestion
SuggestVisible :: ModuleName -> Module -> ModuleOrigin -> ModuleSuggestion
SuggestHidden :: ModuleName -> Module -> ModuleOrigin -> ModuleSuggestion

-- | Package state is all stored in <a>DynFlags</a>, including the details
--   of all packages, which packages are exposed, and which modules they
--   provide.
--   
--   The package state is computed by <a>initPackages</a>, and kept in
--   DynFlags. It is influenced by various package flags:
--   
--   <ul>
--   <li><tt>-package <a>pkg</a></tt> and <tt>-package-id <a>pkg</a></tt>
--   cause <tt><a>pkg</a></tt> to become exposed. If
--   <tt>-hide-all-packages</tt> was not specified, these commands also
--   cause all other packages with the same name to become hidden.</li>
--   <li><tt>-hide-package <a>pkg</a></tt> causes <tt><a>pkg</a></tt> to
--   become hidden.</li>
--   <li>(there are a few more flags, check below for their semantics)</li>
--   </ul>
--   
--   The package state has the following properties.
--   
--   <ul>
--   <li>Let <tt>exposedPackages</tt> be the set of packages thus exposed.
--   Let <tt>depExposedPackages</tt> be the transitive closure from
--   <tt>exposedPackages</tt> of their dependencies.</li>
--   <li>When searching for a module from a preload import declaration,
--   only the exposed modules in <tt>exposedPackages</tt> are valid.</li>
--   <li>When searching for a module from an implicit import, all modules
--   from <tt>depExposedPackages</tt> are valid.</li>
--   <li>When linking in a compilation manager mode, we link in packages
--   the program depends on (the compiler knows this list by the time it
--   gets to the link step). Also, we link in all packages which were
--   mentioned with preload <tt>-package</tt> flags on the command-line, or
--   are a transitive dependency of same, or are "base"/"rts". The reason
--   for this is that we might need packages which don't contain any
--   Haskell modules, and therefore won't be discovered by the normal
--   mechanism of dependency tracking.</li>
--   </ul>
--   
--   Given a module name, there may be multiple ways it came into scope,
--   possibly simultaneously. This data type tracks all the possible ways
--   it could have come into scope. Warning: don't use the record
--   functions, they're partial!
data ModuleOrigin

-- | Module is hidden, and thus never will be available for import. (But
--   maybe the user didn't realize), so we'll still keep track of these
--   modules.)
ModHidden :: ModuleOrigin

-- | Module is unavailable because the package is unusable.
ModUnusable :: UnusablePackageReason -> ModuleOrigin

-- | Module is public, and could have come from some places.
ModOrigin :: Maybe Bool -> [PackageConfig] -> [PackageConfig] -> Bool -> ModuleOrigin

-- | <tt>Just False</tt> means that this module is in someone's
--   <tt>exported-modules</tt> list, but that package is hidden; <tt>Just
--   True</tt> means that it is available; <tt>Nothing</tt> means neither
--   applies.
[fromOrigPackage] :: ModuleOrigin -> Maybe Bool

-- | Is the module available from a reexport of an exposed package? There
--   could be multiple.
[fromExposedReexport] :: ModuleOrigin -> [PackageConfig]

-- | Is the module available from a reexport of a hidden package?
[fromHiddenReexport] :: ModuleOrigin -> [PackageConfig]

-- | Did the module export come from a package flag? (ToDo: track more
--   information.
[fromPackageFlag] :: ModuleOrigin -> Bool

-- | The reason why a package is unusable.
data UnusablePackageReason

-- | We ignored it explicitly using <tt>-ignore-package</tt>.
IgnoredWithFlag :: UnusablePackageReason

-- | This package transitively depends on a package that was never present
--   in any of the provided databases.
BrokenDependencies :: [InstalledUnitId] -> UnusablePackageReason

-- | This package transitively depends on a package involved in a cycle.
--   Note that the list of <a>InstalledUnitId</a> reports the direct
--   dependencies of this package that (transitively) depended on the
--   cycle, and not the actual cycle itself (which we report separately at
--   high verbosity.)
CyclicDependencies :: [InstalledUnitId] -> UnusablePackageReason

-- | This package transitively depends on a package which was ignored.
IgnoredDependencies :: [InstalledUnitId] -> UnusablePackageReason

-- | This package transitively depends on a package which was shadowed by
--   an ABI-incompatible package.
ShadowedDependencies :: [InstalledUnitId] -> UnusablePackageReason
pprReason :: SDoc -> UnusablePackageReason -> SDoc

-- | Find all the include directories in these and the preload packages
getPackageIncludePath :: DynFlags -> [PreloadUnitId] -> IO [String]

-- | Find all the library paths in these and the preload packages
getPackageLibraryPath :: DynFlags -> [PreloadUnitId] -> IO [String]

-- | Find all the link options in these and the preload packages, returning
--   (package hs lib options, extra library options, other flags)
getPackageLinkOpts :: DynFlags -> [PreloadUnitId] -> IO ([String], [String], [String])

-- | Find all the C-compiler options in these and the preload packages
getPackageExtraCcOpts :: DynFlags -> [PreloadUnitId] -> IO [String]

-- | Find all the package framework paths in these and the preload packages
getPackageFrameworkPath :: DynFlags -> [PreloadUnitId] -> IO [String]

-- | Find all the package frameworks in these and the preload packages
getPackageFrameworks :: DynFlags -> [PreloadUnitId] -> IO [String]

-- | Retrieve the <a>PackageConfigMap</a> from <a>DynFlags</a>; used in the
--   <tt>hs-boot</tt> loop-breaker.
getPackageConfigMap :: DynFlags -> PackageConfigMap

-- | Find all the <a>PackageConfig</a> in both the preload packages from
--   <a>DynFlags</a> and corresponding to the list of <a>PackageConfig</a>s
getPreloadPackagesAnd :: DynFlags -> [PreloadUnitId] -> IO [PackageConfig]
collectArchives :: DynFlags -> PackageConfig -> IO [FilePath]
collectIncludeDirs :: [PackageConfig] -> [FilePath]
collectLibraryPaths :: DynFlags -> [PackageConfig] -> [FilePath]
collectLinkOpts :: DynFlags -> [PackageConfig] -> ([String], [String], [String])
packageHsLibs :: DynFlags -> PackageConfig -> [String]
getLibs :: DynFlags -> [PreloadUnitId] -> IO [(String, String)]

-- | Given a wired-in <a>UnitId</a>, "unwire" it into the <a>UnitId</a>
--   that it was recorded as in the package database.
unwireUnitId :: DynFlags -> UnitId -> UnitId
pprFlag :: PackageFlag -> SDoc

-- | Show (very verbose) package info
pprPackages :: DynFlags -> SDoc

-- | Show simplified package info.
--   
--   The idea is to only print package id, and any information that might
--   be different from the package databases (exposure, trust)
pprPackagesSimple :: DynFlags -> SDoc

-- | Show the mapping of modules to where they come from.
pprModuleMap :: ModuleToPkgConfAll -> SDoc

-- | A little utility to tell if the <a>thisPackage</a> is indefinite (if
--   it is not, we should never use on-the-fly renaming.)
isIndefinite :: DynFlags -> Bool

-- | Will the <a>Name</a> come from a dynamically linked library?
isDllName :: DynFlags -> Module -> Name -> Bool
instance Outputable.Outputable Packages.ModuleOrigin
instance GHC.Base.Semigroup Packages.ModuleOrigin
instance GHC.Base.Monoid Packages.ModuleOrigin
instance Outputable.Outputable Packages.UnusablePackageReason
instance Outputable.Outputable Packages.UnitVisibility
instance GHC.Base.Semigroup Packages.UnitVisibility
instance GHC.Base.Monoid Packages.UnitVisibility

module FileCleanup

-- | Used when a temp file is created. This determines which component Set
--   of FilesToClean will get the temp file
data TempFileLifetime

-- | A file with lifetime TFL_CurrentModule will be cleaned up at the end
--   of upweep_mod
TFL_CurrentModule :: TempFileLifetime

-- | A file with lifetime TFL_GhcSession will be cleaned up at the end of
--   runGhc(T)
TFL_GhcSession :: TempFileLifetime
cleanTempDirs :: DynFlags -> IO ()

-- | Delete all files in <tt>filesToClean dflags</tt>.
cleanTempFiles :: DynFlags -> IO ()

-- | Delete all files in <tt>filesToClean dflags</tt>. That have lifetime
--   TFL_CurrentModule. If a file must be cleaned eventually, but must
--   survive a cleanCurrentModuleTempFiles, ensure it has lifetime
--   TFL_GhcSession.
cleanCurrentModuleTempFiles :: DynFlags -> IO ()

-- | Ensure that new_files are cleaned on the next call of
--   <a>cleanTempFiles</a> or <a>cleanCurrentModuleTempFiles</a>, depending
--   on lifetime. If any of new_files are already tracked, they will have
--   their lifetime updated.
addFilesToClean :: DynFlags -> TempFileLifetime -> [FilePath] -> IO ()

-- | Update the lifetime of files already being tracked. If any files are
--   not being tracked they will be discarded.
changeTempFilesLifetime :: DynFlags -> TempFileLifetime -> [FilePath] -> IO ()
newTempName :: DynFlags -> TempFileLifetime -> Suffix -> IO FilePath
newTempLibName :: DynFlags -> TempFileLifetime -> Suffix -> IO (FilePath, FilePath, String)
newTempDir :: DynFlags -> IO FilePath

-- | Create and use a temporary directory in the system standard temporary
--   directory.
--   
--   Behaves exactly the same as <a>withTempDirectory</a>, except that the
--   parent temporary directory will be that returned by
--   <a>getTemporaryDirectory</a>.
withSystemTempDirectory :: String -> (FilePath -> IO a) -> IO a

-- | Create and use a temporary directory.
--   
--   Creates a new temporary directory inside the given directory, making
--   use of the template. The temp directory is deleted after use. For
--   example:
--   
--   <pre>
--   withTempDirectory "src" "sdist." $ \tmpDir -&gt; do ...
--   </pre>
--   
--   The <tt>tmpDir</tt> will be a new subdirectory of the given directory,
--   e.g. <tt>src/sdist.342</tt>.
withTempDirectory :: FilePath -> String -> (FilePath -> IO a) -> IO a
instance GHC.Show.Show FileCleanup.TempFileLifetime

module CmmType
data CmmType
b8 :: CmmType
b16 :: CmmType
b32 :: CmmType
b64 :: CmmType
b128 :: CmmType
b256 :: CmmType
b512 :: CmmType
f32 :: CmmType
f64 :: CmmType
bWord :: DynFlags -> CmmType
bHalfWord :: DynFlags -> CmmType
gcWord :: DynFlags -> CmmType
cInt :: DynFlags -> CmmType
cmmBits :: Width -> CmmType
cmmFloat :: Width -> CmmType
typeWidth :: CmmType -> Width
cmmEqType :: CmmType -> CmmType -> Bool
cmmEqType_ignoring_ptrhood :: CmmType -> CmmType -> Bool
isFloatType :: CmmType -> Bool
isGcPtrType :: CmmType -> Bool
isBitsType :: CmmType -> Bool
isWord32 :: CmmType -> Bool
isWord64 :: CmmType -> Bool
isFloat64 :: CmmType -> Bool
isFloat32 :: CmmType -> Bool
data Width
W8 :: Width
W16 :: Width
W32 :: Width
W64 :: Width
W80 :: Width
W128 :: Width
W256 :: Width
W512 :: Width
widthInBits :: Width -> Int
widthInBytes :: Width -> Int
widthInLog :: Width -> Int
widthFromBytes :: Int -> Width
wordWidth :: DynFlags -> Width
halfWordWidth :: DynFlags -> Width
cIntWidth :: DynFlags -> Width
halfWordMask :: DynFlags -> Integer
narrowU :: Width -> Integer -> Integer
narrowS :: Width -> Integer -> Integer
rEP_CostCentreStack_mem_alloc :: DynFlags -> CmmType
rEP_CostCentreStack_scc_count :: DynFlags -> CmmType
rEP_StgEntCounter_allocs :: DynFlags -> CmmType
rEP_StgEntCounter_allocd :: DynFlags -> CmmType
data ForeignHint
NoHint :: ForeignHint
AddrHint :: ForeignHint
SignedHint :: ForeignHint
type Length = Int
vec :: Length -> CmmType -> CmmType
vec2 :: CmmType -> CmmType
vec4 :: CmmType -> CmmType
vec8 :: CmmType -> CmmType
vec16 :: CmmType -> CmmType
vec2f64 :: CmmType
vec2b64 :: CmmType
vec4f32 :: CmmType
vec4b32 :: CmmType
vec8b16 :: CmmType
vec16b8 :: CmmType
cmmVec :: Int -> CmmType -> CmmType
vecLength :: CmmType -> Length
vecElemType :: CmmType -> CmmType
isVecType :: CmmType -> Bool
instance GHC.Classes.Eq CmmType.ForeignHint
instance GHC.Classes.Eq CmmType.CmmCat
instance GHC.Show.Show CmmType.Width
instance GHC.Classes.Ord CmmType.Width
instance GHC.Classes.Eq CmmType.Width
instance Outputable.Outputable CmmType.CmmType
instance Outputable.Outputable CmmType.CmmCat
instance Outputable.Outputable CmmType.Width

module Avail

-- | A collection of <a>AvailInfo</a> - several things that are "available"
type Avails = [AvailInfo]

-- | Records what things are "available", i.e. in scope
data AvailInfo

-- | An ordinary identifier in scope
Avail :: Name -> AvailInfo

-- | A type or class in scope
--   
--   The <b>AvailTC Invariant</b>: If the type or class is itself to be in
--   scope, it must be <i>first</i> in this list. Thus, typically:
--   
--   <pre>
--   AvailTC Eq [Eq, ==, \/=] []
--   </pre>
AvailTC :: Name -> [Name] -> [FieldLabel] -> AvailInfo
avail :: Name -> AvailInfo
availsToNameSet :: [AvailInfo] -> NameSet
availsToNameSetWithSelectors :: [AvailInfo] -> NameSet
availsToNameEnv :: [AvailInfo] -> NameEnv AvailInfo

-- | Just the main name made available, i.e. not the available pieces of
--   type or class brought into scope by the <tt>GenAvailInfo</tt>
availName :: AvailInfo -> Name

-- | All names made available by the availability information (excluding
--   overloaded selectors)
availNames :: AvailInfo -> [Name]

-- | Names for non-fields made available by the availability information
availNonFldNames :: AvailInfo -> [Name]

-- | All names made available by the availability information (including
--   overloaded selectors)
availNamesWithSelectors :: AvailInfo -> [Name]

-- | Fields made available by the availability information
availFlds :: AvailInfo -> [FieldLabel]
availsNamesWithOccs :: [AvailInfo] -> [(Name, OccName)]

-- | <a>Name</a>s made available by the availability information, paired
--   with the <a>OccName</a> used to refer to each one.
--   
--   When <tt>DuplicateRecordFields</tt> is in use, the <a>Name</a> may be
--   the mangled name of a record selector (e.g. <tt>$sel:foo:MkT</tt>)
--   while the <a>OccName</a> will be the label of the field (e.g.
--   <tt>foo</tt>).
--   
--   See Note [Representing fields in AvailInfo].
availNamesWithOccs :: AvailInfo -> [(Name, OccName)]

-- | Compare lexicographically
stableAvailCmp :: AvailInfo -> AvailInfo -> Ordering
plusAvail :: AvailInfo -> AvailInfo -> AvailInfo

-- | trims an <a>AvailInfo</a> to keep only a single name
trimAvail :: AvailInfo -> Name -> AvailInfo

-- | filters an <a>AvailInfo</a> by the given predicate
filterAvail :: (Name -> Bool) -> AvailInfo -> [AvailInfo] -> [AvailInfo]

-- | filters <a>AvailInfo</a>s by the given predicate
filterAvails :: (Name -> Bool) -> [AvailInfo] -> [AvailInfo]

-- | Combines <a>AvailInfo</a>s from the same family <tt>avails</tt> may
--   have several items with the same availName E.g import Ix( Ix(..),
--   index ) will give Ix(Ix,index,range) and Ix(index) We want to combine
--   these; addAvail does that
nubAvails :: [AvailInfo] -> [AvailInfo]
instance Data.Data.Data Avail.AvailInfo
instance GHC.Classes.Eq Avail.AvailInfo
instance Outputable.Outputable Avail.AvailInfo
instance Binary.Binary Avail.AvailInfo


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see <a>OccName#name_types</a></li>
--   <li><a>RdrName</a> is the type of names that come directly from the
--   parser. They have not yet had their scoping and binding resolved by
--   the renamer and can be thought of to a first approximation as an
--   <a>OccName</a> with an optional module qualifier</li>
--   <li><a>Name</a>: see <a>Name#name_types</a></li>
--   <li><a>Id</a>: see <a>Id#name_types</a></li>
--   <li><a>Var</a>: see <a>Var#name_types</a></li>
--   </ul>
module RdrName

-- | Reader Name
--   
--   Do not use the data constructors of RdrName directly: prefer the
--   family of functions that creates them, such as <a>mkRdrUnqual</a>
--   
--   <ul>
--   <li>Note: A Located RdrName will only have API Annotations if it is a
--   compound one, e.g.</li>
--   </ul>
--   
--   <pre>
--   `bar`
--   ( ~ )
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnOpen</a> <tt>'('</tt>
--   or <tt>'['</tt> or <tt>'[:'</tt>, <a>AnnClose</a> <tt>')'</tt> or
--   <tt>']'</tt> or <tt>':]'</tt>,, <a>AnnBackquote</a> <tt>'`'</tt>,
--   <a>AnnVal</a> <a>AnnTilde</a>,</li>
--   </ul>
data RdrName

-- | Unqualified name
--   
--   Used for ordinary, unqualified occurrences, e.g. <tt>x</tt>,
--   <tt>y</tt> or <tt>Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrUnqual</a>
Unqual :: OccName -> RdrName

-- | Qualified name
--   
--   A qualified name written by the user in <i>source</i> code. The module
--   isn't necessarily the module where the thing is defined; just the one
--   from which it is imported. Examples are <tt>Bar.x</tt>, <tt>Bar.y</tt>
--   or <tt>Bar.Foo</tt>. Create such a <a>RdrName</a> with
--   <a>mkRdrQual</a>
Qual :: ModuleName -> OccName -> RdrName

-- | Original name
--   
--   An original name; the module is the <i>defining</i> module. This is
--   used when GHC generates code that will be fed into the renamer (e.g.
--   from deriving clauses), but where we want to say "Use Prelude.map
--   dammit". One of these can be created with <a>mkOrig</a>
Orig :: Module -> OccName -> RdrName

-- | Exact name
--   
--   We know exactly the <a>Name</a>. This is used:
--   
--   <ol>
--   <li>When the parser parses built-in syntax like <tt>[]</tt> and
--   <tt>(,)</tt>, but wants a <a>RdrName</a> from it</li>
--   <li>By Template Haskell, when TH has generated a unique name</li>
--   </ol>
--   
--   Such a <a>RdrName</a> can be created by using <a>getRdrName</a> on a
--   <a>Name</a>
Exact :: Name -> RdrName
mkRdrUnqual :: OccName -> RdrName
mkRdrQual :: ModuleName -> OccName -> RdrName
mkUnqual :: NameSpace -> FastString -> RdrName
mkVarUnqual :: FastString -> RdrName

-- | Make a qualified <a>RdrName</a> in the given namespace and where the
--   <a>ModuleName</a> and the <a>OccName</a> are taken from the first and
--   second elements of the tuple respectively
mkQual :: NameSpace -> (FastString, FastString) -> RdrName
mkOrig :: Module -> OccName -> RdrName
nameRdrName :: Name -> RdrName
getRdrName :: NamedThing thing => thing -> RdrName
rdrNameOcc :: RdrName -> OccName
rdrNameSpace :: RdrName -> NameSpace
demoteRdrName :: RdrName -> Maybe RdrName
isRdrDataCon :: RdrName -> Bool
isRdrTyVar :: RdrName -> Bool
isRdrTc :: RdrName -> Bool
isQual :: RdrName -> Bool
isQual_maybe :: RdrName -> Maybe (ModuleName, OccName)
isUnqual :: RdrName -> Bool
isOrig :: RdrName -> Bool
isOrig_maybe :: RdrName -> Maybe (Module, OccName)
isExact :: RdrName -> Bool
isExact_maybe :: RdrName -> Maybe Name
isSrcRdrName :: RdrName -> Bool

-- | Local Reader Environment
--   
--   This environment is used to store local bindings (<tt>let</tt>,
--   <tt>where</tt>, lambda, <tt>case</tt>). It is keyed by OccName,
--   because we never use it for qualified names We keep the current
--   mapping, *and* the set of all Names in scope Reason: see Note
--   [Splicing Exact names] in RnEnv
data LocalRdrEnv
emptyLocalRdrEnv :: LocalRdrEnv
extendLocalRdrEnv :: LocalRdrEnv -> Name -> LocalRdrEnv
extendLocalRdrEnvList :: LocalRdrEnv -> [Name] -> LocalRdrEnv
lookupLocalRdrEnv :: LocalRdrEnv -> RdrName -> Maybe Name
lookupLocalRdrOcc :: LocalRdrEnv -> OccName -> Maybe Name
elemLocalRdrEnv :: RdrName -> LocalRdrEnv -> Bool
inLocalRdrEnvScope :: Name -> LocalRdrEnv -> Bool
localRdrEnvElts :: LocalRdrEnv -> [Name]
delLocalRdrEnvList :: LocalRdrEnv -> [OccName] -> LocalRdrEnv

-- | Global Reader Environment
--   
--   Keyed by <a>OccName</a>; when looking up a qualified name we look up
--   the <a>OccName</a> part, and then check the <tt>Provenance</tt> to see
--   if the appropriate qualification is valid. This saves routinely
--   doubling the size of the env by adding both qualified and unqualified
--   names to the domain.
--   
--   The list in the codomain is required because there may be name clashes
--   These only get reported on lookup, not on construction
--   
--   INVARIANT 1: All the members of the list have distinct <a>gre_name</a>
--   fields; that is, no duplicate Names
--   
--   INVARIANT 2: Imported provenance =&gt; Name is an ExternalName However
--   LocalDefs can have an InternalName. This happens only when
--   type-checking a [d| ... |] Template Haskell quotation; see this note
--   in RnNames Note [Top-level Names in Template Haskell decl quotes]
--   
--   INVARIANT 3: If the GlobalRdrEnv maps [occ -&gt; gre], then greOccName
--   gre = occ
--   
--   NB: greOccName gre is usually the same as nameOccName (gre_name gre),
--   but not always in the case of record seectors; see greOccName
type GlobalRdrEnv = OccEnv [GlobalRdrElt]
emptyGlobalRdrEnv :: GlobalRdrEnv
mkGlobalRdrEnv :: [GlobalRdrElt] -> GlobalRdrEnv
plusGlobalRdrEnv :: GlobalRdrEnv -> GlobalRdrEnv -> GlobalRdrEnv
lookupGlobalRdrEnv :: GlobalRdrEnv -> OccName -> [GlobalRdrElt]
extendGlobalRdrEnv :: GlobalRdrEnv -> GlobalRdrElt -> GlobalRdrEnv
greOccName :: GlobalRdrElt -> OccName
shadowNames :: GlobalRdrEnv -> [Name] -> GlobalRdrEnv
pprGlobalRdrEnv :: Bool -> GlobalRdrEnv -> SDoc
globalRdrEnvElts :: GlobalRdrEnv -> [GlobalRdrElt]
lookupGRE_RdrName :: RdrName -> GlobalRdrEnv -> [GlobalRdrElt]

-- | Look for precisely this <a>Name</a> in the environment. This tests
--   whether it is in scope, ignoring anything else that might be in scope
--   with the same <a>OccName</a>.
lookupGRE_Name :: GlobalRdrEnv -> Name -> Maybe GlobalRdrElt

-- | Look for a particular record field selector in the environment, where
--   the selector name and field label may be different: the GlobalRdrEnv
--   is keyed on the label. See Note [Parents for record fields] for why
--   this happens.
lookupGRE_FieldLabel :: GlobalRdrEnv -> FieldLabel -> Maybe GlobalRdrElt

-- | Look for precisely this <a>Name</a> in the environment, but with an
--   <a>OccName</a> that might differ from that of the <a>Name</a>. See
--   <a>lookupGRE_FieldLabel</a> and Note [Parents for record fields].
lookupGRE_Name_OccName :: GlobalRdrEnv -> Name -> OccName -> Maybe GlobalRdrElt
getGRE_NameQualifier_maybes :: GlobalRdrEnv -> Name -> [Maybe [ModuleName]]

-- | Apply a transformation function to the GREs for these OccNames
transformGREs :: (GlobalRdrElt -> GlobalRdrElt) -> [OccName] -> GlobalRdrEnv -> GlobalRdrEnv

-- | Takes a list of GREs which have the right OccName <tt>x</tt> Pick
--   those GREs that are in scope * Qualified, as <a>x</a> if want_qual is
--   Qual M _ * Unqualified, as <tt>x</tt> if want_unqual is Unqual _
--   
--   Return each such GRE, with its ImportSpecs filtered, to reflect how it
--   is in scope qualified or unqualified respectively. See Note [GRE
--   filtering]
pickGREs :: RdrName -> [GlobalRdrElt] -> [GlobalRdrElt]

-- | Pick GREs that are in scope *both* qualified *and* unqualified Return
--   each GRE that is, as a pair (qual_gre, unqual_gre) These two GREs are
--   the original GRE with imports filtered to express how it is in scope
--   qualified an unqualified respectively
--   
--   Used only for the 'module M' item in export list; see
--   RnNames.exports_from_avail
pickGREsModExp :: ModuleName -> [GlobalRdrElt] -> [(GlobalRdrElt, GlobalRdrElt)]

-- | make a <a>GlobalRdrEnv</a> where all the elements point to the same
--   Provenance (useful for "hiding" imports, or imports with no details).
gresFromAvails :: Maybe ImportSpec -> [AvailInfo] -> [GlobalRdrElt]
gresFromAvail :: (Name -> Maybe ImportSpec) -> AvailInfo -> [GlobalRdrElt]
localGREsFromAvail :: AvailInfo -> [GlobalRdrElt]
availFromGRE :: GlobalRdrElt -> AvailInfo
greRdrNames :: GlobalRdrElt -> [RdrName]
greSrcSpan :: GlobalRdrElt -> SrcSpan
greQualModName :: GlobalRdrElt -> ModuleName

-- | Takes a list of distinct GREs and folds them into AvailInfos. This is
--   more efficient than mapping each individual GRE to an AvailInfo and
--   the folding using <a>plusAvail</a> but needs the uniqueness
--   assumption.
gresToAvailInfo :: [GlobalRdrElt] -> [AvailInfo]

-- | Global Reader Element
--   
--   An element of the <a>GlobalRdrEnv</a>
data GlobalRdrElt
GRE :: Name -> Parent -> Bool -> [ImportSpec] -> GlobalRdrElt
[gre_name] :: GlobalRdrElt -> Name
[gre_par] :: GlobalRdrElt -> Parent

-- | True <a>=</a> the thing was defined locally
[gre_lcl] :: GlobalRdrElt -> Bool

-- | In scope through these imports
[gre_imp] :: GlobalRdrElt -> [ImportSpec]
isLocalGRE :: GlobalRdrElt -> Bool
isRecFldGRE :: GlobalRdrElt -> Bool
greLabel :: GlobalRdrElt -> Maybe FieldLabelString

-- | Test if an unqualified version of this thing would be in scope
unQualOK :: GlobalRdrElt -> Bool

-- | Is in scope qualified with the given module?
qualSpecOK :: ModuleName -> ImportSpec -> Bool

-- | Is in scope unqualified?
unQualSpecOK :: ImportSpec -> Bool

-- | Print out one place where the name was define/imported (With
--   -dppr-debug, print them all)
pprNameProvenance :: GlobalRdrElt -> SDoc

-- | The children of a Name are the things that are abbreviated by the ".."
--   notation in export lists. See Note [Parents]
data Parent
NoParent :: Parent
ParentIs :: Name -> Parent
[par_is] :: Parent -> Name

-- | See Note [Parents for record fields]
FldParent :: Name -> Maybe FieldLabelString -> Parent
[par_is] :: Parent -> Name
[par_lbl] :: Parent -> Maybe FieldLabelString
greParent_maybe :: GlobalRdrElt -> Maybe Name

-- | Import Specification
--   
--   The <a>ImportSpec</a> of something says how it came to be imported
--   It's quite elaborate so that we can give accurate unused-name
--   warnings.
data ImportSpec
ImpSpec :: ImpDeclSpec -> ImpItemSpec -> ImportSpec
[is_decl] :: ImportSpec -> ImpDeclSpec
[is_item] :: ImportSpec -> ImpItemSpec

-- | Import Declaration Specification
--   
--   Describes a particular import declaration and is shared among all the
--   <tt>Provenance</tt>s for that decl
data ImpDeclSpec
ImpDeclSpec :: ModuleName -> ModuleName -> Bool -> SrcSpan -> ImpDeclSpec

-- | Module imported, e.g. <tt>import Muggle</tt> Note the <tt>Muggle</tt>
--   may well not be the defining module for this thing!
[is_mod] :: ImpDeclSpec -> ModuleName

-- | Import alias, e.g. from <tt>as M</tt> (or <tt>Muggle</tt> if there is
--   no <tt>as</tt> clause)
[is_as] :: ImpDeclSpec -> ModuleName

-- | Was this import qualified?
[is_qual] :: ImpDeclSpec -> Bool

-- | The location of the entire import declaration
[is_dloc] :: ImpDeclSpec -> SrcSpan

-- | Import Item Specification
--   
--   Describes import info a particular Name
data ImpItemSpec

-- | The import had no import list, or had a hiding list
ImpAll :: ImpItemSpec

-- | The import had an import list. The <a>is_explicit</a> field is
--   <tt>True</tt> iff the thing was named <i>explicitly</i> in the import
--   specs rather than being imported as part of a "..." group. Consider:
--   
--   <pre>
--   import C( T(..) )
--   </pre>
--   
--   Here the constructors of <tt>T</tt> are not named explicitly; only
--   <tt>T</tt> is named explicitly.
ImpSome :: Bool -> SrcSpan -> ImpItemSpec
[is_explicit] :: ImpItemSpec -> Bool
[is_iloc] :: ImpItemSpec -> SrcSpan
importSpecLoc :: ImportSpec -> SrcSpan
importSpecModule :: ImportSpec -> ModuleName
isExplicitItem :: ImpItemSpec -> Bool
bestImport :: [ImportSpec] -> ImportSpec

-- | Display info about the treatment of <a>*</a> under NoStarIsType.
--   
--   With StarIsType, three properties of <a>*</a> hold:
--   
--   (a) it is not an infix operator (b) it is always in scope (c) it is a
--   synonym for Data.Kind.Type
--   
--   However, the user might not know that he's working on a module with
--   NoStarIsType and write code that still assumes (a), (b), and (c),
--   which actually do not hold in that module.
--   
--   Violation of (a) shows up in the parser. For instance, in the
--   following examples, we have <a>*</a> not applied to enough arguments:
--   
--   data A :: * data F :: * -&gt; *
--   
--   Violation of (b) or (c) show up in the renamer and the typechecker
--   respectively. For instance:
--   
--   type K = Either * Bool
--   
--   This will parse differently depending on whether StarIsType is
--   enabled, but it will parse nonetheless. With NoStarIsType it is parsed
--   as a type operator, thus we have ((*) Either Bool). Now there are two
--   cases to consider:
--   
--   <ol>
--   <li>There is no definition of (*) in scope. In this case the renamer
--   will fail to look it up. This is a violation of assumption (b).</li>
--   <li>There is a definition of the (*) type operator in scope (for
--   example coming from GHC.TypeNats). In this case the user will get a
--   kind mismatch error. This is a violation of assumption (c).</li>
--   </ol>
--   
--   The user might unknowingly be working on a module with NoStarIsType or
--   use <a>*</a> as <a>Type</a> out of habit. So it is important to give a
--   hint whenever an assumption about <a>*</a> is violated. Unfortunately,
--   it is somewhat difficult to deal with (c), so we limit ourselves to
--   (a) and (b).
--   
--   <a>starInfo</a> generates an appropriate hint to the user depending on
--   the extensions enabled in the module and the name that triggered the
--   error. That is, if we have NoStarIsType and the error is related to
--   <a>*</a> or its Unicode variant, the resulting SDoc will contain a
--   helpful suggestion. Otherwise it is empty.
starInfo :: Bool -> RdrName -> SDoc
instance GHC.Classes.Eq RdrName.GlobalRdrElt
instance Data.Data.Data RdrName.GlobalRdrElt
instance Data.Data.Data RdrName.ImportSpec
instance GHC.Classes.Ord RdrName.ImportSpec
instance GHC.Classes.Eq RdrName.ImportSpec
instance Data.Data.Data RdrName.ImpItemSpec
instance Data.Data.Data RdrName.ImpDeclSpec
instance Data.Data.Data RdrName.Parent
instance GHC.Classes.Eq RdrName.Parent
instance Data.Data.Data RdrName.RdrName
instance Outputable.Outputable RdrName.GlobalRdrElt
instance Outputable.Outputable RdrName.ImportSpec
instance GHC.Classes.Eq RdrName.ImpItemSpec
instance GHC.Classes.Ord RdrName.ImpItemSpec
instance GHC.Classes.Eq RdrName.ImpDeclSpec
instance GHC.Classes.Ord RdrName.ImpDeclSpec
instance Outputable.Outputable RdrName.Parent
instance Outputable.Outputable RdrName.LocalRdrEnv
instance OccName.HasOccName RdrName.RdrName
instance Outputable.Outputable RdrName.RdrName
instance Outputable.OutputableBndr RdrName.RdrName
instance GHC.Classes.Eq RdrName.RdrName
instance GHC.Classes.Ord RdrName.RdrName

module PrelNames

-- | Unique identifier.
--   
--   The type of unique identifiers that are used in many places in GHC for
--   fast ordering and equality tests. You should generate these with the
--   functions from the <tt>UniqSupply</tt> module
--   
--   These are sometimes also referred to as "keys" in comments in GHC.
data Unique

-- | Class of things that we can obtain a <a>Unique</a> from
class Uniquable a
getUnique :: Uniquable a => a -> Unique
hasKey :: Uniquable a => a -> Unique -> Bool
liftedTypeKindTyConKey :: Unique
mAIN :: Module
allNameStrings :: [String]
itName :: Unique -> SrcSpan -> Name
mkUnboundName :: OccName -> Name
isUnboundName :: Name -> Bool
basicKnownKeyNames :: [Name]
genericTyConNames :: [Name]
pRELUDE :: Module
gHC_PRIM :: Module
gHC_TYPES :: Module
gHC_MAGIC :: Module
gHC_CSTRING :: Module
gHC_CLASSES :: Module
gHC_BASE :: Module
gHC_ENUM :: Module
gHC_GHCI :: Module
gHC_SHOW :: Module
gHC_READ :: Module
gHC_NUM :: Module
gHC_MAYBE :: Module
gHC_INTEGER_TYPE :: Module
gHC_NATURAL :: Module
gHC_LIST :: Module
gHC_TUPLE :: Module
dATA_TUPLE :: Module
dATA_EITHER :: Module
dATA_STRING :: Module
dATA_FOLDABLE :: Module
dATA_TRAVERSABLE :: Module
gHC_CONC :: Module
gHC_IO :: Module
gHC_IO_Exception :: Module
gHC_ST :: Module
gHC_ARR :: Module
gHC_STABLE :: Module
gHC_PTR :: Module
gHC_ERR :: Module
gHC_REAL :: Module
gHC_FLOAT :: Module
gHC_TOP_HANDLER :: Module
sYSTEM_IO :: Module
dYNAMIC :: Module
tYPEABLE :: Module
tYPEABLE_INTERNAL :: Module
gENERICS :: Module
rEAD_PREC :: Module
lEX :: Module
gHC_INT :: Module
gHC_WORD :: Module
mONAD :: Module
mONAD_FIX :: Module
mONAD_ZIP :: Module
mONAD_FAIL :: Module
aRROW :: Module
cONTROL_APPLICATIVE :: Module
gHC_DESUGAR :: Module
rANDOM :: Module
gHC_EXTS :: Module
cONTROL_EXCEPTION_BASE :: Module
gHC_GENERICS :: Module
gHC_TYPELITS :: Module
gHC_TYPENATS :: Module
dATA_TYPE_EQUALITY :: Module
dATA_COERCE :: Module
dEBUG_TRACE :: Module
gHC_SRCLOC :: Module
gHC_STACK :: Module
gHC_STACK_TYPES :: Module
gHC_STATICPTR :: Module
gHC_STATICPTR_INTERNAL :: Module
gHC_FINGERPRINT_TYPE :: Module
gHC_OVER_LABELS :: Module
gHC_RECORDS :: Module
rOOT_MAIN :: Module
mkInteractiveModule :: Int -> Module
pRELUDE_NAME :: ModuleName
mAIN_NAME :: ModuleName
dATA_ARRAY_PARALLEL_NAME :: ModuleName
dATA_ARRAY_PARALLEL_PRIM_NAME :: ModuleName
mkPrimModule :: FastString -> Module
mkIntegerModule :: FastString -> Module
mkBaseModule :: FastString -> Module
mkBaseModule_ :: ModuleName -> Module
mkThisGhcModule :: FastString -> Module
mkThisGhcModule_ :: ModuleName -> Module
mkMainModule :: FastString -> Module
mkMainModule_ :: ModuleName -> Module
main_RDR_Unqual :: RdrName
eq_RDR :: RdrName
ge_RDR :: RdrName
le_RDR :: RdrName
lt_RDR :: RdrName
gt_RDR :: RdrName
compare_RDR :: RdrName
ltTag_RDR :: RdrName
eqTag_RDR :: RdrName
gtTag_RDR :: RdrName
eqClass_RDR :: RdrName
numClass_RDR :: RdrName
ordClass_RDR :: RdrName
enumClass_RDR :: RdrName
monadClass_RDR :: RdrName
map_RDR :: RdrName
append_RDR :: RdrName
foldr_RDR :: RdrName
build_RDR :: RdrName
returnM_RDR :: RdrName
bindM_RDR :: RdrName
failM_RDR :: RdrName
left_RDR :: RdrName
right_RDR :: RdrName
fromEnum_RDR :: RdrName
toEnum_RDR :: RdrName
enumFrom_RDR :: RdrName
enumFromTo_RDR :: RdrName
enumFromThen_RDR :: RdrName
enumFromThenTo_RDR :: RdrName
ratioDataCon_RDR :: RdrName
plusInteger_RDR :: RdrName
timesInteger_RDR :: RdrName
ioDataCon_RDR :: RdrName
eqString_RDR :: RdrName
unpackCString_RDR :: RdrName
unpackCStringFoldr_RDR :: RdrName
unpackCStringUtf8_RDR :: RdrName
newStablePtr_RDR :: RdrName
bindIO_RDR :: RdrName
returnIO_RDR :: RdrName
fromInteger_RDR :: RdrName
fromRational_RDR :: RdrName
minus_RDR :: RdrName
times_RDR :: RdrName
plus_RDR :: RdrName
toInteger_RDR :: RdrName
toRational_RDR :: RdrName
fromIntegral_RDR :: RdrName
stringTy_RDR :: RdrName
fromString_RDR :: RdrName
fromList_RDR :: RdrName
fromListN_RDR :: RdrName
toList_RDR :: RdrName
compose_RDR :: RdrName
and_RDR :: RdrName
not_RDR :: RdrName
getTag_RDR :: RdrName
succ_RDR :: RdrName
pred_RDR :: RdrName
minBound_RDR :: RdrName
maxBound_RDR :: RdrName
range_RDR :: RdrName
inRange_RDR :: RdrName
index_RDR :: RdrName
unsafeIndex_RDR :: RdrName
unsafeRangeSize_RDR :: RdrName
readList_RDR :: RdrName
readListDefault_RDR :: RdrName
readListPrec_RDR :: RdrName
readListPrecDefault_RDR :: RdrName
readPrec_RDR :: RdrName
parens_RDR :: RdrName
choose_RDR :: RdrName
lexP_RDR :: RdrName
expectP_RDR :: RdrName
readField_RDR :: RdrName
readFieldHash_RDR :: RdrName
readSymField_RDR :: RdrName
punc_RDR :: RdrName
ident_RDR :: RdrName
symbol_RDR :: RdrName
step_RDR :: RdrName
alt_RDR :: RdrName
reset_RDR :: RdrName
prec_RDR :: RdrName
pfail_RDR :: RdrName
showsPrec_RDR :: RdrName
shows_RDR :: RdrName
showString_RDR :: RdrName
showSpace_RDR :: RdrName
showCommaSpace_RDR :: RdrName
showParen_RDR :: RdrName
undefined_RDR :: RdrName
error_RDR :: RdrName
u1DataCon_RDR :: RdrName
par1DataCon_RDR :: RdrName
rec1DataCon_RDR :: RdrName
k1DataCon_RDR :: RdrName
m1DataCon_RDR :: RdrName
l1DataCon_RDR :: RdrName
r1DataCon_RDR :: RdrName
prodDataCon_RDR :: RdrName
comp1DataCon_RDR :: RdrName
unPar1_RDR :: RdrName
unRec1_RDR :: RdrName
unK1_RDR :: RdrName
unComp1_RDR :: RdrName
from_RDR :: RdrName
from1_RDR :: RdrName
to_RDR :: RdrName
to1_RDR :: RdrName
datatypeName_RDR :: RdrName
moduleName_RDR :: RdrName
packageName_RDR :: RdrName
isNewtypeName_RDR :: RdrName
selName_RDR :: RdrName
conName_RDR :: RdrName
conFixity_RDR :: RdrName
conIsRecord_RDR :: RdrName
prefixDataCon_RDR :: RdrName
infixDataCon_RDR :: RdrName
leftAssocDataCon_RDR :: RdrName
rightAssocDataCon_RDR :: RdrName
notAssocDataCon_RDR :: RdrName
uAddrDataCon_RDR :: RdrName
uCharDataCon_RDR :: RdrName
uDoubleDataCon_RDR :: RdrName
uFloatDataCon_RDR :: RdrName
uIntDataCon_RDR :: RdrName
uWordDataCon_RDR :: RdrName
uAddrHash_RDR :: RdrName
uCharHash_RDR :: RdrName
uDoubleHash_RDR :: RdrName
uFloatHash_RDR :: RdrName
uIntHash_RDR :: RdrName
uWordHash_RDR :: RdrName
fmap_RDR :: RdrName
replace_RDR :: RdrName
pure_RDR :: RdrName
ap_RDR :: RdrName
liftA2_RDR :: RdrName
foldable_foldr_RDR :: RdrName
foldMap_RDR :: RdrName
null_RDR :: RdrName
all_RDR :: RdrName
traverse_RDR :: RdrName
mempty_RDR :: RdrName
mappend_RDR :: RdrName
varQual_RDR :: Module -> FastString -> RdrName
tcQual_RDR :: Module -> FastString -> RdrName
clsQual_RDR :: Module -> FastString -> RdrName
dataQual_RDR :: Module -> FastString -> RdrName
wildCardName :: Name
runMainIOName :: Name
runRWName :: Name
orderingTyConName :: Name
ordLTDataConName :: Name
ordEQDataConName :: Name
ordGTDataConName :: Name
specTyConName :: Name
eitherTyConName :: Name
leftDataConName :: Name
rightDataConName :: Name
v1TyConName :: Name
u1TyConName :: Name
par1TyConName :: Name
rec1TyConName :: Name
k1TyConName :: Name
m1TyConName :: Name
sumTyConName :: Name
prodTyConName :: Name
compTyConName :: Name
rTyConName :: Name
dTyConName :: Name
cTyConName :: Name
sTyConName :: Name
rec0TyConName :: Name
d1TyConName :: Name
c1TyConName :: Name
s1TyConName :: Name
noSelTyConName :: Name
repTyConName :: Name
rep1TyConName :: Name
uRecTyConName :: Name
uAddrTyConName :: Name
uCharTyConName :: Name
uDoubleTyConName :: Name
uFloatTyConName :: Name
uIntTyConName :: Name
uWordTyConName :: Name
prefixIDataConName :: Name
infixIDataConName :: Name
leftAssociativeDataConName :: Name
rightAssociativeDataConName :: Name
notAssociativeDataConName :: Name
sourceUnpackDataConName :: Name
sourceNoUnpackDataConName :: Name
noSourceUnpackednessDataConName :: Name
sourceLazyDataConName :: Name
sourceStrictDataConName :: Name
noSourceStrictnessDataConName :: Name
decidedLazyDataConName :: Name
decidedStrictDataConName :: Name
decidedUnpackDataConName :: Name
metaDataDataConName :: Name
metaConsDataConName :: Name
metaSelDataConName :: Name
divIntName :: Name
modIntName :: Name
unpackCStringName :: Name
unpackCStringFoldrName :: Name
unpackCStringUtf8Name :: Name
eqStringName :: Name
inlineIdName :: Name
eqClassName :: Name
eqName :: Name
ordClassName :: Name
geName :: Name
functorClassName :: Name
fmapName :: Name
monadClassName :: Name
thenMName :: Name
bindMName :: Name
returnMName :: Name
monadFailClassName :: Name
failMName :: Name
applicativeClassName :: Name
apAName :: Name
pureAName :: Name
thenAName :: Name
foldableClassName :: Name
traversableClassName :: Name
semigroupClassName :: Name
sappendName :: Name
monoidClassName :: Name
memptyName :: Name
mappendName :: Name
mconcatName :: Name
joinMName :: Name
alternativeClassName :: Name
joinMIdKey :: Unique
apAClassOpKey :: Unique
pureAClassOpKey :: Unique
thenAClassOpKey :: Unique
alternativeClassKey :: Unique
groupWithName :: Name
dollarName :: Name
otherwiseIdName :: Name
foldrName :: Name
buildName :: Name
augmentName :: Name
mapName :: Name
appendName :: Name
assertName :: Name
breakpointName :: Name
breakpointCondName :: Name
breakpointAutoName :: Name
opaqueTyConName :: Name
fromStringName :: Name
breakpointJumpName :: Name
breakpointCondJumpName :: Name
breakpointAutoJumpName :: Name
fstName :: Name
sndName :: Name
numClassName :: Name
fromIntegerName :: Name
minusName :: Name
negateName :: Name
integerTyConName :: Name
integerSDataConName :: Name
mkIntegerName :: Name
integerToWord64Name :: Name
integerToInt64Name :: Name
word64ToIntegerName :: Name
int64ToIntegerName :: Name
plusIntegerName :: Name
timesIntegerName :: Name
smallIntegerName :: Name
wordToIntegerName :: Name
integerToWordName :: Name
integerToIntName :: Name
minusIntegerName :: Name
negateIntegerName :: Name
eqIntegerPrimName :: Name
neqIntegerPrimName :: Name
absIntegerName :: Name
signumIntegerName :: Name
leIntegerPrimName :: Name
gtIntegerPrimName :: Name
ltIntegerPrimName :: Name
geIntegerPrimName :: Name
compareIntegerName :: Name
quotRemIntegerName :: Name
divModIntegerName :: Name
quotIntegerName :: Name
remIntegerName :: Name
divIntegerName :: Name
modIntegerName :: Name
floatFromIntegerName :: Name
doubleFromIntegerName :: Name
encodeFloatIntegerName :: Name
encodeDoubleIntegerName :: Name
decodeDoubleIntegerName :: Name
gcdIntegerName :: Name
lcmIntegerName :: Name
andIntegerName :: Name
orIntegerName :: Name
xorIntegerName :: Name
complementIntegerName :: Name
shiftLIntegerName :: Name
shiftRIntegerName :: Name
bitIntegerName :: Name
naturalTyConName :: Name
naturalSDataConName :: Name
naturalFromIntegerName :: Name
naturalToIntegerName :: Name
plusNaturalName :: Name
minusNaturalName :: Name
timesNaturalName :: Name
mkNaturalName :: Name
wordToNaturalName :: Name
rationalTyConName :: Name
ratioTyConName :: Name
ratioDataConName :: Name
realClassName :: Name
integralClassName :: Name
realFracClassName :: Name
fractionalClassName :: Name
fromRationalName :: Name
toIntegerName :: Name
toRationalName :: Name
fromIntegralName :: Name
realToFracName :: Name
floatingClassName :: Name
realFloatClassName :: Name
rationalToFloatName :: Name
rationalToDoubleName :: Name
ixClassName :: Name
trModuleTyConName :: Name
trModuleDataConName :: Name
trNameTyConName :: Name
trNameSDataConName :: Name
trNameDDataConName :: Name
trTyConTyConName :: Name
trTyConDataConName :: Name
kindRepTyConName :: Name
kindRepTyConAppDataConName :: Name
kindRepVarDataConName :: Name
kindRepAppDataConName :: Name
kindRepFunDataConName :: Name
kindRepTYPEDataConName :: Name
kindRepTypeLitSDataConName :: Name
kindRepTypeLitDDataConName :: Name
typeLitSortTyConName :: Name
typeLitSymbolDataConName :: Name
typeLitNatDataConName :: Name
typeableClassName :: Name
typeRepTyConName :: Name
someTypeRepTyConName :: Name
someTypeRepDataConName :: Name
typeRepIdName :: Name
mkTrTypeName :: Name
mkTrConName :: Name
mkTrAppName :: Name
mkTrFunName :: Name
typeNatTypeRepName :: Name
typeSymbolTypeRepName :: Name
trGhcPrimModuleName :: Name
starKindRepName :: Name
starArrStarKindRepName :: Name
starArrStarArrStarKindRepName :: Name
errorMessageTypeErrorFamName :: Name
typeErrorTextDataConName :: Name
typeErrorAppendDataConName :: Name
typeErrorVAppendDataConName :: Name
typeErrorShowTypeDataConName :: Name
toDynName :: Name
dataClassName :: Name
assertErrorName :: Name
traceName :: Name
enumClassName :: Name
enumFromName :: Name
enumFromToName :: Name
enumFromThenName :: Name
enumFromThenToName :: Name
boundedClassName :: Name
concatName :: Name
filterName :: Name
zipName :: Name
isListClassName :: Name
fromListName :: Name
fromListNName :: Name
toListName :: Name
showClassName :: Name
readClassName :: Name
genClassName :: Name
gen1ClassName :: Name
datatypeClassName :: Name
constructorClassName :: Name
selectorClassName :: Name
genericClassNames :: [Name]
ghciIoClassName :: Name
ghciStepIoMName :: Name
ioTyConName :: Name
ioDataConName :: Name
thenIOName :: Name
bindIOName :: Name
returnIOName :: Name
failIOName :: Name
printName :: Name
int8TyConName :: Name
int16TyConName :: Name
int32TyConName :: Name
int64TyConName :: Name
word16TyConName :: Name
word32TyConName :: Name
word64TyConName :: Name
ptrTyConName :: Name
funPtrTyConName :: Name
stablePtrTyConName :: Name
newStablePtrName :: Name
monadFixClassName :: Name
mfixName :: Name
arrAName :: Name
composeAName :: Name
firstAName :: Name
appAName :: Name
choiceAName :: Name
loopAName :: Name
guardMName :: Name
liftMName :: Name
mzipName :: Name
toAnnotationWrapperName :: Name
monadPlusClassName :: Name
randomClassName :: Name
randomGenClassName :: Name
isStringClassName :: Name
knownNatClassName :: Name
knownSymbolClassName :: Name
isLabelClassName :: Name
ipClassName :: Name
hasFieldClassName :: Name
callStackTyConName :: Name
emptyCallStackName :: Name
pushCallStackName :: Name
srcLocDataConName :: Name
pLUGINS :: Module
pluginTyConName :: Name
frontendPluginTyConName :: Name
makeStaticName :: Name
staticPtrInfoTyConName :: Name
staticPtrInfoDataConName :: Name
staticPtrTyConName :: Name
staticPtrDataConName :: Name
fromStaticPtrName :: Name
fingerprintDataConName :: Name
varQual :: Module -> FastString -> Unique -> Name
tcQual :: Module -> FastString -> Unique -> Name
clsQual :: Module -> FastString -> Unique -> Name
dcQual :: Module -> FastString -> Unique -> Name
mk_known_key_name :: NameSpace -> Module -> FastString -> Unique -> Name
boundedClassKey :: Unique
enumClassKey :: Unique
eqClassKey :: Unique
floatingClassKey :: Unique
fractionalClassKey :: Unique
integralClassKey :: Unique
monadClassKey :: Unique
dataClassKey :: Unique
functorClassKey :: Unique
numClassKey :: Unique
ordClassKey :: Unique
readClassKey :: Unique
realClassKey :: Unique
realFloatClassKey :: Unique
realFracClassKey :: Unique
showClassKey :: Unique
ixClassKey :: Unique
typeableClassKey :: Unique
typeable1ClassKey :: Unique
typeable2ClassKey :: Unique
typeable3ClassKey :: Unique
typeable4ClassKey :: Unique
typeable5ClassKey :: Unique
typeable6ClassKey :: Unique
typeable7ClassKey :: Unique
monadFixClassKey :: Unique
monadFailClassKey :: Unique
monadPlusClassKey :: Unique
randomClassKey :: Unique
randomGenClassKey :: Unique
isStringClassKey :: Unique
applicativeClassKey :: Unique
foldableClassKey :: Unique
traversableClassKey :: Unique
genClassKey :: Unique
gen1ClassKey :: Unique
datatypeClassKey :: Unique
constructorClassKey :: Unique
selectorClassKey :: Unique
knownNatClassNameKey :: Unique
knownSymbolClassNameKey :: Unique
ghciIoClassKey :: Unique
isLabelClassNameKey :: Unique
semigroupClassKey :: Unique
monoidClassKey :: Unique
ipClassKey :: Unique
hasFieldClassNameKey :: Unique
addrPrimTyConKey :: Unique
arrayPrimTyConKey :: Unique
boolTyConKey :: Unique
byteArrayPrimTyConKey :: Unique
charPrimTyConKey :: Unique
charTyConKey :: Unique
doublePrimTyConKey :: Unique
doubleTyConKey :: Unique
floatPrimTyConKey :: Unique
floatTyConKey :: Unique
funTyConKey :: Unique
intPrimTyConKey :: Unique
intTyConKey :: Unique
int8PrimTyConKey :: Unique
int8TyConKey :: Unique
int16PrimTyConKey :: Unique
int16TyConKey :: Unique
int32PrimTyConKey :: Unique
int32TyConKey :: Unique
int64PrimTyConKey :: Unique
int64TyConKey :: Unique
integerTyConKey :: Unique
naturalTyConKey :: Unique
listTyConKey :: Unique
foreignObjPrimTyConKey :: Unique
maybeTyConKey :: Unique
weakPrimTyConKey :: Unique
mutableArrayPrimTyConKey :: Unique
mutableByteArrayPrimTyConKey :: Unique
orderingTyConKey :: Unique
mVarPrimTyConKey :: Unique
ratioTyConKey :: Unique
rationalTyConKey :: Unique
realWorldTyConKey :: Unique
stablePtrPrimTyConKey :: Unique
stablePtrTyConKey :: Unique
eqTyConKey :: Unique
heqTyConKey :: Unique
arrayArrayPrimTyConKey :: Unique
mutableArrayArrayPrimTyConKey :: Unique
statePrimTyConKey :: Unique
stableNamePrimTyConKey :: Unique
stableNameTyConKey :: Unique
eqPrimTyConKey :: Unique
eqReprPrimTyConKey :: Unique
eqPhantPrimTyConKey :: Unique
mutVarPrimTyConKey :: Unique
ioTyConKey :: Unique
voidPrimTyConKey :: Unique
wordPrimTyConKey :: Unique
wordTyConKey :: Unique
word8PrimTyConKey :: Unique
word8TyConKey :: Unique
word16PrimTyConKey :: Unique
word16TyConKey :: Unique
word32PrimTyConKey :: Unique
word32TyConKey :: Unique
word64PrimTyConKey :: Unique
word64TyConKey :: Unique
liftedConKey :: Unique
unliftedConKey :: Unique
anyBoxConKey :: Unique
kindConKey :: Unique
boxityConKey :: Unique
typeConKey :: Unique
threadIdPrimTyConKey :: Unique
bcoPrimTyConKey :: Unique
ptrTyConKey :: Unique
funPtrTyConKey :: Unique
tVarPrimTyConKey :: Unique
compactPrimTyConKey :: Unique
objectTyConKey :: Unique
eitherTyConKey :: Unique
tYPETyConKey :: Unique
constraintKindTyConKey :: Unique
runtimeRepTyConKey :: Unique
vecCountTyConKey :: Unique
vecElemTyConKey :: Unique
pluginTyConKey :: Unique
frontendPluginTyConKey :: Unique
unknownTyConKey :: Unique
unknown1TyConKey :: Unique
unknown2TyConKey :: Unique
unknown3TyConKey :: Unique
opaqueTyConKey :: Unique
v1TyConKey :: Unique
u1TyConKey :: Unique
par1TyConKey :: Unique
rec1TyConKey :: Unique
k1TyConKey :: Unique
m1TyConKey :: Unique
sumTyConKey :: Unique
prodTyConKey :: Unique
compTyConKey :: Unique
rTyConKey :: Unique
dTyConKey :: Unique
cTyConKey :: Unique
sTyConKey :: Unique
rec0TyConKey :: Unique
d1TyConKey :: Unique
c1TyConKey :: Unique
s1TyConKey :: Unique
noSelTyConKey :: Unique
repTyConKey :: Unique
rep1TyConKey :: Unique
uRecTyConKey :: Unique
uAddrTyConKey :: Unique
uCharTyConKey :: Unique
uDoubleTyConKey :: Unique
uFloatTyConKey :: Unique
uIntTyConKey :: Unique
uWordTyConKey :: Unique
typeNatKindConNameKey :: Unique
typeSymbolKindConNameKey :: Unique
typeNatAddTyFamNameKey :: Unique
typeNatMulTyFamNameKey :: Unique
typeNatExpTyFamNameKey :: Unique
typeNatLeqTyFamNameKey :: Unique
typeNatSubTyFamNameKey :: Unique
typeSymbolCmpTyFamNameKey :: Unique
typeNatCmpTyFamNameKey :: Unique
typeNatDivTyFamNameKey :: Unique
typeNatModTyFamNameKey :: Unique
typeNatLogTyFamNameKey :: Unique
errorMessageTypeErrorFamKey :: Unique
ntTyConKey :: Unique
coercibleTyConKey :: Unique
proxyPrimTyConKey :: Unique
specTyConKey :: Unique
anyTyConKey :: Unique
smallArrayPrimTyConKey :: Unique
smallMutableArrayPrimTyConKey :: Unique
staticPtrTyConKey :: Unique
staticPtrInfoTyConKey :: Unique
callStackTyConKey :: Unique
typeRepTyConKey :: Unique
someTypeRepTyConKey :: Unique
someTypeRepDataConKey :: Unique
typeSymbolAppendFamNameKey :: Unique
int8X16PrimTyConKey :: Unique
int16X8PrimTyConKey :: Unique
int32X4PrimTyConKey :: Unique
int64X2PrimTyConKey :: Unique
int8X32PrimTyConKey :: Unique
int16X16PrimTyConKey :: Unique
int32X8PrimTyConKey :: Unique
int64X4PrimTyConKey :: Unique
int8X64PrimTyConKey :: Unique
int16X32PrimTyConKey :: Unique
int32X16PrimTyConKey :: Unique
int64X8PrimTyConKey :: Unique
word8X16PrimTyConKey :: Unique
word16X8PrimTyConKey :: Unique
word32X4PrimTyConKey :: Unique
word64X2PrimTyConKey :: Unique
word8X32PrimTyConKey :: Unique
word16X16PrimTyConKey :: Unique
word32X8PrimTyConKey :: Unique
word64X4PrimTyConKey :: Unique
word8X64PrimTyConKey :: Unique
word16X32PrimTyConKey :: Unique
word32X16PrimTyConKey :: Unique
word64X8PrimTyConKey :: Unique
floatX4PrimTyConKey :: Unique
doubleX2PrimTyConKey :: Unique
floatX8PrimTyConKey :: Unique
doubleX4PrimTyConKey :: Unique
floatX16PrimTyConKey :: Unique
doubleX8PrimTyConKey :: Unique
charDataConKey :: Unique
consDataConKey :: Unique
doubleDataConKey :: Unique
falseDataConKey :: Unique
floatDataConKey :: Unique
intDataConKey :: Unique
integerSDataConKey :: Unique
nothingDataConKey :: Unique
justDataConKey :: Unique
eqDataConKey :: Unique
nilDataConKey :: Unique
ratioDataConKey :: Unique
word8DataConKey :: Unique
stableNameDataConKey :: Unique
trueDataConKey :: Unique
wordDataConKey :: Unique
ioDataConKey :: Unique
integerDataConKey :: Unique
heqDataConKey :: Unique
crossDataConKey :: Unique
inlDataConKey :: Unique
inrDataConKey :: Unique
genUnitDataConKey :: Unique
leftDataConKey :: Unique
rightDataConKey :: Unique
ordLTDataConKey :: Unique
ordEQDataConKey :: Unique
ordGTDataConKey :: Unique
coercibleDataConKey :: Unique
staticPtrDataConKey :: Unique
staticPtrInfoDataConKey :: Unique
fingerprintDataConKey :: Unique
srcLocDataConKey :: Unique
trTyConTyConKey :: Unique
trTyConDataConKey :: Unique
trModuleTyConKey :: Unique
trModuleDataConKey :: Unique
trNameTyConKey :: Unique
trNameSDataConKey :: Unique
trNameDDataConKey :: Unique
trGhcPrimModuleKey :: Unique
kindRepTyConKey :: Unique
typeLitSortTyConKey :: Unique
typeErrorTextDataConKey :: Unique
typeErrorAppendDataConKey :: Unique
typeErrorVAppendDataConKey :: Unique
typeErrorShowTypeDataConKey :: Unique
prefixIDataConKey :: Unique
infixIDataConKey :: Unique
leftAssociativeDataConKey :: Unique
rightAssociativeDataConKey :: Unique
notAssociativeDataConKey :: Unique
sourceUnpackDataConKey :: Unique
sourceNoUnpackDataConKey :: Unique
noSourceUnpackednessDataConKey :: Unique
sourceLazyDataConKey :: Unique
sourceStrictDataConKey :: Unique
noSourceStrictnessDataConKey :: Unique
decidedLazyDataConKey :: Unique
decidedStrictDataConKey :: Unique
decidedUnpackDataConKey :: Unique
metaDataDataConKey :: Unique
metaConsDataConKey :: Unique
metaSelDataConKey :: Unique
vecRepDataConKey :: Unique
tupleRepDataConKey :: Unique
sumRepDataConKey :: Unique
runtimeRepSimpleDataConKeys :: [Unique]
liftedRepDataConKey :: Unique
unliftedSimpleRepDataConKeys :: [Unique]
unliftedRepDataConKeys :: [Unique]
vecCountDataConKeys :: [Unique]
vecElemDataConKeys :: [Unique]
kindRepTyConAppDataConKey :: Unique
kindRepVarDataConKey :: Unique
kindRepAppDataConKey :: Unique
kindRepFunDataConKey :: Unique
kindRepTYPEDataConKey :: Unique
kindRepTypeLitSDataConKey :: Unique
kindRepTypeLitDDataConKey :: Unique
typeLitSymbolDataConKey :: Unique
typeLitNatDataConKey :: Unique
wildCardKey :: Unique
absentErrorIdKey :: Unique
augmentIdKey :: Unique
appendIdKey :: Unique
buildIdKey :: Unique
errorIdKey :: Unique
foldrIdKey :: Unique
recSelErrorIdKey :: Unique
seqIdKey :: Unique
eqStringIdKey :: Unique
noMethodBindingErrorIdKey :: Unique
nonExhaustiveGuardsErrorIdKey :: Unique
runtimeErrorIdKey :: Unique
patErrorIdKey :: Unique
realWorldPrimIdKey :: Unique
recConErrorIdKey :: Unique
unpackCStringUtf8IdKey :: Unique
unpackCStringAppendIdKey :: Unique
unpackCStringFoldrIdKey :: Unique
unpackCStringIdKey :: Unique
voidPrimIdKey :: Unique
typeErrorIdKey :: Unique
divIntIdKey :: Unique
modIntIdKey :: Unique
absentSumFieldErrorIdKey :: Unique
unsafeCoerceIdKey :: Unique
concatIdKey :: Unique
filterIdKey :: Unique
zipIdKey :: Unique
bindIOIdKey :: Unique
returnIOIdKey :: Unique
newStablePtrIdKey :: Unique
printIdKey :: Unique
failIOIdKey :: Unique
nullAddrIdKey :: Unique
voidArgIdKey :: Unique
fstIdKey :: Unique
sndIdKey :: Unique
otherwiseIdKey :: Unique
assertIdKey :: Unique
mkIntegerIdKey :: Unique
smallIntegerIdKey :: Unique
integerToWordIdKey :: Unique
integerToIntIdKey :: Unique
integerToWord64IdKey :: Unique
integerToInt64IdKey :: Unique
plusIntegerIdKey :: Unique
timesIntegerIdKey :: Unique
minusIntegerIdKey :: Unique
negateIntegerIdKey :: Unique
eqIntegerPrimIdKey :: Unique
neqIntegerPrimIdKey :: Unique
absIntegerIdKey :: Unique
signumIntegerIdKey :: Unique
leIntegerPrimIdKey :: Unique
gtIntegerPrimIdKey :: Unique
ltIntegerPrimIdKey :: Unique
geIntegerPrimIdKey :: Unique
compareIntegerIdKey :: Unique
quotIntegerIdKey :: Unique
remIntegerIdKey :: Unique
divIntegerIdKey :: Unique
modIntegerIdKey :: Unique
divModIntegerIdKey :: Unique
quotRemIntegerIdKey :: Unique
floatFromIntegerIdKey :: Unique
doubleFromIntegerIdKey :: Unique
encodeFloatIntegerIdKey :: Unique
encodeDoubleIntegerIdKey :: Unique
gcdIntegerIdKey :: Unique
lcmIntegerIdKey :: Unique
andIntegerIdKey :: Unique
orIntegerIdKey :: Unique
xorIntegerIdKey :: Unique
complementIntegerIdKey :: Unique
shiftLIntegerIdKey :: Unique
shiftRIntegerIdKey :: Unique
wordToIntegerIdKey :: Unique
word64ToIntegerIdKey :: Unique
int64ToIntegerIdKey :: Unique
decodeDoubleIntegerIdKey :: Unique
rootMainKey :: Unique
runMainKey :: Unique
thenIOIdKey :: Unique
lazyIdKey :: Unique
assertErrorIdKey :: Unique
oneShotKey :: Unique
runRWKey :: Unique
traceKey :: Unique
breakpointIdKey :: Unique
breakpointCondIdKey :: Unique
breakpointAutoIdKey :: Unique
breakpointJumpIdKey :: Unique
breakpointCondJumpIdKey :: Unique
breakpointAutoJumpIdKey :: Unique
inlineIdKey :: Unique
mapIdKey :: Unique
groupWithIdKey :: Unique
dollarIdKey :: Unique
coercionTokenIdKey :: Unique
noinlineIdKey :: Unique
rationalToFloatIdKey :: Unique
rationalToDoubleIdKey :: Unique
unmarshalObjectIdKey :: Unique
marshalObjectIdKey :: Unique
marshalStringIdKey :: Unique
unmarshalStringIdKey :: Unique
checkDotnetResNameIdKey :: Unique
undefinedKey :: Unique
magicDictKey :: Unique
coerceKey :: Unique
unboundKey :: Unique
fromIntegerClassOpKey :: Unique
minusClassOpKey :: Unique
fromRationalClassOpKey :: Unique
enumFromClassOpKey :: Unique
enumFromThenClassOpKey :: Unique
enumFromToClassOpKey :: Unique
enumFromThenToClassOpKey :: Unique
eqClassOpKey :: Unique
geClassOpKey :: Unique
negateClassOpKey :: Unique
bindMClassOpKey :: Unique
thenMClassOpKey :: Unique
fmapClassOpKey :: Unique
returnMClassOpKey :: Unique
mfixIdKey :: Unique
failMClassOpKey :: Unique
arrAIdKey :: Unique
composeAIdKey :: Unique
firstAIdKey :: Unique
appAIdKey :: Unique
choiceAIdKey :: Unique
loopAIdKey :: Unique
fromStringClassOpKey :: Unique
toAnnotationWrapperIdKey :: Unique
fromIntegralIdKey :: Unique
realToFracIdKey :: Unique
toIntegerClassOpKey :: Unique
toRationalClassOpKey :: Unique
guardMIdKey :: Unique
liftMIdKey :: Unique
mzipIdKey :: Unique
ghciStepIoMClassOpKey :: Unique
isListClassKey :: Unique
fromListClassOpKey :: Unique
fromListNClassOpKey :: Unique
toListClassOpKey :: Unique
proxyHashKey :: Unique
mkTyConKey :: Unique
mkTrTypeKey :: Unique
mkTrConKey :: Unique
mkTrAppKey :: Unique
typeNatTypeRepKey :: Unique
typeSymbolTypeRepKey :: Unique
typeRepIdKey :: Unique
mkTrFunKey :: Unique
trTYPEKey :: Unique
trTYPE'PtrRepLiftedKey :: Unique
trRuntimeRepKey :: Unique
tr'PtrRepLiftedKey :: Unique
starKindRepKey :: Unique
starArrStarKindRepKey :: Unique
starArrStarArrStarKindRepKey :: Unique
toDynIdKey :: Unique
bitIntegerIdKey :: Unique
eqSCSelIdKey :: Unique
heqSCSelIdKey :: Unique
coercibleSCSelIdKey :: Unique
sappendClassOpKey :: Unique
memptyClassOpKey :: Unique
mappendClassOpKey :: Unique
mconcatClassOpKey :: Unique
emptyCallStackKey :: Unique
pushCallStackKey :: Unique
fromStaticPtrClassOpKey :: Unique
makeStaticKey :: Unique
naturalFromIntegerIdKey :: Unique
naturalToIntegerIdKey :: Unique
plusNaturalIdKey :: Unique
minusNaturalIdKey :: Unique
timesNaturalIdKey :: Unique
mkNaturalIdKey :: Unique
naturalSDataConKey :: Unique
wordToNaturalIdKey :: Unique
numericClassKeys :: [Unique]
fractionalClassKeys :: [Unique]
standardClassKeys :: [Unique]
derivableClassKeys :: [Unique]
interactiveClassNames :: [Name]
interactiveClassKeys :: [Unique]
pretendNameIsInScope :: Name -> Bool

module ApiAnnotation

-- | Retrieve a list of annotation <a>SrcSpan</a>s based on the
--   <a>SrcSpan</a> of the annotated AST element, and the known type of the
--   annotation.
getAnnotation :: ApiAnns -> SrcSpan -> AnnKeywordId -> [SrcSpan]

-- | Retrieve a list of annotation <a>SrcSpan</a>s based on the
--   <a>SrcSpan</a> of the annotated AST element, and the known type of the
--   annotation. The list is removed from the annotations.
getAndRemoveAnnotation :: ApiAnns -> SrcSpan -> AnnKeywordId -> ([SrcSpan], ApiAnns)

-- | Retrieve the comments allocated to the current <a>SrcSpan</a>
--   
--   Note: A given <a>SrcSpan</a> may appear in multiple AST elements,
--   beware of duplicates
getAnnotationComments :: ApiAnns -> SrcSpan -> [Located AnnotationComment]

-- | Retrieve the comments allocated to the current <a>SrcSpan</a>, and
--   remove them from the annotations
getAndRemoveAnnotationComments :: ApiAnns -> SrcSpan -> ([Located AnnotationComment], ApiAnns)
type ApiAnns = (Map ApiAnnKey [SrcSpan], Map SrcSpan [Located AnnotationComment])
type ApiAnnKey = (SrcSpan, AnnKeywordId)

-- | API Annotations exist so that tools can perform source to source
--   conversions of Haskell code. They are used to keep track of the
--   various syntactic keywords that are not captured in the existing AST.
--   
--   The annotations, together with original source comments are made
--   available in the <tt><tt>pm_annotations</tt></tt> field of
--   <tt><a>ParsedModule</a></tt>. Comments are only retained if
--   <tt><tt>Opt_KeepRawTokenStream</tt></tt> is set in
--   <tt><a>DynFlags</a></tt> before parsing.
--   
--   The wiki page describing this feature is
--   <a>https://ghc.haskell.org/trac/ghc/wiki/ApiAnnotations</a>
--   
--   Note: in general the names of these are taken from the corresponding
--   token, unless otherwise noted See note [Api annotations] above for
--   details of the usage
data AnnKeywordId
AnnAnyclass :: AnnKeywordId
AnnAs :: AnnKeywordId
AnnAt :: AnnKeywordId

-- | <tt>!</tt>
AnnBang :: AnnKeywordId

-- | '`'
AnnBackquote :: AnnKeywordId
AnnBy :: AnnKeywordId

-- | case or lambda case
AnnCase :: AnnKeywordId
AnnClass :: AnnKeywordId

-- | '#)' or '#-}' etc
AnnClose :: AnnKeywordId

-- | '|)'
AnnCloseB :: AnnKeywordId

-- | '|)', unicode variant
AnnCloseBU :: AnnKeywordId

-- | '}'
AnnCloseC :: AnnKeywordId

-- | '|]'
AnnCloseQ :: AnnKeywordId

-- | '|]', unicode variant
AnnCloseQU :: AnnKeywordId

-- | ')'
AnnCloseP :: AnnKeywordId

-- | ']'
AnnCloseS :: AnnKeywordId
AnnColon :: AnnKeywordId

-- | as a list separator
AnnComma :: AnnKeywordId

-- | in a RdrName for a tuple
AnnCommaTuple :: AnnKeywordId

-- | '=&gt;'
AnnDarrow :: AnnKeywordId

-- | '=&gt;', unicode variant
AnnDarrowU :: AnnKeywordId
AnnData :: AnnKeywordId

-- | '::'
AnnDcolon :: AnnKeywordId

-- | '::', unicode variant
AnnDcolonU :: AnnKeywordId
AnnDefault :: AnnKeywordId
AnnDeriving :: AnnKeywordId
AnnDo :: AnnKeywordId

-- | <a>.</a>
AnnDot :: AnnKeywordId

-- | '..'
AnnDotdot :: AnnKeywordId
AnnElse :: AnnKeywordId
AnnEqual :: AnnKeywordId
AnnExport :: AnnKeywordId
AnnFamily :: AnnKeywordId
AnnForall :: AnnKeywordId

-- | Unicode variant
AnnForallU :: AnnKeywordId
AnnForeign :: AnnKeywordId

-- | for function name in matches where there are multiple equations for
--   the function.
AnnFunId :: AnnKeywordId
AnnGroup :: AnnKeywordId

-- | for CType
AnnHeader :: AnnKeywordId
AnnHiding :: AnnKeywordId
AnnIf :: AnnKeywordId
AnnImport :: AnnKeywordId
AnnIn :: AnnKeywordId

-- | 'infix' or 'infixl' or 'infixr'
AnnInfix :: AnnKeywordId
AnnInstance :: AnnKeywordId
AnnLam :: AnnKeywordId

-- | '&lt;-'
AnnLarrow :: AnnKeywordId

-- | '&lt;-', unicode variant
AnnLarrowU :: AnnKeywordId
AnnLet :: AnnKeywordId
AnnMdo :: AnnKeywordId

-- | <a>-</a>
AnnMinus :: AnnKeywordId
AnnModule :: AnnKeywordId
AnnNewtype :: AnnKeywordId

-- | where a name loses its location in the AST, this carries it
AnnName :: AnnKeywordId
AnnOf :: AnnKeywordId

-- | '(#' or '{-# LANGUAGE' etc
AnnOpen :: AnnKeywordId

-- | '(|'
AnnOpenB :: AnnKeywordId

-- | '(|', unicode variant
AnnOpenBU :: AnnKeywordId

-- | '{'
AnnOpenC :: AnnKeywordId

-- | '[e|' or '[e||'
AnnOpenE :: AnnKeywordId

-- | '[|'
AnnOpenEQ :: AnnKeywordId

-- | '[|', unicode variant
AnnOpenEQU :: AnnKeywordId

-- | '('
AnnOpenP :: AnnKeywordId

-- | '$('
AnnOpenPE :: AnnKeywordId

-- | '$$('
AnnOpenPTE :: AnnKeywordId

-- | '['
AnnOpenS :: AnnKeywordId
AnnPackageName :: AnnKeywordId
AnnPattern :: AnnKeywordId
AnnProc :: AnnKeywordId
AnnQualified :: AnnKeywordId

-- | '-&gt;'
AnnRarrow :: AnnKeywordId

-- | '-&gt;', unicode variant
AnnRarrowU :: AnnKeywordId
AnnRec :: AnnKeywordId
AnnRole :: AnnKeywordId
AnnSafe :: AnnKeywordId

-- | ';'
AnnSemi :: AnnKeywordId

-- | '''
AnnSimpleQuote :: AnnKeywordId
AnnSignature :: AnnKeywordId

-- | <tt>static</tt>
AnnStatic :: AnnKeywordId
AnnStock :: AnnKeywordId
AnnThen :: AnnKeywordId

-- | <a>$</a>
AnnThIdSplice :: AnnKeywordId

-- | <a>$$</a>
AnnThIdTySplice :: AnnKeywordId

-- | double '''
AnnThTyQuote :: AnnKeywordId

-- | '~'
AnnTilde :: AnnKeywordId
AnnType :: AnnKeywordId

-- | '()' for types
AnnUnit :: AnnKeywordId
AnnUsing :: AnnKeywordId

-- | e.g. INTEGER
AnnVal :: AnnKeywordId

-- | String value, will need quotes when output
AnnValStr :: AnnKeywordId

-- | '|'
AnnVbar :: AnnKeywordId

-- | <tt>via</tt>
AnnVia :: AnnKeywordId
AnnWhere :: AnnKeywordId

-- | <tt>-&lt;</tt>
Annlarrowtail :: AnnKeywordId

-- | <tt>-&lt;</tt>, unicode variant
AnnlarrowtailU :: AnnKeywordId

-- | '-&gt;'
Annrarrowtail :: AnnKeywordId

-- | '-&gt;', unicode variant
AnnrarrowtailU :: AnnKeywordId

-- | <tt>-&lt;&lt;</tt>
AnnLarrowtail :: AnnKeywordId

-- | <tt>-&lt;&lt;</tt>, unicode variant
AnnLarrowtailU :: AnnKeywordId

-- | <tt>&gt;&gt;-</tt>
AnnRarrowtail :: AnnKeywordId

-- | <tt>&gt;&gt;-</tt>, unicode variant
AnnRarrowtailU :: AnnKeywordId
AnnEofPos :: AnnKeywordId
data AnnotationComment

-- | something beginning '-- |'
AnnDocCommentNext :: String -> AnnotationComment

-- | something beginning '-- ^'
AnnDocCommentPrev :: String -> AnnotationComment

-- | something beginning '-- $'
AnnDocCommentNamed :: String -> AnnotationComment

-- | a section heading
AnnDocSection :: Int -> String -> AnnotationComment

-- | doc options (prune, ignore-exports, etc)
AnnDocOptions :: String -> AnnotationComment

-- | comment starting by "--"
AnnLineComment :: String -> AnnotationComment

-- | comment in {- -}
AnnBlockComment :: String -> AnnotationComment

-- | Certain tokens can have alternate representations when unicode syntax
--   is enabled. This flag is attached to those tokens in the lexer so that
--   the original source representation can be reproduced in the
--   corresponding <tt>ApiAnnotation</tt>
data IsUnicodeSyntax
UnicodeSyntax :: IsUnicodeSyntax
NormalSyntax :: IsUnicodeSyntax

-- | Convert a normal annotation into its unicode equivalent one
unicodeAnn :: AnnKeywordId -> AnnKeywordId

-- | Some template haskell tokens have two variants, one with an <tt>e</tt>
--   the other not:
--   
--   <pre>
--   [| or [e|
--   [|| or [e||
--   </pre>
--   
--   This type indicates whether the <tt>e</tt> is present or not.
data HasE
HasE :: HasE
NoE :: HasE

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnClose</a>,<a>AnnComma</a>, <a>AnnRarrow</a> <a>AnnTilde</a></li>
--   <li>May have <a>AnnComma</a> when in a list</li>
--   </ul>
type LRdrName = Located RdrName
instance GHC.Show.Show ApiAnnotation.HasE
instance Data.Data.Data ApiAnnotation.HasE
instance GHC.Classes.Ord ApiAnnotation.HasE
instance GHC.Classes.Eq ApiAnnotation.HasE
instance GHC.Show.Show ApiAnnotation.IsUnicodeSyntax
instance Data.Data.Data ApiAnnotation.IsUnicodeSyntax
instance GHC.Classes.Ord ApiAnnotation.IsUnicodeSyntax
instance GHC.Classes.Eq ApiAnnotation.IsUnicodeSyntax
instance GHC.Show.Show ApiAnnotation.AnnotationComment
instance Data.Data.Data ApiAnnotation.AnnotationComment
instance GHC.Classes.Ord ApiAnnotation.AnnotationComment
instance GHC.Classes.Eq ApiAnnotation.AnnotationComment
instance GHC.Show.Show ApiAnnotation.AnnKeywordId
instance Data.Data.Data ApiAnnotation.AnnKeywordId
instance GHC.Classes.Ord ApiAnnotation.AnnKeywordId
instance GHC.Classes.Eq ApiAnnotation.AnnKeywordId
instance Outputable.Outputable ApiAnnotation.AnnotationComment
instance Outputable.Outputable ApiAnnotation.AnnKeywordId

module Lexer
data Token
ITas :: Token
ITcase :: Token
ITclass :: Token
ITdata :: Token
ITdefault :: Token
ITderiving :: Token
ITdo :: Token
ITelse :: Token
IThiding :: Token
ITforeign :: Token
ITif :: Token
ITimport :: Token
ITin :: Token
ITinfix :: Token
ITinfixl :: Token
ITinfixr :: Token
ITinstance :: Token
ITlet :: Token
ITmodule :: Token
ITnewtype :: Token
ITof :: Token
ITqualified :: Token
ITthen :: Token
ITtype :: Token
ITwhere :: Token
ITforall :: IsUnicodeSyntax -> Token
ITexport :: Token
ITlabel :: Token
ITdynamic :: Token
ITsafe :: Token
ITinterruptible :: Token
ITunsafe :: Token
ITstdcallconv :: Token
ITccallconv :: Token
ITcapiconv :: Token
ITprimcallconv :: Token
ITjavascriptcallconv :: Token
ITmdo :: Token
ITfamily :: Token
ITrole :: Token
ITgroup :: Token
ITby :: Token
ITusing :: Token
ITpattern :: Token
ITstatic :: Token
ITstock :: Token
ITanyclass :: Token
ITvia :: Token
ITunit :: Token
ITsignature :: Token
ITdependency :: Token
ITrequires :: Token
ITinline_prag :: SourceText -> InlineSpec -> RuleMatchInfo -> Token
ITspec_prag :: SourceText -> Token
ITspec_inline_prag :: SourceText -> Bool -> Token
ITsource_prag :: SourceText -> Token
ITrules_prag :: SourceText -> Token
ITwarning_prag :: SourceText -> Token
ITdeprecated_prag :: SourceText -> Token
ITline_prag :: SourceText -> Token
ITcolumn_prag :: SourceText -> Token
ITscc_prag :: SourceText -> Token
ITgenerated_prag :: SourceText -> Token
ITcore_prag :: SourceText -> Token
ITunpack_prag :: SourceText -> Token
ITnounpack_prag :: SourceText -> Token
ITann_prag :: SourceText -> Token
ITcomplete_prag :: SourceText -> Token
ITclose_prag :: Token
IToptions_prag :: String -> Token
ITinclude_prag :: String -> Token
ITlanguage_prag :: Token
ITminimal_prag :: SourceText -> Token
IToverlappable_prag :: SourceText -> Token
IToverlapping_prag :: SourceText -> Token
IToverlaps_prag :: SourceText -> Token
ITincoherent_prag :: SourceText -> Token
ITctype :: SourceText -> Token
ITcomment_line_prag :: Token
ITdotdot :: Token
ITcolon :: Token
ITdcolon :: IsUnicodeSyntax -> Token
ITequal :: Token
ITlam :: Token
ITlcase :: Token
ITvbar :: Token
ITlarrow :: IsUnicodeSyntax -> Token
ITrarrow :: IsUnicodeSyntax -> Token
ITat :: Token
ITtilde :: Token
ITdarrow :: IsUnicodeSyntax -> Token
ITminus :: Token
ITbang :: Token
ITstar :: IsUnicodeSyntax -> Token
ITdot :: Token
ITbiglam :: Token
ITocurly :: Token
ITccurly :: Token
ITvocurly :: Token
ITvccurly :: Token
ITobrack :: Token
ITopabrack :: Token
ITcpabrack :: Token
ITcbrack :: Token
IToparen :: Token
ITcparen :: Token
IToubxparen :: Token
ITcubxparen :: Token
ITsemi :: Token
ITcomma :: Token
ITunderscore :: Token
ITbackquote :: Token
ITsimpleQuote :: Token
ITvarid :: FastString -> Token
ITconid :: FastString -> Token
ITvarsym :: FastString -> Token
ITconsym :: FastString -> Token
ITqvarid :: (FastString, FastString) -> Token
ITqconid :: (FastString, FastString) -> Token
ITqvarsym :: (FastString, FastString) -> Token
ITqconsym :: (FastString, FastString) -> Token
ITdupipvarid :: FastString -> Token
ITlabelvarid :: FastString -> Token
ITchar :: SourceText -> Char -> Token
ITstring :: SourceText -> FastString -> Token
ITinteger :: IntegralLit -> Token
ITrational :: FractionalLit -> Token
ITprimchar :: SourceText -> Char -> Token
ITprimstring :: SourceText -> ByteString -> Token
ITprimint :: SourceText -> Integer -> Token
ITprimword :: SourceText -> Integer -> Token
ITprimfloat :: FractionalLit -> Token
ITprimdouble :: FractionalLit -> Token
ITopenExpQuote :: HasE -> IsUnicodeSyntax -> Token
ITopenPatQuote :: Token
ITopenDecQuote :: Token
ITopenTypQuote :: Token
ITcloseQuote :: IsUnicodeSyntax -> Token
ITopenTExpQuote :: HasE -> Token
ITcloseTExpQuote :: Token
ITidEscape :: FastString -> Token
ITparenEscape :: Token
ITidTyEscape :: FastString -> Token
ITparenTyEscape :: Token
ITtyQuote :: Token
ITquasiQuote :: (FastString, FastString, RealSrcSpan) -> Token
ITqQuasiQuote :: (FastString, FastString, FastString, RealSrcSpan) -> Token
ITproc :: Token
ITrec :: Token

-- | <pre>
--   (|
--   </pre>
IToparenbar :: IsUnicodeSyntax -> Token

-- | <pre>
--   |)
--   </pre>
ITcparenbar :: IsUnicodeSyntax -> Token

-- | <pre>
--   -&lt;
--   </pre>
ITlarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   &gt;-
--   </pre>
ITrarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   -&lt;&lt;
--   </pre>
ITLarrowtail :: IsUnicodeSyntax -> Token

-- | <pre>
--   &gt;&gt;-
--   </pre>
ITRarrowtail :: IsUnicodeSyntax -> Token

-- | Type application '@' (lexed differently than as-pattern '@', due to
--   checking for preceding whitespace)
ITtypeApp :: Token

-- | Used when the lexer can't make sense of it
ITunknown :: String -> Token

-- | end of file token
ITeof :: Token

-- | something beginning <tt>-- |</tt>
ITdocCommentNext :: String -> Token

-- | something beginning <tt>-- ^</tt>
ITdocCommentPrev :: String -> Token

-- | something beginning <tt>-- $</tt>
ITdocCommentNamed :: String -> Token

-- | a section heading
ITdocSection :: Int -> String -> Token

-- | doc options (prune, ignore-exports, etc)
ITdocOptions :: String -> Token

-- | comment starting by "--"
ITlineComment :: String -> Token

-- | comment in {- -}
ITblockComment :: String -> Token
lexer :: Bool -> (Located Token -> P a) -> P a
pragState :: DynFlags -> StringBuffer -> RealSrcLoc -> PState

-- | Creates a parse state from a <a>DynFlags</a> value
mkPState :: DynFlags -> StringBuffer -> RealSrcLoc -> PState

-- | Creates a parse state from a <a>ParserFlags</a> value
mkPStatePure :: ParserFlags -> StringBuffer -> RealSrcLoc -> PState
data PState
PState :: StringBuffer -> ParserFlags -> (DynFlags -> Messages) -> Maybe RealSrcSpan -> !Int -> Maybe Token -> RealSrcSpan -> !Int -> RealSrcLoc -> [LayoutContext] -> [Int] -> [FastString] -> [RealLocated Token] -> Maybe (RealLocated Token) -> RealSrcSpan -> [ALRContext] -> Maybe ALRLayout -> Bool -> [(ApiAnnKey, [SrcSpan])] -> [Located AnnotationComment] -> [(SrcSpan, [Located AnnotationComment])] -> PState
[buffer] :: PState -> StringBuffer
[options] :: PState -> ParserFlags
[messages] :: PState -> DynFlags -> Messages
[tab_first] :: PState -> Maybe RealSrcSpan
[tab_count] :: PState -> !Int
[last_tk] :: PState -> Maybe Token
[last_loc] :: PState -> RealSrcSpan
[last_len] :: PState -> !Int
[loc] :: PState -> RealSrcLoc
[context] :: PState -> [LayoutContext]
[lex_state] :: PState -> [Int]
[srcfiles] :: PState -> [FastString]
[alr_pending_implicit_tokens] :: PState -> [RealLocated Token]
[alr_next_token] :: PState -> Maybe (RealLocated Token)
[alr_last_loc] :: PState -> RealSrcSpan
[alr_context] :: PState -> [ALRContext]
[alr_expecting_ocurly] :: PState -> Maybe ALRLayout
[alr_justClosedExplicitLetBlock] :: PState -> Bool
[annotations] :: PState -> [(ApiAnnKey, [SrcSpan])]
[comment_q] :: PState -> [Located AnnotationComment]
[annotations_comments] :: PState -> [(SrcSpan, [Located AnnotationComment])]
newtype P a
P :: (PState -> ParseResult a) -> P a
[unP] :: P a -> PState -> ParseResult a
data ParseResult a
POk :: PState -> a -> ParseResult a
PFailed :: (DynFlags -> Messages) -> SrcSpan -> MsgDoc -> ParseResult a

-- | Extracts the flag information needed for parsing
mkParserFlags :: DynFlags -> ParserFlags

-- | Given exactly the information needed, set up the <a>ParserFlags</a>
mkParserFlags' :: EnumSet WarningFlag -> EnumSet Extension -> UnitId -> Bool -> Bool -> Bool -> Bool -> ParserFlags

-- | The subset of the <a>DynFlags</a> used by the parser. See
--   <a>mkParserFlags</a> or <a>mkParserFlags'</a> for ways to construct
--   this.
data ParserFlags
getRealSrcLoc :: P RealSrcLoc
getPState :: P PState
withThisPackage :: (UnitId -> a) -> P a
failLocMsgP :: RealSrcLoc -> RealSrcLoc -> String -> P a
failSpanMsgP :: SrcSpan -> SDoc -> P a
srcParseFail :: P a
getMessages :: PState -> DynFlags -> Messages
popContext :: P ()
pushModuleContext :: P ()
setLastToken :: RealSrcSpan -> Int -> P ()
setSrcLoc :: RealSrcLoc -> P ()
activeContext :: P Bool
nextIsEOF :: P Bool
getLexState :: P Int
popLexState :: P Int
pushLexState :: Int -> P ()

-- | Various boolean flags, mostly language extensions, that impact lexing
--   and parsing. Note that a handful of these can change during
--   lexing/parsing.
data ExtBits
FfiBit :: ExtBits
InterruptibleFfiBit :: ExtBits
CApiFfiBit :: ExtBits
ArrowsBit :: ExtBits
ThBit :: ExtBits
ThQuotesBit :: ExtBits
IpBit :: ExtBits
OverloadedLabelsBit :: ExtBits
ExplicitForallBit :: ExtBits
BangPatBit :: ExtBits
PatternSynonymsBit :: ExtBits
HaddockBit :: ExtBits
MagicHashBit :: ExtBits
RecursiveDoBit :: ExtBits
UnicodeSyntaxBit :: ExtBits
UnboxedTuplesBit :: ExtBits
UnboxedSumsBit :: ExtBits
DatatypeContextsBit :: ExtBits
MonadComprehensionsBit :: ExtBits
TransformComprehensionsBit :: ExtBits
QqBit :: ExtBits
RawTokenStreamBit :: ExtBits
AlternativeLayoutRuleBit :: ExtBits
ALRTransitionalBit :: ExtBits
RelaxedLayoutBit :: ExtBits
NondecreasingIndentationBit :: ExtBits
SafeHaskellBit :: ExtBits
TraditionalRecordSyntaxBit :: ExtBits
ExplicitNamespacesBit :: ExtBits
LambdaCaseBit :: ExtBits
BinaryLiteralsBit :: ExtBits
NegativeLiteralsBit :: ExtBits
HexFloatLiteralsBit :: ExtBits
TypeApplicationsBit :: ExtBits
StaticPointersBit :: ExtBits
NumericUnderscoresBit :: ExtBits
StarIsTypeBit :: ExtBits
BlockArgumentsBit :: ExtBits
NPlusKPatternsBit :: ExtBits
DoAndIfThenElseBit :: ExtBits
MultiWayIfBit :: ExtBits
GadtSyntaxBit :: ExtBits
InRulePragBit :: ExtBits
InNestedCommentBit :: ExtBits

-- | If this is enabled, '{-}' and '{--}' update the internal position.
--   Otherwise, those pragmas are lexed as tokens of their own.
UsePosPragsBit :: ExtBits

-- | Check if a given flag is currently set in the bitmap.
getBit :: ExtBits -> P Bool
addWarning :: WarningFlag -> SrcSpan -> SDoc -> P ()
lexTokenStream :: StringBuffer -> RealSrcLoc -> DynFlags -> ParseResult [Located Token]
addAnnotation :: SrcSpan -> AnnKeywordId -> SrcSpan -> P ()

-- | Encapsulated call to addAnnotation, requiring only the SrcSpan of the
--   AST construct the annotation belongs to; together with the
--   AnnKeywordId, this is the key of the annotation map.
--   
--   This type is useful for places in the parser where it is not yet known
--   what SrcSpan an annotation should be added to. The most common
--   situation is when we are parsing a list: the annotations need to be
--   associated with the AST element that *contains* the list, not the list
--   itself. <a>AddAnn</a> lets us defer adding the annotations until we
--   finish parsing the list and are now parsing the enclosing element; we
--   then apply the <a>AddAnn</a> to associate the annotations. Another
--   common situation is where a common fragment of the AST has been
--   factored out but there is no separate AST node for this fragment (this
--   occurs in class and data declarations). In this case, the annotation
--   belongs to the parent data declaration.
--   
--   The usual way an <a>AddAnn</a> is created is using the <tt>mj</tt>
--   ("make jump") function, and then it can be discharged using the
--   <tt>ams</tt> function.
type AddAnn = SrcSpan -> P ()

-- | Given a location and a list of AddAnn, apply them all to the location.
addAnnsAt :: SrcSpan -> [AddAnn] -> P ()

-- | Given a <a>SrcSpan</a> that surrounds a <tt>HsPar</tt> or
--   <tt>HsParTy</tt>, generate <a>AddAnn</a> values for the opening and
--   closing bordering on the start and end of the span
mkParensApiAnn :: SrcSpan -> [AddAnn]
commentToAnnotation :: Located Token -> Located AnnotationComment
instance GHC.Enum.Enum Lexer.ExtBits
instance GHC.Show.Show Lexer.LayoutContext
instance GHC.Show.Show Lexer.Token
instance GHC.Base.Functor Lexer.P
instance GHC.Base.Applicative Lexer.P
instance GHC.Base.Monad Lexer.P
instance Control.Monad.Fail.MonadFail Lexer.P
instance Outputable.Outputable Lexer.Token


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see <a>OccName#name_types</a></li>
--   <li><a>RdrName</a>: see <a>RdrName#name_types</a></li>
--   <li><a>Name</a>: see <a>Name#name_types</a></li>
--   <li><a>Id</a>: see <a>Id#name_types</a></li>
--   <li><a>Var</a> is a synonym for the <a>Id</a> type but it may
--   additionally potentially contain type variables, which have a
--   <a>Kind</a> rather than a <a>Type</a> and only contain some extra
--   details during typechecking.</li>
--   </ul>
--   
--   These <a>Var</a> names may either be global or local, see
--   <a>Var#globalvslocal</a>
--   
--   Global <a>Id</a>s and <a>Var</a>s are those that are imported or
--   correspond to a data constructor, primitive operation, or record
--   selectors. Local <a>Id</a>s and <a>Var</a>s are those bound within an
--   expression (e.g. by a lambda) or at the top level of the module being
--   compiled.
module Var

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Coercion Variable
type CoVar = Id

-- | Identifier
type Id = Var

type NcId = Id

-- | Dictionary Identifier
type DictId = EvId

-- | Dictionary Function Identifier
type DFunId = Id

-- | Evidence Variable
type EvVar = EvId

-- | Equality Variable
type EqVar = EvId

-- | Evidence Identifier
type EvId = Id

-- | Implicit parameter Identifier
type IpId = EvId
type JoinId = Id

-- | Type or kind Variable
type TyVar = Var

-- | Type variable that might be a metavariable
type TcTyVar = Var

-- | Type Variable
type TypeVar = Var

-- | Kind Variable
type KindVar = Var

-- | Type or Kind Variable
type TKVar = Var

-- | Type or Coercion Variable
type TyCoVar = Id
type InVar = Var
type InCoVar = CoVar
type InId = Id
type InTyVar = TyVar
type OutVar = Var
type OutCoVar = CoVar
type OutId = Id
type OutTyVar = TyVar
varName :: Var -> Name
varUnique :: Var -> Unique

-- | The type or kind of the <a>Var</a> in question
varType :: Var -> Kind
setVarName :: Var -> Name -> Var
setVarUnique :: Var -> Unique -> Var
setVarType :: Id -> Type -> Id
updateVarType :: (Type -> Type) -> Id -> Id
updateVarTypeM :: Monad m => (Type -> m Type) -> Id -> m Id
mkGlobalVar :: IdDetails -> Name -> Type -> IdInfo -> Id
mkLocalVar :: IdDetails -> Name -> Type -> IdInfo -> Id

-- | Exported <a>Var</a>s will not be removed as dead code
mkExportedLocalVar :: IdDetails -> Name -> Type -> IdInfo -> Id
mkCoVar :: Name -> Type -> CoVar
idInfo :: HasDebugCallStack => Id -> IdInfo
idDetails :: Id -> IdDetails
lazySetIdInfo :: Id -> IdInfo -> Var
setIdDetails :: Id -> IdDetails -> Id

-- | If it's a local, make it global
globaliseId :: Id -> Id

-- | Exports the given local <a>Id</a>. Can also be called on global
--   <a>Id</a>s, such as data constructors and class operations, which are
--   born as global <a>Id</a>s and automatically exported
setIdExported :: Id -> Id

-- | We can only do this to LocalIds
setIdNotExported :: Id -> Id
isId :: Var -> Bool
isTyVar :: Var -> Bool
isTcTyVar :: Var -> Bool

-- | <a>isLocalVar</a> returns <tt>True</tt> for type variables as well as
--   local <a>Id</a>s These are the variables that we need to pay attention
--   to when finding free variables, or doing dependency analysis.
isLocalVar :: Var -> Bool
isLocalId :: Var -> Bool
isCoVar :: Var -> Bool
isNonCoVarId :: Var -> Bool
isTyCoVar :: Var -> Bool
isGlobalId :: Var -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool

-- | <a>mustHaveLocalBinding</a> returns <tt>True</tt> of <a>Id</a>s and
--   <a>TyVar</a>s that must have a binding in this module. The converse is
--   not quite right: there are some global <a>Id</a>s that must have
--   bindings, such as record selectors. But that doesn't matter, because
--   it's only used for assertions
mustHaveLocalBinding :: Var -> Bool
data VarBndr var argf
Bndr :: var -> argf -> VarBndr var argf

-- | Argument Flag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, TyCoVarBinders, TyConBinders,
--   and visibility] in TyCoRep
data ArgFlag
Inferred :: ArgFlag
Specified :: ArgFlag
Required :: ArgFlag

-- | Variable Binder
--   
--   A <a>TyCoVarBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in TyCoRep, because
--   it's used in DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type TyCoVarBinder = VarBndr TyCoVar ArgFlag
type TyVarBinder = VarBndr TyVar ArgFlag
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]
binderArgFlag :: VarBndr tv argf -> argf
binderType :: VarBndr TyCoVar argf -> Type

-- | Does this <a>ArgFlag</a> classify an argument that is written in
--   Haskell?
isVisibleArgFlag :: ArgFlag -> Bool

-- | Does this <a>ArgFlag</a> classify an argument that is not written in
--   Haskell?
isInvisibleArgFlag :: ArgFlag -> Bool

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
sameVis :: ArgFlag -> ArgFlag -> Bool

-- | Make a named binder
mkTyCoVarBinder :: ArgFlag -> TyCoVar -> TyCoVarBinder

-- | Make many named binders
mkTyCoVarBinders :: ArgFlag -> [TyCoVar] -> [TyCoVarBinder]

-- | Make a named binder <tt>var</tt> should be a type variable
mkTyVarBinder :: ArgFlag -> TyVar -> TyVarBinder

-- | Make many named binders Input vars should be type variables
mkTyVarBinders :: ArgFlag -> [TyVar] -> [TyVarBinder]
isTyVarBinder :: TyCoVarBinder -> Bool
mkTyVar :: Name -> Kind -> TyVar
mkTcTyVar :: Name -> Kind -> TcTyVarDetails -> TyVar
tyVarName :: TyVar -> Name
tyVarKind :: TyVar -> Kind
tcTyVarDetails :: TyVar -> TcTyVarDetails
setTcTyVarDetails :: TyVar -> TcTyVarDetails -> TyVar
setTyVarName :: TyVar -> Name -> TyVar
setTyVarUnique :: TyVar -> Unique -> TyVar
setTyVarKind :: TyVar -> Kind -> TyVar
updateTyVarKind :: (Kind -> Kind) -> TyVar -> TyVar
updateTyVarKindM :: Monad m => (Kind -> m Kind) -> TyVar -> m TyVar

-- | Compare Vars by their Uniques. This is what Ord Var does, provided
--   here to make it explicit at the call-site that it can introduce
--   non-determinism. See Note [Unique Determinism]
nonDetCmpVar :: Var -> Var -> Ordering
instance (Data.Data.Data var, Data.Data.Data argf) => Data.Data.Data (Var.VarBndr var argf)
instance Data.Data.Data Var.ArgFlag
instance GHC.Classes.Ord Var.ArgFlag
instance GHC.Classes.Eq Var.ArgFlag
instance Outputable.Outputable tv => Outputable.Outputable (Var.VarBndr tv Var.ArgFlag)
instance (Binary.Binary tv, Binary.Binary vis) => Binary.Binary (Var.VarBndr tv vis)
instance Name.NamedThing tv => Name.NamedThing (Var.VarBndr tv flag)
instance Outputable.Outputable Var.ArgFlag
instance Binary.Binary Var.ArgFlag
instance Outputable.Outputable Var.Var
instance Name.NamedThing Var.Var
instance Unique.Uniquable Var.Var
instance GHC.Classes.Eq Var.Var
instance GHC.Classes.Ord Var.Var
instance Data.Data.Data Var.Var
instance OccName.HasOccName Var.Var

module PlaceHolder
placeHolderNamesTc :: NameSet

-- | Follow the <tt>id</tt>, but never beyond Name. This is used in a
--   <tt>HsMatchContext</tt>, for printing messages related to a
--   <tt>Match</tt>
type family NameOrRdrName id

module HsExtension

-- | used as place holder in TTG values
data NoExt
NoExt :: NoExt

-- | Used when constructing a term with an unused extension point.
noExt :: NoExt

-- | Used as a data type index for the hsSyn AST
data GhcPass (c :: Pass)
data Pass
Parsed :: Pass
Renamed :: Pass
Typechecked :: Pass
type GhcPs = GhcPass  'Parsed
type GhcRn = GhcPass  'Renamed
type GhcTc = GhcPass  'Typechecked
type GhcTcId = GhcTc

-- | Maps the "normal" id type for a given pass
type family IdP p
type LIdP p = Located (IdP p)

-- | Marks that a field uses the GhcRn variant even when the pass parameter
--   is GhcTc. Useful for storing HsTypes in HsExprs, say, because HsType
--   GhcTc should never occur.
type family NoGhcTc (p :: Type)
type family NoGhcTcPass (p :: Pass) :: Pass
type family XHsValBinds x x'
type family XHsIPBinds x x'
type family XEmptyLocalBinds x x'
type family XXHsLocalBindsLR x x'
type ForallXHsLocalBindsLR (c :: * -> Constraint) (x :: *) (x' :: *) = (c (XHsValBinds x x'), c (XHsIPBinds x x'), c (XEmptyLocalBinds x x'), c (XXHsLocalBindsLR x x'))
type family XValBinds x x'
type family XXValBindsLR x x'
type ForallXValBindsLR (c :: * -> Constraint) (x :: *) (x' :: *) = (c (XValBinds x x'), c (XXValBindsLR x x'))
type family XFunBind x x'
type family XPatBind x x'
type family XVarBind x x'
type family XAbsBinds x x'
type family XPatSynBind x x'
type family XXHsBindsLR x x'
type ForallXHsBindsLR (c :: * -> Constraint) (x :: *) (x' :: *) = (c (XFunBind x x'), c (XPatBind x x'), c (XVarBind x x'), c (XAbsBinds x x'), c (XPatSynBind x x'), c (XXHsBindsLR x x'))
type family XABE x
type family XXABExport x
type ForallXABExport (c :: * -> Constraint) (x :: *) = (c (XABE x), c (XXABExport x))
type family XPSB x x'
type family XXPatSynBind x x'
type ForallXPatSynBind (c :: * -> Constraint) (x :: *) (x' :: *) = (c (XPSB x x'), c (XXPatSynBind x x'))
type family XIPBinds x
type family XXHsIPBinds x
type ForallXHsIPBinds (c :: * -> Constraint) (x :: *) = (c (XIPBinds x), c (XXHsIPBinds x))
type family XCIPBind x
type family XXIPBind x
type ForallXIPBind (c :: * -> Constraint) (x :: *) = (c (XCIPBind x), c (XXIPBind x))
type family XTypeSig x
type family XPatSynSig x
type family XClassOpSig x
type family XIdSig x
type family XFixSig x
type family XInlineSig x
type family XSpecSig x
type family XSpecInstSig x
type family XMinimalSig x
type family XSCCFunSig x
type family XCompleteMatchSig x
type family XXSig x
type ForallXSig (c :: * -> Constraint) (x :: *) = (c (XTypeSig x), c (XPatSynSig x), c (XClassOpSig x), c (XIdSig x), c (XFixSig x), c (XInlineSig x), c (XSpecSig x), c (XSpecInstSig x), c (XMinimalSig x), c (XSCCFunSig x), c (XCompleteMatchSig x), c (XXSig x))
type family XFixitySig x
type family XXFixitySig x
type ForallXFixitySig (c :: * -> Constraint) (x :: *) = (c (XFixitySig x), c (XXFixitySig x))
type family XTyClD x
type family XInstD x
type family XDerivD x
type family XValD x
type family XSigD x
type family XDefD x
type family XForD x
type family XWarningD x
type family XAnnD x
type family XRuleD x
type family XSpliceD x
type family XDocD x
type family XRoleAnnotD x
type family XXHsDecl x
type ForallXHsDecl (c :: * -> Constraint) (x :: *) = (c (XTyClD x), c (XInstD x), c (XDerivD x), c (XValD x), c (XSigD x), c (XDefD x), c (XForD x), c (XWarningD x), c (XAnnD x), c (XRuleD x), c (XSpliceD x), c (XDocD x), c (XRoleAnnotD x), c (XXHsDecl x))
type family XCHsGroup x
type family XXHsGroup x
type ForallXHsGroup (c :: * -> Constraint) (x :: *) = (c (XCHsGroup x), c (XXHsGroup x))
type family XSpliceDecl x
type family XXSpliceDecl x
type ForallXSpliceDecl (c :: * -> Constraint) (x :: *) = (c (XSpliceDecl x), c (XXSpliceDecl x))
type family XFamDecl x
type family XSynDecl x
type family XDataDecl x
type family XClassDecl x
type family XXTyClDecl x
type ForallXTyClDecl (c :: * -> Constraint) (x :: *) = (c (XFamDecl x), c (XSynDecl x), c (XDataDecl x), c (XClassDecl x), c (XXTyClDecl x))
type family XCTyClGroup x
type family XXTyClGroup x
type ForallXTyClGroup (c :: * -> Constraint) (x :: *) = (c (XCTyClGroup x), c (XXTyClGroup x))
type family XNoSig x
type family XCKindSig x
type family XTyVarSig x
type family XXFamilyResultSig x
type ForallXFamilyResultSig (c :: * -> Constraint) (x :: *) = (c (XNoSig x), c (XCKindSig x), c (XTyVarSig x), c (XXFamilyResultSig x))
type family XCFamilyDecl x
type family XXFamilyDecl x
type ForallXFamilyDecl (c :: * -> Constraint) (x :: *) = (c (XCFamilyDecl x), c (XXFamilyDecl x))
type family XCHsDataDefn x
type family XXHsDataDefn x
type ForallXHsDataDefn (c :: * -> Constraint) (x :: *) = (c (XCHsDataDefn x), c (XXHsDataDefn x))
type family XCHsDerivingClause x
type family XXHsDerivingClause x
type ForallXHsDerivingClause (c :: * -> Constraint) (x :: *) = (c (XCHsDerivingClause x), c (XXHsDerivingClause x))
type family XConDeclGADT x
type family XConDeclH98 x
type family XXConDecl x
type ForallXConDecl (c :: * -> Constraint) (x :: *) = (c (XConDeclGADT x), c (XConDeclH98 x), c (XXConDecl x))
type family XCFamEqn x p r
type family XXFamEqn x p r
type ForallXFamEqn (c :: * -> Constraint) (x :: *) (p :: *) (r :: *) = (c (XCFamEqn x p r), c (XXFamEqn x p r))
type family XCClsInstDecl x
type family XXClsInstDecl x
type ForallXClsInstDecl (c :: * -> Constraint) (x :: *) = (c (XCClsInstDecl x), c (XXClsInstDecl x))
type family XClsInstD x
type family XDataFamInstD x
type family XTyFamInstD x
type family XXInstDecl x
type ForallXInstDecl (c :: * -> Constraint) (x :: *) = (c (XClsInstD x), c (XDataFamInstD x), c (XTyFamInstD x), c (XXInstDecl x))
type family XCDerivDecl x
type family XXDerivDecl x
type ForallXDerivDecl (c :: * -> Constraint) (x :: *) = (c (XCDerivDecl x), c (XXDerivDecl x))
type family XViaStrategy x
type family XCDefaultDecl x
type family XXDefaultDecl x
type ForallXDefaultDecl (c :: * -> Constraint) (x :: *) = (c (XCDefaultDecl x), c (XXDefaultDecl x))
type family XForeignImport x
type family XForeignExport x
type family XXForeignDecl x
type ForallXForeignDecl (c :: * -> Constraint) (x :: *) = (c (XForeignImport x), c (XForeignExport x), c (XXForeignDecl x))
type family XCRuleDecls x
type family XXRuleDecls x
type ForallXRuleDecls (c :: * -> Constraint) (x :: *) = (c (XCRuleDecls x), c (XXRuleDecls x))
type family XHsRule x
type family XXRuleDecl x
type ForallXRuleDecl (c :: * -> Constraint) (x :: *) = (c (XHsRule x), c (XXRuleDecl x))
type family XCRuleBndr x
type family XRuleBndrSig x
type family XXRuleBndr x
type ForallXRuleBndr (c :: * -> Constraint) (x :: *) = (c (XCRuleBndr x), c (XRuleBndrSig x), c (XXRuleBndr x))
type family XWarnings x
type family XXWarnDecls x
type ForallXWarnDecls (c :: * -> Constraint) (x :: *) = (c (XWarnings x), c (XXWarnDecls x))
type family XWarning x
type family XXWarnDecl x
type ForallXWarnDecl (c :: * -> Constraint) (x :: *) = (c (XWarning x), c (XXWarnDecl x))
type family XHsAnnotation x
type family XXAnnDecl x
type ForallXAnnDecl (c :: * -> Constraint) (x :: *) = (c (XHsAnnotation x), c (XXAnnDecl x))
type family XCRoleAnnotDecl x
type family XXRoleAnnotDecl x
type ForallXRoleAnnotDecl (c :: * -> Constraint) (x :: *) = (c (XCRoleAnnotDecl x), c (XXRoleAnnotDecl x))
type family XVar x
type family XUnboundVar x
type family XConLikeOut x
type family XRecFld x
type family XOverLabel x
type family XIPVar x
type family XOverLitE x
type family XLitE x
type family XLam x
type family XLamCase x
type family XApp x
type family XAppTypeE x
type family XOpApp x
type family XNegApp x
type family XPar x
type family XSectionL x
type family XSectionR x
type family XExplicitTuple x
type family XExplicitSum x
type family XCase x
type family XIf x
type family XMultiIf x
type family XLet x
type family XDo x
type family XExplicitList x
type family XRecordCon x
type family XRecordUpd x
type family XExprWithTySig x
type family XArithSeq x
type family XSCC x
type family XCoreAnn x
type family XBracket x
type family XRnBracketOut x
type family XTcBracketOut x
type family XSpliceE x
type family XProc x
type family XStatic x
type family XArrApp x
type family XArrForm x
type family XTick x
type family XBinTick x
type family XTickPragma x
type family XEWildPat x
type family XEAsPat x
type family XEViewPat x
type family XELazyPat x
type family XWrap x
type family XXExpr x
type ForallXExpr (c :: * -> Constraint) (x :: *) = (c (XVar x), c (XUnboundVar x), c (XConLikeOut x), c (XRecFld x), c (XOverLabel x), c (XIPVar x), c (XOverLitE x), c (XLitE x), c (XLam x), c (XLamCase x), c (XApp x), c (XAppTypeE x), c (XOpApp x), c (XNegApp x), c (XPar x), c (XSectionL x), c (XSectionR x), c (XExplicitTuple x), c (XExplicitSum x), c (XCase x), c (XIf x), c (XMultiIf x), c (XLet x), c (XDo x), c (XExplicitList x), c (XRecordCon x), c (XRecordUpd x), c (XExprWithTySig x), c (XArithSeq x), c (XSCC x), c (XCoreAnn x), c (XBracket x), c (XRnBracketOut x), c (XTcBracketOut x), c (XSpliceE x), c (XProc x), c (XStatic x), c (XArrApp x), c (XArrForm x), c (XTick x), c (XBinTick x), c (XTickPragma x), c (XEWildPat x), c (XEAsPat x), c (XEViewPat x), c (XELazyPat x), c (XWrap x), c (XXExpr x))
type family XUnambiguous x
type family XAmbiguous x
type family XXAmbiguousFieldOcc x
type ForallXAmbiguousFieldOcc (c :: * -> Constraint) (x :: *) = (c (XUnambiguous x), c (XAmbiguous x), c (XXAmbiguousFieldOcc x))
type family XPresent x
type family XMissing x
type family XXTupArg x
type ForallXTupArg (c :: * -> Constraint) (x :: *) = (c (XPresent x), c (XMissing x), c (XXTupArg x))
type family XTypedSplice x
type family XUntypedSplice x
type family XQuasiQuote x
type family XSpliced x
type family XXSplice x
type ForallXSplice (c :: * -> Constraint) (x :: *) = (c (XTypedSplice x), c (XUntypedSplice x), c (XQuasiQuote x), c (XSpliced x), c (XXSplice x))
type family XExpBr x
type family XPatBr x
type family XDecBrL x
type family XDecBrG x
type family XTypBr x
type family XVarBr x
type family XTExpBr x
type family XXBracket x
type ForallXBracket (c :: * -> Constraint) (x :: *) = (c (XExpBr x), c (XPatBr x), c (XDecBrL x), c (XDecBrG x), c (XTypBr x), c (XVarBr x), c (XTExpBr x), c (XXBracket x))
type family XCmdTop x
type family XXCmdTop x
type ForallXCmdTop (c :: * -> Constraint) (x :: *) = (c (XCmdTop x), c (XXCmdTop x))
type family XMG x b
type family XXMatchGroup x b
type ForallXMatchGroup (c :: * -> Constraint) (x :: *) (b :: *) = (c (XMG x b), c (XXMatchGroup x b))
type family XCMatch x b
type family XXMatch x b
type ForallXMatch (c :: * -> Constraint) (x :: *) (b :: *) = (c (XCMatch x b), c (XXMatch x b))
type family XCGRHSs x b
type family XXGRHSs x b
type ForallXGRHSs (c :: * -> Constraint) (x :: *) (b :: *) = (c (XCGRHSs x b), c (XXGRHSs x b))
type family XCGRHS x b
type family XXGRHS x b
type ForallXGRHS (c :: * -> Constraint) (x :: *) (b :: *) = (c (XCGRHS x b), c (XXGRHS x b))
type family XLastStmt x x' b
type family XBindStmt x x' b
type family XApplicativeStmt x x' b
type family XBodyStmt x x' b
type family XLetStmt x x' b
type family XParStmt x x' b
type family XTransStmt x x' b
type family XRecStmt x x' b
type family XXStmtLR x x' b
type ForallXStmtLR (c :: * -> Constraint) (x :: *) (x' :: *) (b :: *) = (c (XLastStmt x x' b), c (XBindStmt x x' b), c (XApplicativeStmt x x' b), c (XBodyStmt x x' b), c (XLetStmt x x' b), c (XParStmt x x' b), c (XTransStmt x x' b), c (XRecStmt x x' b), c (XXStmtLR x x' b))
type family XCmdArrApp x
type family XCmdArrForm x
type family XCmdApp x
type family XCmdLam x
type family XCmdPar x
type family XCmdCase x
type family XCmdIf x
type family XCmdLet x
type family XCmdDo x
type family XCmdWrap x
type family XXCmd x
type ForallXCmd (c :: * -> Constraint) (x :: *) = (c (XCmdArrApp x), c (XCmdArrForm x), c (XCmdApp x), c (XCmdLam x), c (XCmdPar x), c (XCmdCase x), c (XCmdIf x), c (XCmdLet x), c (XCmdDo x), c (XCmdWrap x), c (XXCmd x))
type family XParStmtBlock x x'
type family XXParStmtBlock x x'
type ForallXParStmtBlock (c :: * -> Constraint) (x :: *) (x' :: *) = (c (XParStmtBlock x x'), c (XXParStmtBlock x x'))
type family XApplicativeArgOne x
type family XApplicativeArgMany x
type family XXApplicativeArg x
type ForallXApplicativeArg (c :: * -> Constraint) (x :: *) = (c (XApplicativeArgOne x), c (XApplicativeArgMany x), c (XXApplicativeArg x))
type family XHsChar x
type family XHsCharPrim x
type family XHsString x
type family XHsStringPrim x
type family XHsInt x
type family XHsIntPrim x
type family XHsWordPrim x
type family XHsInt64Prim x
type family XHsWord64Prim x
type family XHsInteger x
type family XHsRat x
type family XHsFloatPrim x
type family XHsDoublePrim x
type family XXLit x

-- | Helper to apply a constraint to all extension points. It has one entry
--   per extension point type family.
type ForallXHsLit (c :: * -> Constraint) (x :: *) = (c (XHsChar x), c (XHsCharPrim x), c (XHsDoublePrim x), c (XHsFloatPrim x), c (XHsInt x), c (XHsInt64Prim x), c (XHsIntPrim x), c (XHsInteger x), c (XHsRat x), c (XHsString x), c (XHsStringPrim x), c (XHsWord64Prim x), c (XHsWordPrim x), c (XXLit x))
type family XOverLit x
type family XXOverLit x
type ForallXOverLit (c :: * -> Constraint) (x :: *) = (c (XOverLit x), c (XXOverLit x))
type family XWildPat x
type family XVarPat x
type family XLazyPat x
type family XAsPat x
type family XParPat x
type family XBangPat x
type family XListPat x
type family XTuplePat x
type family XSumPat x
type family XConPat x
type family XViewPat x
type family XSplicePat x
type family XLitPat x
type family XNPat x
type family XNPlusKPat x
type family XSigPat x
type family XCoPat x
type family XXPat x
type ForallXPat (c :: * -> Constraint) (x :: *) = (c (XWildPat x), c (XVarPat x), c (XLazyPat x), c (XAsPat x), c (XParPat x), c (XBangPat x), c (XListPat x), c (XTuplePat x), c (XSumPat x), c (XViewPat x), c (XSplicePat x), c (XLitPat x), c (XNPat x), c (XNPlusKPat x), c (XSigPat x), c (XCoPat x), c (XXPat x))
type family XHsQTvs x
type family XXLHsQTyVars x
type ForallXLHsQTyVars (c :: * -> Constraint) (x :: *) = (c (XHsQTvs x), c (XXLHsQTyVars x))
type family XHsIB x b
type family XXHsImplicitBndrs x b
type ForallXHsImplicitBndrs (c :: * -> Constraint) (x :: *) (b :: *) = (c (XHsIB x b), c (XXHsImplicitBndrs x b))
type family XHsWC x b
type family XXHsWildCardBndrs x b
type ForallXHsWildCardBndrs (c :: * -> Constraint) (x :: *) (b :: *) = (c (XHsWC x b), c (XXHsWildCardBndrs x b))
type family XForAllTy x
type family XQualTy x
type family XTyVar x
type family XAppTy x
type family XAppKindTy x
type family XFunTy x
type family XListTy x
type family XTupleTy x
type family XSumTy x
type family XOpTy x
type family XParTy x
type family XIParamTy x
type family XStarTy x
type family XKindSig x
type family XSpliceTy x
type family XDocTy x
type family XBangTy x
type family XRecTy x
type family XExplicitListTy x
type family XExplicitTupleTy x
type family XTyLit x
type family XWildCardTy x
type family XXType x

-- | Helper to apply a constraint to all extension points. It has one entry
--   per extension point type family.
type ForallXType (c :: * -> Constraint) (x :: *) = (c (XForAllTy x), c (XQualTy x), c (XTyVar x), c (XAppTy x), c (XAppKindTy x), c (XFunTy x), c (XListTy x), c (XTupleTy x), c (XSumTy x), c (XOpTy x), c (XParTy x), c (XIParamTy x), c (XStarTy x), c (XKindSig x), c (XSpliceTy x), c (XDocTy x), c (XBangTy x), c (XRecTy x), c (XExplicitListTy x), c (XExplicitTupleTy x), c (XTyLit x), c (XWildCardTy x), c (XXType x))
type family XUserTyVar x
type family XKindedTyVar x
type family XXTyVarBndr x
type ForallXTyVarBndr (c :: * -> Constraint) (x :: *) = (c (XUserTyVar x), c (XKindedTyVar x), c (XXTyVarBndr x))
type family XConDeclField x
type family XXConDeclField x
type ForallXConDeclField (c :: * -> Constraint) (x :: *) = (c (XConDeclField x), c (XXConDeclField x))
type family XCFieldOcc x
type family XXFieldOcc x
type ForallXFieldOcc (c :: * -> Constraint) (x :: *) = (c (XCFieldOcc x), c (XXFieldOcc x))
type family XCImportDecl x
type family XXImportDecl x
type ForallXImportDecl (c :: * -> Constraint) (x :: *) = (c (XCImportDecl x), c (XXImportDecl x))
type family XIEVar x
type family XIEThingAbs x
type family XIEThingAll x
type family XIEThingWith x
type family XIEModuleContents x
type family XIEGroup x
type family XIEDoc x
type family XIEDocNamed x
type family XXIE x
type ForallXIE (c :: * -> Constraint) (x :: *) = (c (XIEVar x), c (XIEThingAbs x), c (XIEThingAll x), c (XIEThingWith x), c (XIEModuleContents x), c (XIEGroup x), c (XIEDoc x), c (XIEDocNamed x), c (XXIE x))

-- | Conversion of annotations from one type index to another. This is
--   required where the AST is converted from one pass to another, and the
--   extension values need to be brought along if possible. So for example
--   a <tt>SourceText</tt> is converted via <a>id</a>, but needs a type
--   signature to keep the type checker happy.
class Convertable a b | a -> b
convert :: Convertable a b => a -> b

-- | A constraint capturing all the extension points that can be converted
--   via <tt>instance Convertable a a</tt>
type ConvertIdX a b = (XHsDoublePrim a ~ XHsDoublePrim b, XHsFloatPrim a ~ XHsFloatPrim b, XHsRat a ~ XHsRat b, XHsInteger a ~ XHsInteger b, XHsWord64Prim a ~ XHsWord64Prim b, XHsInt64Prim a ~ XHsInt64Prim b, XHsWordPrim a ~ XHsWordPrim b, XHsIntPrim a ~ XHsIntPrim b, XHsInt a ~ XHsInt b, XHsStringPrim a ~ XHsStringPrim b, XHsString a ~ XHsString b, XHsCharPrim a ~ XHsCharPrim b, XHsChar a ~ XHsChar b, XXLit a ~ XXLit b)

-- | Provide a summary constraint that gives all am Outputable constraint
--   to extension points needing one
type OutputableX p = (Outputable (XIPBinds p), Outputable (XViaStrategy p), Outputable (XViaStrategy GhcRn))

-- | Constraint type to bundle up the requirement for <a>OutputableBndr</a>
--   on both the <tt>id</tt> and the <a>NameOrRdrName</a> type for it
type OutputableBndrId id = (OutputableBndr (NameOrRdrName (IdP id)), OutputableBndr (IdP id), OutputableBndr (NameOrRdrName (IdP (NoGhcTc id))), OutputableBndr (IdP (NoGhcTc id)), NoGhcTc id ~ NoGhcTc (NoGhcTc id), OutputableX id, OutputableX (NoGhcTc id))
instance Data.Data.Data HsExtension.Pass
instance GHC.Classes.Ord HsExtension.NoExt
instance GHC.Classes.Eq HsExtension.NoExt
instance Data.Data.Data HsExtension.NoExt
instance GHC.Classes.Eq (HsExtension.GhcPass c)
instance Data.Typeable.Internal.Typeable c => Data.Data.Data (HsExtension.GhcPass c)
instance HsExtension.Convertable a a
instance Outputable.Outputable HsExtension.NoExt

module HsImpExp

-- | Located Import Declaration
type LImportDecl pass = Located (ImportDecl pass) " When in a list this may have  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi'"

-- | Import Declaration
--   
--   A single Haskell <tt>import</tt> declaration.
data ImportDecl pass
ImportDecl :: XCImportDecl pass -> SourceText -> Located ModuleName -> Maybe StringLiteral -> Bool -> Bool -> Bool -> Bool -> Maybe (Located ModuleName) -> Maybe (Bool, Located [LIE pass]) -> ImportDecl pass
[ideclExt] :: ImportDecl pass -> XCImportDecl pass
[ideclSourceSrc] :: ImportDecl pass -> SourceText

-- | Module name.
[ideclName] :: ImportDecl pass -> Located ModuleName

-- | Package qualifier.
[ideclPkgQual] :: ImportDecl pass -> Maybe StringLiteral

-- | True <a>=</a> {-# SOURCE #-} import
[ideclSource] :: ImportDecl pass -> Bool

-- | True =&gt; safe import
[ideclSafe] :: ImportDecl pass -> Bool

-- | True =&gt; qualified
[ideclQualified] :: ImportDecl pass -> Bool

-- | True =&gt; implicit import (of Prelude)
[ideclImplicit] :: ImportDecl pass -> Bool

-- | as Module
[ideclAs] :: ImportDecl pass -> Maybe (Located ModuleName)

-- | (True =&gt; hiding, names)
[ideclHiding] :: ImportDecl pass -> Maybe (Bool, Located [LIE pass])

-- | <a>AnnKeywordId</a>s
--   
--   <ul>
--   <li><a>AnnImport</a></li>
--   <li><a>AnnOpen</a>, <a>AnnClose</a> for ideclSource</li>
--   <li><a>AnnSafe</a>,<a>AnnQualified</a>,
--   <a>AnnPackageName</a>,<a>AnnAs</a>, <a>AnnVal</a></li>
--   <li><a>AnnHiding</a>,<a>AnnOpen</a>, <a>AnnClose</a> attached to
--   location in ideclHiding</li>
--   </ul>
XImportDecl :: XXImportDecl pass -> ImportDecl pass
simpleImportDecl :: ModuleName -> ImportDecl (GhcPass p)

-- | A name in an import or export specification which may have adornments.
--   Used primarily for accurate pretty printing of ParsedSource, and API
--   Annotation placement.
data IEWrappedName name

-- | no extra
IEName :: Located name -> IEWrappedName name

-- | pattern X
IEPattern :: Located name -> IEWrappedName name

-- | type (:+:)
IEType :: Located name -> IEWrappedName name

-- | Located name with possible adornment - <a>AnnKeywordId</a>s :
--   <a>AnnType</a>, <a>AnnPattern</a>
type LIEWrappedName name = Located (IEWrappedName name)

-- | Located Import or Export
type LIE pass = Located (IE pass) " When in a list this may have  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma'"

-- | Imported or exported entity.
data IE pass

-- | Imported or Exported Variable
IEVar :: XIEVar pass -> LIEWrappedName (IdP pass) -> IE pass

-- | Imported or exported Thing with Absent list
--   
--   The thing is a Class/Type (can't tell) - <a>AnnKeywordId</a>s :
--   <a>AnnPattern</a>, <a>AnnType</a>,<a>AnnVal</a>
IEThingAbs :: XIEThingAbs pass -> LIEWrappedName (IdP pass) -> IE pass

-- | Imported or exported Thing with All imported or exported
--   
--   The thing is a Class<i>Type and the All refers to
--   methods</i>constructors
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a>,
--   <a>AnnDotdot</a>,<a>AnnClose</a>, <a>AnnType</a></li>
--   </ul>
IEThingAll :: XIEThingAll pass -> LIEWrappedName (IdP pass) -> IE pass

-- | Imported or exported Thing With given imported or exported
--   
--   The thing is a Class/Type and the imported or exported things are
--   methods/constructors and record fields; see Note [IEThingWith] -
--   <a>AnnKeywordId</a>s : <a>AnnOpen</a>, <a>AnnClose</a>,
--   <a>AnnComma</a>, <a>AnnType</a>
IEThingWith :: XIEThingWith pass -> LIEWrappedName (IdP pass) -> IEWildcard -> [LIEWrappedName (IdP pass)] -> [Located (FieldLbl (IdP pass))] -> IE pass

-- | Imported or exported module contents
--   
--   (Export Only)
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnModule</a></li>
--   </ul>
IEModuleContents :: XIEModuleContents pass -> Located ModuleName -> IE pass

-- | Doc section heading
IEGroup :: XIEGroup pass -> Int -> HsDocString -> IE pass

-- | Some documentation
IEDoc :: XIEDoc pass -> HsDocString -> IE pass

-- | Reference to named doc
IEDocNamed :: XIEDocNamed pass -> String -> IE pass
XIE :: XXIE pass -> IE pass

-- | Imported or Exported Wildcard
data IEWildcard
NoIEWildcard :: IEWildcard
IEWildcard :: Int -> IEWildcard
ieName :: IE pass -> IdP pass
ieNames :: IE pass -> [IdP pass]
ieWrappedName :: IEWrappedName name -> name
lieWrappedName :: LIEWrappedName name -> name
ieLWrappedName :: LIEWrappedName name -> Located name
replaceWrappedName :: IEWrappedName name1 -> name2 -> IEWrappedName name2
replaceLWrappedName :: LIEWrappedName name1 -> name2 -> LIEWrappedName name2
pprImpExp :: (HasOccName name, OutputableBndr name) => name -> SDoc
instance Data.Data.Data HsImpExp.IEWildcard
instance GHC.Classes.Eq HsImpExp.IEWildcard
instance Data.Data.Data name => Data.Data.Data (HsImpExp.IEWrappedName name)
instance GHC.Classes.Eq name => GHC.Classes.Eq (HsImpExp.IEWrappedName name)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsImpExp.ImportDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsImpExp.IE p)
instance OccName.HasOccName name => OccName.HasOccName (HsImpExp.IEWrappedName name)
instance Outputable.OutputableBndr name => Outputable.OutputableBndr (HsImpExp.IEWrappedName name)
instance Outputable.OutputableBndr name => Outputable.Outputable (HsImpExp.IEWrappedName name)

module CostCentre

-- | A Cost Centre is a single <tt>{--}</tt> annotation.
data CostCentre
NormalCC :: CCFlavour -> CcName -> Module -> SrcSpan -> CostCentre

-- | Two cost centres may have the same name and module but different
--   SrcSpans, so we need a way to distinguish them easily and give them
--   different object-code labels. So every CostCentre has an associated
--   flavour that indicates how it was generated, and flavours that allow
--   multiple instances of the same name and module have a deterministic
--   0-based index.
[cc_flavour] :: CostCentre -> CCFlavour

-- | Name of the cost centre itself
[cc_name] :: CostCentre -> CcName

-- | Name of module defining this CC.
[cc_mod] :: CostCentre -> Module
[cc_loc] :: CostCentre -> SrcSpan
AllCafsCC :: Module -> SrcSpan -> CostCentre

-- | Name of module defining this CC.
[cc_mod] :: CostCentre -> Module
[cc_loc] :: CostCentre -> SrcSpan
type CcName = FastString

-- | The flavour of a cost centre.
--   
--   Index fields represent 0-based indices giving source-code ordering of
--   centres with the same module, name, and flavour.
data CCFlavour

-- | Auto-generated top-level thunk
CafCC :: CCFlavour

-- | Explicitly annotated expression
ExprCC :: !CostCentreIndex -> CCFlavour

-- | Explicitly annotated declaration
DeclCC :: !CostCentreIndex -> CCFlavour

-- | Generated by HPC for coverage
HpcCC :: !CostCentreIndex -> CCFlavour

-- | A Cost Centre Stack is something that can be attached to a closure.
--   This is either:
--   
--   <ul>
--   <li>the current cost centre stack (CCCS)</li>
--   <li>a pre-defined cost centre stack (there are several pre-defined
--   CCSs, see below).</li>
--   </ul>
data CostCentreStack
type CollectedCCs = ([CostCentre], [CostCentreStack])
emptyCollectedCCs :: CollectedCCs
collectCC :: CostCentre -> CostCentreStack -> CollectedCCs -> CollectedCCs
currentCCS :: CostCentreStack
dontCareCCS :: CostCentreStack
isCurrentCCS :: CostCentreStack -> Bool
maybeSingletonCCS :: CostCentreStack -> Maybe CostCentre
mkUserCC :: FastString -> Module -> SrcSpan -> CCFlavour -> CostCentre
mkAutoCC :: Id -> Module -> CostCentre
mkAllCafsCC :: Module -> SrcSpan -> CostCentre
mkSingletonCCS :: CostCentre -> CostCentreStack
isCafCCS :: CostCentreStack -> Bool
isCafCC :: CostCentre -> Bool

-- | Is this a cost-centre which records scc counts
isSccCountCC :: CostCentre -> Bool

-- | Is this a cost-centre which can be sccd ?
sccAbleCC :: CostCentre -> Bool
ccFromThisModule :: CostCentre -> Module -> Bool

-- | Print a flavour in Core
pprCostCentreCore :: CostCentre -> SDoc
costCentreUserName :: CostCentre -> String
costCentreUserNameFS :: CostCentre -> FastString
costCentreSrcSpan :: CostCentre -> SrcSpan
cmpCostCentre :: CostCentre -> CostCentre -> Ordering
instance GHC.Classes.Ord CostCentre.CostCentreStack
instance GHC.Classes.Eq CostCentre.CostCentreStack
instance Data.Data.Data CostCentre.CostCentre
instance Data.Data.Data CostCentre.CCFlavour
instance GHC.Classes.Ord CostCentre.CCFlavour
instance GHC.Classes.Eq CostCentre.CCFlavour
instance Outputable.Outputable CostCentre.CostCentreStack
instance GHC.Classes.Eq CostCentre.CostCentre
instance GHC.Classes.Ord CostCentre.CostCentre
instance Outputable.Outputable CostCentre.CostCentre
instance Binary.Binary CostCentre.CostCentre
instance Binary.Binary CostCentre.CCFlavour


-- | Module for coercion axioms, used to represent type family instances
--   and newtypes
module CoAxiom
data BranchFlag
type Branched =  'Branched
type Unbranched =  'Unbranched
type BranchIndex = Int
newtype Branches (br :: BranchFlag)
MkBranches :: Array BranchIndex CoAxBranch -> Branches
[unMkBranches] :: Branches -> Array BranchIndex CoAxBranch
manyBranches :: [CoAxBranch] -> Branches Branched
unbranched :: CoAxBranch -> Branches Unbranched
fromBranches :: Branches br -> [CoAxBranch]
numBranches :: Branches br -> Int

-- | The <tt>[CoAxBranch]</tt> passed into the mapping function is a list
--   of all previous branches, reversed
mapAccumBranches :: ([CoAxBranch] -> CoAxBranch -> CoAxBranch) -> Branches br -> Branches br

-- | A <a>CoAxiom</a> is a "coercion constructor", i.e. a named equality
--   axiom.
data CoAxiom br
CoAxiom :: Unique -> Name -> Role -> TyCon -> Branches br -> Bool -> CoAxiom br
[co_ax_unique] :: CoAxiom br -> Unique
[co_ax_name] :: CoAxiom br -> Name
[co_ax_role] :: CoAxiom br -> Role
[co_ax_tc] :: CoAxiom br -> TyCon
[co_ax_branches] :: CoAxiom br -> Branches br
[co_ax_implicit] :: CoAxiom br -> Bool
data CoAxBranch
CoAxBranch :: SrcSpan -> [TyVar] -> [TyVar] -> [CoVar] -> [Role] -> [Type] -> Type -> [CoAxBranch] -> CoAxBranch
[cab_loc] :: CoAxBranch -> SrcSpan
[cab_tvs] :: CoAxBranch -> [TyVar]
[cab_eta_tvs] :: CoAxBranch -> [TyVar]
[cab_cvs] :: CoAxBranch -> [CoVar]
[cab_roles] :: CoAxBranch -> [Role]
[cab_lhs] :: CoAxBranch -> [Type]
[cab_rhs] :: CoAxBranch -> Type
[cab_incomps] :: CoAxBranch -> [CoAxBranch]
toBranchedAxiom :: CoAxiom br -> CoAxiom Branched
toUnbranchedAxiom :: CoAxiom br -> CoAxiom Unbranched
coAxiomName :: CoAxiom br -> Name
coAxiomArity :: CoAxiom br -> BranchIndex -> Arity
coAxiomBranches :: CoAxiom br -> Branches br
coAxiomTyCon :: CoAxiom br -> TyCon
isImplicitCoAxiom :: CoAxiom br -> Bool
coAxiomNumPats :: CoAxiom br -> Int
coAxiomNthBranch :: CoAxiom br -> BranchIndex -> CoAxBranch
coAxiomSingleBranch_maybe :: CoAxiom br -> Maybe CoAxBranch
coAxiomRole :: CoAxiom br -> Role
coAxiomSingleBranch :: CoAxiom Unbranched -> CoAxBranch
coAxBranchTyVars :: CoAxBranch -> [TyVar]
coAxBranchCoVars :: CoAxBranch -> [CoVar]
coAxBranchRoles :: CoAxBranch -> [Role]
coAxBranchLHS :: CoAxBranch -> [Type]
coAxBranchRHS :: CoAxBranch -> Type
coAxBranchSpan :: CoAxBranch -> SrcSpan
coAxBranchIncomps :: CoAxBranch -> [CoAxBranch]
placeHolderIncomps :: [CoAxBranch]
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
fsFromRole :: Role -> FastString

-- | For now, we work only with nominal equality.
data CoAxiomRule
CoAxiomRule :: FastString -> [Role] -> Role -> ([TypeEqn] -> Maybe TypeEqn) -> CoAxiomRule
[coaxrName] :: CoAxiomRule -> FastString
[coaxrAsmpRoles] :: CoAxiomRule -> [Role]
[coaxrRole] :: CoAxiomRule -> Role

-- | coaxrProves returns <tt>Nothing</tt> when it doesn't like the supplied
--   arguments. When this happens in a coercion that means that the
--   coercion is ill-formed, and Core Lint checks for that.
[coaxrProves] :: CoAxiomRule -> [TypeEqn] -> Maybe TypeEqn

-- | A more explicit representation for `t1 ~ t2`.
type TypeEqn = Pair Type
data BuiltInSynFamily
BuiltInSynFamily :: ([Type] -> Maybe (CoAxiomRule, [Type], Type)) -> ([Type] -> Type -> [TypeEqn]) -> ([Type] -> Type -> [Type] -> Type -> [TypeEqn]) -> BuiltInSynFamily
[sfMatchFam] :: BuiltInSynFamily -> [Type] -> Maybe (CoAxiomRule, [Type], Type)
[sfInteractTop] :: BuiltInSynFamily -> [Type] -> Type -> [TypeEqn]
[sfInteractInert] :: BuiltInSynFamily -> [Type] -> Type -> [Type] -> Type -> [TypeEqn]
trivialBuiltInFamily :: BuiltInSynFamily
instance Data.Data.Data CoAxiom.CoAxBranch
instance Data.Data.Data CoAxiom.Role
instance GHC.Classes.Ord CoAxiom.Role
instance GHC.Classes.Eq CoAxiom.Role
instance Data.Data.Data CoAxiom.CoAxiomRule
instance Unique.Uniquable CoAxiom.CoAxiomRule
instance GHC.Classes.Eq CoAxiom.CoAxiomRule
instance GHC.Classes.Ord CoAxiom.CoAxiomRule
instance Outputable.Outputable CoAxiom.CoAxiomRule
instance GHC.Classes.Eq (CoAxiom.CoAxiom br)
instance Unique.Uniquable (CoAxiom.CoAxiom br)
instance Outputable.Outputable (CoAxiom.CoAxiom br)
instance Name.NamedThing (CoAxiom.CoAxiom br)
instance Data.Typeable.Internal.Typeable br => Data.Data.Data (CoAxiom.CoAxiom br)
instance Outputable.Outputable CoAxiom.CoAxBranch
instance Outputable.Outputable CoAxiom.Role
instance Binary.Binary CoAxiom.Role

module Class
data Class
type ClassOpItem = (Id, DefMethInfo)
data ClassATItem
ATI :: TyCon -> Maybe (Type, SrcSpan) -> ClassATItem
type ClassMinimalDef = BooleanFormula Name
type DefMethInfo = Maybe (Name, DefMethSpec Type)
pprDefMethInfo :: DefMethInfo -> SDoc
type FunDep a = ([a], [a])
pprFundeps :: Outputable a => [FunDep a] -> SDoc
pprFunDep :: Outputable a => FunDep a -> SDoc
mkClass :: Name -> [TyVar] -> [FunDep TyVar] -> [PredType] -> [Id] -> [ClassATItem] -> [ClassOpItem] -> ClassMinimalDef -> TyCon -> Class
mkAbstractClass :: Name -> [TyVar] -> [FunDep TyVar] -> TyCon -> Class
classTyVars :: Class -> [TyVar]
classArity :: Class -> Arity
classKey :: Class -> Unique
className :: Class -> Name
classATs :: Class -> [TyCon]
classATItems :: Class -> [ClassATItem]
classTyCon :: Class -> TyCon
classMethods :: Class -> [Id]
classOpItems :: Class -> [ClassOpItem]
classBigSig :: Class -> ([TyVar], [PredType], [Id], [ClassOpItem])
classExtraBigSig :: Class -> ([TyVar], [FunDep TyVar], [PredType], [Id], [ClassATItem], [ClassOpItem])
classTvsFds :: Class -> ([TyVar], [FunDep TyVar])
classSCTheta :: Class -> [PredType]
classAllSelIds :: Class -> [Id]
classSCSelId :: Class -> Int -> Id
classSCSelIds :: Class -> [Id]
classMinimalDef :: Class -> ClassMinimalDef
classHasFds :: Class -> Bool
isAbstractClass :: Class -> Bool
instance GHC.Classes.Eq Class.Class
instance Unique.Uniquable Class.Class
instance Name.NamedThing Class.Class
instance Outputable.Outputable Class.Class
instance Data.Data.Data Class.Class

module VarSet

-- | A non-deterministic Variable Set
--   
--   A non-deterministic set of variables. See Note [Deterministic UniqFM]
--   in UniqDFM for explanation why it's not deterministic and why it
--   matters. Use DVarSet if the set eventually gets converted into a list
--   or folded over in a way where the order changes the generated code,
--   for example when abstracting variables.
type VarSet = UniqSet Var

-- | Identifier Set
type IdSet = UniqSet Id

-- | Type Variable Set
type TyVarSet = UniqSet TyVar

-- | Coercion Variable Set
type CoVarSet = UniqSet CoVar

-- | Type or Coercion Variable Set
type TyCoVarSet = UniqSet TyCoVar
emptyVarSet :: VarSet
unitVarSet :: Var -> VarSet
mkVarSet :: [Var] -> VarSet
extendVarSet :: VarSet -> Var -> VarSet
extendVarSetList :: VarSet -> [Var] -> VarSet
elemVarSet :: Var -> VarSet -> Bool
subVarSet :: VarSet -> VarSet -> Bool
unionVarSet :: VarSet -> VarSet -> VarSet
unionVarSets :: [VarSet] -> VarSet

-- | map the function over the list, and union the results
mapUnionVarSet :: (a -> VarSet) -> [a] -> VarSet
intersectVarSet :: VarSet -> VarSet -> VarSet
intersectsVarSet :: VarSet -> VarSet -> Bool
disjointVarSet :: VarSet -> VarSet -> Bool
isEmptyVarSet :: VarSet -> Bool
delVarSet :: VarSet -> Var -> VarSet
delVarSetList :: VarSet -> [Var] -> VarSet
delVarSetByKey :: VarSet -> Unique -> VarSet
minusVarSet :: VarSet -> VarSet -> VarSet
filterVarSet :: (Var -> Bool) -> VarSet -> VarSet
mapVarSet :: Uniquable b => (a -> b) -> UniqSet a -> UniqSet b
anyVarSet :: (Var -> Bool) -> VarSet -> Bool
allVarSet :: (Var -> Bool) -> VarSet -> Bool
transCloVarSet :: (VarSet -> VarSet) -> VarSet -> VarSet
fixVarSet :: (VarSet -> VarSet) -> VarSet -> VarSet
lookupVarSet_Directly :: VarSet -> Unique -> Maybe Var
lookupVarSet :: VarSet -> Var -> Maybe Var
lookupVarSetByName :: VarSet -> Name -> Maybe Var
sizeVarSet :: VarSet -> Int
seqVarSet :: VarSet -> ()
elemVarSetByKey :: Unique -> VarSet -> Bool
partitionVarSet :: (Var -> Bool) -> VarSet -> (VarSet, VarSet)

-- | Determines the pluralisation suffix appropriate for the length of a
--   set in the same way that plural from Outputable does for lists.
pluralVarSet :: VarSet -> SDoc

-- | Pretty-print a non-deterministic set. The order of variables is
--   non-deterministic and for pretty-printing that shouldn't be a problem.
--   Having this function helps contain the non-determinism created with
--   nonDetEltsUFM. Passing a list to the pretty-printing function allows
--   the caller to decide on the order of Vars (eg. toposort them) without
--   them having to use nonDetEltsUFM at the call site. This prevents from
--   let-binding non-deterministically ordered lists and reusing them where
--   determinism matters.
pprVarSet :: VarSet -> ([Var] -> SDoc) -> SDoc

-- | Deterministic Variable Set
type DVarSet = UniqDSet Var

-- | Deterministic Identifier Set
type DIdSet = UniqDSet Id

-- | Deterministic Type Variable Set
type DTyVarSet = UniqDSet TyVar

-- | Deterministic Type or Coercion Variable Set
type DTyCoVarSet = UniqDSet TyCoVar
emptyDVarSet :: DVarSet
unitDVarSet :: Var -> DVarSet
mkDVarSet :: [Var] -> DVarSet
extendDVarSet :: DVarSet -> Var -> DVarSet

-- | Add a list of variables to DVarSet
extendDVarSetList :: DVarSet -> [Var] -> DVarSet
elemDVarSet :: Var -> DVarSet -> Bool
dVarSetElems :: DVarSet -> [Var]
subDVarSet :: DVarSet -> DVarSet -> Bool
unionDVarSet :: DVarSet -> DVarSet -> DVarSet
unionDVarSets :: [DVarSet] -> DVarSet

-- | Map the function over the list, and union the results
mapUnionDVarSet :: (a -> DVarSet) -> [a] -> DVarSet
intersectDVarSet :: DVarSet -> DVarSet -> DVarSet
dVarSetIntersectVarSet :: DVarSet -> VarSet -> DVarSet

-- | True if non-empty intersection
intersectsDVarSet :: DVarSet -> DVarSet -> Bool

-- | True if empty intersection
disjointDVarSet :: DVarSet -> DVarSet -> Bool
isEmptyDVarSet :: DVarSet -> Bool
delDVarSet :: DVarSet -> Var -> DVarSet

-- | Delete a list of variables from DVarSet
delDVarSetList :: DVarSet -> [Var] -> DVarSet
minusDVarSet :: DVarSet -> DVarSet -> DVarSet
foldDVarSet :: (Var -> a -> a) -> a -> DVarSet -> a
filterDVarSet :: (Var -> Bool) -> DVarSet -> DVarSet
mapDVarSet :: Uniquable b => (a -> b) -> UniqDSet a -> UniqDSet b
dVarSetMinusVarSet :: DVarSet -> VarSet -> DVarSet
anyDVarSet :: (Var -> Bool) -> DVarSet -> Bool
allDVarSet :: (Var -> Bool) -> DVarSet -> Bool

-- | transCloVarSet for DVarSet
transCloDVarSet :: (DVarSet -> DVarSet) -> DVarSet -> DVarSet
sizeDVarSet :: DVarSet -> Int
seqDVarSet :: DVarSet -> ()

-- | Partition DVarSet according to the predicate given
partitionDVarSet :: (Var -> Bool) -> DVarSet -> (DVarSet, DVarSet)

-- | Convert a DVarSet to a VarSet by forgeting the order of insertion
dVarSetToVarSet :: DVarSet -> VarSet

module VarEnv

-- | Variable Environment
type VarEnv elt = UniqFM elt

-- | Identifier Environment
type IdEnv elt = VarEnv elt

-- | Type Variable Environment
type TyVarEnv elt = VarEnv elt

-- | Coercion Variable Environment
type CoVarEnv elt = VarEnv elt

-- | Type or Coercion Variable Environment
type TyCoVarEnv elt = VarEnv elt
emptyVarEnv :: VarEnv a
unitVarEnv :: Var -> a -> VarEnv a
mkVarEnv :: [(Var, a)] -> VarEnv a
mkVarEnv_Directly :: [(Unique, a)] -> VarEnv a
elemVarEnv :: Var -> VarEnv a -> Bool
disjointVarEnv :: VarEnv a -> VarEnv a -> Bool
extendVarEnv :: VarEnv a -> Var -> a -> VarEnv a
extendVarEnv_C :: (a -> a -> a) -> VarEnv a -> Var -> a -> VarEnv a
extendVarEnv_Acc :: (a -> b -> b) -> (a -> b) -> VarEnv b -> Var -> a -> VarEnv b
extendVarEnv_Directly :: VarEnv a -> Unique -> a -> VarEnv a
extendVarEnvList :: VarEnv a -> [(Var, a)] -> VarEnv a
plusVarEnv :: VarEnv a -> VarEnv a -> VarEnv a
plusVarEnv_C :: (a -> a -> a) -> VarEnv a -> VarEnv a -> VarEnv a
plusVarEnv_CD :: (a -> a -> a) -> VarEnv a -> a -> VarEnv a -> a -> VarEnv a
plusMaybeVarEnv_C :: (a -> a -> Maybe a) -> VarEnv a -> VarEnv a -> VarEnv a
plusVarEnvList :: [VarEnv a] -> VarEnv a
alterVarEnv :: (Maybe a -> Maybe a) -> VarEnv a -> Var -> VarEnv a
delVarEnvList :: VarEnv a -> [Var] -> VarEnv a
delVarEnv :: VarEnv a -> Var -> VarEnv a
delVarEnv_Directly :: VarEnv a -> Unique -> VarEnv a
minusVarEnv :: VarEnv a -> VarEnv b -> VarEnv a
intersectsVarEnv :: VarEnv a -> VarEnv a -> Bool
lookupVarEnv :: VarEnv a -> Var -> Maybe a
lookupVarEnv_NF :: VarEnv a -> Var -> a
lookupWithDefaultVarEnv :: VarEnv a -> a -> Var -> a
mapVarEnv :: (a -> b) -> VarEnv a -> VarEnv b
zipVarEnv :: [Var] -> [a] -> VarEnv a
modifyVarEnv :: (a -> a) -> VarEnv a -> Var -> VarEnv a
modifyVarEnv_Directly :: (a -> a) -> UniqFM a -> Unique -> UniqFM a
isEmptyVarEnv :: VarEnv a -> Bool
elemVarEnvByKey :: Unique -> VarEnv a -> Bool
lookupVarEnv_Directly :: VarEnv a -> Unique -> Maybe a
filterVarEnv :: (a -> Bool) -> VarEnv a -> VarEnv a
filterVarEnv_Directly :: (Unique -> a -> Bool) -> VarEnv a -> VarEnv a
restrictVarEnv :: VarEnv a -> VarSet -> VarEnv a
partitionVarEnv :: (a -> Bool) -> VarEnv a -> (VarEnv a, VarEnv a)

-- | Deterministic Variable Environment
type DVarEnv elt = UniqDFM elt

-- | Deterministic Identifier Environment
type DIdEnv elt = DVarEnv elt

-- | Deterministic Type Variable Environment
type DTyVarEnv elt = DVarEnv elt
emptyDVarEnv :: DVarEnv a
mkDVarEnv :: [(Var, a)] -> DVarEnv a
dVarEnvElts :: DVarEnv a -> [a]
extendDVarEnv :: DVarEnv a -> Var -> a -> DVarEnv a
extendDVarEnv_C :: (a -> a -> a) -> DVarEnv a -> Var -> a -> DVarEnv a
extendDVarEnvList :: DVarEnv a -> [(Var, a)] -> DVarEnv a
lookupDVarEnv :: DVarEnv a -> Var -> Maybe a
elemDVarEnv :: Var -> DVarEnv a -> Bool
isEmptyDVarEnv :: DVarEnv a -> Bool
foldDVarEnv :: (a -> b -> b) -> b -> DVarEnv a -> b
mapDVarEnv :: (a -> b) -> DVarEnv a -> DVarEnv b
filterDVarEnv :: (a -> Bool) -> DVarEnv a -> DVarEnv a
modifyDVarEnv :: (a -> a) -> DVarEnv a -> Var -> DVarEnv a
alterDVarEnv :: (Maybe a -> Maybe a) -> DVarEnv a -> Var -> DVarEnv a
plusDVarEnv :: DVarEnv a -> DVarEnv a -> DVarEnv a
plusDVarEnv_C :: (a -> a -> a) -> DVarEnv a -> DVarEnv a -> DVarEnv a
unitDVarEnv :: Var -> a -> DVarEnv a
delDVarEnv :: DVarEnv a -> Var -> DVarEnv a
delDVarEnvList :: DVarEnv a -> [Var] -> DVarEnv a
minusDVarEnv :: DVarEnv a -> DVarEnv a' -> DVarEnv a
partitionDVarEnv :: (a -> Bool) -> DVarEnv a -> (DVarEnv a, DVarEnv a)
anyDVarEnv :: (a -> Bool) -> DVarEnv a -> Bool

-- | A set of variables that are in scope at some point "Secrets of the
--   Glasgow Haskell Compiler inliner" Section 3.2 provides the motivation
--   for this abstraction.
data InScopeSet
emptyInScopeSet :: InScopeSet
mkInScopeSet :: VarSet -> InScopeSet
delInScopeSet :: InScopeSet -> Var -> InScopeSet
extendInScopeSet :: InScopeSet -> Var -> InScopeSet
extendInScopeSetList :: InScopeSet -> [Var] -> InScopeSet
extendInScopeSetSet :: InScopeSet -> VarSet -> InScopeSet
getInScopeVars :: InScopeSet -> VarSet

-- | Look up a variable the <a>InScopeSet</a>. This lets you map from the
--   variable's identity (unique) to its full value.
lookupInScope :: InScopeSet -> Var -> Maybe Var
lookupInScope_Directly :: InScopeSet -> Unique -> Maybe Var
unionInScope :: InScopeSet -> InScopeSet -> InScopeSet
elemInScopeSet :: Var -> InScopeSet -> Bool

-- | <tt>uniqAway in_scope v</tt> finds a unique that is not used in the
--   in-scope set, and gives that to v.
uniqAway :: InScopeSet -> Var -> Var
varSetInScope :: VarSet -> InScopeSet -> Bool

-- | Rename Environment 2
--   
--   When we are comparing (or matching) types or terms, we are faced with
--   "going under" corresponding binders. E.g. when comparing:
--   
--   <pre>
--   \x. e1     ~   \y. e2
--   </pre>
--   
--   Basically we want to rename [<tt>x</tt> -&gt; <tt>y</tt>] or
--   [<tt>y</tt> -&gt; <tt>x</tt>], but there are lots of things we must be
--   careful of. In particular, <tt>x</tt> might be free in <tt>e2</tt>, or
--   y in <tt>e1</tt>. So the idea is that we come up with a fresh binder
--   that is free in neither, and rename <tt>x</tt> and <tt>y</tt>
--   respectively. That means we must maintain:
--   
--   <ol>
--   <li>A renaming for the left-hand expression</li>
--   <li>A renaming for the right-hand expressions</li>
--   <li>An in-scope set</li>
--   </ol>
--   
--   Furthermore, when matching, we want to be able to have an 'occurs
--   check', to prevent:
--   
--   <pre>
--   \x. f   ~   \y. y
--   </pre>
--   
--   matching with [<tt>f</tt> -&gt; <tt>y</tt>]. So for each expression we
--   want to know that set of locally-bound variables. That is precisely
--   the domain of the mappings 1. and 2., but we must ensure that we
--   always extend the mappings as we go in.
--   
--   All of this information is bundled up in the <a>RnEnv2</a>
data RnEnv2
mkRnEnv2 :: InScopeSet -> RnEnv2

-- | <tt>rnBndr2 env bL bR</tt> goes under a binder <tt>bL</tt> in the Left
--   term, and binder <tt>bR</tt> in the Right term. It finds a new binder,
--   <tt>new_b</tt>, and returns an environment mapping <tt>bL -&gt;
--   new_b</tt> and <tt>bR -&gt; new_b</tt>
rnBndr2 :: RnEnv2 -> Var -> Var -> RnEnv2

-- | Applies <a>rnBndr2</a> to several variables: the two variable lists
--   must be of equal length
rnBndrs2 :: RnEnv2 -> [Var] -> [Var] -> RnEnv2

-- | Similar to <a>rnBndr2</a> but returns the new variable as well as the
--   new environment
rnBndr2_var :: RnEnv2 -> Var -> Var -> (RnEnv2, Var)

-- | Look up the renaming of an occurrence in the left or right term
rnOccL :: RnEnv2 -> Var -> Var

-- | Look up the renaming of an occurrence in the left or right term
rnOccR :: RnEnv2 -> Var -> Var

-- | Tells whether a variable is locally bound
inRnEnvL :: RnEnv2 -> Var -> Bool

-- | Tells whether a variable is locally bound
inRnEnvR :: RnEnv2 -> Var -> Bool

-- | Look up the renaming of an occurrence in the left or right term
rnOccL_maybe :: RnEnv2 -> Var -> Maybe Var

-- | Look up the renaming of an occurrence in the left or right term
rnOccR_maybe :: RnEnv2 -> Var -> Maybe Var

-- | Similar to <a>rnBndr2</a> but used when there's a binder on the left
--   side only.
rnBndrL :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Similar to <a>rnBndr2</a> but used when there's a binder on the right
--   side only.
rnBndrR :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Wipe the left or right side renaming
nukeRnEnvL :: RnEnv2 -> RnEnv2

-- | Wipe the left or right side renaming
nukeRnEnvR :: RnEnv2 -> RnEnv2

-- | swap the meaning of left and right
rnSwap :: RnEnv2 -> RnEnv2
delBndrL :: RnEnv2 -> Var -> RnEnv2
delBndrR :: RnEnv2 -> Var -> RnEnv2
delBndrsL :: RnEnv2 -> [Var] -> RnEnv2
delBndrsR :: RnEnv2 -> [Var] -> RnEnv2
addRnInScopeSet :: RnEnv2 -> VarSet -> RnEnv2

-- | Similar to <a>rnBndrL</a> but used for eta expansion See Note [Eta
--   expansion]
rnEtaL :: RnEnv2 -> Var -> (RnEnv2, Var)

-- | Similar to <a>rnBndr2</a> but used for eta expansion See Note [Eta
--   expansion]
rnEtaR :: RnEnv2 -> Var -> (RnEnv2, Var)
rnInScope :: Var -> RnEnv2 -> Bool
rnInScopeSet :: RnEnv2 -> InScopeSet
lookupRnInScope :: RnEnv2 -> Var -> Var

-- | Retrieve the left mapping
rnEnvL :: RnEnv2 -> VarEnv Var

-- | Retrieve the right mapping
rnEnvR :: RnEnv2 -> VarEnv Var

-- | Tidy Environment
--   
--   When tidying up print names, we keep a mapping of in-scope occ-names
--   (the <a>TidyOccEnv</a>) and a Var-to-Var of the current renamings
type TidyEnv = (TidyOccEnv, VarEnv Var)
emptyTidyEnv :: TidyEnv
mkEmptyTidyEnv :: TidyOccEnv -> TidyEnv
instance Outputable.Outputable VarEnv.InScopeSet

module TyCon

-- | TyCons represent type constructors. Type constructors are introduced
--   by things such as:
--   
--   1) Data declarations: <tt>data Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor of kind <tt>*</tt>
--   
--   2) Type synonyms: <tt>type Foo = ...</tt> creates the <tt>Foo</tt>
--   type constructor
--   
--   3) Newtypes: <tt>newtype Foo a = MkFoo ...</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>* -&gt; *</tt>
--   
--   4) Class declarations: <tt>class Foo where</tt> creates the
--   <tt>Foo</tt> type constructor of kind <tt>*</tt>
--   
--   This data type also encodes a number of primitive, built in type
--   constructors such as those for function and tuple types.
data TyCon

-- | Represents right-hand-sides of <a>TyCon</a>s for algebraic types
data AlgTyConRhs

-- | Says that we know nothing about this data type, except that it's
--   represented by a pointer. Used when we export a data type abstractly
--   into an .hi file.
AbstractTyCon :: AlgTyConRhs

-- | Information about those <a>TyCon</a>s derived from a <tt>data</tt>
--   declaration. This includes data types with no constructors at all.
DataTyCon :: [DataCon] -> Int -> Bool -> AlgTyConRhs

-- | The data type constructors; can be empty if the user declares the type
--   to have no constructors
--   
--   INVARIANT: Kept in order of increasing <a>DataCon</a> tag (see the tag
--   assignment in mkTyConTagMap)
[data_cons] :: AlgTyConRhs -> [DataCon]

-- | Cached value: length data_cons
[data_cons_size] :: AlgTyConRhs -> Int

-- | Cached value: is this an enumeration type? See Note [Enumeration
--   types]
[is_enum] :: AlgTyConRhs -> Bool
TupleTyCon :: DataCon -> TupleSort -> AlgTyConRhs

-- | The unique constructor for the <tt>newtype</tt>. It has no
--   existentials
[data_con] :: AlgTyConRhs -> DataCon

-- | Is this a boxed, unboxed or constraint tuple?
[tup_sort] :: AlgTyConRhs -> TupleSort

-- | An unboxed sum type.
SumTyCon :: [DataCon] -> Int -> AlgTyConRhs

-- | The data type constructors; can be empty if the user declares the type
--   to have no constructors
--   
--   INVARIANT: Kept in order of increasing <a>DataCon</a> tag (see the tag
--   assignment in mkTyConTagMap)
[data_cons] :: AlgTyConRhs -> [DataCon]

-- | Cached value: length data_cons
[data_cons_size] :: AlgTyConRhs -> Int

-- | Information about those <a>TyCon</a>s derived from a <tt>newtype</tt>
--   declaration
NewTyCon :: DataCon -> Type -> ([TyVar], Type) -> CoAxiom Unbranched -> AlgTyConRhs

-- | The unique constructor for the <tt>newtype</tt>. It has no
--   existentials
[data_con] :: AlgTyConRhs -> DataCon

-- | Cached value: the argument type of the constructor, which is just the
--   representation type of the <a>TyCon</a> (remember that
--   <tt>newtype</tt>s do not exist at runtime so need a different
--   representation type).
--   
--   The free <a>TyVar</a>s of this type are the <a>tyConTyVars</a> from
--   the corresponding <a>TyCon</a>
[nt_rhs] :: AlgTyConRhs -> Type

-- | Same as the <a>nt_rhs</a>, but this time eta-reduced. Hence the list
--   of <a>TyVar</a>s in this field may be shorter than the declared arity
--   of the <a>TyCon</a>.
[nt_etad_rhs] :: AlgTyConRhs -> ([TyVar], Type)
[nt_co] :: AlgTyConRhs -> CoAxiom Unbranched

-- | Both type classes as well as family instances imply implicit type
--   constructors. These implicit type constructors refer to their parent
--   structure (ie, the class or family from which they derive) using a
--   type of the following form.
--   
--   Extract those <a>DataCon</a>s that we are able to learn about. Note
--   that visibility in this sense does not correspond to visibility in the
--   context of any particular user program!
visibleDataCons :: AlgTyConRhs -> [DataCon]
data AlgTyConFlav

-- | An ordinary type constructor has no parent.
VanillaAlgTyCon :: TyConRepName -> AlgTyConFlav

-- | An unboxed type constructor. The TyConRepName is a Maybe since we
--   currently don't allow unboxed sums to be Typeable since there are too
--   many of them. See #13276.
UnboxedAlgTyCon :: Maybe TyConRepName -> AlgTyConFlav

-- | Type constructors representing a class dictionary. See Note [ATyCon
--   for classes] in TyCoRep
ClassTyCon :: Class -> TyConRepName -> AlgTyConFlav

-- | Type constructors representing an *instance* of a *data* family.
--   Parameters:
--   
--   1) The type family in question
--   
--   2) Instance types; free variables are the <a>tyConTyVars</a> of the
--   current <a>TyCon</a> (not the family one). INVARIANT: the number of
--   types matches the arity of the family <a>TyCon</a>
--   
--   3) A <tt>CoTyCon</tt> identifying the representation type with the
--   type instance family
DataFamInstTyCon :: CoAxiom Unbranched -> TyCon -> [Type] -> AlgTyConFlav
isNoParent :: AlgTyConFlav -> Bool

-- | Information pertaining to the expansion of a type synonym
--   (<tt>type</tt>)
data FamTyConFlav

-- | Represents an open type family without a fixed right hand side.
--   Additional instances can appear at any time.
--   
--   These are introduced by either a top level declaration:
--   
--   <pre>
--   data family T a :: *
--   </pre>
--   
--   Or an associated data type declaration, within a class declaration:
--   
--   <pre>
--   class C a b where
--     data T b :: *
--   </pre>
DataFamilyTyCon :: TyConRepName -> FamTyConFlav

-- | An open type synonym family e.g. <tt>type family F x y :: * -&gt;
--   *</tt>
OpenSynFamilyTyCon :: FamTyConFlav

-- | A closed type synonym family e.g. <tt>type family F x where { F Int =
--   Bool }</tt>
ClosedSynFamilyTyCon :: Maybe (CoAxiom Branched) -> FamTyConFlav

-- | A closed type synonym family declared in an hs-boot file with type
--   family F a where ..
AbstractClosedSynFamilyTyCon :: FamTyConFlav

-- | Built-in type family used by the TypeNats solver
BuiltInSynFamTyCon :: BuiltInSynFamily -> FamTyConFlav
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
data Injectivity
NotInjective :: Injectivity
Injective :: [Bool] -> Injectivity

-- | Some promoted datacons signify extra info relevant to GHC. For
--   example, the <tt>IntRep</tt> constructor of <tt>RuntimeRep</tt>
--   corresponds to the <a>IntRep</a> constructor of <a>PrimRep</a>. This
--   data structure allows us to store this information right in the
--   <a>TyCon</a>. The other approach would be to look up things like
--   <tt>RuntimeRep</tt>'s <tt>PrimRep</tt> by known-key every time.
data RuntimeRepInfo

-- | an ordinary promoted data con
NoRRI :: RuntimeRepInfo

-- | A constructor of <tt>RuntimeRep</tt>. The argument to the function
--   should be the list of arguments to the promoted datacon.
RuntimeRep :: ([Type] -> [PrimRep]) -> RuntimeRepInfo

-- | A constructor of <tt>VecCount</tt>
VecCount :: Int -> RuntimeRepInfo

-- | A constructor of <tt>VecElem</tt>
VecElem :: PrimElemRep -> RuntimeRepInfo

-- | Paints a picture of what a <a>TyCon</a> represents, in broad strokes.
--   This is used towards more informative error messages.
data TyConFlavour
ClassFlavour :: TyConFlavour
TupleFlavour :: Boxity -> TyConFlavour
SumFlavour :: TyConFlavour
DataTypeFlavour :: TyConFlavour
NewtypeFlavour :: TyConFlavour
AbstractTypeFlavour :: TyConFlavour
DataFamilyFlavour :: Maybe TyCon -> TyConFlavour
OpenTypeFamilyFlavour :: Maybe TyCon -> TyConFlavour
ClosedTypeFamilyFlavour :: TyConFlavour
TypeSynonymFlavour :: TyConFlavour

-- | e.g., the <tt>(-&gt;)</tt> <a>TyCon</a>.
BuiltInTypeFlavour :: TyConFlavour
PromotedDataConFlavour :: TyConFlavour
type TyConBinder = VarBndr TyVar TyConBndrVis
data TyConBndrVis
NamedTCB :: ArgFlag -> TyConBndrVis
AnonTCB :: TyConBndrVis
type TyConTyCoBinder = VarBndr TyCoVar TyConBndrVis
mkNamedTyConBinder :: ArgFlag -> TyVar -> TyConBinder
mkNamedTyConBinders :: ArgFlag -> [TyVar] -> [TyConBinder]

-- | Make a Required TyConBinder. It chooses between NamedTCB and AnonTCB
--   based on whether the tv is mentioned in the dependent set
mkRequiredTyConBinder :: TyCoVarSet -> TyVar -> TyConBinder
mkAnonTyConBinder :: TyVar -> TyConBinder
mkAnonTyConBinders :: [TyVar] -> [TyConBinder]
tyConBinderArgFlag :: TyConBinder -> ArgFlag
tyConBndrVisArgFlag :: TyConBndrVis -> ArgFlag
isNamedTyConBinder :: TyConBinder -> Bool
isVisibleTyConBinder :: VarBndr tv TyConBndrVis -> Bool
isInvisibleTyConBinder :: VarBndr tv TyConBndrVis -> Bool

-- | The labels for the fields of this particular <a>TyCon</a>
tyConFieldLabels :: TyCon -> [FieldLabel]

-- | Look up a field label belonging to this <a>TyCon</a>
lookupTyConFieldLabel :: FieldLabelString -> TyCon -> Maybe FieldLabel

-- | This is the making of an algebraic <a>TyCon</a>. Notably, you have to
--   pass in the generic (in the -XGenerics sense) information about the
--   type constructor - you can get hold of it easily (see Generics module)
mkAlgTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> Maybe CType -> [PredType] -> AlgTyConRhs -> AlgTyConFlav -> Bool -> TyCon

-- | Simpler specialization of <a>mkAlgTyCon</a> for classes
mkClassTyCon :: Name -> [TyConBinder] -> [Role] -> AlgTyConRhs -> Class -> Name -> TyCon

-- | Given the name of the function type constructor and it's kind, create
--   the corresponding <a>TyCon</a>. It is recommended to use
--   <a>funTyCon</a> if you want this functionality
mkFunTyCon :: Name -> [TyConBinder] -> Name -> TyCon

-- | Create an unlifted primitive <a>TyCon</a>, such as <tt>Int#</tt>.
mkPrimTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> TyCon

-- | Kind constructors
mkKindTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> Name -> TyCon

-- | Create a lifted primitive <a>TyCon</a> such as <tt>RealWorld</tt>
mkLiftedPrimTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> TyCon
mkTupleTyCon :: Name -> [TyConBinder] -> Kind -> Arity -> DataCon -> TupleSort -> AlgTyConFlav -> TyCon
mkSumTyCon :: Name -> [TyConBinder] -> Kind -> Arity -> [TyVar] -> [DataCon] -> AlgTyConFlav -> TyCon
mkDataTyConRhs :: [DataCon] -> AlgTyConRhs

-- | Create a type synonym <a>TyCon</a>
mkSynonymTyCon :: Name -> [TyConBinder] -> Kind -> [Role] -> Type -> Bool -> Bool -> TyCon

-- | Create a type family <a>TyCon</a>
mkFamilyTyCon :: Name -> [TyConBinder] -> Kind -> Maybe Name -> FamTyConFlav -> Maybe Class -> Injectivity -> TyCon

-- | Create a promoted data constructor <a>TyCon</a> Somewhat dodgily, we
--   give it the same Name as the data constructor itself; when we
--   pretty-print the TyCon we add a quote; see the Outputable TyCon
--   instance
mkPromotedDataCon :: DataCon -> Name -> TyConRepName -> [TyConTyCoBinder] -> Kind -> [Role] -> RuntimeRepInfo -> TyCon

-- | Makes a tycon suitable for use during type-checking. It stores a
--   variety of details about the definition of the TyCon, but no
--   right-hand side. It lives only during the type-checking of a
--   mutually-recursive group of tycons; it is then zonked to a proper
--   TyCon in zonkTcTyCon. See also Note [Kind checking recursive type and
--   class declarations] in TcTyClsDecls.
mkTcTyCon :: Name -> SDoc -> [TyConBinder] -> Kind -> [(Name, TcTyVar)] -> Bool -> TyConFlavour -> TyCon

-- | Returns <tt>True</tt> if the supplied <a>TyCon</a> resulted from
--   either a <tt>data</tt> or <tt>newtype</tt> declaration
isAlgTyCon :: TyCon -> Bool

-- | Returns <tt>True</tt> for vanilla AlgTyCons -- that is, those created
--   with a <tt>data</tt> or <tt>newtype</tt> declaration.
isVanillaAlgTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a class instance?
isClassTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a data family instance?
isFamInstTyCon :: TyCon -> Bool
isFunTyCon :: TyCon -> Bool

-- | Does this <a>TyCon</a> represent something that cannot be defined in
--   Haskell?
isPrimTyCon :: TyCon -> Bool

-- | Does this <a>TyCon</a> represent a tuple?
--   
--   NB: when compiling <tt>Data.Tuple</tt>, the tycons won't reply
--   <tt>True</tt> to <a>isTupleTyCon</a>, because they are built as
--   <tt>AlgTyCons</tt>. However they get spat into the interface file as
--   tuple tycons, so I don't think it matters.
isTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for an unboxed tuple?
isUnboxedTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for a boxed tuple?
isBoxedTupleTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for an unboxed sum?
isUnboxedSumTyCon :: TyCon -> Bool

-- | Is this the <a>TyCon</a> for a <i>promoted</i> tuple?
isPromotedTupleTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a> representing a regular H98 type synonym
--   (<tt>type</tt>)?
isTypeSynonymTyCon :: TyCon -> Bool

-- | True iff we can decompose (T a b c) into ((T a b) c) I.e. is it
--   injective and generative w.r.t nominal equality? That is, if (T a b)
--   ~N d e f, is it always the case that (T ~N d), (a ~N e) and (b ~N f)?
--   Specifically NOT true of synonyms (open and otherwise)
--   
--   It'd be unusual to call mightBeUnsaturatedTyCon on a regular H98 type
--   synonym, because you should probably have expanded it first But
--   regardless, it's not decomposable
mightBeUnsaturatedTyCon :: TyCon -> Bool

-- | Is this a PromotedDataCon?
isPromotedDataCon :: TyCon -> Bool

-- | Retrieves the promoted DataCon if this is a PromotedDataCon;
isPromotedDataCon_maybe :: TyCon -> Maybe DataCon

-- | Is this tycon really meant for use at the kind level? That is, should
--   it be permitted without -XDataKinds?
isKindTyCon :: TyCon -> Bool
isLiftedTypeKindTyConName :: Name -> Bool
isTauTyCon :: TyCon -> Bool
isFamFreeTyCon :: TyCon -> Bool

-- | Returns <tt>True</tt> for data types that are <i>definitely</i>
--   represented by heap-allocated constructors. These are scrutinised by
--   Core-level <tt>case</tt> expressions, and they get info tables
--   allocated for them.
--   
--   Generally, the function will be true for all <tt>data</tt> types and
--   false for <tt>newtype</tt>s, unboxed tuples, unboxed sums and type
--   family <a>TyCon</a>s. But it is not guaranteed to return <tt>True</tt>
--   in all cases that it could.
--   
--   NB: for a data type family, only the <i>instance</i> <a>TyCon</a>s get
--   an info table. The family declaration <a>TyCon</a> does not
isDataTyCon :: TyCon -> Bool
isProductTyCon :: TyCon -> Bool
isDataProductTyCon_maybe :: TyCon -> Maybe DataCon
isDataSumTyCon_maybe :: TyCon -> Maybe [DataCon]

-- | Is this an algebraic <a>TyCon</a> which is just an enumeration of
--   values?
isEnumerationTyCon :: TyCon -> Bool

-- | Is this <a>TyCon</a> that for a <tt>newtype</tt>
isNewTyCon :: TyCon -> Bool

-- | Test if the <a>TyCon</a> is algebraic but abstract (invisible data
--   constructors)
isAbstractTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family?
isFamilyTyCon :: TyCon -> Bool

-- | Is this a <a>TyCon</a>, synonym or otherwise, that defines a family
--   with instances?
isOpenFamilyTyCon :: TyCon -> Bool

-- | Is this a synonym <a>TyCon</a> that can have may have further
--   instances appear?
isTypeFamilyTyCon :: TyCon -> Bool

-- | Is this a synonym <a>TyCon</a> that can have may have further
--   instances appear?
isDataFamilyTyCon :: TyCon -> Bool

-- | Is this an open type family TyCon?
isOpenTypeFamilyTyCon :: TyCon -> Bool

-- | Is this a non-empty closed type family? Returns <a>Nothing</a> for
--   abstract or empty closed families.
isClosedSynFamilyTyConWithAxiom_maybe :: TyCon -> Maybe (CoAxiom Branched)

-- | <tt><a>tyConInjectivityInfo</a> tc</tt> returns <tt><a>Injective</a>
--   is</tt> is <tt>tc</tt> is an injective tycon (where <tt>is</tt> states
--   for which <a>tyConBinders</a> <tt>tc</tt> is injective), or
--   <a>NotInjective</a> otherwise.
tyConInjectivityInfo :: TyCon -> Injectivity
isBuiltInSynFamTyCon_maybe :: TyCon -> Maybe BuiltInSynFamily

-- | Is this <a>TyCon</a> unlifted (i.e. cannot contain bottom)? Note that
--   this can only be true for primitive and unboxed-tuple <a>TyCon</a>s
isUnliftedTyCon :: TyCon -> Bool

-- | Is this an algebraic <a>TyCon</a> declared with the GADT syntax?
isGadtSyntaxTyCon :: TyCon -> Bool

-- | <a>isInjectiveTyCon</a> is true of <a>TyCon</a>s for which this
--   property holds (where X is the role passed in): If (T a1 b1 c1) ~X (T
--   a2 b2 c2), then (a1 ~X1 a2), (b1 ~X2 b2), and (c1 ~X3 c2) (where X1,
--   X2, and X3, are the roles given by tyConRolesX tc X) See also Note
--   [Decomposing equality] in TcCanonical
isInjectiveTyCon :: TyCon -> Role -> Bool

-- | <a>isGenerativeTyCon</a> is true of <a>TyCon</a>s for which this
--   property holds (where X is the role passed in): If (T tys ~X t), then
--   (t's head ~X T). See also Note [Decomposing equality] in TcCanonical
isGenerativeTyCon :: TyCon -> Role -> Bool

-- | Is this an <a>AlgTyConRhs</a> of a <a>TyCon</a> that is generative and
--   injective with respect to representational equality?
isGenInjAlgRhs :: AlgTyConRhs -> Bool

-- | Is this TyCon for an associated type?
isTyConAssoc :: TyCon -> Bool

-- | Get the enclosing class TyCon (if there is one) for the given TyCon.
tyConAssoc_maybe :: TyCon -> Maybe TyCon

-- | Get the enclosing class TyCon (if there is one) for the given
--   TyConFlavour
tyConFlavourAssoc_maybe :: TyConFlavour -> Maybe TyCon

-- | Identifies implicit tycons that, in particular, do not go into
--   interface files (because they are implicitly reconstructed when the
--   interface is read).
--   
--   Note that:
--   
--   <ul>
--   <li>Associated families are implicit, as they are re-constructed from
--   the class declaration in which they reside, and</li>
--   <li>Family instances are <i>not</i> implicit as they represent the
--   instance body (similar to a <tt>dfun</tt> does that for a class
--   instance).</li>
--   <li>Tuples are implicit iff they have a wired-in name (namely: boxed
--   and unboxed tupeles are wired-in and implicit, but constraint tuples
--   are not)</li>
--   </ul>
isImplicitTyCon :: TyCon -> Bool

-- | Check if the tycon actually refers to a proper `data` or `newtype`
--   with user defined constructors rather than one from a class or other
--   construction.
isTyConWithSrcDataCons :: TyCon -> Bool

-- | Is this a TcTyCon? (That is, one only used during type-checking?)
isTcTyCon :: TyCon -> Bool

-- | Could this TyCon ever be levity-polymorphic when fully applied? True
--   is safe. False means we're sure. Does only a quick check based on the
--   TyCon's category. Precondition: The fully-applied TyCon has kind (TYPE
--   blah)
isTcLevPoly :: TyCon -> Bool

-- | Name of the constructor
tyConName :: TyCon -> Name

-- | Returns whether or not this <a>TyCon</a> is definite, or a hole that
--   may be filled in at some later point. See Note [Skolem abstract data]
tyConSkolem :: TyCon -> Bool

-- | Kind of this TyCon
tyConKind :: TyCon -> Kind

-- | A Unique of this TyCon. Invariant: identical to Unique of Name stored
--   in tyConName field.
tyConUnique :: TyCon -> Unique

-- | TyVar binders
tyConTyVars :: TyCon -> [TyVar]
tyConVisibleTyVars :: TyCon -> [TyVar]

-- | The C type that should be used for this type when using the FFI and
--   CAPI
tyConCType :: TyCon -> Maybe CType
tyConCType_maybe :: TyCon -> Maybe CType

-- | As <a>tyConDataCons_maybe</a>, but returns the empty list of
--   constructors if no constructors could be found
tyConDataCons :: TyCon -> [DataCon]

-- | Determine the <a>DataCon</a>s originating from the given <a>TyCon</a>,
--   if the <a>TyCon</a> is the sort that can have any constructors (note:
--   this does not include abstract algebraic types)
tyConDataCons_maybe :: TyCon -> Maybe [DataCon]

-- | If the given <a>TyCon</a> has a <i>single</i> data constructor, i.e.
--   it is a <tt>data</tt> type with one alternative, a tuple type or a
--   <tt>newtype</tt> then that constructor is returned. If the
--   <a>TyCon</a> has more than one constructor, or represents a primitive
--   or function type constructor then <tt>Nothing</tt> is returned. In any
--   other case, the function panics
tyConSingleDataCon_maybe :: TyCon -> Maybe DataCon
tyConSingleDataCon :: TyCon -> DataCon
tyConSingleAlgDataCon_maybe :: TyCon -> Maybe DataCon

-- | Determine the number of value constructors a <a>TyCon</a> has. Panics
--   if the <a>TyCon</a> is not algebraic or a tuple
tyConFamilySize :: TyCon -> Int

-- | Find the "stupid theta" of the <a>TyCon</a>. A "stupid theta" is the
--   context to the left of an algebraic type declaration, e.g. <tt>Eq
--   a</tt> in the declaration <tt>data Eq a =&gt; T a ...</tt>
tyConStupidTheta :: TyCon -> [PredType]

-- | Arity
tyConArity :: TyCon -> Arity

-- | Get the list of roles for the type parameters of a TyCon
tyConRoles :: TyCon -> [Role]
tyConFlavour :: TyCon -> TyConFlavour
tyConTuple_maybe :: TyCon -> Maybe TupleSort

-- | If this <a>TyCon</a> is that for a class instance, return the class it
--   is for. Otherwise returns <tt>Nothing</tt>
tyConClass_maybe :: TyCon -> Maybe Class

-- | Return the associated types of the <a>TyCon</a>, if any
tyConATs :: TyCon -> [TyCon]

-- | If this <a>TyCon</a> is that of a data family instance, return the
--   family in question and the instance types. Otherwise, return
--   <tt>Nothing</tt>
tyConFamInst_maybe :: TyCon -> Maybe (TyCon, [Type])
tyConFamInstSig_maybe :: TyCon -> Maybe (TyCon, [Type], CoAxiom Unbranched)

-- | If this <a>TyCon</a> is that of a data family instance, return a
--   <a>TyCon</a> which represents a coercion identifying the
--   representation type with the type instance family. Otherwise, return
--   <tt>Nothing</tt>
tyConFamilyCoercion_maybe :: TyCon -> Maybe (CoAxiom Unbranched)

-- | Extract type variable naming the result of injective type family
tyConFamilyResVar_maybe :: TyCon -> Maybe Name

-- | Extract the <a>TyVar</a>s bound by a vanilla type synonym and the
--   corresponding (unsubstituted) right hand side.
synTyConDefn_maybe :: TyCon -> Maybe ([TyVar], Type)

-- | Extract the information pertaining to the right hand side of a type
--   synonym (<tt>type</tt>) declaration.
synTyConRhs_maybe :: TyCon -> Maybe Type

-- | Extract the flavour of a type family (with all the extra information
--   that it carries)
famTyConFlav_maybe :: TyCon -> Maybe FamTyConFlav

-- | Name of result type variable, used for pretty-printing with
--   --show-iface and for reifying TyCon in Template Haskell
famTcResVar :: TyCon -> Maybe Name

-- | Extract an <a>AlgTyConRhs</a> with information about data constructors
--   from an algebraic or tuple <a>TyCon</a>. Panics for any other sort of
--   <a>TyCon</a>
algTyConRhs :: TyCon -> AlgTyConRhs

-- | Extract the bound type variables and type expansion of a type synonym
--   <a>TyCon</a>. Panics if the <a>TyCon</a> is not a synonym
newTyConRhs :: TyCon -> ([TyVar], Type)

-- | The number of type parameters that need to be passed to a newtype to
--   resolve it. May be less than in the definition if it can be
--   eta-contracted.
newTyConEtadArity :: TyCon -> Int

-- | Extract the bound type variables and type expansion of an
--   eta-contracted type synonym <a>TyCon</a>. Panics if the <a>TyCon</a>
--   is not a synonym
newTyConEtadRhs :: TyCon -> ([TyVar], Type)

-- | Take a <a>TyCon</a> apart into the <a>TyVar</a>s it scopes over, the
--   <a>Type</a> it expands into, and (possibly) a coercion from the
--   representation type to the <tt>newtype</tt>. Returns <tt>Nothing</tt>
--   if this is not possible.
unwrapNewTyCon_maybe :: TyCon -> Maybe ([TyVar], Type, CoAxiom Unbranched)
unwrapNewTyConEtad_maybe :: TyCon -> Maybe ([TyVar], Type, CoAxiom Unbranched)
newTyConDataCon_maybe :: TyCon -> Maybe DataCon

-- | Maps a label to information about the field
algTcFields :: TyCon -> FieldLabelEnv

-- | Extract any <a>RuntimeRepInfo</a> from this TyCon
tyConRuntimeRepInfo :: TyCon -> RuntimeRepInfo

-- | Full binders
tyConBinders :: TyCon -> [TyConBinder]

-- | Result kind
tyConResKind :: TyCon -> Kind
tyConTyVarBinders :: [TyConBinder] -> [TyVarBinder]

-- | Scoped tyvars over the tycon's body See Note [How TcTyCons work] in
--   TcTyClsDecls Order *does* matter: for TcTyCons with a CUSK, it's the
--   correct dependency order. For TcTyCons without a CUSK, it's the
--   original left-to-right that the user wrote. Nec'y for getting
--   Specified variables in the right order.
tcTyConScopedTyVars :: TyCon -> [(Name, TyVar)]

-- | Original, user-written tycon tyvars
tcTyConUserTyVars :: TyCon -> SDoc

-- | Is this TcTyCon already generalized?
tcTyConIsPoly :: TyCon -> Bool
mkTyConTagMap :: TyCon -> NameEnv ConTag

-- | Expand a type synonym application, if any
expandSynTyCon_maybe :: TyCon -> [tyco] -> Maybe ([(TyVar, tyco)], Type, [tyco])

-- | Make a fake, recovery <a>TyCon</a> from an existing one. Used when
--   recovering from errors
makeRecoveryTyCon :: TyCon -> TyCon
newTyConCo :: TyCon -> CoAxiom Unbranched

-- | Extracts the <tt>newtype</tt> coercion from such a <a>TyCon</a>, which
--   can be used to construct something with the <tt>newtype</tt>s type
--   from its representation type (right hand side). If the supplied
--   <a>TyCon</a> is not a <tt>newtype</tt>, returns <tt>Nothing</tt>
newTyConCo_maybe :: TyCon -> Maybe (CoAxiom Unbranched)
pprPromotionQuote :: TyCon -> SDoc
mkTyConKind :: [TyConBinder] -> Kind -> Kind

-- | Can this flavour of <a>TyCon</a> appear unsaturated?
tcFlavourCanBeUnsaturated :: TyConFlavour -> Bool

-- | Is this flavour of <a>TyCon</a> an open type family or a data family?
tcFlavourIsOpen :: TyConFlavour -> Bool
type TyConRepName = Name
tyConRepName_maybe :: TyCon -> Maybe TyConRepName

-- | Make a <a>Name</a> for the <tt>Typeable</tt> representation of the
--   given wired-in type
mkPrelTyConRepName :: Name -> TyConRepName

-- | The name (and defining module) for the Typeable representation (TyCon)
--   of a type constructor.
--   
--   See Note [Grand plan for Typeable] in <tt>TcTypeable</tt> in
--   TcTypeable.
tyConRepModOcc :: Module -> OccName -> (Module, OccName)

-- | A <a>PrimRep</a> is an abstraction of a type. It contains information
--   that the code generator needs in order to pass arguments, return
--   results, and store values of this type.
data PrimRep
VoidRep :: PrimRep
LiftedRep :: PrimRep

-- | Unlifted pointer
UnliftedRep :: PrimRep

-- | Signed, 8-bit value
Int8Rep :: PrimRep

-- | Signed, 16-bit value
Int16Rep :: PrimRep

-- | Signed, word-sized value
IntRep :: PrimRep

-- | Unsigned, word-sized value
WordRep :: PrimRep

-- | Signed, 64 bit value (with 32-bit words only)
Int64Rep :: PrimRep

-- | Unsigned, 8 bit value
Word8Rep :: PrimRep

-- | Unsigned, 16 bit value
Word16Rep :: PrimRep

-- | Unsigned, 64 bit value (with 32-bit words only)
Word64Rep :: PrimRep

-- | A pointer, but <i>not</i> to a Haskell value (use '(Un)liftedRep')
AddrRep :: PrimRep
FloatRep :: PrimRep
DoubleRep :: PrimRep

-- | A vector
VecRep :: Int -> PrimElemRep -> PrimRep
data PrimElemRep
Int8ElemRep :: PrimElemRep
Int16ElemRep :: PrimElemRep
Int32ElemRep :: PrimElemRep
Int64ElemRep :: PrimElemRep
Word8ElemRep :: PrimElemRep
Word16ElemRep :: PrimElemRep
Word32ElemRep :: PrimElemRep
Word64ElemRep :: PrimElemRep
FloatElemRep :: PrimElemRep
DoubleElemRep :: PrimElemRep
isVoidRep :: PrimRep -> Bool
isGcPtrRep :: PrimRep -> Bool

-- | The size of a <a>PrimRep</a> in bytes.
--   
--   This applies also when used in a constructor, where we allow packing
--   the fields. For instance, in <tt>data Foo = Foo Float</tt> the two
--   fields will take only 8 bytes, which for 64-bit arch will be equal to
--   1 word. See also mkVirtHeapOffsetsWithPadding for details of how data
--   fields are layed out.
primRepSizeB :: DynFlags -> PrimRep -> Int
primElemRepSizeB :: PrimElemRep -> Int

-- | Return if Rep stands for floating type, returns Nothing for vector
--   types.
primRepIsFloat :: PrimRep -> Maybe Bool
data RecTcChecker

-- | Initialise a <a>RecTcChecker</a> with <a>defaultRecTcMaxBound</a>.
initRecTc :: RecTcChecker

-- | The default upper bound (100) for the number of times a
--   <a>RecTcChecker</a> is allowed to encounter each <a>TyCon</a>.
defaultRecTcMaxBound :: Int

-- | Change the upper bound for the number of times a <a>RecTcChecker</a>
--   is allowed to encounter each <a>TyCon</a>.
setRecTcMaxBound :: Int -> RecTcChecker -> RecTcChecker
checkRecTc :: RecTcChecker -> TyCon -> Maybe RecTcChecker
instance GHC.Classes.Eq TyCon.TyConFlavour
instance GHC.Show.Show TyCon.PrimRep
instance GHC.Classes.Eq TyCon.PrimRep
instance GHC.Show.Show TyCon.PrimElemRep
instance GHC.Classes.Eq TyCon.PrimElemRep
instance GHC.Classes.Eq TyCon.Injectivity
instance Outputable.Outputable TyCon.AlgTyConFlav
instance GHC.Classes.Eq TyCon.TyCon
instance Unique.Uniquable TyCon.TyCon
instance Outputable.Outputable TyCon.TyCon
instance Outputable.Outputable TyCon.TyConFlavour
instance Name.NamedThing TyCon.TyCon
instance Data.Data.Data TyCon.TyCon
instance Outputable.Outputable TyCon.PrimRep
instance Outputable.Outputable TyCon.PrimElemRep
instance Outputable.Outputable TyCon.FamTyConFlav
instance Binary.Binary TyCon.Injectivity
instance Outputable.Outputable TyCon.TyConBndrVis
instance Outputable.Outputable tv => Outputable.Outputable (Var.VarBndr tv TyCon.TyConBndrVis)
instance Binary.Binary TyCon.TyConBndrVis

module IfaceType
type IfExtName = Name
type IfLclName = FastString

-- | A kind of universal type, used for types and kinds.
--   
--   Any time a <tt>Type</tt> is pretty-printed, it is first converted to
--   an <a>IfaceType</a> before being printed. See Note [Pretty printing
--   via IfaceSyn] in PprTyThing
data IfaceType
IfaceFreeTyVar :: TyVar -> IfaceType
IfaceTyVar :: IfLclName -> IfaceType
IfaceLitTy :: IfaceTyLit -> IfaceType
IfaceAppTy :: IfaceType -> IfaceAppArgs -> IfaceType
IfaceFunTy :: IfaceType -> IfaceType -> IfaceType
IfaceDFunTy :: IfaceType -> IfaceType -> IfaceType
IfaceForAllTy :: IfaceForAllBndr -> IfaceType -> IfaceType
IfaceTyConApp :: IfaceTyCon -> IfaceAppArgs -> IfaceType
IfaceCastTy :: IfaceType -> IfaceCoercion -> IfaceType
IfaceCoercionTy :: IfaceCoercion -> IfaceType
IfaceTupleTy :: TupleSort -> PromotionFlag -> IfaceAppArgs -> IfaceType
type IfacePredType = IfaceType
type IfaceKind = IfaceType
data IfaceCoercion
IfaceReflCo :: IfaceType -> IfaceCoercion
IfaceGReflCo :: Role -> IfaceType -> IfaceMCoercion -> IfaceCoercion
IfaceFunCo :: Role -> IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceTyConAppCo :: Role -> IfaceTyCon -> [IfaceCoercion] -> IfaceCoercion
IfaceAppCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceForAllCo :: IfaceBndr -> IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceCoVarCo :: IfLclName -> IfaceCoercion
IfaceAxiomInstCo :: IfExtName -> BranchIndex -> [IfaceCoercion] -> IfaceCoercion
IfaceAxiomRuleCo :: IfLclName -> [IfaceCoercion] -> IfaceCoercion
IfaceUnivCo :: IfaceUnivCoProv -> Role -> IfaceType -> IfaceType -> IfaceCoercion
IfaceSymCo :: IfaceCoercion -> IfaceCoercion
IfaceTransCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceNthCo :: Int -> IfaceCoercion -> IfaceCoercion
IfaceLRCo :: LeftOrRight -> IfaceCoercion -> IfaceCoercion
IfaceInstCo :: IfaceCoercion -> IfaceCoercion -> IfaceCoercion
IfaceKindCo :: IfaceCoercion -> IfaceCoercion
IfaceSubCo :: IfaceCoercion -> IfaceCoercion
IfaceFreeCoVar :: CoVar -> IfaceCoercion

-- | See Note [Holes in IfaceCoercion]
IfaceHoleCo :: CoVar -> IfaceCoercion
data IfaceMCoercion
IfaceMRefl :: IfaceMCoercion
IfaceMCo :: IfaceCoercion -> IfaceMCoercion
data IfaceUnivCoProv
IfaceUnsafeCoerceProv :: IfaceUnivCoProv
IfacePhantomProv :: IfaceCoercion -> IfaceUnivCoProv
IfaceProofIrrelProv :: IfaceCoercion -> IfaceUnivCoProv
IfacePluginProv :: String -> IfaceUnivCoProv
data IfaceTyCon
IfaceTyCon :: IfExtName -> IfaceTyConInfo -> IfaceTyCon
[ifaceTyConName] :: IfaceTyCon -> IfExtName
[ifaceTyConInfo] :: IfaceTyCon -> IfaceTyConInfo
data IfaceTyConInfo
IfaceTyConInfo :: PromotionFlag -> IfaceTyConSort -> IfaceTyConInfo
[ifaceTyConIsPromoted] :: IfaceTyConInfo -> PromotionFlag
[ifaceTyConSort] :: IfaceTyConInfo -> IfaceTyConSort

-- | The various types of TyCons which have special, built-in syntax.
data IfaceTyConSort

-- | a regular tycon
IfaceNormalTyCon :: IfaceTyConSort

-- | e.g. <tt>(a, b, c)</tt> or <tt>()</tt>. The arity is the tuple width,
--   not the tycon arity (which is twice the width in the case of unboxed
--   tuples).
IfaceTupleTyCon :: !Arity -> !TupleSort -> IfaceTyConSort

-- | e.g. <tt>(a | b | c)</tt>
IfaceSumTyCon :: !Arity -> IfaceTyConSort

-- | A heterogeneous equality TyCon (i.e. eqPrimTyCon, eqReprPrimTyCon,
--   heqTyCon) that is actually being applied to two types of the same
--   kind. This affects pretty-printing only: see Note [Equality predicates
--   in IfaceType]
IfaceEqualityTyCon :: IfaceTyConSort
data IfaceTyLit
IfaceNumTyLit :: Integer -> IfaceTyLit
IfaceStrTyLit :: FastString -> IfaceTyLit

-- | Stores the arguments in a type application as a list. See <tt>Note
--   [Suppressing invisible arguments]</tt>.
data IfaceAppArgs
IA_Nil :: IfaceAppArgs
IA_Arg :: IfaceType -> ArgFlag -> IfaceAppArgs -> IfaceAppArgs
type IfaceContext = [IfacePredType]
data IfaceBndr
IfaceIdBndr :: {-# UNPACK #-} !IfaceIdBndr -> IfaceBndr
IfaceTvBndr :: {-# UNPACK #-} !IfaceTvBndr -> IfaceBndr
data IfaceOneShot
IfaceNoOneShot :: IfaceOneShot
IfaceOneShot :: IfaceOneShot
type IfaceLamBndr = (IfaceBndr, IfaceOneShot)
type IfaceTvBndr = (IfLclName, IfaceKind)
type IfaceIdBndr = (IfLclName, IfaceType)
type IfaceTyConBinder = VarBndr IfaceBndr TyConBndrVis
type IfaceForAllBndr = VarBndr IfaceBndr ArgFlag

-- | Argument Flag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, TyCoVarBinders, TyConBinders,
--   and visibility] in TyCoRep
data ArgFlag
Inferred :: ArgFlag
Specified :: ArgFlag
Required :: ArgFlag

-- | Show forall flag
--   
--   Unconditionally show the forall quantifier with
--   (<a>ShowForAllMust</a>) or when (<a>ShowForAllWhen</a>) the names used
--   are free in the binder or when compiling with
--   -fprint-explicit-foralls.
data ShowForAllFlag
ShowForAllMust :: ShowForAllFlag
ShowForAllWhen :: ShowForAllFlag

-- | Make an <a>IfaceForAllBndr</a> from an <a>IfaceTvBndr</a>.
mkIfaceForAllTvBndr :: ArgFlag -> IfaceTvBndr -> IfaceForAllBndr

-- | Extract an <a>IfaceBndr</a> from an <a>IfaceForAllBndr</a>.
ifForAllBndrVar :: IfaceForAllBndr -> IfaceBndr

-- | Extract the variable name from an <a>IfaceForAllBndr</a>.
ifForAllBndrName :: IfaceForAllBndr -> IfLclName
ifaceBndrName :: IfaceBndr -> IfLclName

-- | Extract an <a>IfaceBndr</a> from an <a>IfaceTyConBinder</a>.
ifTyConBinderVar :: IfaceTyConBinder -> IfaceBndr

-- | Extract the variable name from an <a>IfaceTyConBinder</a>.
ifTyConBinderName :: IfaceTyConBinder -> IfLclName
isIfaceLiftedTypeKind :: IfaceKind -> Bool
appArgsIfaceTypes :: IfaceAppArgs -> [IfaceType]
appArgsIfaceTypesArgFlags :: IfaceAppArgs -> [(IfaceType, ArgFlag)]
pprIfaceType :: IfaceType -> SDoc
pprParendIfaceType :: IfaceType -> SDoc
pprPrecIfaceType :: PprPrec -> IfaceType -> SDoc

-- | Prints a context or <tt>()</tt> if empty You give it the context
--   precedence
pprIfaceContext :: PprPrec -> [IfacePredType] -> SDoc

-- | Prints "(C a, D b) =&gt;", including the arrow. Used when we want to
--   print a context in a type, so we use <a>funPrec</a> to decide whether
--   to parenthesise a singleton predicate; e.g. Num a =&gt; a -&gt; a
pprIfaceContextArr :: [IfacePredType] -> SDoc
pprIfaceIdBndr :: IfaceIdBndr -> SDoc
pprIfaceLamBndr :: IfaceLamBndr -> SDoc
pprIfaceTvBndr :: Bool -> IfaceTvBndr -> SDoc
pprIfaceTyConBinders :: [IfaceTyConBinder] -> SDoc
pprIfaceBndrs :: [IfaceBndr] -> SDoc
pprIfaceAppArgs :: IfaceAppArgs -> SDoc
pprParendIfaceAppArgs :: IfaceAppArgs -> SDoc
pprIfaceForAllPart :: [IfaceForAllBndr] -> [IfacePredType] -> SDoc -> SDoc

-- | Like <a>pprIfaceForAllPart</a>, but always uses an explicit
--   <tt>forall</tt>.
pprIfaceForAllPartMust :: [IfaceForAllBndr] -> [IfacePredType] -> SDoc -> SDoc

-- | Render the "forall ... ." or "forall ... -&gt;" bit of a type.
pprIfaceForAll :: [IfaceForAllBndr] -> SDoc
pprIfaceSigmaType :: ShowForAllFlag -> IfaceType -> SDoc
pprIfaceTyLit :: IfaceTyLit -> SDoc
pprIfaceCoercion :: IfaceCoercion -> SDoc
pprParendIfaceCoercion :: IfaceCoercion -> SDoc
splitIfaceSigmaTy :: IfaceType -> ([IfaceForAllBndr], [IfacePredType], IfaceType)
pprIfaceTypeApp :: PprPrec -> IfaceTyCon -> IfaceAppArgs -> SDoc
pprUserIfaceForAll :: [IfaceForAllBndr] -> SDoc
pprIfaceCoTcApp :: PprPrec -> IfaceTyCon -> [IfaceCoercion] -> SDoc
pprTyTcApp :: PprPrec -> IfaceTyCon -> IfaceAppArgs -> SDoc
pprIfacePrefixApp :: PprPrec -> SDoc -> [SDoc] -> SDoc
suppressIfaceInvisibles :: DynFlags -> [IfaceTyConBinder] -> [a] -> [a]
stripIfaceInvisVars :: DynFlags -> [IfaceTyConBinder] -> [IfaceTyConBinder]
stripInvisArgs :: DynFlags -> IfaceAppArgs -> IfaceAppArgs
mkIfaceTySubst :: [(IfLclName, IfaceType)] -> IfaceTySubst
substIfaceTyVar :: IfaceTySubst -> IfLclName -> IfaceType
substIfaceAppArgs :: IfaceTySubst -> IfaceAppArgs -> IfaceAppArgs
inDomIfaceTySubst :: IfaceTySubst -> IfaceTvBndr -> Bool
instance GHC.Classes.Eq IfaceType.IfaceTyCon
instance GHC.Classes.Eq IfaceType.IfaceTyConInfo
instance GHC.Classes.Eq IfaceType.IfaceTyConSort
instance GHC.Classes.Eq IfaceType.IfaceTyLit
instance GHC.Base.Semigroup IfaceType.IfaceAppArgs
instance GHC.Base.Monoid IfaceType.IfaceAppArgs
instance Outputable.Outputable IfaceType.IfaceBndr
instance Binary.Binary IfaceType.IfaceBndr
instance Outputable.Outputable IfaceType.IfaceType
instance Outputable.Outputable IfaceType.IfaceAppArgs
instance Outputable.Outputable IfaceType.IfaceCoercion
instance Binary.Binary IfaceType.IfaceAppArgs
instance Binary.Binary IfaceType.IfaceType
instance Binary.Binary IfaceType.IfaceMCoercion
instance Binary.Binary IfaceType.IfaceCoercion
instance Binary.Binary IfaceType.IfaceUnivCoProv
instance Binary.Binary (BasicTypes.DefMethSpec IfaceType.IfaceType)
instance Outputable.Outputable IfaceType.IfaceTyCon
instance Binary.Binary IfaceType.IfaceTyCon
instance Binary.Binary IfaceType.IfaceTyConInfo
instance Binary.Binary IfaceType.IfaceTyConSort
instance Outputable.Outputable IfaceType.IfaceTyLit
instance Binary.Binary IfaceType.IfaceTyLit
instance Binary.Binary IfaceType.IfaceOneShot

module FV
type FV = InterestingVarFun -> VarSet -> ([Var], VarSet) -> ([Var], VarSet)

-- | Predicate on possible free variables: returns <tt>True</tt> iff the
--   variable is interesting
type InterestingVarFun = Var -> Bool

-- | Run a free variable computation, returning a list of distinct free
--   variables in deterministic order and a non-deterministic set
--   containing those variables.
fvVarListVarSet :: FV -> ([Var], VarSet)

-- | Run a free variable computation, returning a list of distinct free
--   variables in deterministic order.
fvVarList :: FV -> [Var]

-- | Run a free variable computation, returning a non-deterministic set of
--   free variables. Don't use if the set will be later converted to a list
--   and the order of that list will impact the generated code.
fvVarSet :: FV -> VarSet

-- | Run a free variable computation, returning a deterministic set of free
--   variables. Note that this is just a wrapper around the version that
--   returns a deterministic list. If you need a list you should use
--   <a>fvVarList</a>.
fvDVarSet :: FV -> DVarSet

-- | Add a variable - when free, to the returned free variables. Ignores
--   duplicates and respects the filtering function.
unitFV :: Id -> FV

-- | Return no free variables.
emptyFV :: FV

-- | Add multiple variables - when free, to the returned free variables.
--   Ignores duplicates and respects the filtering function.
mkFVs :: [Var] -> FV

-- | Union two free variable computations.
unionFV :: FV -> FV -> FV

-- | Union many free variable computations.
unionsFV :: [FV] -> FV

-- | Mark the variable as not free by putting it in scope.
delFV :: Var -> FV -> FV

-- | Mark many free variables as not free.
delFVs :: VarSet -> FV -> FV

-- | Filter a free variable computation.
filterFV :: InterestingVarFun -> FV -> FV

-- | Map a free variable computation over a list and union the results.
mapUnionFV :: (a -> FV) -> [a] -> FV

module TyCoRep

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See <tt>TcEnv</tt> for
--   how to retrieve a <a>TyThing</a> given a <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing
tyThingCategory :: TyThing -> String
pprTyThingCategory :: TyThing -> SDoc
pprShortTyThing :: TyThing -> SDoc
data Type

-- | Vanilla type or kind variable (*never* a coercion variable)
TyVarTy :: Var -> Type

-- | Type application to something other than a <a>TyCon</a>. Parameters:
--   
--   1) Function: must <i>not</i> be a <a>TyConApp</a> or <a>CastTy</a>,
--   must be another <a>AppTy</a>, or <a>TyVarTy</a> See Note <a>Respecting
--   definitional equality</a> about the no <a>CastTy</a> requirement
--   
--   2) Argument type
AppTy :: Type -> Type -> Type

-- | Application of a <a>TyCon</a>, including newtypes <i>and</i> synonyms.
--   Invariant: saturated applications of <tt>FunTyCon</tt> must use
--   <a>FunTy</a> and saturated synonyms must use their own constructors.
--   However, <i>unsaturated</i> <tt>FunTyCon</tt>s do appear as
--   <a>TyConApp</a>s. Parameters:
--   
--   1) Type constructor being applied to.
--   
--   2) Type arguments. Might not have enough type arguments here to
--   saturate the constructor. Even type synonyms are not necessarily
--   saturated; for example unsaturated type synonyms can appear as the
--   right hand side of a type synonym.
TyConApp :: TyCon -> [KindOrType] -> Type

-- | A  type.
ForAllTy :: {-# UNPACK #-} !TyCoVarBinder -> Type -> Type

-- | t1 -&gt; t2 Very common, so an important special case
FunTy :: Type -> Type -> Type

-- | Type literals are similar to type constructors.
LitTy :: TyLit -> Type

-- | A kind cast. The coercion is always nominal. INVARIANT: The cast is
--   never refl. INVARIANT: The Type is not a CastTy (use TransCo instead)
--   See Note <a>Respecting definitional equality</a> and (EQ3)
CastTy :: Type -> KindCoercion -> Type

-- | Injection of a Coercion into a type This should only ever be used in
--   the RHS of an AppTy, in the list of a TyConApp, when applying a
--   promoted GADT data constructor
CoercionTy :: Coercion -> Type
data TyLit
NumTyLit :: Integer -> TyLit
StrTyLit :: FastString -> TyLit

-- | The key representation of types within the compiler
type KindOrType = Type

-- | The key type representing kinds in the compiler.
type Kind = Type

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   TcTyClsDecls
type KnotTied ty = ty

-- | A type of the form <tt>p</tt> of kind <tt>Constraint</tt> represents a
--   value whose type is the Haskell predicate <tt>p</tt>, where a
--   predicate is what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]

-- | Argument Flag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, TyCoVarBinders, TyConBinders,
--   and visibility] in TyCoRep
data ArgFlag
Inferred :: ArgFlag
Specified :: ArgFlag
Required :: ArgFlag

-- | A <a>Coercion</a> is concrete evidence of the equality/convertibility
--   of two types.
data Coercion
Refl :: Type -> Coercion
GRefl :: Role -> Type -> MCoercionN -> Coercion
TyConAppCo :: Role -> TyCon -> [Coercion] -> Coercion
AppCo :: Coercion -> CoercionN -> Coercion
ForAllCo :: TyCoVar -> KindCoercion -> Coercion -> Coercion
FunCo :: Role -> Coercion -> Coercion -> Coercion
CoVarCo :: CoVar -> Coercion
AxiomInstCo :: CoAxiom Branched -> BranchIndex -> [Coercion] -> Coercion
AxiomRuleCo :: CoAxiomRule -> [Coercion] -> Coercion
UnivCo :: UnivCoProvenance -> Role -> Type -> Type -> Coercion
SymCo :: Coercion -> Coercion
TransCo :: Coercion -> Coercion -> Coercion
NthCo :: Role -> Int -> Coercion -> Coercion
LRCo :: LeftOrRight -> CoercionN -> Coercion
InstCo :: Coercion -> CoercionN -> Coercion
KindCo :: Coercion -> Coercion
SubCo :: CoercionN -> Coercion

-- | See Note [Coercion holes] Only present during typechecking
HoleCo :: CoercionHole -> Coercion

-- | For simplicity, we have just one UnivCo that represents a coercion
--   from some type to some other type, with (in general) no restrictions
--   on the type. The UnivCoProvenance specifies more exactly what the
--   coercion really is and why a program should (or shouldn't!) trust the
--   coercion. It is reasonable to consider each constructor of
--   <a>UnivCoProvenance</a> as a totally independent coercion form; their
--   only commonality is that they don't tell you what types they coercion
--   between. (That info is in the <a>UnivCo</a> constructor of
--   <a>Coercion</a>.
data UnivCoProvenance

-- | From <tt>unsafeCoerce#</tt>. These are unsound.
UnsafeCoerceProv :: UnivCoProvenance

-- | See Note [Phantom coercions]. Only in Phantom roled coercions
PhantomProv :: KindCoercion -> UnivCoProvenance

-- | From the fact that any two coercions are considered equivalent. See
--   Note [ProofIrrelProv]. Can be used in Nominal or Representational
--   coercions
ProofIrrelProv :: KindCoercion -> UnivCoProvenance

-- | From a plugin, which asserts that this coercion is sound. The string
--   is for the use of the plugin.
PluginProv :: String -> UnivCoProvenance

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
CoercionHole :: CoVar -> IORef (Maybe Coercion) -> CoercionHole
[ch_co_var] :: CoercionHole -> CoVar
[ch_ref] :: CoercionHole -> IORef (Maybe Coercion)
coHoleCoVar :: CoercionHole -> CoVar
setCoHoleCoVar :: CoercionHole -> CoVar -> CoercionHole
type CoercionN = Coercion
type CoercionR = Coercion
type CoercionP = Coercion
type KindCoercion = CoercionN

-- | A semantically more meaningful type to represent what may or may not
--   be a useful <a>Coercion</a>.
data MCoercion
MRefl :: MCoercion
MCo :: Coercion -> MCoercion
type MCoercionR = MCoercion
type MCoercionN = MCoercion

-- | Create the plain type constructor type which has been applied to no
--   type arguments at all.
mkTyConTy :: TyCon -> Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]
mkTyCoVarTy :: TyCoVar -> Type
mkTyCoVarTys :: [TyCoVar] -> [Type]

-- | Make an arrow type
mkFunTy :: Type -> Type -> Type
infixr 3 `mkFunTy`

-- | Make nested arrow types
mkFunTys :: [Type] -> Type -> Type

-- | If tv is a coercion variable and it is not used in the body, returns a
--   FunTy, otherwise makes a forall type. See Note [Unused coercion
--   variable in ForAllTy]
mkTyCoForAllTy :: TyCoVar -> ArgFlag -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [TyCoVarBinder] -> Type -> Type

-- | Like <a>mkTyCoForAllTy</a>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: TyCoVar -> ArgFlag -> Type -> Type
mkTyCoPiTy :: TyCoBinder -> Type -> Type
mkTyCoPiTys :: [TyCoBinder] -> Type -> Type

-- | Like <a>mkTyCoPiTys</a>, but does not check the occurrence of the
--   binder
mkPiTys :: [TyCoBinder] -> Type -> Type

-- | Given a kind (TYPE rr), extract its RuntimeRep classifier rr. For
--   example, <tt>kindRep_maybe * = Just LiftedRep</tt> Returns
--   <a>Nothing</a> if the kind is not of form (TYPE rr) Treats * and
--   Constraint as the same
kindRep_maybe :: HasDebugCallStack => Kind -> Maybe Type

-- | Extract the RuntimeRep classifier of a type from its kind. For
--   example, <tt>kindRep * = LiftedRep</tt>; Panics if this is not
--   possible. Treats * and Constraint as the same
kindRep :: HasDebugCallStack => Kind -> Type

-- | This version considers Constraint to be the same as *. Returns True if
--   the argument is equivalent to Type/Constraint and False otherwise. See
--   Note [Kind Constraint and kind Type]
isLiftedTypeKind :: Kind -> Bool

-- | Returns True if the kind classifies unlifted types and False
--   otherwise. Note that this returns False for levity-polymorphic kinds,
--   which may be specialized to a kind that classifies unlifted types.
isUnliftedTypeKind :: Kind -> Bool
isLiftedRuntimeRep :: Type -> Bool
isUnliftedRuntimeRep :: Type -> Bool

-- | Is this the type <a>RuntimeRep</a>?
isRuntimeRepTy :: Type -> Bool

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
sameVis :: ArgFlag -> ArgFlag -> Bool

-- | A <a>TyCoBinder</a> represents an argument to a function. TyCoBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [TyCoBinders]
data TyCoBinder
Named :: TyCoVarBinder -> TyCoBinder
Anon :: Type -> TyCoBinder

-- | Variable Binder
--   
--   A <a>TyCoVarBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in TyCoRep, because
--   it's used in DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type TyCoVarBinder = VarBndr TyCoVar ArgFlag

-- | <a>TyBinder</a> is like <a>TyCoBinder</a>, but there can only be
--   <a>TyVarBinder</a> in the <a>Named</a> field.
type TyBinder = TyCoBinder
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]
binderType :: VarBndr TyCoVar argf -> Type
binderArgFlag :: VarBndr tv argf -> argf

-- | Remove the binder's variable from the set, if the binder has a
--   variable.
delBinderVar :: VarSet -> TyCoVarBinder -> VarSet

-- | Does this <a>ArgFlag</a> classify an argument that is not written in
--   Haskell?
isInvisibleArgFlag :: ArgFlag -> Bool

-- | Does this <a>ArgFlag</a> classify an argument that is written in
--   Haskell?
isVisibleArgFlag :: ArgFlag -> Bool

-- | Does this binder bind an invisible argument?
isInvisibleBinder :: TyCoBinder -> Bool

-- | Does this binder bind a visible argument?
isVisibleBinder :: TyCoBinder -> Bool

-- | If its a named binder, is the binder a tyvar? Returns True for
--   nondependent binder.
isTyBinder :: TyCoBinder -> Bool
isNamedBinder :: TyCoBinder -> Bool
tyCoBinderArgFlag :: TyCoBinder -> ArgFlag
pickLR :: LeftOrRight -> (a, a) -> a
pprType :: Type -> SDoc
pprParendType :: Type -> SDoc
pprPrecType :: PprPrec -> Type -> SDoc
pprPrecTypeX :: TidyEnv -> PprPrec -> Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc
pprTCvBndr :: TyCoVarBinder -> SDoc
pprTCvBndrs :: [TyCoVarBinder] -> SDoc
pprSigmaType :: Type -> SDoc
pprTheta :: ThetaType -> SDoc
pprParendTheta :: ThetaType -> SDoc
pprForAll :: [TyCoVarBinder] -> SDoc

-- | Print a user-level forall; see Note [When to print foralls]
pprUserForAll :: [TyCoVarBinder] -> SDoc
pprTyVar :: TyVar -> SDoc
pprTyVars :: [TyVar] -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
pprClassPred :: Class -> [Type] -> SDoc
pprKind :: Kind -> SDoc
pprParendKind :: Kind -> SDoc
pprTyLit :: TyLit -> SDoc

-- | A general-purpose pretty-printing precedence type.
newtype PprPrec
PprPrec :: Int -> PprPrec
topPrec :: PprPrec
sigPrec :: PprPrec
opPrec :: PprPrec
funPrec :: PprPrec
appPrec :: PprPrec
maybeParen :: PprPrec -> PprPrec -> SDoc -> SDoc
pprDataCons :: TyCon -> SDoc

-- | Display all kind information (with <tt>-fprint-explicit-kinds</tt>)
--   when the provided <a>Bool</a> argument is <a>True</a>. See <tt>Note
--   [Kind arguments in error messages]</tt> in <a>TcErrors</a>.
pprWithExplicitKindsWhen :: Bool -> SDoc -> SDoc
pprCo :: Coercion -> SDoc
pprParendCo :: Coercion -> SDoc

-- | debugPprType is a simple pretty printer that prints a type without
--   going through IfaceType. It does not format as prettily as the normal
--   route, but it's much more direct, and that can be useful for
--   debugging. E.g. with -dppr-debug it prints the kind on type-variable
--   <i>occurrences</i> which the normal route fundamentally cannot do.
debugPprType :: Type -> SDoc
tyCoVarsOfType :: Type -> TyCoVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in FV.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | Returns free variables of types, including kind variables as a
--   deterministic set. For type synonyms it does <i>not</i> expand the
--   synonym.
tyCoVarsOfTypesDSet :: [Type] -> DTyCoVarSet
tyCoFVsBndr :: TyCoVarBinder -> FV -> FV
tyCoFVsVarBndr :: Var -> FV -> FV
tyCoFVsVarBndrs :: [Var] -> FV -> FV

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in FV.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in FV for explanation.
tyCoFVsOfType :: Type -> FV

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in
--   deterministic order. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in FV.
tyCoVarsOfTypeList :: Type -> [TyCoVar]
tyCoFVsOfTypes :: [Type] -> FV

-- | Returns free variables of types, including kind variables as a
--   deterministically ordered list. For type synonyms it does <i>not</i>
--   expand the synonym.
tyCoVarsOfTypesList :: [Type] -> [TyCoVar]
coVarsOfType :: Type -> CoVarSet
coVarsOfTypes :: [Type] -> TyCoVarSet
coVarsOfCo :: Coercion -> CoVarSet
coVarsOfCos :: [Coercion] -> CoVarSet
tyCoVarsOfCo :: Coercion -> TyCoVarSet
tyCoVarsOfCos :: [Coercion] -> TyCoVarSet

-- | Get a deterministic set of the vars free in a coercion
tyCoVarsOfCoDSet :: Coercion -> DTyCoVarSet
tyCoFVsOfCo :: Coercion -> FV
tyCoFVsOfCos :: [Coercion] -> FV
tyCoVarsOfCoList :: Coercion -> [TyCoVar]
tyCoVarsOfProv :: UnivCoProvenance -> TyCoVarSet

-- | Given a covar and a coercion, returns True if covar is almost devoid
--   in the coercion. That is, covar can only appear in Refl and GRefl. See
--   last wrinkle in Note [Unused coercion variable in ForAllCo] in
--   Coercion
almostDevoidCoVarOfCo :: CoVar -> Coercion -> Bool

-- | Returns the free variables of a <a>TyConBinder</a> that are in
--   injective positions. (See <tt>Note [Kind annotations on
--   TyConApps]</tt> in <a>TcSplice</a> for an explanation of what an
--   injective position is.)
injectiveVarsOfBinder :: TyConBinder -> FV

-- | Returns the free variables of a <a>Type</a> that are in injective
--   positions. (See <tt>Note [Kind annotations on TyConApps]</tt> in
--   <a>TcSplice</a> for an explanation of what an injective position is.)
injectiveVarsOfType :: Type -> FV

-- | Returns True if this type has no free variables. Should be the same as
--   isEmptyVarSet . tyCoVarsOfType, but faster in the non-forall case.
noFreeVarsOfType :: Type -> Bool

-- | Returns True if this coercion has no free variables. Should be the
--   same as isEmptyVarSet . tyCoVarsOfCo, but faster in the non-forall
--   case.
noFreeVarsOfCo :: Coercion -> Bool

-- | Type &amp; coercion substitution
--   
--   The following invariants must hold of a <a>TCvSubst</a>:
--   
--   <ol>
--   <li>The in-scope set is needed <i>only</i> to guide the generation of
--   fresh uniques</li>
--   <li>In particular, the <i>kind</i> of the type variables in the
--   in-scope set is not relevant</li>
--   <li>The substitution is only applied ONCE! This is because in general
--   such application will not reach a fixed point.</li>
--   </ol>
data TCvSubst
TCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> TCvSubst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | A substitution of <a>Coercion</a>s for <a>CoVar</a>s
type CvSubstEnv = CoVarEnv Coercion
emptyTvSubstEnv :: TvSubstEnv
emptyCvSubstEnv :: CvSubstEnv

-- | <tt>(compose env1 env2)(x)</tt> is <tt>env1(env2(x))</tt>; i.e. apply
--   <tt>env2</tt> then <tt>env1</tt>. It assumes that both are idempotent.
--   Typically, <tt>env1</tt> is the refinement to a base substitution
--   <tt>env2</tt>
composeTCvSubstEnv :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> (TvSubstEnv, CvSubstEnv) -> (TvSubstEnv, CvSubstEnv)

-- | Composes two substitutions, applying the second one provided first,
--   like in function composition.
composeTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst
emptyTCvSubst :: TCvSubst
mkEmptyTCvSubst :: InScopeSet -> TCvSubst
isEmptyTCvSubst :: TCvSubst -> Bool
mkTCvSubst :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> TCvSubst

-- | Make a TCvSubst with specified tyvar subst and empty covar subst
mkTvSubst :: InScopeSet -> TvSubstEnv -> TCvSubst

-- | Make a TCvSubst with specified covar subst and empty tyvar subst
mkCvSubst :: InScopeSet -> CvSubstEnv -> TCvSubst
getTvSubstEnv :: TCvSubst -> TvSubstEnv
getCvSubstEnv :: TCvSubst -> CvSubstEnv
getTCvInScope :: TCvSubst -> InScopeSet

-- | Returns the free variables of the types in the range of a substitution
--   as a non-deterministic set.
getTCvSubstRangeFVs :: TCvSubst -> VarSet
isInScope :: Var -> TCvSubst -> Bool
notElemTCvSubst :: Var -> TCvSubst -> Bool
setTvSubstEnv :: TCvSubst -> TvSubstEnv -> TCvSubst
setCvSubstEnv :: TCvSubst -> CvSubstEnv -> TCvSubst
zapTCvSubst :: TCvSubst -> TCvSubst
extendTCvInScope :: TCvSubst -> Var -> TCvSubst
extendTCvInScopeList :: TCvSubst -> [Var] -> TCvSubst
extendTCvInScopeSet :: TCvSubst -> VarSet -> TCvSubst
extendTCvSubst :: TCvSubst -> TyCoVar -> Type -> TCvSubst
extendTCvSubstWithClone :: TCvSubst -> TyCoVar -> TyCoVar -> TCvSubst
extendCvSubst :: TCvSubst -> CoVar -> Coercion -> TCvSubst
extendCvSubstWithClone :: TCvSubst -> CoVar -> CoVar -> TCvSubst
extendTvSubst :: TCvSubst -> TyVar -> Type -> TCvSubst
extendTvSubstBinderAndInScope :: TCvSubst -> TyCoBinder -> Type -> TCvSubst
extendTvSubstWithClone :: TCvSubst -> TyVar -> TyVar -> TCvSubst
extendTvSubstList :: TCvSubst -> [Var] -> [Type] -> TCvSubst
extendTvSubstAndInScope :: TCvSubst -> TyVar -> Type -> TCvSubst
extendTCvSubstList :: TCvSubst -> [Var] -> [Type] -> TCvSubst
unionTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst
zipTyEnv :: [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: [CoVar] -> [Coercion] -> CvSubstEnv

-- | Generates an in-scope set from the free variables in a list of types
--   and a list of coercions
mkTyCoInScopeSet :: [Type] -> [Coercion] -> InScopeSet

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
zipTvSubst :: [TyVar] -> [Type] -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No TyVars, please!
zipCvSubst :: [CoVar] -> [Coercion] -> TCvSubst
zipTCvSubst :: [TyCoVar] -> [Type] -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
mkTvSubstPrs :: [(TyVar, Type)] -> TCvSubst

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Substitute covars within a type
substTyWithCoVars :: [CoVar] -> [Coercion] -> Type -> Type

-- | Type substitution, see <a>zipTvSubst</a>
substTysWith :: [TyVar] -> [Type] -> [Type] -> [Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTysWithCoVars :: [CoVar] -> [Coercion] -> [Type] -> [Type]

-- | Coercion substitution, see <a>zipTvSubst</a>
substCoWith :: HasCallStack => [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasCallStack => TCvSubst -> Type -> Type

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: TCvSubst -> Type -> Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: TCvSubst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: TCvSubst -> [Type] -> [Type]

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: TCvSubst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: TCvSubst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute tyvars within a type using a known <a>InScopeSet</a>.
--   Pre-condition: the <tt>in_scope</tt> set should satisfy Note [The
--   substitution invariant]; specifically it should include the free vars
--   of <tt>tys</tt>, and of <tt>ty</tt> minus the domain of the subst.
substTyWithInScope :: InScopeSet -> [TyVar] -> [Type] -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasCallStack => TCvSubst -> [Type] -> [Type]

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasCallStack => TCvSubst -> ThetaType -> ThetaType
lookupTyVar :: TCvSubst -> TyVar -> Maybe Type

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasCallStack => TCvSubst -> Coercion -> Coercion

-- | Substitute within several <a>Coercion</a>s The substitution has to
--   satisfy the invariants described in Note [The substitution invariant].
substCos :: HasCallStack => TCvSubst -> [Coercion] -> [Coercion]
substCoVar :: TCvSubst -> CoVar -> Coercion
substCoVars :: TCvSubst -> [CoVar] -> [Coercion]
lookupCoVar :: TCvSubst -> Var -> Maybe Coercion
cloneTyVarBndr :: TCvSubst -> TyVar -> Unique -> (TCvSubst, TyVar)
cloneTyVarBndrs :: TCvSubst -> [TyVar] -> UniqSupply -> (TCvSubst, [TyVar])
substVarBndr :: HasCallStack => TCvSubst -> TyCoVar -> (TCvSubst, TyCoVar)
substVarBndrs :: HasCallStack => TCvSubst -> [TyCoVar] -> (TCvSubst, [TyCoVar])
substTyVarBndr :: HasCallStack => TCvSubst -> TyVar -> (TCvSubst, TyVar)
substTyVarBndrs :: HasCallStack => TCvSubst -> [TyVar] -> (TCvSubst, [TyVar])
substCoVarBndr :: HasCallStack => TCvSubst -> CoVar -> (TCvSubst, CoVar)
substTyVar :: TCvSubst -> TyVar -> Type
substTyVars :: TCvSubst -> [TyVar] -> [Type]
substTyCoVars :: TCvSubst -> [TyCoVar] -> [Type]
substForAllCoBndr :: TCvSubst -> TyCoVar -> KindCoercion -> (TCvSubst, TyCoVar, Coercion)
substVarBndrUsing :: (TCvSubst -> Type -> Type) -> TCvSubst -> TyCoVar -> (TCvSubst, TyCoVar)
substForAllCoBndrUsing :: Bool -> (Coercion -> Coercion) -> TCvSubst -> TyCoVar -> KindCoercion -> (TCvSubst, TyCoVar, KindCoercion)

-- | This checks if the substitution satisfies the invariant from Note [The
--   substitution invariant].
checkValidSubst :: HasCallStack => TCvSubst -> [Type] -> [Coercion] -> a -> a

-- | When calling <a>substTy</a> it should be the case that the in-scope
--   set in the substitution is a superset of the free vars of the range of
--   the substitution. See also Note [The substitution invariant].
isValidTCvSubst :: TCvSubst -> Bool
tidyType :: TidyEnv -> Type -> Type
tidyTypes :: TidyEnv -> [Type] -> [Type]
tidyOpenType :: TidyEnv -> Type -> (TidyEnv, Type)

-- | Grabs the free type variables, tidies them and then uses
--   <a>tidyType</a> to work over the type itself
tidyOpenTypes :: TidyEnv -> [Type] -> (TidyEnv, [Type])
tidyOpenKind :: TidyEnv -> Kind -> (TidyEnv, Kind)
tidyVarBndr :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | This tidies up a type for printing in an error message, or in an
--   interface file.
--   
--   It doesn't change the uniques at all, just the print names.
tidyVarBndrs :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])

-- | Add the free <a>TyVar</a>s to the env in tidy form, so that we can
--   tidy the type they are free in
tidyFreeTyCoVars :: TidyEnv -> [TyCoVar] -> TidyEnv
avoidNameClashes :: [TyCoVar] -> TidyEnv -> TidyEnv

-- | Treat a new <a>TyCoVar</a> as a binder, and give it a fresh tidy name
--   using the environment if one has not already been allocated. See also
--   <a>tidyVarBndr</a>
tidyOpenTyCoVar :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)
tidyOpenTyCoVars :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
tidyTyCoVarOcc :: TidyEnv -> TyCoVar -> TyCoVar

-- | Calls <a>tidyType</a> on a top-level type (i.e. with an empty tidying
--   environment)
tidyTopType :: Type -> Type
tidyKind :: TidyEnv -> Kind -> Kind
tidyCo :: TidyEnv -> Coercion -> Coercion
tidyCos :: TidyEnv -> [Coercion] -> [Coercion]
tidyTyCoVarBinder :: TidyEnv -> VarBndr TyCoVar vis -> (TidyEnv, VarBndr TyCoVar vis)
tidyTyCoVarBinders :: TidyEnv -> [VarBndr TyCoVar vis] -> (TidyEnv, [VarBndr TyCoVar vis])
typeSize :: Type -> Int
coercionSize :: Coercion -> Int
provSize :: UnivCoProvenance -> Int
instance Data.Data.Data TyCoRep.TyCoBinder
instance Data.Data.Data TyCoRep.Type
instance Data.Data.Data TyCoRep.MCoercion
instance Data.Data.Data TyCoRep.UnivCoProvenance
instance Data.Data.Data TyCoRep.Coercion
instance Data.Data.Data TyCoRep.TyLit
instance GHC.Classes.Ord TyCoRep.TyLit
instance GHC.Classes.Eq TyCoRep.TyLit
instance Outputable.Outputable TyCoRep.TCvSubst
instance Outputable.Outputable TyCoRep.TyCoBinder
instance Outputable.Outputable TyCoRep.MCoercion
instance Outputable.Outputable TyCoRep.UnivCoProvenance
instance Data.Data.Data TyCoRep.CoercionHole
instance Outputable.Outputable TyCoRep.CoercionHole
instance Outputable.Outputable TyCoRep.Type
instance Outputable.Outputable TyCoRep.Coercion
instance Outputable.Outputable TyCoRep.TyLit
instance Outputable.Outputable TyCoRep.TyThing
instance Name.NamedThing TyCoRep.TyThing


-- | This module defines TyCons that can't be expressed in Haskell. They
--   are all, therefore, wired-in TyCons. C.f module TysWiredIn
module TysPrim
mkPrimTyConName :: FastString -> Unique -> TyCon -> Name
mkTemplateKindVars :: [Kind] -> [TyVar]
mkTemplateTyVars :: [Kind] -> [TyVar]
mkTemplateTyVarsFrom :: Int -> [Kind] -> [TyVar]
mkTemplateKiTyVars :: [Kind] -> ([Kind] -> [Kind]) -> [TyVar]
mkTemplateTyConBinders :: [Kind] -> ([Kind] -> [Kind]) -> [TyConBinder]
mkTemplateKindTyConBinders :: [Kind] -> [TyConBinder]
mkTemplateAnonTyConBinders :: [Kind] -> [TyConBinder]
alphaTyVars :: [TyVar]
alphaTyVar :: TyVar
betaTyVar :: TyVar
gammaTyVar :: TyVar
deltaTyVar :: TyVar
alphaTys :: [Type]
alphaTy :: Type
betaTy :: Type
gammaTy :: Type
deltaTy :: Type
alphaTyVarsUnliftedRep :: [TyVar]
alphaTyVarUnliftedRep :: TyVar
alphaTysUnliftedRep :: [Type]
alphaTyUnliftedRep :: Type
runtimeRep1TyVar :: TyVar
runtimeRep2TyVar :: TyVar
runtimeRep1Ty :: Type
runtimeRep2Ty :: Type
openAlphaTy :: Type
openBetaTy :: Type
openAlphaTyVar :: TyVar
openBetaTyVar :: TyVar
tYPETyCon :: TyCon
tYPETyConName :: Name

-- | Given a RuntimeRep, applies TYPE to it. see Note [TYPE and RuntimeRep]
tYPE :: Type -> Type

-- | Convert a <a>PrimRep</a> to a <a>Type</a> of kind RuntimeRep Defined
--   here to avoid (more) module loops
primRepToRuntimeRep :: PrimRep -> Type

-- | The <tt>(-&gt;)</tt> type constructor.
--   
--   <pre>
--   (-&gt;) :: forall (rep1 :: RuntimeRep) (rep2 :: RuntimeRep).
--           TYPE rep1 -&gt; TYPE rep2 -&gt; *
--   </pre>
funTyCon :: TyCon
funTyConName :: Name

-- | Primitive <a>TyCon</a>s that are defined in <a>GHC.Prim</a> but not
--   exposed. It's important to keep these separate as we don't want users
--   to be able to write them (see Trac #15209) or see them in GHCi's
--   <tt>:browse</tt> output (see Trac #12023).
unexposedPrimTyCons :: [TyCon]

-- | Primitive <a>TyCon</a>s that are defined in, and exported from,
--   <a>GHC.Prim</a>.
exposedPrimTyCons :: [TyCon]
primTyCons :: [TyCon]
charPrimTyCon :: TyCon
charPrimTy :: Type
charPrimTyConName :: Name
intPrimTyCon :: TyCon
intPrimTy :: Type
intPrimTyConName :: Name
wordPrimTyCon :: TyCon
wordPrimTy :: Type
wordPrimTyConName :: Name
addrPrimTyCon :: TyCon
addrPrimTy :: Type
addrPrimTyConName :: Name
floatPrimTyCon :: TyCon
floatPrimTy :: Type
floatPrimTyConName :: Name
doublePrimTyCon :: TyCon
doublePrimTy :: Type
doublePrimTyConName :: Name
voidPrimTyCon :: TyCon
voidPrimTy :: Type
statePrimTyCon :: TyCon
mkStatePrimTy :: Type -> Type
realWorldTyCon :: TyCon
realWorldTy :: Type
realWorldStatePrimTy :: Type
proxyPrimTyCon :: TyCon
mkProxyPrimTy :: Type -> Type -> Type
arrayPrimTyCon :: TyCon
mkArrayPrimTy :: Type -> Type
byteArrayPrimTyCon :: TyCon
byteArrayPrimTy :: Type
arrayArrayPrimTyCon :: TyCon
mkArrayArrayPrimTy :: Type
smallArrayPrimTyCon :: TyCon
mkSmallArrayPrimTy :: Type -> Type
mutableArrayPrimTyCon :: TyCon
mkMutableArrayPrimTy :: Type -> Type -> Type
mutableByteArrayPrimTyCon :: TyCon
mkMutableByteArrayPrimTy :: Type -> Type
mutableArrayArrayPrimTyCon :: TyCon
mkMutableArrayArrayPrimTy :: Type -> Type
smallMutableArrayPrimTyCon :: TyCon
mkSmallMutableArrayPrimTy :: Type -> Type -> Type
mutVarPrimTyCon :: TyCon
mkMutVarPrimTy :: Type -> Type -> Type
mVarPrimTyCon :: TyCon
mkMVarPrimTy :: Type -> Type -> Type
tVarPrimTyCon :: TyCon
mkTVarPrimTy :: Type -> Type -> Type
stablePtrPrimTyCon :: TyCon
mkStablePtrPrimTy :: Type -> Type
stableNamePrimTyCon :: TyCon
mkStableNamePrimTy :: Type -> Type
compactPrimTyCon :: TyCon
compactPrimTy :: Type
bcoPrimTyCon :: TyCon
bcoPrimTy :: Type
weakPrimTyCon :: TyCon
mkWeakPrimTy :: Type -> Type
threadIdPrimTyCon :: TyCon
threadIdPrimTy :: Type
int8PrimTyCon :: TyCon
int8PrimTy :: Type
int8PrimTyConName :: Name
word8PrimTyCon :: TyCon
word8PrimTy :: Type
word8PrimTyConName :: Name
int16PrimTyCon :: TyCon
int16PrimTy :: Type
int16PrimTyConName :: Name
word16PrimTyCon :: TyCon
word16PrimTy :: Type
word16PrimTyConName :: Name
int32PrimTyCon :: TyCon
int32PrimTy :: Type
int32PrimTyConName :: Name
word32PrimTyCon :: TyCon
word32PrimTy :: Type
word32PrimTyConName :: Name
int64PrimTyCon :: TyCon
int64PrimTy :: Type
int64PrimTyConName :: Name
word64PrimTyCon :: TyCon
word64PrimTy :: Type
word64PrimTyConName :: Name
eqPrimTyCon :: TyCon
eqReprPrimTyCon :: TyCon
eqPhantPrimTyCon :: TyCon
int8X16PrimTy :: Type
int8X16PrimTyCon :: TyCon
int16X8PrimTy :: Type
int16X8PrimTyCon :: TyCon
int32X4PrimTy :: Type
int32X4PrimTyCon :: TyCon
int64X2PrimTy :: Type
int64X2PrimTyCon :: TyCon
int8X32PrimTy :: Type
int8X32PrimTyCon :: TyCon
int16X16PrimTy :: Type
int16X16PrimTyCon :: TyCon
int32X8PrimTy :: Type
int32X8PrimTyCon :: TyCon
int64X4PrimTy :: Type
int64X4PrimTyCon :: TyCon
int8X64PrimTy :: Type
int8X64PrimTyCon :: TyCon
int16X32PrimTy :: Type
int16X32PrimTyCon :: TyCon
int32X16PrimTy :: Type
int32X16PrimTyCon :: TyCon
int64X8PrimTy :: Type
int64X8PrimTyCon :: TyCon
word8X16PrimTy :: Type
word8X16PrimTyCon :: TyCon
word16X8PrimTy :: Type
word16X8PrimTyCon :: TyCon
word32X4PrimTy :: Type
word32X4PrimTyCon :: TyCon
word64X2PrimTy :: Type
word64X2PrimTyCon :: TyCon
word8X32PrimTy :: Type
word8X32PrimTyCon :: TyCon
word16X16PrimTy :: Type
word16X16PrimTyCon :: TyCon
word32X8PrimTy :: Type
word32X8PrimTyCon :: TyCon
word64X4PrimTy :: Type
word64X4PrimTyCon :: TyCon
word8X64PrimTy :: Type
word8X64PrimTyCon :: TyCon
word16X32PrimTy :: Type
word16X32PrimTyCon :: TyCon
word32X16PrimTy :: Type
word32X16PrimTyCon :: TyCon
word64X8PrimTy :: Type
word64X8PrimTyCon :: TyCon
floatX4PrimTy :: Type
floatX4PrimTyCon :: TyCon
doubleX2PrimTy :: Type
doubleX2PrimTyCon :: TyCon
floatX8PrimTy :: Type
floatX8PrimTyCon :: TyCon
doubleX4PrimTy :: Type
doubleX4PrimTyCon :: TyCon
floatX16PrimTy :: Type
floatX16PrimTyCon :: TyCon
doubleX8PrimTy :: Type
doubleX8PrimTyCon :: TyCon

module Kind

-- | The key type representing kinds in the compiler.
type Kind = Type

-- | This version considers Constraint to be the same as *. Returns True if
--   the argument is equivalent to Type/Constraint and False otherwise. See
--   Note [Kind Constraint and kind Type]
isLiftedTypeKind :: Kind -> Bool

-- | Returns True if the kind classifies unlifted types and False
--   otherwise. Note that this returns False for levity-polymorphic kinds,
--   which may be specialized to a kind that classifies unlifted types.
isUnliftedTypeKind :: Kind -> Bool
isConstraintKindCon :: TyCon -> Bool

-- | Does this classify a type allowed to have values? Responds True to
--   things like *, #, TYPE Lifted, TYPE v, Constraint.
--   
--   True of any sub-kind of OpenTypeKind
classifiesTypeWithValues :: Kind -> Bool

-- | Tests whether the given kind (which should look like <tt>TYPE x</tt>)
--   is something other than a constructor tree (that is, constructors at
--   every node). E.g. True of TYPE k, TYPE (F Int) False of TYPE
--   'LiftedRep
isKindLevPoly :: Kind -> Bool


-- | Main functions for manipulating types and type-related things
module Type

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See <tt>TcEnv</tt> for
--   how to retrieve a <a>TyThing</a> given a <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing
data Type

-- | Argument Flag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, TyCoVarBinders, TyConBinders,
--   and visibility] in TyCoRep
data ArgFlag
Inferred :: ArgFlag
Specified :: ArgFlag
Required :: ArgFlag

-- | The key representation of types within the compiler
type KindOrType = Type

-- | A type of the form <tt>p</tt> of kind <tt>Constraint</tt> represents a
--   value whose type is the Haskell predicate <tt>p</tt>, where a
--   predicate is what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Type or kind Variable
type TyVar = Var
isTyVar :: Var -> Bool

-- | Type or Coercion Variable
type TyCoVar = Id

-- | A <a>TyCoBinder</a> represents an argument to a function. TyCoBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [TyCoBinders]
data TyCoBinder

-- | Variable Binder
--   
--   A <a>TyCoVarBinder</a> is the binder of a ForAllTy It's convenient to
--   define this synonym here rather its natural home in TyCoRep, because
--   it's used in DataCon.hs-boot
--   
--   A <a>TyVarBinder</a> is a binder with only TyVar
type TyCoVarBinder = VarBndr TyCoVar ArgFlag
type TyVarBinder = VarBndr TyVar ArgFlag

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   TcTyClsDecls
type KnotTied ty = ty
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]

-- | Attempts to obtain the type variable underlying a <a>Type</a>, and
--   panics with the given message if this is not a type variable type. See
--   also <a>getTyVar_maybe</a>
getTyVar :: String -> Type -> TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>
getTyVar_maybe :: Type -> Maybe TyVar

-- | Attempts to obtain the type variable underlying a <a>Type</a>, without
--   any expansion
repGetTyVar_maybe :: Type -> Maybe TyVar

-- | If the type is a tyvar, possibly under a cast, returns it, along with
--   the coercion. Thus, the co is :: kind tv ~N kind ty
getCastedTyVar_maybe :: Type -> Maybe (TyVar, CoercionN)
tyVarKind :: TyVar -> Kind

-- | The type or kind of the <a>Var</a> in question
varType :: Var -> Kind

-- | Applies a type to another, as in e.g. <tt>k a</tt>
mkAppTy :: Type -> Type -> Type
mkAppTys :: Type -> [Type] -> Type

-- | Attempts to take a type application apart, as in
--   <a>splitAppTy_maybe</a>, and panics if this is not possible
splitAppTy :: Type -> (Type, Type)

-- | Recursively splits a type as far as is possible, leaving a residual
--   type being applied to and the type arguments applied to it. Never
--   fails, even if that means returning an empty list of type
--   applications.
splitAppTys :: Type -> (Type, [Type])

-- | Like <a>splitAppTys</a>, but doesn't look through type synonyms
repSplitAppTys :: HasDebugCallStack => Type -> (Type, [Type])

-- | Attempt to take a type application apart, whether it is a function,
--   type constructor, or plain type application. Note that type family
--   applications are NEVER unsaturated by this!
splitAppTy_maybe :: Type -> Maybe (Type, Type)

-- | Does the AppTy split as in <a>splitAppTy_maybe</a>, but assumes that
--   any Core view stuff is already done
repSplitAppTy_maybe :: HasDebugCallStack => Type -> Maybe (Type, Type)

-- | Does the AppTy split as in <tt>tcSplitAppTy_maybe</tt>, but assumes
--   that any coreView stuff is already done. Refuses to look through (c
--   =&gt; t)
tcRepSplitAppTy_maybe :: Type -> Maybe (Type, Type)

-- | Make an arrow type
mkFunTy :: Type -> Type -> Type
infixr 3 `mkFunTy`

-- | Make nested arrow types
mkFunTys :: [Type] -> Type -> Type

-- | Attempts to extract the argument and result types from a type, and
--   panics if that is not possible. See also <a>splitFunTy_maybe</a>
splitFunTy :: Type -> (Type, Type)

-- | Attempts to extract the argument and result types from a type
splitFunTy_maybe :: Type -> Maybe (Type, Type)
splitFunTys :: Type -> ([Type], Type)

-- | Extract the function result type and panic if that is not possible
funResultTy :: Type -> Type

-- | Just like <a>piResultTys</a> but for a single argument Try not to
--   iterate <a>piResultTy</a>, because it's inefficient to substitute one
--   variable at a time; instead use 'piResultTys"
--   
--   Extract the function argument type and panic if that is not possible
funArgTy :: Type -> Type

-- | A key function: builds a <a>TyConApp</a> or <a>FunTy</a> as
--   appropriate to its arguments. Applies its arguments to the constructor
--   from left to right.
mkTyConApp :: TyCon -> [Type] -> Type

-- | Create the plain type constructor type which has been applied to no
--   type arguments at all.
mkTyConTy :: TyCon -> Type

-- | The same as <tt>fst . splitTyConApp</tt>
tyConAppTyCon_maybe :: Type -> Maybe TyCon

-- | Retrieve the tycon heading this type, if there is one. Does <i>not</i>
--   look through synonyms.
tyConAppTyConPicky_maybe :: Type -> Maybe TyCon

-- | The same as <tt>snd . splitTyConApp</tt>
tyConAppArgs_maybe :: Type -> Maybe [Type]
tyConAppTyCon :: Type -> TyCon
tyConAppArgs :: Type -> [Type]

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor
splitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])

-- | Attempts to tease a type apart into a type constructor and the
--   application of a number of arguments to that constructor. Panics if
--   that is not possible. See also <a>splitTyConApp_maybe</a>
splitTyConApp :: Type -> (TyCon, [Type])
tyConAppArgN :: Int -> Type -> Type
nextRole :: Type -> Role

-- | Like <a>tcSplitTyConApp_maybe</a> but doesn't look through type
--   synonyms.
tcRepSplitTyConApp_maybe :: HasCallStack => Type -> Maybe (TyCon, [Type])

-- | Like <tt>tcSplitTyConApp</tt> but doesn't look through type synonyms.
tcRepSplitTyConApp :: HasCallStack => Type -> (TyCon, [Type])

-- | Split a type constructor application into its type constructor and
--   applied types. Note that this may fail in the case of a <a>FunTy</a>
--   with an argument of unknown kind <a>FunTy</a> (e.g. <tt>FunTy (a :: k)
--   Int</tt>. since the kind of <tt>a</tt> isn't of the form <tt>TYPE
--   rep</tt>). Consequently, you may need to zonk your type before using
--   this function.
--   
--   If you only need the <a>TyCon</a>, consider using
--   <tt>tcTyConAppTyCon_maybe</tt>.
tcSplitTyConApp_maybe :: HasCallStack => Type -> Maybe (TyCon, [Type])

-- | Attempts to tease a list type apart and gives the type of the elements
--   if successful (looks through type synonyms)
splitListTyConApp_maybe :: Type -> Maybe Type

-- | Like <a>splitTyConApp_maybe</a>, but doesn't look through synonyms.
--   This assumes the synonyms have already been dealt with.
repSplitTyConApp_maybe :: HasDebugCallStack => Type -> Maybe (TyCon, [Type])

-- | Like <a>mkTyCoForAllTy</a>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: TyCoVar -> ArgFlag -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [TyCoVarBinder] -> Type -> Type

-- | Like mkForAllTys, but assumes all variables are dependent and
--   Inferred, a common case
mkTyCoInvForAllTys :: [TyCoVar] -> Type -> Type

-- | Like mkForAllTys, but assumes all variables are dependent and
--   Specified, a common case
mkSpecForAllTys :: [TyVar] -> Type -> Type

-- | Like mkForAllTys, but assumes all variables are dependent and visible
mkVisForAllTys :: [TyVar] -> Type -> Type

-- | Make a dependent forall over an Inferred variablem
mkTyCoInvForAllTy :: TyCoVar -> Type -> Type

-- | Like mkTyCoInvForAllTy, but tv should be a tyvar
mkInvForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTys</a>, but tvs should be a list of tyvar
mkInvForAllTys :: [TyVar] -> Type -> Type

-- | Take a ForAllTy apart, returning the list of tycovars and the result
--   type. This always succeeds, even if it returns only an empty list.
--   Note that the result type returned may have free variables that were
--   bound by a forall.
splitForAllTys :: Type -> ([TyCoVar], Type)

-- | Like <a>splitPiTys</a> but split off only <i>named</i> binders and
--   returns TyCoVarBinders rather than TyCoBinders
splitForAllVarBndrs :: Type -> ([TyCoVarBinder], Type)

-- | Attempts to take a forall type apart, but only if it's a proper
--   forall, with a named binder
splitForAllTy_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Take a forall type apart, or panics if that is not possible.
splitForAllTy :: Type -> (TyCoVar, Type)

-- | Like splitForAllTy_maybe, but only returns Just if it is a tyvar
--   binder.
splitForAllTy_ty_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Like splitForAllTy_maybe, but only returns Just if it is a covar
--   binder.
splitForAllTy_co_maybe :: Type -> Maybe (TyCoVar, Type)

-- | Attempts to take a forall type apart; works with proper foralls and
--   functions
splitPiTy_maybe :: Type -> Maybe (TyCoBinder, Type)

-- | Takes a forall type apart, or panics
splitPiTy :: Type -> (TyCoBinder, Type)

-- | Split off all TyCoBinders to a type, splitting both proper foralls and
--   functions
splitPiTys :: Type -> ([TyCoBinder], Type)
mkTyCoPiTy :: TyCoBinder -> Type -> Type
mkTyCoPiTys :: [TyCoBinder] -> Type -> Type

-- | Given a list of type-level vars and the free vars of a result kind,
--   makes TyCoBinders, preferring anonymous binders if the variable is, in
--   fact, not dependent. e.g. mkTyConBindersPreferAnon
--   <a>(k:*),(b:k),(c:k)</a> We want (k:*) Named, (b:k) Anon, (c:k) Anon
--   
--   All non-coercion binders are <i>visible</i>.
mkTyConBindersPreferAnon :: [TyVar] -> TyCoVarSet -> [TyConBinder]

-- | Like <a>mkTyCoPiTys</a>, but does not check the occurrence of the
--   binder
mkPiTys :: [TyCoBinder] -> Type -> Type

-- | Makes a <tt>(-&gt;)</tt> type or an implicit forall type, depending on
--   whether it is given a type variable or a term variable. This is used,
--   for example, when producing the type of a lambda. Always uses Inferred
--   binders.
mkLamType :: Var -> Type -> Type

-- | <a>mkLamType</a> for multiple type or value arguments
mkLamTypes :: [Var] -> Type -> Type
piResultTy :: HasDebugCallStack => Type -> Type -> Type

-- | (piResultTys f_ty [ty1, .., tyn]) gives the type of (f ty1 .. tyn)
--   where f :: f_ty <a>piResultTys</a> is interesting because: 1.
--   <tt>f_ty</tt> may have more for-alls than there are args 2. Less
--   obviously, it may have fewer for-alls For case 2. think of:
--   piResultTys (forall a.a) [forall b.b, Int] This really can happen, but
--   only (I think) in situations involving undefined. For example:
--   undefined :: forall a. a Term: undefined <tt>(forall b. b-&gt;b)
--   </tt>Int This term should have type (Int -&gt; Int), but notice that
--   there are more type args than foralls in <a>undefined</a>s type.
piResultTys :: HasDebugCallStack => Type -> [Type] -> Type
applyTysX :: [TyVar] -> Type -> [Type] -> Type

-- | Drops all ForAllTys
dropForAlls :: Type -> Type
mkNumLitTy :: Integer -> Type

-- | Is this a numeric literal. We also look through type synonyms.
isNumLitTy :: Type -> Maybe Integer
mkStrLitTy :: FastString -> Type

-- | Is this a symbol literal. We also look through type synonyms.
isStrLitTy :: Type -> Maybe FastString

-- | Is this a type literal (symbol or numeric).
isLitTy :: Type -> Maybe TyLit

-- | Extract the RuntimeRep classifier of a type. For instance,
--   <tt>getRuntimeRep_maybe Int = LiftedRep</tt>. Returns <a>Nothing</a>
--   if this is not possible.
getRuntimeRep_maybe :: HasDebugCallStack => Type -> Maybe Type

-- | Given a kind (TYPE rr), extract its RuntimeRep classifier rr. For
--   example, <tt>kindRep_maybe * = Just LiftedRep</tt> Returns
--   <a>Nothing</a> if the kind is not of form (TYPE rr) Treats * and
--   Constraint as the same
kindRep_maybe :: HasDebugCallStack => Kind -> Maybe Type

-- | Extract the RuntimeRep classifier of a type from its kind. For
--   example, <tt>kindRep * = LiftedRep</tt>; Panics if this is not
--   possible. Treats * and Constraint as the same
kindRep :: HasDebugCallStack => Kind -> Type

-- | Make a <a>CastTy</a>. The Coercion must be nominal. Checks the
--   Coercion for reflexivity, dropping it if it's reflexive. See Note
--   [Respecting definitional equality] in TyCoRep
mkCastTy :: Type -> Coercion -> Type
mkCoercionTy :: Coercion -> Type
splitCastTy_maybe :: Type -> Maybe (Type, Coercion)

-- | Is this type a custom user error? If so, give us the kind and the
--   error message.
userTypeError_maybe :: Type -> Maybe Type

-- | Render a type corresponding to a user type error into a SDoc.
pprUserTypeErrorTy :: Type -> SDoc

-- | Get the type on the LHS of a coercion induced by a type/data family
--   instance.
coAxNthLHS :: CoAxiom br -> Int -> Type
stripCoercionTy :: Type -> Coercion

-- | Try to split up a coercion type into the types that it coerces
splitCoercionType_maybe :: Type -> Maybe (Type, Type)
splitPiTysInvisible :: Type -> ([TyCoBinder], Type)
splitPiTysInvisibleN :: Int -> Type -> ([TyCoBinder], Type)
invisibleTyBndrCount :: Type -> Int

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   invisible (i.e., <a>Inferred</a> or <a>Specified</a>) arguments.
filterOutInvisibleTypes :: TyCon -> [Type] -> [Type]

-- | Given a <a>TyCon</a> and a list of argument types, filter out any
--   <a>Inferred</a> arguments.
filterOutInferredTypes :: TyCon -> [Type] -> [Type]

-- | Given a <a>TyCon</a> and a list of argument types, partition the
--   arguments into:
--   
--   <ol>
--   <li><a>Inferred</a> or <a>Specified</a> (i.e., invisible) arguments
--   and</li>
--   <li><a>Required</a> (i.e., visible) arguments</li>
--   </ol>
partitionInvisibleTypes :: TyCon -> [Type] -> ([Type], [Type])

-- | Given a list of things paired with their visibilities, partition the
--   things into (invisible things, visible things).
partitionInvisibles :: [(a, ArgFlag)] -> ([a], [a])

-- | Given a <a>TyCon</a> and a list of argument types to which the
--   <a>TyCon</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Wrinkle: consider the following scenario:
--   
--   <pre>
--   T :: forall k. k -&gt; k
--   tyConArgFlags T [forall m. m -&gt; m -&gt; m, S, R, Q]
--   </pre>
--   
--   After substituting, we get
--   
--   <pre>
--   T (forall m. m -&gt; m -&gt; m) :: (forall m. m -&gt; m -&gt; m) -&gt; forall n. n -&gt; n -&gt; n
--   </pre>
--   
--   Thus, the first argument is invisible, <tt>S</tt> is visible,
--   <tt>R</tt> is invisible again, and <tt>Q</tt> is visible.
tyConArgFlags :: TyCon -> [Type] -> [ArgFlag]

-- | Given a <a>Type</a> and a list of argument types to which the
--   <a>Type</a> is applied, determine each argument's visibility
--   (<a>Inferred</a>, <a>Specified</a>, or <a>Required</a>).
--   
--   Most of the time, the arguments will be <a>Required</a>, but not
--   always. Consider <tt>f :: forall a. a -&gt; Type</tt>. In <tt>f Type
--   Bool</tt>, the first argument (<tt>Type</tt>) is <a>Specified</a> and
--   the second argument (<tt>Bool</tt>) is <a>Required</a>. It is
--   precisely this sort of higher-rank situation in which
--   <a>appTyArgFlags</a> comes in handy, since <tt>f Type Bool</tt> would
--   be represented in Core using <a>AppTy</a>s. (See also Trac #15792).
appTyArgFlags :: Type -> [Type] -> [ArgFlag]

-- | Find the result <a>Kind</a> of a type synonym, after applying it to
--   its <tt>arity</tt> number of type variables Actually this function
--   works fine on data types too, but they'd always return <a>*</a>, so we
--   never need to ask
synTyConResKind :: TyCon -> Kind
modifyJoinResTy :: Int -> (Type -> Type) -> Type -> Type
setJoinResTy :: Int -> Type -> Type -> Type

-- | This describes how a "map" operation over a type/coercion should
--   behave
data TyCoMapper env m
TyCoMapper :: Bool -> (env -> TyVar -> m Type) -> (env -> CoVar -> m Coercion) -> (env -> CoercionHole -> m Coercion) -> (env -> TyCoVar -> ArgFlag -> m (env, TyCoVar)) -> (TyCon -> m TyCon) -> TyCoMapper env m

-- | Should the new type be created with smart constructors?
[tcm_smart] :: TyCoMapper env m -> Bool
[tcm_tyvar] :: TyCoMapper env m -> env -> TyVar -> m Type
[tcm_covar] :: TyCoMapper env m -> env -> CoVar -> m Coercion

-- | What to do with coercion holes. See Note [Coercion holes] in TyCoRep.
[tcm_hole] :: TyCoMapper env m -> env -> CoercionHole -> m Coercion

-- | The returned env is used in the extended scope
[tcm_tycobinder] :: TyCoMapper env m -> env -> TyCoVar -> ArgFlag -> m (env, TyCoVar)

-- | This is used only to turn <tt>TcTyCon</tt>s into <a>TyCon</a>s. See
--   Note [Type checking recursive type and class declarations] in
--   TcTyClsDecls
[tcm_tycon] :: TyCoMapper env m -> TyCon -> m TyCon
mapType :: Monad m => TyCoMapper env m -> env -> Type -> m Type
mapCoercion :: Monad m => TyCoMapper env m -> env -> Coercion -> m Coercion

-- | Unwrap one <tt>layer</tt> of newtype on a type constructor and its
--   arguments, using an eta-reduced version of the <tt>newtype</tt> if
--   possible. This requires tys to have at least <tt>newTyConInstArity
--   tycon</tt> elements.
newTyConInstRhs :: TyCon -> [Type] -> Type

-- | Given a family instance TyCon and its arg types, return the
--   corresponding family type. E.g:
--   
--   <pre>
--   data family T a
--   data instance T (Maybe b) = MkT b
--   </pre>
--   
--   Where the instance tycon is :RTL, so:
--   
--   <pre>
--   mkFamilyTyConApp :RTL Int  =  T (Maybe Int)
--   </pre>
mkFamilyTyConApp :: TyCon -> [Type] -> Type
isDictLikeTy :: Type -> Bool

-- | Creates a primitive type equality predicate. Invariant: the types are
--   not Coercions
mkPrimEqPred :: Type -> Type -> Type
mkReprPrimEqPred :: Type -> Type -> Type

-- | Makes a lifted equality predicate at the given role
mkPrimEqPredRole :: Role -> Type -> Type -> PredType
equalityTyCon :: Role -> TyCon

-- | Creates a primite type equality predicate with explicit kinds
mkHeteroPrimEqPred :: Kind -> Kind -> Type -> Type -> Type

-- | Creates a primitive representational type equality predicate with
--   explicit kinds
mkHeteroReprPrimEqPred :: Kind -> Kind -> Type -> Type -> Type
mkClassPred :: Class -> [Type] -> PredType
isClassPred :: PredType -> Bool
isEqPred :: PredType -> Bool
isNomEqPred :: PredType -> Bool
isIPPred :: PredType -> Bool
isIPPred_maybe :: Type -> Maybe (FastString, Type)
isIPTyCon :: TyCon -> Bool
isIPClass :: Class -> Bool
isCTupleClass :: Class -> Bool
data PredTree
ClassPred :: Class -> [Type] -> PredTree
EqPred :: EqRel -> Type -> Type -> PredTree
IrredPred :: PredType -> PredTree
ForAllPred :: [TyCoVarBinder] -> [PredType] -> PredType -> PredTree

-- | A choice of equality relation. This is separate from the type
--   <a>Role</a> because <a>Phantom</a> does not define a (non-trivial)
--   equality relation.
data EqRel
NomEq :: EqRel
ReprEq :: EqRel
eqRelRole :: EqRel -> Role
classifyPredType :: PredType -> PredTree
getClassPredTys :: HasDebugCallStack => PredType -> (Class, [Type])
getClassPredTys_maybe :: PredType -> Maybe (Class, [Type])
getEqPredTys :: PredType -> (Type, Type)
getEqPredTys_maybe :: PredType -> Maybe (Role, Type, Type)
getEqPredRole :: PredType -> Role

-- | Get the equality relation relevant for a pred type.
predTypeEqRel :: PredType -> EqRel

-- | Do these denote the same level of visibility? <a>Required</a>
--   arguments are visible, others are not. So this function equates
--   <a>Specified</a> and <a>Inferred</a>. Used for printing.
sameVis :: ArgFlag -> ArgFlag -> Bool

-- | Make a named binder
mkTyCoVarBinder :: ArgFlag -> TyCoVar -> TyCoVarBinder

-- | Make many named binders
mkTyCoVarBinders :: ArgFlag -> [TyCoVar] -> [TyCoVarBinder]

-- | Make many named binders Input vars should be type variables
mkTyVarBinders :: ArgFlag -> [TyVar] -> [TyVarBinder]

-- | Make an anonymous binder
mkAnonBinder :: Type -> TyCoBinder

-- | Does this binder bind a variable that is <i>not</i> erased? Returns
--   <a>True</a> for anonymous binders.
isAnonTyCoBinder :: TyCoBinder -> Bool
binderVar :: VarBndr tv argf -> tv
binderVars :: [VarBndr tv argf] -> [tv]
binderType :: VarBndr TyCoVar argf -> Type
binderArgFlag :: VarBndr tv argf -> argf
tyCoBinderType :: TyCoBinder -> Type
tyCoBinderVar_maybe :: TyCoBinder -> Maybe TyCoVar
tyBinderType :: TyBinder -> Type

-- | Extract a relevant type, if there is one.
binderRelevantType_maybe :: TyCoBinder -> Maybe Type

-- | Like <a>maybe</a>, but for binders.
caseBinder :: TyCoBinder -> (TyCoVarBinder -> a) -> (Type -> a) -> a

-- | Does this <a>ArgFlag</a> classify an argument that is written in
--   Haskell?
isVisibleArgFlag :: ArgFlag -> Bool

-- | Does this <a>ArgFlag</a> classify an argument that is not written in
--   Haskell?
isInvisibleArgFlag :: ArgFlag -> Bool

-- | Does this binder bind a visible argument?
isVisibleBinder :: TyCoBinder -> Bool

-- | Does this binder bind an invisible argument?
isInvisibleBinder :: TyCoBinder -> Bool
isNamedBinder :: TyCoBinder -> Bool
tyConBindersTyCoBinders :: [TyConBinder] -> [TyCoBinder]

-- | The <tt>(-&gt;)</tt> type constructor.
--   
--   <pre>
--   (-&gt;) :: forall (rep1 :: RuntimeRep) (rep2 :: RuntimeRep).
--           TYPE rep1 -&gt; TYPE rep2 -&gt; *
--   </pre>
funTyCon :: TyCon
isTyVarTy :: Type -> Bool
isFunTy :: Type -> Bool
isDictTy :: Type -> Bool
isPredTy :: Type -> Bool
isCoercionTy :: Type -> Bool
isCoercionTy_maybe :: Type -> Maybe Coercion

-- | Checks whether this is a proper forall (with a named binder)
isForAllTy :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a tyvar binder
isForAllTy_ty :: Type -> Bool

-- | Like <a>isForAllTy</a>, but returns True only if it is a covar binder
isForAllTy_co :: Type -> Bool

-- | Is this a function or forall?
isPiTy :: Type -> Bool
isTauTy :: Type -> Bool
isFamFreeTy :: Type -> Bool

-- | Does this type classify a core (unlifted) Coercion? At either role
--   nominal or representational (t1 ~ t2) See Note [Types for coercions,
--   predicates, and evidence]
isCoVarType :: Type -> Bool
isEvVarType :: Type -> Bool

-- | Determine whether a type could be the type of a join point of given
--   total arity, according to the polymorphism rule. A join point cannot
--   be polymorphic in its return type, since given join j <tt>a </tt>b x y
--   z = e1 in e2, the types of e1 and e2 must be the same, and a and b are
--   not in scope for e2. (See Note [The polymorphism rule of join points]
--   in CoreSyn.) Returns False also if the type simply doesn't have enough
--   arguments.
--   
--   Note that we need to know how many arguments (type *and* value) the
--   putative join point takes; for instance, if j :: forall a. a -&gt; Int
--   then j could be a binary join point returning an Int, but it could
--   *not* be a unary join point returning a -&gt; Int.
--   
--   TODO: See Note [Excess polymorphism and join points]
isValidJoinPointType :: JoinArity -> Type -> Bool

-- | Returns Just True if this type is surely lifted, Just False if it is
--   surely unlifted, Nothing if we can't be sure (i.e., it is levity
--   polymorphic), and panics if the kind does not have the shape TYPE r.
isLiftedType_maybe :: HasDebugCallStack => Type -> Maybe Bool

-- | See <a>Type#type_classification</a> for what an unlifted type is.
--   Panics on levity polymorphic types.
isUnliftedType :: HasDebugCallStack => Type -> Bool
isUnboxedTupleType :: Type -> Bool
isUnboxedSumType :: Type -> Bool

-- | See <a>Type#type_classification</a> for what an algebraic type is.
--   Should only be applied to <i>types</i>, as opposed to e.g. partially
--   saturated type constructors
isAlgType :: Type -> Bool

-- | Check whether a type is a data family type
isDataFamilyAppType :: Type -> Bool

-- | Returns true of types that are opaque to Haskell.
isPrimitiveType :: Type -> Bool

-- | Computes whether an argument (or let right hand side) should be
--   computed strictly or lazily, based only on its type. Currently, it's
--   just <a>isUnliftedType</a>. Panics on levity-polymorphic types.
isStrictType :: HasDebugCallStack => Type -> Bool

-- | Is this the type <a>RuntimeRep</a>?
isRuntimeRepTy :: Type -> Bool

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Is this a type of kind RuntimeRep? (e.g. LiftedRep)
isRuntimeRepKindedTy :: Type -> Bool

-- | Drops prefix of RuntimeRep constructors in <a>TyConApp</a>s. Useful
--   for e.g. dropping 'LiftedRep arguments of unboxed tuple TyCon
--   applications:
--   
--   dropRuntimeRepArgs [ 'LiftedRep, 'IntRep , String, Int]
dropRuntimeRepArgs :: [Type] -> [Type]

-- | Extract the RuntimeRep classifier of a type. For instance,
--   <tt>getRuntimeRep_maybe Int = LiftedRep</tt>. Panics if this is not
--   possible.
getRuntimeRep :: HasDebugCallStack => Type -> Type

-- | The key type representing kinds in the compiler.
type Kind = Type
typeKind :: HasDebugCallStack => Type -> Kind
tcTypeKind :: HasDebugCallStack => Type -> Kind

-- | Returns True if a type is levity polymorphic. Should be the same as
--   (isKindLevPoly . typeKind) but much faster. Precondition: The type has
--   kind (TYPE blah)
isTypeLevPoly :: Type -> Bool

-- | Looking past all pi-types, is the end result potentially levity
--   polymorphic? Example: True for (forall r (a :: TYPE r). String -&gt;
--   a) Example: False for (forall r1 r2 (a :: TYPE r1) (b :: TYPE r2). a
--   -&gt; b -&gt; Type)
resultIsLevPoly :: Type -> Bool

-- | Is this kind equivalent to <tt>*</tt>?
--   
--   This considers <tt>Constraint</tt> to be distinct from <tt>*</tt>. For
--   a version that treats them as the same type, see
--   <a>isLiftedTypeKind</a>.
tcIsLiftedTypeKind :: Kind -> Bool
tcIsConstraintKind :: Kind -> Bool
tcReturnsConstraintKind :: Kind -> Bool
liftedTypeKind :: Kind

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in FV.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in FV for explanation.
tyCoFVsOfType :: Type -> FV
tyCoFVsBndr :: TyCoVarBinder -> FV -> FV
tyCoFVsVarBndr :: Var -> FV -> FV
tyCoFVsVarBndrs :: [Var] -> FV -> FV
tyCoVarsOfType :: Type -> TyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in FV.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet
coVarsOfType :: Type -> CoVarSet
coVarsOfTypes :: [Type] -> TyCoVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | Given a list of tyvars returns a deterministic FV computation that
--   returns the given tyvars with the kind variables free in the kinds of
--   the given tyvars.
closeOverKindsFV :: [TyVar] -> FV

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministically ordered list.
closeOverKindsList :: [TyVar] -> [TyVar]

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a non-deterministic set.
closeOverKinds :: TyVarSet -> TyVarSet

-- | Returns True if this type has no free variables. Should be the same as
--   isEmptyVarSet . tyCoVarsOfType, but faster in the non-forall case.
noFreeVarsOfType :: Type -> Bool

-- | Retrieve the free variables in this type, splitting them based on
--   whether they are used visibly or invisibly. Invisible ones come first.
splitVisVarsOfType :: Type -> Pair TyCoVarSet
splitVisVarsOfTypes :: [Type] -> Pair TyCoVarSet

-- | Expand out all type synonyms. Actually, it'd suffice to expand out
--   just the ones that discard type variables (e.g. type Funny a = Int)
--   But we don't know which those are currently, so we just expand all.
--   
--   <a>expandTypeSynonyms</a> only expands out type synonyms mentioned in
--   the type, not in the kinds of any TyCon or TyVar mentioned in the
--   type.
--   
--   Keep this synchronized with <tt>synonymTyConsOfType</tt>
expandTypeSynonyms :: Type -> Type
typeSize :: Type -> Int
occCheckExpand :: [Var] -> Type -> Maybe Type

-- | Extract a well-scoped list of variables from a deterministic set of
--   variables. The result is deterministic. NB: There used to exist
--   varSetElemsWellScoped :: VarSet -&gt; [Var] which took a
--   non-deterministic set and produced a non-deterministic well-scoped
--   list. If you care about the list being well-scoped you also most
--   likely care about it being in deterministic order.
dVarSetElemsWellScoped :: DVarSet -> [Var]

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in RnTypes
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | Get the free vars of a type in scoped order
tyCoVarsOfTypeWellScoped :: Type -> [TyVar]

-- | Get the free vars of types in scoped order
tyCoVarsOfTypesWellScoped :: [Type] -> [TyVar]

-- | Given the suffix of a telescope, returns the prefix. Ex: given [(k ::
--   j), (a :: Proxy k)], returns [(j :: *)].
tyCoVarsOfBindersWellScoped :: [TyVar] -> [TyVar]

-- | Type equality on source types. Does not look through <tt>newtypes</tt>
--   or <a>PredType</a>s, but it does look through type synonyms. This
--   first checks that the kinds of the types are equal and then checks
--   whether the types are equal, ignoring casts and coercions. (The kind
--   check is a recursive call, but since all kinds have type
--   <tt>Type</tt>, there is no need to check the types of kinds.) See also
--   Note [Non-trivial definitional equality] in TyCoRep.
eqType :: Type -> Type -> Bool

-- | Compare types with respect to a (presumably) non-empty <a>RnEnv2</a>.
eqTypeX :: RnEnv2 -> Type -> Type -> Bool

-- | Type equality on lists of types, looking through type synonyms but not
--   newtypes.
eqTypes :: [Type] -> [Type] -> Bool
nonDetCmpType :: Type -> Type -> Ordering
nonDetCmpTypes :: [Type] -> [Type] -> Ordering
nonDetCmpTypeX :: RnEnv2 -> Type -> Type -> Ordering
nonDetCmpTypesX :: RnEnv2 -> [Type] -> [Type] -> Ordering

-- | Compare two <a>TyCon</a>s. NB: This should <i>never</i> see
--   <tt>Constraint</tt> (as recognized by Kind.isConstraintKindCon) which
--   is considered a synonym for <a>Type</a> in Core. See Note [Kind
--   Constraint and kind Type] in Kind. See Note [nonDetCmpType
--   nondeterminism]
nonDetCmpTc :: TyCon -> TyCon -> Ordering
eqVarBndrs :: RnEnv2 -> [Var] -> [Var] -> Maybe RnEnv2
seqType :: Type -> ()
seqTypes :: [Type] -> ()

-- | This function Strips off the <i>top layer only</i> of a type synonym
--   application (if any) its underlying representation type. Returns
--   Nothing if there is nothing to look through. This function considers
--   <tt>Constraint</tt> to be a synonym of <tt>TYPE LiftedRep</tt>.
--   
--   By being non-recursive and inlined, this case analysis gets
--   efficiently joined onto the case analysis that the caller is already
--   doing
coreView :: Type -> Maybe Type

-- | Gives the typechecker view of a type. This unwraps synonyms but leaves
--   <tt>Constraint</tt> alone. c.f. coreView, which turns Constraint into
--   TYPE LiftedRep. Returns Nothing if no unwrapping happens. See also
--   Note [coreView vs tcView]
tcView :: Type -> Maybe Type

-- | All type constructors occurring in the type; looking through type
--   synonyms, but not newtypes. When it finds a Class, it returns the
--   class TyCon.
tyConsOfType :: Type -> UniqSet TyCon

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | Type &amp; coercion substitution
--   
--   The following invariants must hold of a <a>TCvSubst</a>:
--   
--   <ol>
--   <li>The in-scope set is needed <i>only</i> to guide the generation of
--   fresh uniques</li>
--   <li>In particular, the <i>kind</i> of the type variables in the
--   in-scope set is not relevant</li>
--   <li>The substitution is only applied ONCE! This is because in general
--   such application will not reach a fixed point.</li>
--   </ol>
data TCvSubst
TCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> TCvSubst
emptyTvSubstEnv :: TvSubstEnv
emptyTCvSubst :: TCvSubst
mkEmptyTCvSubst :: InScopeSet -> TCvSubst
mkTCvSubst :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
zipTvSubst :: [TyVar] -> [Type] -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
mkTvSubstPrs :: [(TyVar, Type)] -> TCvSubst
zipTCvSubst :: [TyCoVar] -> [Type] -> TCvSubst
notElemTCvSubst :: Var -> TCvSubst -> Bool
getTvSubstEnv :: TCvSubst -> TvSubstEnv
setTvSubstEnv :: TCvSubst -> TvSubstEnv -> TCvSubst
zapTCvSubst :: TCvSubst -> TCvSubst
getTCvInScope :: TCvSubst -> InScopeSet

-- | Returns the free variables of the types in the range of a substitution
--   as a non-deterministic set.
getTCvSubstRangeFVs :: TCvSubst -> VarSet
extendTCvInScope :: TCvSubst -> Var -> TCvSubst
extendTCvInScopeList :: TCvSubst -> [Var] -> TCvSubst
extendTCvInScopeSet :: TCvSubst -> VarSet -> TCvSubst
extendTCvSubst :: TCvSubst -> TyCoVar -> Type -> TCvSubst
extendCvSubst :: TCvSubst -> CoVar -> Coercion -> TCvSubst
extendTvSubst :: TCvSubst -> TyVar -> Type -> TCvSubst
extendTvSubstBinderAndInScope :: TCvSubst -> TyCoBinder -> Type -> TCvSubst
extendTvSubstList :: TCvSubst -> [Var] -> [Type] -> TCvSubst
extendTvSubstAndInScope :: TCvSubst -> TyVar -> Type -> TCvSubst
extendTCvSubstList :: TCvSubst -> [Var] -> [Type] -> TCvSubst
extendTvSubstWithClone :: TCvSubst -> TyVar -> TyVar -> TCvSubst
extendTCvSubstWithClone :: TCvSubst -> TyCoVar -> TyCoVar -> TCvSubst
isInScope :: Var -> TCvSubst -> Bool

-- | <tt>(compose env1 env2)(x)</tt> is <tt>env1(env2(x))</tt>; i.e. apply
--   <tt>env2</tt> then <tt>env1</tt>. It assumes that both are idempotent.
--   Typically, <tt>env1</tt> is the refinement to a base substitution
--   <tt>env2</tt>
composeTCvSubstEnv :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> (TvSubstEnv, CvSubstEnv) -> (TvSubstEnv, CvSubstEnv)

-- | Composes two substitutions, applying the second one provided first,
--   like in function composition.
composeTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst
zipTyEnv :: [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: [CoVar] -> [Coercion] -> CvSubstEnv
isEmptyTCvSubst :: TCvSubst -> Bool
unionTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasCallStack => TCvSubst -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasCallStack => TCvSubst -> [Type] -> [Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Type substitution, see <a>zipTvSubst</a>
substTysWith :: [TyVar] -> [Type] -> [Type] -> [Type]

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasCallStack => TCvSubst -> ThetaType -> ThetaType

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: TCvSubst -> Type -> Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: TCvSubst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: TCvSubst -> [Type] -> [Type]

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: TCvSubst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: TCvSubst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion
substTyVarBndr :: HasCallStack => TCvSubst -> TyVar -> (TCvSubst, TyVar)
substTyVarBndrs :: HasCallStack => TCvSubst -> [TyVar] -> (TCvSubst, [TyVar])
substTyVar :: TCvSubst -> TyVar -> Type
substTyVars :: TCvSubst -> [TyVar] -> [Type]
substVarBndr :: HasCallStack => TCvSubst -> TyCoVar -> (TCvSubst, TyCoVar)
substVarBndrs :: HasCallStack => TCvSubst -> [TyCoVar] -> (TCvSubst, [TyCoVar])
cloneTyVarBndr :: TCvSubst -> TyVar -> Unique -> (TCvSubst, TyVar)
cloneTyVarBndrs :: TCvSubst -> [TyVar] -> UniqSupply -> (TCvSubst, [TyVar])
lookupTyVar :: TCvSubst -> TyVar -> Maybe Type
pprType :: Type -> SDoc
pprParendType :: Type -> SDoc
pprPrecType :: PprPrec -> Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc
pprTyThingCategory :: TyThing -> SDoc
pprShortTyThing :: TyThing -> SDoc
pprTCvBndr :: TyCoVarBinder -> SDoc
pprTCvBndrs :: [TyCoVarBinder] -> SDoc
pprForAll :: [TyCoVarBinder] -> SDoc

-- | Print a user-level forall; see Note [When to print foralls]
pprUserForAll :: [TyCoVarBinder] -> SDoc
pprSigmaType :: Type -> SDoc

-- | Display all kind information (with <tt>-fprint-explicit-kinds</tt>)
--   when the provided <a>Bool</a> argument is <a>True</a>. See <tt>Note
--   [Kind arguments in error messages]</tt> in <a>TcErrors</a>.
pprWithExplicitKindsWhen :: Bool -> SDoc -> SDoc
pprTheta :: ThetaType -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
pprClassPred :: Class -> [Type] -> SDoc
pprKind :: Kind -> SDoc
pprParendKind :: Kind -> SDoc

-- | Pretty prints a <a>TyCon</a>, using the family instance in case of a
--   representation tycon. For example:
--   
--   <pre>
--   data T [a] = ...
--   </pre>
--   
--   In that case we want to print <tt>T [a]</tt>, where <tt>T</tt> is the
--   family <a>TyCon</a>
pprSourceTyCon :: TyCon -> SDoc

-- | A general-purpose pretty-printing precedence type.
newtype PprPrec
PprPrec :: Int -> PprPrec
topPrec :: PprPrec
sigPrec :: PprPrec
opPrec :: PprPrec
funPrec :: PprPrec
appPrec :: PprPrec
maybeParen :: PprPrec -> PprPrec -> SDoc -> SDoc
pprTyVar :: TyVar -> SDoc
pprTyVars :: [TyVar] -> SDoc

-- | This variant preserves any use of TYPE in a type, effectively locally
--   setting -fprint-explicit-runtime-reps.
pprWithTYPE :: Type -> SDoc
tidyType :: TidyEnv -> Type -> Type
tidyTypes :: TidyEnv -> [Type] -> [Type]
tidyOpenType :: TidyEnv -> Type -> (TidyEnv, Type)

-- | Grabs the free type variables, tidies them and then uses
--   <a>tidyType</a> to work over the type itself
tidyOpenTypes :: TidyEnv -> [Type] -> (TidyEnv, [Type])
tidyOpenKind :: TidyEnv -> Kind -> (TidyEnv, Kind)
tidyVarBndr :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)

-- | This tidies up a type for printing in an error message, or in an
--   interface file.
--   
--   It doesn't change the uniques at all, just the print names.
tidyVarBndrs :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])

-- | Add the free <a>TyVar</a>s to the env in tidy form, so that we can
--   tidy the type they are free in
tidyFreeTyCoVars :: TidyEnv -> [TyCoVar] -> TidyEnv

-- | Treat a new <a>TyCoVar</a> as a binder, and give it a fresh tidy name
--   using the environment if one has not already been allocated. See also
--   <a>tidyVarBndr</a>
tidyOpenTyCoVar :: TidyEnv -> TyCoVar -> (TidyEnv, TyCoVar)
tidyOpenTyCoVars :: TidyEnv -> [TyCoVar] -> (TidyEnv, [TyCoVar])
tidyTyCoVarOcc :: TidyEnv -> TyCoVar -> TyCoVar

-- | Calls <a>tidyType</a> on a top-level type (i.e. with an empty tidying
--   environment)
tidyTopType :: Type -> Type
tidyKind :: TidyEnv -> Kind -> Kind
tidyTyCoVarBinder :: TidyEnv -> VarBndr TyCoVar vis -> (TidyEnv, VarBndr TyCoVar vis)
tidyTyCoVarBinders :: TidyEnv -> [VarBndr TyCoVar vis] -> (TidyEnv, [VarBndr TyCoVar vis])
instance GHC.Enum.Bounded Type.TypeOrdering
instance GHC.Enum.Enum Type.TypeOrdering
instance GHC.Classes.Ord Type.TypeOrdering
instance GHC.Classes.Eq Type.TypeOrdering
instance GHC.Classes.Ord Type.EqRel
instance GHC.Classes.Eq Type.EqRel
instance Outputable.Outputable Type.EqRel

module PatSyn

-- | Pattern Synonym
--   
--   See Note [Pattern synonym representation] See Note [Pattern synonym
--   signature contexts]
data PatSyn

-- | Build a new pattern synonym
mkPatSyn :: Name -> Bool -> ([TyVarBinder], ThetaType) -> ([TyVarBinder], ThetaType) -> [Type] -> Type -> (Id, Bool) -> Maybe (Id, Bool) -> [FieldLabel] -> PatSyn

-- | The <a>Name</a> of the <a>PatSyn</a>, giving it a unique, rooted
--   identification
patSynName :: PatSyn -> Name

-- | Arity of the pattern synonym
patSynArity :: PatSyn -> Arity

-- | Should the <a>PatSyn</a> be presented infix?
patSynIsInfix :: PatSyn -> Bool
patSynArgs :: PatSyn -> [Type]
patSynMatcher :: PatSyn -> (Id, Bool)
patSynBuilder :: PatSyn -> Maybe (Id, Bool)
patSynUnivTyVarBinders :: PatSyn -> [TyVarBinder]
patSynExTyVars :: PatSyn -> [TyVar]
patSynExTyVarBinders :: PatSyn -> [TyVarBinder]
patSynSig :: PatSyn -> ([TyVar], ThetaType, [TyVar], ThetaType, [Type], Type)
patSynInstArgTys :: PatSyn -> [Type] -> [Type]
patSynInstResTy :: PatSyn -> [Type] -> Type
patSynFieldLabels :: PatSyn -> [FieldLabel]

-- | Extract the type for any given labelled field of the <tt>DataCon</tt>
patSynFieldType :: PatSyn -> FieldLabelString -> Type
tidyPatSynIds :: (Id -> Id) -> PatSyn -> PatSyn

-- | Print the type of a pattern synonym. The foralls are printed
--   explicitly
pprPatSynType :: PatSyn -> SDoc
instance GHC.Classes.Eq PatSyn.PatSyn
instance Unique.Uniquable PatSyn.PatSyn
instance Name.NamedThing PatSyn.PatSyn
instance Outputable.Outputable PatSyn.PatSyn
instance Outputable.OutputableBndr PatSyn.PatSyn
instance Data.Data.Data PatSyn.PatSyn

module Literal

-- | So-called <a>Literal</a>s are one of:
--   
--   <ul>
--   <li>An unboxed numeric literal or floating-point literal which is
--   presumed to be surrounded by appropriate constructors (<tt>Int#</tt>,
--   etc.), so that the overall thing makes sense.</li>
--   </ul>
--   
--   We maintain the invariant that the <a>Integer</a> in the
--   <a>LitNumber</a> constructor is actually in the (possibly
--   target-dependent) range. The mkLit{Int,Word}*Wrap smart constructors
--   ensure this by applying the target machine's wrapping semantics. Use
--   these in situations where you know the wrapping semantics are correct.
--   
--   <ul>
--   <li>The literal derived from the label mentioned in a "foreign label"
--   declaration (<a>LitLabel</a>)</li>
--   <li>A <a>LitRubbish</a> to be used in place of values of
--   <a>UnliftedRep</a> (i.e. 'MutVar#') when the the value is never
--   used.</li>
--   <li>A character</li>
--   <li>A string</li>
--   <li>The NULL pointer</li>
--   </ul>
data Literal

-- | <tt>Char#</tt> - at least 31 bits. Create with <a>mkLitChar</a>
LitChar :: Char -> Literal

-- | Any numeric literal that can be internally represented with an Integer
LitNumber :: !LitNumType -> !Integer -> Type -> Literal

-- | A string-literal: stored and emitted UTF-8 encoded, we'll arrange to
--   decode it at runtime. Also emitted with a <tt>'\0'</tt> terminator.
--   Create with <a>mkLitString</a>
LitString :: ByteString -> Literal

-- | The <tt>NULL</tt> pointer, the only pointer value that can be
--   represented as a Literal. Create with <a>nullAddrLit</a>
LitNullAddr :: Literal

-- | A nonsense value, used when an unlifted binding is absent and has type
--   <tt>forall (a :: <tt>TYPE</tt> <a>UnliftedRep</a>). a</tt>. May be
--   lowered by code-gen to any possible value. Also see Note [Rubbish
--   literals]
LitRubbish :: Literal

-- | <tt>Float#</tt>. Create with <a>mkLitFloat</a>
LitFloat :: Rational -> Literal

-- | <tt>Double#</tt>. Create with <a>mkLitDouble</a>
LitDouble :: Rational -> Literal

-- | A label literal. Parameters:
--   
--   1) The name of the symbol mentioned in the declaration
--   
--   2) The size (in bytes) of the arguments the label expects. Only
--   applicable with <tt>stdcall</tt> labels. <tt>Just x</tt> =&gt;
--   <tt>&lt;x&gt;</tt> will be appended to label name when emitting
--   assembly.
--   
--   3) Flag indicating whether the symbol references a function or a data
LitLabel :: FastString -> Maybe Int -> FunctionOrData -> Literal

-- | Numeric literal type
data LitNumType

-- | <tt>Integer</tt> (see Note [Integer literals])
LitNumInteger :: LitNumType

-- | <tt>Natural</tt> (see Note [Natural literals])
LitNumNatural :: LitNumType

-- | <tt>Int#</tt> - according to target machine
LitNumInt :: LitNumType

-- | <tt>Int64#</tt> - exactly 64 bits
LitNumInt64 :: LitNumType

-- | <tt>Word#</tt> - according to target machine
LitNumWord :: LitNumType

-- | <tt>Word64#</tt> - exactly 64 bits
LitNumWord64 :: LitNumType

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>
mkLitInt :: DynFlags -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>. If the argument is out
--   of the (target-dependent) range, it is wrapped. See Note [Word<i>Int
--   underflow</i>overflow]
mkLitIntWrap :: DynFlags -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int#</tt>, as well as a
--   <a>Bool</a>ean flag indicating overflow. That is, if the argument is
--   out of the (target-dependent) range the argument is wrapped and the
--   overflow flag will be set. See Note [Word<i>Int underflow</i>overflow]
mkLitIntWrapC :: DynFlags -> Integer -> (Literal, Bool)

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>
mkLitWord :: DynFlags -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>. If the argument is
--   out of the (target-dependent) range, it is wrapped. See Note
--   [Word<i>Int underflow</i>overflow]
mkLitWordWrap :: DynFlags -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word#</tt>, as well as a
--   <a>Bool</a>ean flag indicating carry. That is, if the argument is out
--   of the (target-dependent) range the argument is wrapped and the carry
--   flag will be set. See Note [Word<i>Int underflow</i>overflow]
mkLitWordWrapC :: DynFlags -> Integer -> (Literal, Bool)

-- | Creates a <a>Literal</a> of type <tt>Int64#</tt>
mkLitInt64 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Int64#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitInt64Wrap :: DynFlags -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word64#</tt>
mkLitWord64 :: Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Word64#</tt>. If the argument is
--   out of the range, it is wrapped.
mkLitWord64Wrap :: DynFlags -> Integer -> Literal

-- | Creates a <a>Literal</a> of type <tt>Float#</tt>
mkLitFloat :: Rational -> Literal

-- | Creates a <a>Literal</a> of type <tt>Double#</tt>
mkLitDouble :: Rational -> Literal

-- | Creates a <a>Literal</a> of type <tt>Char#</tt>
mkLitChar :: Char -> Literal

-- | Creates a <a>Literal</a> of type <tt>Addr#</tt>, which is appropriate
--   for passing to e.g. some of the "error" functions in GHC.Err such as
--   <tt>GHC.Err.runtimeError</tt>
mkLitString :: String -> Literal
mkLitInteger :: Integer -> Type -> Literal
mkLitNatural :: Integer -> Type -> Literal

-- | Create a numeric <a>Literal</a> of the given type
mkLitNumber :: DynFlags -> LitNumType -> Integer -> Type -> Literal

-- | Create a numeric <a>Literal</a> of the given type
mkLitNumberWrap :: DynFlags -> LitNumType -> Integer -> Type -> Literal

-- | Find the Haskell <a>Type</a> the literal occupies
literalType :: Literal -> Type
absentLiteralOf :: TyCon -> Maybe Literal
pprLiteral :: (SDoc -> SDoc) -> Literal -> SDoc

-- | Indicate if a numeric literal type supports negative numbers
litNumIsSigned :: LitNumType -> Bool

-- | Check that a given number is in the range of a numeric literal
litNumCheckRange :: DynFlags -> LitNumType -> Integer -> Bool

-- | True if code space does not go bad if we duplicate this literal
litIsDupable :: DynFlags -> Literal -> Bool

-- | True if there is absolutely no penalty to duplicating the literal.
--   False principally of strings.
--   
--   "Why?", you say? I'm glad you asked. Well, for one duplicating strings
--   would blow up code sizes. Not only this, it's also unsafe.
--   
--   Consider a program that wants to traverse a string. One way it might
--   do this is to first compute the Addr# pointing to the end of the
--   string, and then, starting from the beginning, bump a pointer using
--   eqAddr# to determine the end. For instance,
--   
--   <pre>
--   -- Given pointers to the start and end of a string, count how many zeros
--   -- the string contains.
--   countZeros :: Addr -&gt; -&gt; Int
--   countZeros start end = go start 0
--     where
--       go off n
--         | off `addrEq#` end = n
--         | otherwise         = go (off `plusAddr#` 1) n'
--         where n' | isTrue off 0 0#) = n + 1
--                  | otherwise                                 = n
--   </pre>
--   
--   Consider what happens if we considered strings to be trivial (and
--   therefore duplicable) and emitted a call like <tt>countZeros "hello"
--   <tt>plusAddr</tt># 5)</tt>. The beginning and end pointers do not
--   belong to the same string, meaning that an iteration like the above
--   would blow up terribly. This is what happened in #12757.
--   
--   Ultimately the solution here is to make primitive strings a bit more
--   structured, ensuring that the compiler can't inline in ways that will
--   break user code. One approach to this is described in #8472.
litIsTrivial :: Literal -> Bool
litIsLifted :: Literal -> Bool
inIntRange :: DynFlags -> Integer -> Bool
inWordRange :: DynFlags -> Integer -> Bool
tARGET_MAX_INT :: DynFlags -> Integer
inCharRange :: Char -> Bool

-- | Tests whether the literal represents a zero of whatever type it is
isZeroLit :: Literal -> Bool
litFitsInChar :: Literal -> Bool

-- | Returns the <a>Integer</a> contained in the <a>Literal</a>, for when
--   that makes sense, i.e. for <a>Char</a>, <a>Int</a>, <a>Word</a>,
--   <tt>LitInteger</tt> and <tt>LitNatural</tt>.
litValue :: Literal -> Integer

-- | Indicate if the <a>Literal</a> contains an <a>Integer</a> value, e.g.
--   <a>Char</a>, <a>Int</a>, <a>Word</a>, <tt>LitInteger</tt> and
--   <tt>LitNatural</tt>.
isLitValue :: Literal -> Bool

-- | Returns the <a>Integer</a> contained in the <a>Literal</a>, for when
--   that makes sense, i.e. for <a>Char</a> and numbers.
isLitValue_maybe :: Literal -> Maybe Integer

-- | Apply a function to the <a>Integer</a> contained in the
--   <a>Literal</a>, for when that makes sense, e.g. for <a>Char</a> and
--   numbers. For fixed-size integral literals, the result will be wrapped
--   in accordance with the semantics of the target type. See Note
--   [Word<i>Int underflow</i>overflow]
mapLitValue :: DynFlags -> (Integer -> Integer) -> Literal -> Literal
word2IntLit :: DynFlags -> Literal -> Literal
int2WordLit :: DynFlags -> Literal -> Literal

-- | Narrow a literal number (unchecked result range)
narrowLit :: forall a. Integral a => Proxy a -> Literal -> Literal
narrow8IntLit :: Literal -> Literal
narrow16IntLit :: Literal -> Literal
narrow32IntLit :: Literal -> Literal
narrow8WordLit :: Literal -> Literal
narrow16WordLit :: Literal -> Literal
narrow32WordLit :: Literal -> Literal
char2IntLit :: Literal -> Literal
int2CharLit :: Literal -> Literal
float2IntLit :: Literal -> Literal
int2FloatLit :: Literal -> Literal
double2IntLit :: Literal -> Literal
int2DoubleLit :: Literal -> Literal
nullAddrLit :: Literal

-- | A nonsense literal of type <tt>forall (a :: <tt>TYPE</tt>
--   <a>UnliftedRep</a>). a</tt>.
rubbishLit :: Literal
float2DoubleLit :: Literal -> Literal
double2FloatLit :: Literal -> Literal
instance Data.Data.Data Literal.Literal
instance GHC.Classes.Ord Literal.LitNumType
instance GHC.Classes.Eq Literal.LitNumType
instance GHC.Enum.Enum Literal.LitNumType
instance Data.Data.Data Literal.LitNumType
instance Binary.Binary Literal.Literal
instance Outputable.Outputable Literal.Literal
instance GHC.Classes.Eq Literal.Literal
instance GHC.Classes.Ord Literal.Literal
instance Binary.Binary Literal.LitNumType

module TrieMap
data MaybeMap m a
data ListMap m a
type LiteralMap a = Map Literal a
class TrieMap m where {
    type family Key m :: *;
}
emptyTM :: TrieMap m => m a
lookupTM :: forall b. TrieMap m => Key m -> m b -> Maybe b
alterTM :: forall b. TrieMap m => Key m -> XT b -> m b -> m b
mapTM :: TrieMap m => (a -> b) -> m a -> m b
foldTM :: TrieMap m => (a -> b -> b) -> m a -> b -> b
insertTM :: TrieMap m => Key m -> a -> m a -> m a
deleteTM :: TrieMap m => Key m -> m a -> m a
(>.>) :: (a -> b) -> (b -> c) -> a -> c
infixr 1 >.>
(|>) :: a -> (a -> b) -> b
infixr 1 |>
(|>>) :: TrieMap m2 => (XT (m2 a) -> m1 (m2 a) -> m1 (m2 a)) -> (m2 a -> m2 a) -> m1 (m2 a) -> m1 (m2 a)
infixr 1 |>>
type XT a = Maybe a -> Maybe a
foldMaybe :: (a -> b -> b) -> Maybe a -> b -> b
data GenMap m a
lkG :: (Eq (Key m), TrieMap m) => Key m -> GenMap m a -> Maybe a
xtG :: (Eq (Key m), TrieMap m) => Key m -> XT a -> GenMap m a -> GenMap m a
mapG :: TrieMap m => (a -> b) -> GenMap m a -> GenMap m b
fdG :: TrieMap m => (a -> b -> b) -> GenMap m a -> b -> b
xtList :: TrieMap m => (forall b. k -> XT b -> m b -> m b) -> [k] -> XT a -> ListMap m a -> ListMap m a
lkList :: TrieMap m => (forall b. k -> m b -> Maybe b) -> [k] -> ListMap m a -> Maybe a
instance (Outputable.Outputable a, Outputable.Outputable (m a)) => Outputable.Outputable (TrieMap.GenMap m a)
instance (GHC.Classes.Eq (TrieMap.Key m), TrieMap.TrieMap m) => TrieMap.TrieMap (TrieMap.GenMap m)
instance TrieMap.TrieMap m => TrieMap.TrieMap (TrieMap.ListMap m)
instance (TrieMap.TrieMap m, Outputable.Outputable a) => Outputable.Outputable (TrieMap.ListMap m a)
instance TrieMap.TrieMap m => TrieMap.TrieMap (TrieMap.MaybeMap m)
instance TrieMap.TrieMap Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord k => TrieMap.TrieMap (Data.Map.Internal.Map k)
instance TrieMap.TrieMap UniqDFM.UniqDFM

module HsLit

-- | Haskell Literal
data HsLit x

-- | Character
HsChar :: XHsChar x -> Char -> HsLit x

-- | Unboxed character
HsCharPrim :: XHsCharPrim x -> Char -> HsLit x

-- | String
HsString :: XHsString x -> FastString -> HsLit x

-- | Packed bytes
HsStringPrim :: XHsStringPrim x -> ByteString -> HsLit x

-- | Genuinely an Int; arises from <tt>TcGenDeriv</tt>, and from
--   TRANSLATION
HsInt :: XHsInt x -> IntegralLit -> HsLit x

-- | literal <tt>Int#</tt>
HsIntPrim :: XHsIntPrim x -> Integer -> HsLit x

-- | literal <tt>Word#</tt>
HsWordPrim :: XHsWordPrim x -> Integer -> HsLit x

-- | literal <tt>Int64#</tt>
HsInt64Prim :: XHsInt64Prim x -> Integer -> HsLit x

-- | literal <tt>Word64#</tt>
HsWord64Prim :: XHsWord64Prim x -> Integer -> HsLit x

-- | Genuinely an integer; arises only from TRANSLATION (overloaded
--   literals are done with HsOverLit)
HsInteger :: XHsInteger x -> Integer -> Type -> HsLit x

-- | Genuinely a rational; arises only from TRANSLATION (overloaded
--   literals are done with HsOverLit)
HsRat :: XHsRat x -> FractionalLit -> Type -> HsLit x

-- | Unboxed Float
HsFloatPrim :: XHsFloatPrim x -> FractionalLit -> HsLit x

-- | Unboxed Double
HsDoublePrim :: XHsDoublePrim x -> FractionalLit -> HsLit x
XLit :: XXLit x -> HsLit x

-- | Haskell Overloaded Literal
data HsOverLit p
OverLit :: XOverLit p -> OverLitVal -> HsExpr p -> HsOverLit p
[ol_ext] :: HsOverLit p -> XOverLit p
[ol_val] :: HsOverLit p -> OverLitVal
[ol_witness] :: HsOverLit p -> HsExpr p
XOverLit :: XXOverLit p -> HsOverLit p
data OverLitTc
OverLitTc :: Bool -> Type -> OverLitTc
[ol_rebindable] :: OverLitTc -> Bool
[ol_type] :: OverLitTc -> Type

-- | Overloaded Literal Value
data OverLitVal

-- | Integer-looking literals;
HsIntegral :: !IntegralLit -> OverLitVal

-- | Frac-looking literals
HsFractional :: !FractionalLit -> OverLitVal

-- | String-looking literals
HsIsString :: !SourceText -> !FastString -> OverLitVal
negateOverLitVal :: OverLitVal -> OverLitVal
overLitType :: HsOverLit GhcTc -> Type

-- | Convert a literal from one index type to another, updating the
--   annotations according to the relevant <a>Convertable</a> instance
convertLit :: ConvertIdX a b => HsLit a -> HsLit b
pp_st_suffix :: SourceText -> SDoc -> SDoc -> SDoc

-- | pmPprHsLit pretty prints literals and is used when pretty printing
--   pattern match warnings. All are printed the same (i.e., without hashes
--   if they are primitive and not wrapped in constructors if they are
--   boxed). This happens mainly for too reasons: * We do not want to
--   expose their internal representation * The warnings become too messy
pmPprHsLit :: HsLit (GhcPass x) -> SDoc

-- | <tt><a>hsLitNeedsParens</a> p l</tt> returns <a>True</a> if a literal
--   <tt>l</tt> needs to be parenthesized under precedence <tt>p</tt>.
hsLitNeedsParens :: PprPrec -> HsLit x -> Bool

-- | <tt><a>hsOverLitNeedsParens</a> p ol</tt> returns <a>True</a> if an
--   overloaded literal <tt>ol</tt> needs to be parenthesized under
--   precedence <tt>p</tt>.
hsOverLitNeedsParens :: PprPrec -> HsOverLit x -> Bool
instance Data.Data.Data HsLit.OverLitVal
instance Data.Data.Data HsLit.OverLitTc
instance GHC.Classes.Eq (HsExtension.XXOverLit p) => GHC.Classes.Eq (HsLit.HsOverLit p)
instance GHC.Classes.Ord (HsExtension.XXOverLit p) => GHC.Classes.Ord (HsLit.HsOverLit p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsLit.HsOverLit p)
instance GHC.Classes.Eq HsLit.OverLitVal
instance GHC.Classes.Ord HsLit.OverLitVal
instance Outputable.Outputable HsLit.OverLitVal
instance GHC.Classes.Eq (HsLit.HsLit x)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass) => Outputable.Outputable (HsLit.HsLit p)


-- | Module for (a) type kinds and (b) type coercions, as used in System
--   FC. See <a>Expr</a> for more on System FC and how coercions fit into
--   it.
module Coercion

-- | A <a>Coercion</a> is concrete evidence of the equality/convertibility
--   of two types.
data Coercion
type CoercionN = Coercion
type CoercionR = Coercion
type CoercionP = Coercion

-- | A semantically more meaningful type to represent what may or may not
--   be a useful <a>Coercion</a>.
data MCoercion
MRefl :: MCoercion
MCo :: Coercion -> MCoercion
type MCoercionR = MCoercion

-- | For simplicity, we have just one UnivCo that represents a coercion
--   from some type to some other type, with (in general) no restrictions
--   on the type. The UnivCoProvenance specifies more exactly what the
--   coercion really is and why a program should (or shouldn't!) trust the
--   coercion. It is reasonable to consider each constructor of
--   <a>UnivCoProvenance</a> as a totally independent coercion form; their
--   only commonality is that they don't tell you what types they coercion
--   between. (That info is in the <a>UnivCo</a> constructor of
--   <a>Coercion</a>.
data UnivCoProvenance

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
CoercionHole :: CoVar -> IORef (Maybe Coercion) -> CoercionHole
[ch_co_var] :: CoercionHole -> CoVar
[ch_ref] :: CoercionHole -> IORef (Maybe Coercion)
coHoleCoVar :: CoercionHole -> CoVar
setCoHoleCoVar :: CoercionHole -> CoVar -> CoercionHole
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Coercion Variable
type CoVar = Id

-- | Type or Coercion Variable
type TyCoVar = Id
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
ltRole :: Role -> Role -> Bool
coVarTypes :: HasDebugCallStack => CoVar -> Pair Type
coVarKind :: CoVar -> Type
coVarKindsTypesRole :: HasDebugCallStack => CoVar -> (Kind, Kind, Type, Type, Role)
coVarRole :: CoVar -> Role
coercionType :: Coercion -> Type

-- | If it is the case that
--   
--   <pre>
--   c :: (t1 ~ t2)
--   </pre>
--   
--   i.e. the kind of <tt>c</tt> relates <tt>t1</tt> and <tt>t2</tt>, then
--   <tt>coercionKind c = Pair t1 t2</tt>.
coercionKind :: Coercion -> Pair Type

-- | Apply <a>coercionKind</a> to multiple <a>Coercion</a>s
coercionKinds :: [Coercion] -> Pair [Type]

-- | Makes a coercion type from two types: the types whose equality is
--   proven by the relevant <a>Coercion</a>
mkCoercionType :: Role -> Type -> Type -> Type

-- | Retrieve the role from a coercion.
coercionRole :: Coercion -> Role

-- | Get a coercion's kind and role.
coercionKindRole :: Coercion -> (Pair Type, Role)

-- | Make a generalized reflexive coercion
mkGReflCo :: Role -> Type -> MCoercionN -> Coercion

-- | Make a reflexive coercion
mkReflCo :: Role -> Type -> Coercion

-- | Make a representational reflexive coercion
mkRepReflCo :: Type -> Coercion

-- | Make a nominal reflexive coercion
mkNomReflCo :: Type -> Coercion
mkCoVarCo :: CoVar -> Coercion
mkCoVarCos :: [CoVar] -> [Coercion]
mkAxInstCo :: Role -> CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Coercion
mkUnbranchedAxInstCo :: Role -> CoAxiom Unbranched -> [Type] -> [Coercion] -> Coercion
mkAxInstRHS :: CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type
mkUnbranchedAxInstRHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type

-- | Return the left-hand type of the axiom, when the axiom is instantiated
--   at the types given.
mkAxInstLHS :: CoAxiom br -> BranchIndex -> [Type] -> [Coercion] -> Type

-- | Instantiate the left-hand side of an unbranched axiom
mkUnbranchedAxInstLHS :: CoAxiom Unbranched -> [Type] -> [Coercion] -> Type

-- | Make a forall <a>Coercion</a>, where both types related by the
--   coercion are quantified over the same variable.
mkPiCo :: Role -> Var -> Coercion -> Coercion
mkPiCos :: Role -> [Var] -> Coercion -> Coercion
mkCoCast :: Coercion -> CoercionR -> Coercion

-- | Create a symmetric version of the given <a>Coercion</a> that asserts
--   equality between the same types but in the other "direction", so a
--   kind of <tt>t1 ~ t2</tt> becomes the kind <tt>t2 ~ t1</tt>.
mkSymCo :: Coercion -> Coercion

-- | Create a new <a>Coercion</a> by composing the two given
--   <a>Coercion</a>s transitively. (co1 ; co2)
mkTransCo :: Coercion -> Coercion -> Coercion

-- | Compose two MCoercions via transitivity
mkTransMCo :: MCoercion -> MCoercion -> MCoercion
mkNthCo :: HasDebugCallStack => Role -> Int -> Coercion -> Coercion

-- | If you're about to call <tt>mkNthCo r n co</tt>, then <tt>r</tt>
--   should be whatever <tt>nthCoRole n co</tt> returns.
nthCoRole :: Int -> Coercion -> Role
mkLRCo :: LeftOrRight -> Coercion -> Coercion

-- | Instantiates a <a>Coercion</a>.
mkInstCo :: Coercion -> Coercion -> Coercion

-- | Apply a <a>Coercion</a> to another <a>Coercion</a>. The second
--   coercion must be Nominal, unless the first is Phantom. If the first is
--   Phantom, then the second can be either Phantom or Nominal.
mkAppCo :: Coercion -> Coercion -> Coercion

-- | Applies multiple <a>Coercion</a>s to another <a>Coercion</a>, from
--   left to right. See also <a>mkAppCo</a>.
mkAppCos :: Coercion -> [Coercion] -> Coercion

-- | Apply a type constructor to a list of coercions. It is the caller's
--   responsibility to get the roles correct on argument coercions.
mkTyConAppCo :: HasDebugCallStack => Role -> TyCon -> [Coercion] -> Coercion

-- | Build a function <a>Coercion</a> from two other <a>Coercion</a>s. That
--   is, given <tt>co1 :: a ~ b</tt> and <tt>co2 :: x ~ y</tt> produce
--   <tt>co :: (a -&gt; x) ~ (b -&gt; y)</tt>.
mkFunCo :: Role -> Coercion -> Coercion -> Coercion

-- | Make a Coercion from a tycovar, a kind coercion, and a body coercion.
--   The kind of the tycovar should be the left-hand kind of the kind
--   coercion. See Note [Unused coercion variable in ForAllCo]
mkForAllCo :: TyCoVar -> CoercionN -> Coercion -> Coercion

-- | Make nested ForAllCos
mkForAllCos :: [(TyCoVar, CoercionN)] -> Coercion -> Coercion

-- | Make a Coercion quantified over a type/coercion variable; the variable
--   has the same type in both sides of the coercion
mkHomoForAllCos :: [TyCoVar] -> Coercion -> Coercion

-- | Make a phantom coercion between two types. The coercion passed in must
--   be a nominal coercion between the kinds of the types.
mkPhantomCo :: Coercion -> Type -> Type -> Coercion

-- | Manufacture an unsafe coercion from thin air. Currently (May 14) this
--   is used only to implement the <tt>unsafeCoerce#</tt> primitive.
--   Optimise by pushing down through type constructors.
mkUnsafeCo :: Role -> Type -> Type -> Coercion

-- | Make a coercion from a coercion hole
mkHoleCo :: CoercionHole -> Coercion

-- | Make a universal coercion between two arbitrary types.
mkUnivCo :: UnivCoProvenance -> Role -> Type -> Type -> Coercion
mkSubCo :: Coercion -> Coercion
mkAxiomInstCo :: CoAxiom Branched -> BranchIndex -> [Coercion] -> Coercion

-- | Make a "coercion between coercions".
mkProofIrrelCo :: Role -> Coercion -> Coercion -> Coercion -> Coercion

-- | Like <a>downgradeRole_maybe</a>, but panics if the change isn't a
--   downgrade. See Note [Role twiddling functions]
downgradeRole :: Role -> Role -> Coercion -> Coercion

-- | If the EqRel is ReprEq, makes a SubCo; otherwise, does nothing. Note
--   that the input coercion should always be nominal.
maybeSubCo :: EqRel -> Coercion -> Coercion
mkAxiomRuleCo :: CoAxiomRule -> [Coercion] -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, produces <tt>co' ::
--   ty ~r (ty |&gt; co)</tt>
mkGReflRightCo :: Role -> Type -> CoercionN -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, produces <tt>co' ::
--   (ty |&gt; co) ~r ty</tt>
mkGReflLeftCo :: Role -> Type -> CoercionN -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty ~r
--   ty'</tt>, produces @co' :: (ty |&gt; co) ~r ty' It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceLeftCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>ty :: k1</tt>, <tt>co :: k1 ~ k2</tt>, <tt>co2:: ty' ~r
--   ty</tt>, produces @co' :: ty' ~r (ty |&gt; co) It is not only a
--   utility function, but it saves allocation when co is a GRefl coercion.
mkCoherenceRightCo :: Role -> Type -> CoercionN -> Coercion -> Coercion

-- | Given <tt>co :: (a :: k) ~ (b :: k')</tt> produce <tt>co' :: k ~
--   k'</tt>.
mkKindCo :: Coercion -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind g r t1 t2 h1 h2</tt>, where <tt>g :: t1 ~r
--   t2</tt>, has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt>
--   and <tt>h2</tt> must be nominal.
castCoercionKind :: Coercion -> Role -> Type -> Type -> CoercionN -> CoercionN -> Coercion

-- | Creates a new coercion with both of its types casted by different
--   casts <tt>castCoercionKind g h1 h2</tt>, where <tt>g :: t1 ~r t2</tt>,
--   has type <tt>(t1 |&gt; h1) ~r (t2 |&gt; h2)</tt>. <tt>h1</tt> and
--   <tt>h2</tt> must be nominal. It calls <tt>coercionKindRole</tt>, so
--   it's quite inefficient (which <tt>I</tt> stands for) Use
--   <tt>castCoercionKind</tt> instead if <tt>t1</tt>, <tt>t2</tt>, and
--   <tt>r</tt> are known beforehand.
castCoercionKindI :: Coercion -> CoercionN -> CoercionN -> Coercion
mkHeteroCoercionType :: Role -> Kind -> Kind -> Type -> Type -> Type

-- | If <tt>co :: T ts ~ rep_ty</tt> then:
--   
--   <pre>
--   instNewTyCon_maybe T ts = Just (rep_ty, co)
--   </pre>
--   
--   Checks for a newtype, and for being saturated
instNewTyCon_maybe :: TyCon -> [Type] -> Maybe (Type, Coercion)

-- | A function to check if we can reduce a type by one step. Used with
--   <a>topNormaliseTypeX</a>.
type NormaliseStepper ev = RecTcChecker -> TyCon -> [Type] -> NormaliseStepResult ev

-- | The result of stepping in a normalisation function. See
--   <a>topNormaliseTypeX</a>.
data NormaliseStepResult ev

-- | Nothing more to do
NS_Done :: NormaliseStepResult ev

-- | Utter failure. The outer function should fail too.
NS_Abort :: NormaliseStepResult ev

-- | We stepped, yielding new bits; ^ ev is evidence; Usually a co :: old
--   type ~ new type
NS_Step :: RecTcChecker -> Type -> ev -> NormaliseStepResult ev

-- | Try one stepper and then try the next, if the first doesn't make
--   progress. So if it returns NS_Done, it means that both steppers are
--   satisfied
composeSteppers :: NormaliseStepper ev -> NormaliseStepper ev -> NormaliseStepper ev
mapStepResult :: (ev1 -> ev2) -> NormaliseStepResult ev1 -> NormaliseStepResult ev2

-- | A <a>NormaliseStepper</a> that unwraps newtypes, careful not to fall
--   into a loop. If it would fall into a loop, it produces
--   <a>NS_Abort</a>.
unwrapNewTypeStepper :: NormaliseStepper Coercion

-- | Sometimes we want to look through a <tt>newtype</tt> and get its
--   associated coercion. This function strips off <tt>newtype</tt> layers
--   enough to reveal something that isn't a <tt>newtype</tt>.
--   Specifically, here's the invariant:
--   
--   <pre>
--   topNormaliseNewType_maybe rec_nts ty = Just (co, ty')
--   </pre>
--   
--   then (a) <tt>co : ty0 ~ ty'</tt>. (b) ty' is not a newtype.
--   
--   The function returns <tt>Nothing</tt> for non-<tt>newtypes</tt>, or
--   unsaturated applications
--   
--   This function does *not* look through type families, because it has no
--   access to the type family environment. If you do have that at hand,
--   consider to use topNormaliseType_maybe, which should be a drop-in
--   replacement for topNormaliseNewType_maybe If topNormliseNewType_maybe
--   ty = Just (co, ty'), then co : ty ~R ty'
topNormaliseNewType_maybe :: Type -> Maybe (Coercion, Type)

-- | A general function for normalising the top-level of a type. It
--   continues to use the provided <a>NormaliseStepper</a> until that
--   function fails, and then this function returns. The roles of the
--   coercions produced by the <a>NormaliseStepper</a> must all be the
--   same, which is the role returned from the call to
--   <a>topNormaliseTypeX</a>.
--   
--   Typically ev is Coercion.
--   
--   If topNormaliseTypeX step plus ty = Just (ev, ty') then ty ~ev1~ t1
--   ~ev2~ t2 ... ~evn~ ty' and ev = ev1 <tt>plus</tt> ev2 <tt>plus</tt>
--   ... <tt>plus</tt> evn If it returns Nothing then no newtype unwrapping
--   could happen
topNormaliseTypeX :: NormaliseStepper ev -> (ev -> ev -> ev) -> Type -> Maybe (ev, Type)

-- | This breaks a <a>Coercion</a> with type <tt>T A B C ~ T D E F</tt>
--   into a list of <a>Coercion</a>s of kinds <tt>A ~ D</tt>, <tt>B ~
--   E</tt> and <tt>E ~ F</tt>. Hence:
--   
--   <pre>
--   decomposeCo 3 c [r1, r2, r3] = [nth r1 0 c, nth r2 1 c, nth r3 2 c]
--   </pre>
decomposeCo :: Arity -> Coercion -> [Role] -> [Coercion]
decomposeFunCo :: HasDebugCallStack => Role -> Coercion -> (Coercion, Coercion)
decomposePiCos :: HasDebugCallStack => CoercionN -> Pair Type -> [Type] -> ([CoercionN], CoercionN)

-- | Attempts to obtain the type variable underlying a <a>Coercion</a>
getCoVar_maybe :: Coercion -> Maybe CoVar

-- | Attempts to tease a coercion apart into a type constructor and the
--   application of a number of coercion arguments to that constructor
splitTyConAppCo_maybe :: Coercion -> Maybe (TyCon, [Coercion])

-- | Attempt to take a coercion application apart.
splitAppCo_maybe :: Coercion -> Maybe (Coercion, Coercion)
splitFunCo_maybe :: Coercion -> Maybe (Coercion, Coercion)
splitForAllCo_maybe :: Coercion -> Maybe (TyCoVar, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for tyvar
--   binder
splitForAllCo_ty_maybe :: Coercion -> Maybe (TyVar, Coercion, Coercion)

-- | Like <a>splitForAllCo_maybe</a>, but only returns Just for covar
--   binder
splitForAllCo_co_maybe :: Coercion -> Maybe (CoVar, Coercion, Coercion)
nthRole :: Role -> TyCon -> Int -> Role
tyConRolesX :: Role -> TyCon -> [Role]
tyConRolesRepresentational :: TyCon -> [Role]

-- | Converts a coercion to be nominal, if possible. See Note [Role
--   twiddling functions]
setNominalRole_maybe :: Role -> Coercion -> Maybe Coercion
pickLR :: LeftOrRight -> (a, a) -> a

-- | Tests if this coercion is obviously a generalized reflexive coercion.
--   Guaranteed to work very quickly.
isGReflCo :: Coercion -> Bool

-- | Tests if this coercion is obviously reflexive. Guaranteed to work very
--   quickly. Sometimes a coercion can be reflexive, but not obviously so.
--   c.f. <a>isReflexiveCo</a>
isReflCo :: Coercion -> Bool

-- | Returns the type coerced if this coercion is reflexive. Guaranteed to
--   work very quickly. Sometimes a coercion can be reflexive, but not
--   obviously so. c.f. <a>isReflexiveCo_maybe</a>
isReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Returns the type coerced if this coercion is a generalized reflexive
--   coercion. Guaranteed to work very quickly.
isGReflCo_maybe :: Coercion -> Maybe (Type, Role)

-- | Slowly checks if the coercion is reflexive. Don't call this in a loop,
--   as it walks over the entire coercion.
isReflexiveCo :: Coercion -> Bool

-- | Extracts the coerced type from a reflexive coercion. This potentially
--   walks over the entire coercion, so avoid doing this in a loop.
isReflexiveCo_maybe :: Coercion -> Maybe (Type, Role)
isReflCoVar_maybe :: Var -> Maybe Coercion
mkCoVar :: Name -> Type -> CoVar
isCoVar :: Var -> Bool
coVarName :: CoVar -> Name
setCoVarName :: CoVar -> Name -> CoVar
setCoVarUnique :: CoVar -> Unique -> CoVar

-- | Extract a covar, if possible. This check is dirty. Be ashamed of
--   yourself. (It's dirty because it cares about the structure of a
--   coercion, which is morally reprehensible.)
isCoVar_maybe :: Coercion -> Maybe CoVar
tyCoVarsOfCo :: Coercion -> TyCoVarSet
tyCoVarsOfCos :: [Coercion] -> TyCoVarSet
coVarsOfCo :: Coercion -> CoVarSet
tyCoFVsOfCo :: Coercion -> FV
tyCoFVsOfCos :: [Coercion] -> FV

-- | Get a deterministic set of the vars free in a coercion
tyCoVarsOfCoDSet :: Coercion -> DTyCoVarSet
coercionSize :: Coercion -> Int

-- | A substitution of <a>Coercion</a>s for <a>CoVar</a>s
type CvSubstEnv = CoVarEnv Coercion
emptyCvSubstEnv :: CvSubstEnv
lookupCoVar :: TCvSubst -> Var -> Maybe Coercion

-- | Substitute within a <a>Coercion</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substCo :: HasCallStack => TCvSubst -> Coercion -> Coercion

-- | Substitute within several <a>Coercion</a>s The substitution has to
--   satisfy the invariants described in Note [The substitution invariant].
substCos :: HasCallStack => TCvSubst -> [Coercion] -> [Coercion]
substCoVar :: TCvSubst -> CoVar -> Coercion
substCoVars :: TCvSubst -> [CoVar] -> [Coercion]

-- | Coercion substitution, see <a>zipTvSubst</a>
substCoWith :: HasCallStack => [TyVar] -> [Type] -> Coercion -> Coercion
substCoVarBndr :: HasCallStack => TCvSubst -> CoVar -> (TCvSubst, CoVar)
extendTvSubstAndInScope :: TCvSubst -> TyVar -> Type -> TCvSubst
getCvSubstEnv :: TCvSubst -> CvSubstEnv

-- | <tt>liftCoSubst role lc ty</tt> produces a coercion (at role
--   <tt>role</tt>) that coerces between <tt>lc_left(ty)</tt> and
--   <tt>lc_right(ty)</tt>, where <tt>lc_left</tt> is a substitution
--   mapping type variables to the left-hand types of the mapped coercions
--   in <tt>lc</tt>, and similar for <tt>lc_right</tt>.
liftCoSubst :: HasDebugCallStack => Role -> LiftingContext -> Type -> Coercion
liftCoSubstTyVar :: LiftingContext -> Role -> TyVar -> Maybe Coercion
liftCoSubstWith :: Role -> [TyCoVar] -> [Coercion] -> Type -> Coercion
liftCoSubstWithEx :: Role -> [TyVar] -> [Coercion] -> [TyCoVar] -> [Type] -> (Type -> Coercion, [Type])
emptyLiftingContext :: InScopeSet -> LiftingContext

-- | Extend a lifting context with a new mapping.
extendLiftingContext :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext

-- | Extend a lifting context with a new mapping, and extend the in-scope
--   set
extendLiftingContextAndInScope :: LiftingContext -> TyCoVar -> Coercion -> LiftingContext
liftCoSubstVarBndrUsing :: (LiftingContext -> Type -> (CoercionN, a)) -> LiftingContext -> TyCoVar -> (LiftingContext, TyCoVar, CoercionN, a)

-- | Is a var in the domain of a lifting context?
isMappedByLC :: TyCoVar -> LiftingContext -> Bool
mkSubstLiftingContext :: TCvSubst -> LiftingContext

-- | Erase the environments in a lifting context
zapLiftingContext :: LiftingContext -> LiftingContext

-- | Like <a>substForAllCoBndr</a>, but works on a lifting context
substForAllCoBndrUsingLC :: Bool -> (Coercion -> Coercion) -> LiftingContext -> TyCoVar -> Coercion -> (LiftingContext, TyCoVar, Coercion)

-- | Extract the underlying substitution from the LiftingContext
lcTCvSubst :: LiftingContext -> TCvSubst

-- | Get the <a>InScopeSet</a> from a <a>LiftingContext</a>
lcInScopeSet :: LiftingContext -> InScopeSet
type LiftCoEnv = VarEnv Coercion
data LiftingContext
LC :: TCvSubst -> LiftCoEnv -> LiftingContext
liftEnvSubstLeft :: TCvSubst -> LiftCoEnv -> TCvSubst
liftEnvSubstRight :: TCvSubst -> LiftCoEnv -> TCvSubst
substRightCo :: LiftingContext -> Coercion -> Coercion
substLeftCo :: LiftingContext -> Coercion -> Coercion

-- | Apply "sym" to all coercions in a <a>LiftCoEnv</a>
swapLiftCoEnv :: LiftCoEnv -> LiftCoEnv
lcSubstLeft :: LiftingContext -> TCvSubst
lcSubstRight :: LiftingContext -> TCvSubst

-- | Syntactic equality of coercions
eqCoercion :: Coercion -> Coercion -> Bool

-- | Compare two <a>Coercion</a>s, with respect to an RnEnv2
eqCoercionX :: RnEnv2 -> Coercion -> Coercion -> Bool
seqCo :: Coercion -> ()
pprCo :: Coercion -> SDoc
pprParendCo :: Coercion -> SDoc
pprCoAxiom :: CoAxiom br -> SDoc
pprCoAxBranch :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchLHS :: TyCon -> CoAxBranch -> SDoc
pprCoAxBranchUser :: TyCon -> CoAxBranch -> SDoc
tidyCoAxBndrsForUser :: TidyEnv -> [Var] -> (TidyEnv, [Var])
etaExpandCoAxBranch :: CoAxBranch -> ([TyVar], [Type], Type)
tidyCo :: TidyEnv -> Coercion -> Coercion
tidyCos :: TidyEnv -> [Coercion] -> [Coercion]

-- | like mkKindCo, but aggressively &amp; recursively optimizes to avoid
--   using a KindCo constructor. The output role is nominal.
promoteCoercion :: Coercion -> CoercionN

-- | Assuming that two types are the same, ignoring coercions, find a
--   nominal coercion between the types. This is useful when optimizing
--   transitivity over coercion applications, where splitting two AppCos
--   might yield different kinds. See Note [EtaAppCo] in OptCoercion.
buildCoercion :: Type -> Type -> CoercionN
simplifyArgsWorker :: [TyCoBinder] -> Kind -> TyCoVarSet -> [Role] -> [(Type, Coercion)] -> ([Type], [Coercion], CoercionN)
instance Outputable.Outputable Coercion.LiftingContext

module Unify

-- | <tt>tcMatchTy t1 t2</tt> produces a substitution (over fvs(t1))
--   <tt>s</tt> such that <tt>s(t1)</tt> equals <tt>t2</tt>. The returned
--   substitution might bind coercion variables, if the variable is an
--   argument to a GADT constructor.
--   
--   Precondition: typeKind ty1 <a>eqType</a> typeKind ty2
--   
--   We don't pass in a set of "template variables" to be bound by the
--   match, because tcMatchTy (and similar functions) are always used on
--   top-level types, so we can bind any of the free variables of the LHS.
--   See also Note [tcMatchTy vs tcMatchTyKi]
tcMatchTy :: Type -> Type -> Maybe TCvSubst

-- | Like <a>tcMatchTy</a>, but allows the kinds of the types to differ,
--   and thus matches them as well. See also Note [tcMatchTy vs
--   tcMatchTyKi]
tcMatchTyKi :: Type -> Type -> Maybe TCvSubst

-- | Like <a>tcMatchTy</a> but over a list of types. See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTys :: [Type] -> [Type] -> Maybe TCvSubst

-- | Like <a>tcMatchTyKi</a> but over a list of types. See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTyKis :: [Type] -> [Type] -> Maybe TCvSubst

-- | This is similar to <a>tcMatchTy</a>, but extends a substitution See
--   also Note [tcMatchTy vs tcMatchTyKi]
tcMatchTyX :: TCvSubst -> Type -> Type -> Maybe TCvSubst

-- | Like <a>tcMatchTys</a>, but extending a substitution See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTysX :: TCvSubst -> [Type] -> [Type] -> Maybe TCvSubst

-- | Like <a>tcMatchTyKis</a>, but extending a substitution See also Note
--   [tcMatchTy vs tcMatchTyKi]
tcMatchTyKisX :: TCvSubst -> [Type] -> [Type] -> Maybe TCvSubst
tcMatchTyX_BM :: (TyVar -> BindFlag) -> TCvSubst -> Type -> Type -> Maybe TCvSubst

-- | This one is called from the expression matcher, which already has a
--   MatchEnv in hand
ruleMatchTyKiX :: TyCoVarSet -> RnEnv2 -> TvSubstEnv -> Type -> Type -> Maybe TvSubstEnv
roughMatchTcs :: [Type] -> [Maybe Name]
instanceCantMatch :: [Maybe Name] -> [Maybe Name] -> Bool

-- | Given a list of pairs of types, are any two members of a pair surely
--   apart, even after arbitrary type function evaluation and substitution?
typesCantMatch :: [(Type, Type)] -> Bool

-- | Simple unification of two types; all type variables are bindable
--   Precondition: the kinds are already equal
tcUnifyTy :: Type -> Type -> Maybe TCvSubst

-- | Like <a>tcUnifyTy</a>, but also unifies the kinds
tcUnifyTyKi :: Type -> Type -> Maybe TCvSubst
tcUnifyTys :: (TyCoVar -> BindFlag) -> [Type] -> [Type] -> Maybe TCvSubst

-- | Like <a>tcUnifyTys</a> but also unifies the kinds
tcUnifyTyKis :: (TyCoVar -> BindFlag) -> [Type] -> [Type] -> Maybe TCvSubst

-- | <tt>tcUnifyTysFG bind_tv tys1 tys2</tt> attepts to find a substitution
--   <tt>s</tt> (whose domain elements all respond <a>BindMe</a> to
--   <tt>bind_tv</tt>) such that <tt>s(tys1)</tt> and that of
--   <tt>s(tys2)</tt> are equal, as witnessed by the returned Coercions.
--   This version requires that the kinds of the types are the same, if you
--   unify left-to-right.
tcUnifyTysFG :: (TyVar -> BindFlag) -> [Type] -> [Type] -> UnifyResult

-- | Unify two types, treating type family applications as possibly
--   unifying with anything and looking through injective type family
--   applications. Precondition: kinds are the same
tcUnifyTyWithTFs :: Bool -> Type -> Type -> Maybe TCvSubst
data BindFlag
BindMe :: BindFlag
Skolem :: BindFlag
type UnifyResult = UnifyResultM TCvSubst
data UnifyResultM a
Unifiable :: a -> UnifyResultM a
MaybeApart :: a -> UnifyResultM a
SurelyApart :: UnifyResultM a

-- | <a>liftCoMatch</a> is sort of inverse to <a>liftCoSubst</a>. In
--   particular, if <tt>liftCoMatch vars ty co == Just s</tt>, then
--   <tt>liftCoSubst s ty == co</tt>, where <tt>==</tt> there means that
--   the result of <a>liftCoSubst</a> has the same type as the original co;
--   but may be different under the hood. That is, it matches a type
--   against a coercion of the same "shape", and returns a lifting
--   substitution which could have been used to produce the given coercion
--   from the given type. Note that this function is incomplete -- it might
--   return Nothing when there does indeed exist a possible lifting
--   context.
--   
--   This function is incomplete in that it doesn't respect the equality in
--   <a>eqType</a>. That is, it's possible that this will succeed for t1
--   and fail for t2, even when t1 <a>eqType</a> t2. That's because it
--   depends on there being a very similar structure between the type and
--   the coercion. This incompleteness shouldn't be all that surprising,
--   especially because it depends on the structure of the coercion, which
--   is a silly thing to do.
--   
--   The lifting context produced doesn't have to be exacting in the roles
--   of the mappings. This is because any use of the lifting context will
--   also require a desired role. Thus, this algorithm prefers mapping to
--   nominal coercions where it can do so.
liftCoMatch :: TyCoVarSet -> Type -> Coercion -> Maybe LiftingContext
instance GHC.Classes.Eq Unify.BindFlag
instance GHC.Base.Functor Unify.UnifyResultM
instance GHC.Base.Functor Unify.UM
instance GHC.Base.Applicative Unify.UM
instance GHC.Base.Monad Unify.UM
instance GHC.Base.Alternative Unify.UM
instance GHC.Base.MonadPlus Unify.UM
instance Control.Monad.Fail.MonadFail Unify.UM
instance GHC.Base.Applicative Unify.UnifyResultM
instance GHC.Base.Monad Unify.UnifyResultM
instance GHC.Base.Alternative Unify.UnifyResultM
instance GHC.Base.MonadPlus Unify.UnifyResultM
instance Outputable.Outputable a => Outputable.Outputable (Unify.UnifyResultM a)

module DataCon

-- | A data constructor
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnClose</a>,<a>AnnComma</a></li>
--   </ul>
data DataCon

-- | Data Constructor Representation See Note [Data constructor workers and
--   wrappers]
data DataConRep
NoDataConRep :: DataConRep
DCR :: Id -> DataConBoxer -> [Type] -> [StrictnessMark] -> [HsImplBang] -> DataConRep
[dcr_wrap_id] :: DataConRep -> Id
[dcr_boxer] :: DataConRep -> DataConBoxer
[dcr_arg_tys] :: DataConRep -> [Type]
[dcr_stricts] :: DataConRep -> [StrictnessMark]
[dcr_bangs] :: DataConRep -> [HsImplBang]

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie '~'
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {--} specified
SrcUnpack :: SrcUnpackedness

-- | {--} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness

-- | Haskell Source Bang
--   
--   Bangs on data constructor arguments as the user wrote them in the
--   source code.
--   
--   <tt>(HsSrcBang _ SrcUnpack SrcLazy)</tt> and <tt>(HsSrcBang _
--   SrcUnpack NoSrcStrict)</tt> (without StrictData) makes no sense, we
--   emit a warning (in checkValidDataCon) and treat it like <tt>(HsSrcBang
--   _ NoSrcUnpack SrcLazy)</tt>
data HsSrcBang
HsSrcBang :: SourceText -> SrcUnpackedness -> SrcStrictness -> HsSrcBang

-- | Haskell Implementation Bang
--   
--   Bangs of data constructor arguments as generated by the compiler after
--   consulting HsSrcBang, flags, etc.
data HsImplBang

-- | Lazy field, or one with an unlifted type
HsLazy :: HsImplBang

-- | Strict but not unpacked field
HsStrict :: HsImplBang

-- | Strict and unpacked field co :: arg-ty ~ product-ty HsBang
HsUnpack :: Maybe Coercion -> HsImplBang
data StrictnessMark
MarkedStrict :: StrictnessMark
NotMarkedStrict :: StrictnessMark

-- | Constructor Tag
--   
--   Type of the tags associated with each constructor possibility or
--   superclass selector
type ConTag = Int

-- | An <a>EqSpec</a> is a tyvar/type pair representing an equality made in
--   rejigging a GADT constructor
data EqSpec

-- | Make a non-dependent <a>EqSpec</a>
mkEqSpec :: TyVar -> Type -> EqSpec
eqSpecTyVar :: EqSpec -> TyVar
eqSpecType :: EqSpec -> Type
eqSpecPair :: EqSpec -> (TyVar, Type)
eqSpecPreds :: [EqSpec] -> ThetaType

-- | Substitute in an <a>EqSpec</a>. Precondition: if the LHS of the EqSpec
--   is mapped in the substitution, it is mapped to a type variable, not a
--   full type.
substEqSpec :: TCvSubst -> EqSpec -> EqSpec

-- | Filter out any <a>TyVar</a>s mentioned in an <a>EqSpec</a>.
filterEqSpec :: [EqSpec] -> [TyVar] -> [TyVar]

-- | Fields in an algebraic record type
data FieldLbl a
FieldLabel :: FieldLabelString -> Bool -> a -> FieldLbl a

-- | User-visible label of the field
[flLabel] :: FieldLbl a -> FieldLabelString

-- | Was DuplicateRecordFields on in the defining module for this datatype?
[flIsOverloaded] :: FieldLbl a -> Bool

-- | Record selector function
[flSelector] :: FieldLbl a -> a
type FieldLabel = FieldLbl Name

-- | Field labels are just represented as strings; they are not necessarily
--   unique (even within a module)
type FieldLabelString = FastString

-- | Build a new data constructor
mkDataCon :: Name -> Bool -> TyConRepName -> [HsSrcBang] -> [FieldLabel] -> [TyVar] -> [TyCoVar] -> [TyVarBinder] -> [EqSpec] -> KnotTied ThetaType -> [KnotTied Type] -> KnotTied Type -> RuntimeRepInfo -> KnotTied TyCon -> ConTag -> ThetaType -> Id -> DataConRep -> DataCon
buildAlgTyCon :: Name -> [TyVar] -> [Role] -> Maybe CType -> ThetaType -> AlgTyConRhs -> Bool -> AlgTyConFlav -> TyCon
buildSynTyCon :: Name -> [KnotTied TyConBinder] -> Kind -> [Role] -> KnotTied Type -> TyCon

-- | Tags are allocated from here for real constructors or for superclass
--   selectors
fIRST_TAG :: ConTag

-- | The representation type of the data constructor, i.e. the sort type
--   that will represent values of this type at runtime
dataConRepType :: DataCon -> Type

-- | The "signature" of the <a>DataCon</a> returns, in order:
--   
--   1) The result of <a>dataConUnivAndExTyCoVars</a>,
--   
--   2) All the <a>ThetaType</a>s relating to the <a>DataCon</a> (coercion,
--   dictionary, implicit parameter - whatever), including dependent GADT
--   equalities. Dependent GADT equalities are *also* listed in return
--   value (1), so be careful!
--   
--   3) The type arguments to the constructor
--   
--   4) The <i>original</i> result type of the <a>DataCon</a>
dataConSig :: DataCon -> ([TyCoVar], ThetaType, [Type], Type)

-- | Instantiate the universal tyvars of a data con, returning (
--   instantiated existentials , instantiated constraints including
--   dependent GADT equalities which are *also* listed in the instantiated
--   existentials , instantiated args)
dataConInstSig :: DataCon -> [Type] -> ([TyCoVar], ThetaType, [Type])

-- | The "full signature" of the <a>DataCon</a> returns, in order:
--   
--   1) The result of <a>dataConUnivTyVars</a>
--   
--   2) The result of <a>dataConExTyCoVars</a>
--   
--   3) The non-dependent GADT equalities. Dependent GADT equalities are
--   implied by coercion variables in return value (2).
--   
--   4) The other constraints of the data constructor type, excluding GADT
--   equalities
--   
--   5) The original argument types to the <a>DataCon</a> (i.e. before any
--   change of the representation of the type)
--   
--   6) The original result type of the <a>DataCon</a>
dataConFullSig :: DataCon -> ([TyVar], [TyCoVar], [EqSpec], ThetaType, [Type], Type)

-- | The <a>Name</a> of the <a>DataCon</a>, giving it a unique, rooted
--   identification
dataConName :: DataCon -> Name

-- | The string <tt>package:module.name</tt> identifying a constructor,
--   which is attached to its info table and used by the GHCi debugger and
--   the heap profiler
dataConIdentity :: DataCon -> [Word8]

-- | The tag used for ordering <a>DataCon</a>s
dataConTag :: DataCon -> ConTag
dataConTagZ :: DataCon -> ConTagZ

-- | The type constructor that we are building via this data constructor
dataConTyCon :: DataCon -> TyCon

-- | The original type constructor used in the definition of this data
--   constructor. In case of a data family instance, that will be the
--   family type constructor.
dataConOrigTyCon :: DataCon -> TyCon

-- | The user-declared type of the data constructor in the nice-to-read
--   form:
--   
--   <pre>
--   T :: forall a b. a -&gt; b -&gt; T [a]
--   </pre>
--   
--   rather than:
--   
--   <pre>
--   T :: forall a c. forall b. (c~[a]) =&gt; a -&gt; b -&gt; T c
--   </pre>
--   
--   The type variables are quantified in the order that the user wrote
--   them. See <tt>Note [DataCon user type variable binders]</tt>.
--   
--   NB: If the constructor is part of a data instance, the result type
--   mentions the family tycon, not the internal one.
dataConUserType :: DataCon -> Type

-- | The universally-quantified type variables of the constructor
dataConUnivTyVars :: DataCon -> [TyVar]

-- | The existentially-quantified type/coercion variables of the
--   constructor including dependent (kind-) GADT equalities
dataConExTyCoVars :: DataCon -> [TyCoVar]

-- | Both the universal and existential type/coercion variables of the
--   constructor
dataConUnivAndExTyCoVars :: DataCon -> [TyCoVar]

-- | The type variables of the constructor, in the order the user wrote
--   them
dataConUserTyVars :: DataCon -> [TyVar]

-- | <a>TyCoVarBinder</a>s for the type variables of the constructor, in
--   the order the user wrote them
dataConUserTyVarBinders :: DataCon -> [TyVarBinder]

-- | Equalities derived from the result type of the data constructor, as
--   written by the programmer in any GADT declaration. This includes *all*
--   GADT-like equalities, including those written in by hand by the
--   programmer.
dataConEqSpec :: DataCon -> [EqSpec]

-- | The *full* constraints on the constructor type, including dependent
--   GADT equalities.
dataConTheta :: DataCon -> ThetaType

-- | The "stupid theta" of the <a>DataCon</a>, such as <tt>data Eq a</tt>
--   in:
--   
--   <pre>
--   data Eq a =&gt; T a = ...
--   </pre>
dataConStupidTheta :: DataCon -> ThetaType

-- | Finds the instantiated types of the arguments required to construct a
--   <a>DataCon</a> representation NB: these INCLUDE any dictionary args
--   but EXCLUDE the data-declaration context, which is discarded It's all
--   post-flattening etc; this is a representation type
dataConInstArgTys :: DataCon -> [Type] -> [Type]

-- | Returns the argument types of the wrapper, excluding all dictionary
--   arguments and without substituting for any type variables
dataConOrigArgTys :: DataCon -> [Type]
dataConOrigResTy :: DataCon -> Type

-- | Returns just the instantiated <i>value</i> argument types of a
--   <a>DataCon</a>, (excluding dictionary args)
dataConInstOrigArgTys :: DataCon -> [Type] -> [Type]

-- | Returns the arg types of the worker, including *all* non-dependent
--   evidence, after any flattening has been done and without substituting
--   for any type variables
dataConRepArgTys :: DataCon -> [Type]

-- | The labels for the fields of this particular <a>DataCon</a>
dataConFieldLabels :: DataCon -> [FieldLabel]

-- | Extract the type for any given labelled field of the <a>DataCon</a>
dataConFieldType :: DataCon -> FieldLabelString -> Type

-- | Extract the label and type for any given labelled field of the
--   <a>DataCon</a>, or return <a>Nothing</a> if the field does not belong
--   to it
dataConFieldType_maybe :: DataCon -> FieldLabelString -> Maybe (FieldLabel, Type)

-- | Strictness/unpack annotations, from user; or, for imported DataCons,
--   from the interface file The list is in one-to-one correspondence with
--   the arity of the <a>DataCon</a>
dataConSrcBangs :: DataCon -> [HsSrcBang]

-- | Source-level arity of the data constructor
dataConSourceArity :: DataCon -> Arity

-- | Gives the number of actual fields in the <i>representation</i> of the
--   data constructor. This may be more than appear in the source code; the
--   extra ones are the existentially quantified dictionaries
dataConRepArity :: DataCon -> Arity

-- | Should the <a>DataCon</a> be presented infix?
dataConIsInfix :: DataCon -> Bool

-- | Get the Id of the <a>DataCon</a> worker: a function that is the
--   "actual" constructor and has no top level binding in the program. The
--   type may be different from the obvious one written in the source
--   program. Panics if there is no such <a>Id</a> for this <a>DataCon</a>
dataConWorkId :: DataCon -> Id

-- | Returns an Id which looks like the Haskell-source constructor by using
--   the wrapper if it exists (see <a>dataConWrapId_maybe</a>) and failing
--   over to the worker (see <a>dataConWorkId</a>)
dataConWrapId :: DataCon -> Id

-- | Get the Id of the <a>DataCon</a> wrapper: a function that wraps the
--   "actual" constructor so it has the type visible in the source program:
--   c.f. <a>dataConWorkId</a>. Returns Nothing if there is no wrapper,
--   which occurs for an algebraic data constructor and also for a newtype
--   (whose constructor is inlined compulsorily)
dataConWrapId_maybe :: DataCon -> Maybe Id

-- | Find all the <a>Id</a>s implicitly brought into scope by the data
--   constructor. Currently, the union of the <a>dataConWorkId</a> and the
--   <a>dataConWrapId</a>
dataConImplicitTyThings :: DataCon -> [TyThing]

-- | Give the demands on the arguments of a Core constructor application
--   (Con dc args)
dataConRepStrictness :: DataCon -> [StrictnessMark]
dataConImplBangs :: DataCon -> [HsImplBang]
dataConBoxer :: DataCon -> Maybe DataConBoxer

-- | Extract the type constructor, type argument, data constructor and it's
--   <i>representation</i> argument types from a type if it is a product
--   type.
--   
--   Precisely, we return <tt>Just</tt> for any type that is all of:
--   
--   <ul>
--   <li>Concrete (i.e. constructors visible)</li>
--   <li>Single-constructor</li>
--   <li>Not existentially quantified</li>
--   </ul>
--   
--   Whether the type is a <tt>data</tt> type or a <tt>newtype</tt>
splitDataProductType_maybe :: Type -> Maybe (TyCon, [Type], DataCon, [Type])

-- | Return whether there are any argument types for this <a>DataCon</a>s
--   original source type See Note [DataCon arities]
isNullarySrcDataCon :: DataCon -> Bool

-- | Return whether there are any argument types for this <a>DataCon</a>s
--   runtime representation type See Note [DataCon arities]
isNullaryRepDataCon :: DataCon -> Bool
isTupleDataCon :: DataCon -> Bool
isUnboxedTupleCon :: DataCon -> Bool
isUnboxedSumCon :: DataCon -> Bool

-- | Vanilla <a>DataCon</a>s are those that are nice boring Haskell 98
--   constructors
isVanillaDataCon :: DataCon -> Bool
classDataCon :: Class -> DataCon
dataConCannotMatch :: [Type] -> DataCon -> Bool

-- | Were the type variables of the data con written in a different order
--   than the regular order (universal tyvars followed by existential
--   tyvars)?
--   
--   This is not a cheap test, so we minimize its use in GHC as much as
--   possible. Currently, its only call site in the GHC codebase is in
--   <tt>mkDataConRep</tt> in <a>MkId</a>, and so
--   <a>dataConUserTyVarsArePermuted</a> is only called at most once during
--   a data constructor's lifetime.
dataConUserTyVarsArePermuted :: DataCon -> Bool
isBanged :: HsImplBang -> Bool
isMarkedStrict :: StrictnessMark -> Bool

-- | Compare strictness annotations
eqHsBang :: HsImplBang -> HsImplBang -> Bool
isSrcStrict :: SrcStrictness -> Bool
isSrcUnpacked :: SrcUnpackedness -> Bool

-- | Should this DataCon be allowed in a type even without -XDataKinds?
--   Currently, only Lifted &amp; Unlifted
specialPromotedDc :: DataCon -> Bool
promoteDataCon :: DataCon -> TyCon
instance Data.Data.Data DataCon.HsSrcBang
instance Data.Data.Data DataCon.SrcUnpackedness
instance GHC.Classes.Eq DataCon.SrcUnpackedness
instance Data.Data.Data DataCon.SrcStrictness
instance GHC.Classes.Eq DataCon.SrcStrictness
instance Data.Data.Data DataCon.HsImplBang
instance GHC.Classes.Eq DataCon.DataCon
instance Unique.Uniquable DataCon.DataCon
instance Name.NamedThing DataCon.DataCon
instance Outputable.Outputable DataCon.DataCon
instance Outputable.OutputableBndr DataCon.DataCon
instance Data.Data.Data DataCon.DataCon
instance Outputable.Outputable DataCon.EqSpec
instance Outputable.Outputable DataCon.StrictnessMark
instance Outputable.Outputable DataCon.HsSrcBang
instance Outputable.Outputable DataCon.SrcUnpackedness
instance Binary.Binary DataCon.SrcUnpackedness
instance Outputable.Outputable DataCon.SrcStrictness
instance Binary.Binary DataCon.SrcStrictness
instance Outputable.Outputable DataCon.HsImplBang

module RepType
type UnaryType = Type
type NvUnaryType = Type
isNvUnaryType :: Type -> Bool

-- | Gets rid of the stuff that prevents us from understanding the runtime
--   representation of a type. Including: 1. Casts 2. Newtypes 3. Foralls
--   4. Synonyms But not type/data families, because we don't have the envs
--   to hand.
unwrapType :: Type -> Type

-- | True if the type has zero width.
isVoidTy :: Type -> Bool

-- | Discovers the primitive representation of a <a>Type</a>. Returns a
--   list of <a>PrimRep</a>: it's a list because of the possibility of no
--   runtime representation (void) or multiple (unboxed tuple/sum)
typePrimRep :: HasDebugCallStack => Type -> [PrimRep]

-- | Like <a>typePrimRep</a>, but assumes that there is precisely one
--   <a>PrimRep</a> output; an empty list of PrimReps becomes a VoidRep
typePrimRep1 :: HasDebugCallStack => UnaryType -> PrimRep

-- | Take a type of kind RuntimeRep and extract the list of <a>PrimRep</a>
--   that it encodes.
runtimeRepPrimRep :: HasDebugCallStack => SDoc -> Type -> [PrimRep]
typePrimRepArgs :: Type -> [PrimRep]

-- | A <a>PrimRep</a> is an abstraction of a type. It contains information
--   that the code generator needs in order to pass arguments, return
--   results, and store values of this type.
data PrimRep
VoidRep :: PrimRep
LiftedRep :: PrimRep

-- | Unlifted pointer
UnliftedRep :: PrimRep

-- | Signed, 8-bit value
Int8Rep :: PrimRep

-- | Signed, 16-bit value
Int16Rep :: PrimRep

-- | Signed, word-sized value
IntRep :: PrimRep

-- | Unsigned, word-sized value
WordRep :: PrimRep

-- | Signed, 64 bit value (with 32-bit words only)
Int64Rep :: PrimRep

-- | Unsigned, 8 bit value
Word8Rep :: PrimRep

-- | Unsigned, 16 bit value
Word16Rep :: PrimRep

-- | Unsigned, 64 bit value (with 32-bit words only)
Word64Rep :: PrimRep

-- | A pointer, but <i>not</i> to a Haskell value (use '(Un)liftedRep')
AddrRep :: PrimRep
FloatRep :: PrimRep
DoubleRep :: PrimRep

-- | A vector
VecRep :: Int -> PrimElemRep -> PrimRep

-- | Convert a PrimRep back to a Type. Used only in the unariser to give
--   types to fresh Ids. Really, only the type's representation matters.
primRepToType :: PrimRep -> Type
countFunRepArgs :: Arity -> Type -> RepArity
countConRepArgs :: DataCon -> RepArity

-- | Find the runtime representation of a <a>TyCon</a>. Defined here to
--   avoid module loops. Returns a list of the register shapes necessary.
tyConPrimRep :: HasDebugCallStack => TyCon -> [PrimRep]

-- | Like <a>tyConPrimRep</a>, but assumed that there is precisely zero or
--   one <a>PrimRep</a> output
tyConPrimRep1 :: HasDebugCallStack => TyCon -> PrimRep

-- | Given the arguments of a sum type constructor application, return the
--   unboxed sum rep type.
--   
--   E.g.
--   
--   ( | Maybe Int | (, Float) #)
--   
--   We call `ubxSumRepType [ [IntRep], [LiftedRep], [IntRep, FloatRep] ]`,
--   which returns [WordSlot, PtrSlot, WordSlot, FloatSlot]
--   
--   INVARIANT: Result slots are sorted (via Ord SlotTy), except that at
--   the head of the list we have the slot for the tag.
ubxSumRepType :: [[PrimRep]] -> [SlotTy]
layoutUbxSum :: SortedSlotTys -> [SlotTy] -> [Int]
typeSlotTy :: UnaryType -> Maybe SlotTy
data SlotTy
PtrSlot :: SlotTy
WordSlot :: SlotTy
Word64Slot :: SlotTy
FloatSlot :: SlotTy
DoubleSlot :: SlotTy
slotPrimRep :: SlotTy -> PrimRep
primRepSlot :: PrimRep -> SlotTy
instance GHC.Classes.Ord RepType.SlotTy
instance GHC.Classes.Eq RepType.SlotTy
instance Outputable.Outputable RepType.SlotTy

module Demand

-- | Vanilla strictness domain
data StrDmd

-- | Domain for genuine usage
data UseDmd

-- | Call demand for absence. Used only for values of function type
UCall :: Count -> UseDmd -> UseDmd

-- | Product. Used only for values of product type See Note [Don't optimise
--   UProd(Used) to Used]
--   
--   Invariant: Not all components are Abs (in that case, use UHead)
UProd :: [ArgUse] -> UseDmd

-- | May be used but its sub-components are definitely *not* used. For
--   product types, UHead is equivalent to U(AAA); see mkUProd.
--   
--   UHead is needed only to express the demand of <a>seq</a> and 'case'
--   which are polymorphic; i.e. the scrutinised value is of type
--   <tt>a</tt> rather than a product type. That's why we can't use UProd
--   [A,A,A]
--   
--   Since (UCall _ Abs) is ill-typed, UHead doesn't make sense for lambdas
UHead :: UseDmd

-- | May be used and its sub-components may be used. (top of the lattice)
Used :: UseDmd

-- | Abstract counting of usages
data Count
type Demand = JointDmd ArgStr ArgUse
type DmdShell = JointDmd (Str ()) (Use ())
type CleanDemand = JointDmd StrDmd UseDmd
getStrDmd :: JointDmd s u -> s
getUseDmd :: JointDmd s u -> u
mkProdDmd :: [Demand] -> CleanDemand
mkOnceUsedDmd :: CleanDemand -> Demand
mkManyUsedDmd :: CleanDemand -> Demand
mkHeadStrict :: CleanDemand -> CleanDemand
oneifyDmd :: JointDmd s (Use u) -> JointDmd s (Use u)
toCleanDmd :: Demand -> (DmdShell, CleanDemand)
absDmd :: Demand
topDmd :: Demand
botDmd :: Demand
seqDmd :: Demand
lubDmd :: Demand -> Demand -> Demand
bothDmd :: Demand -> Demand -> Demand
lazyApply1Dmd :: Demand
lazyApply2Dmd :: Demand
strictApply1Dmd :: Demand
catchArgDmd :: Demand
isTopDmd :: Demand -> Bool
isAbsDmd :: JointDmd (Str s) (Use u) -> Bool
isSeqDmd :: Demand -> Bool
peelUseCall :: UseDmd -> Maybe (Count, UseDmd)
cleanUseDmd_maybe :: Demand -> Maybe UseDmd
strictenDmd :: Demand -> CleanDemand
bothCleanDmd :: CleanDemand -> CleanDemand -> CleanDemand
addCaseBndrDmd :: Demand -> [Demand] -> [Demand]
data DmdType
DmdType :: DmdEnv -> [Demand] -> DmdResult -> DmdType
dmdTypeDepth :: DmdType -> Arity
lubDmdType :: DmdType -> DmdType -> DmdType
bothDmdType :: DmdType -> BothDmdArg -> DmdType
nopDmdType :: DmdType
botDmdType :: DmdType
mkDmdType :: DmdEnv -> [Demand] -> DmdResult -> DmdType
addDemand :: Demand -> DmdType -> DmdType
removeDmdTyArgs :: DmdType -> DmdType
type BothDmdArg = (DmdEnv, Termination ())
mkBothDmdArg :: DmdEnv -> BothDmdArg
toBothDmdArg :: DmdType -> BothDmdArg
type DmdEnv = VarEnv Demand
emptyDmdEnv :: VarEnv Demand
peelFV :: DmdType -> Var -> (DmdType, Demand)
findIdDemand :: DmdType -> Var -> Demand
type DmdResult = Termination CPRResult
data CPRResult
isBotRes :: DmdResult -> Bool
isTopRes :: DmdResult -> Bool
topRes :: DmdResult
botRes :: DmdResult
exnRes :: DmdResult
cprProdRes :: [DmdType] -> DmdResult
vanillaCprProdRes :: Arity -> DmdResult
cprSumRes :: ConTag -> DmdResult
appIsBottom :: StrictSig -> Int -> Bool
isBottomingSig :: StrictSig -> Bool
pprIfaceStrictSig :: StrictSig -> SDoc
trimCPRInfo :: Bool -> Bool -> DmdResult -> DmdResult
returnsCPR_maybe :: DmdResult -> Maybe ConTag
newtype StrictSig
StrictSig :: DmdType -> StrictSig
mkStrictSig :: DmdType -> StrictSig
mkClosedStrictSig :: [Demand] -> DmdResult -> StrictSig
nopSig :: StrictSig
botSig :: StrictSig
exnSig :: StrictSig
cprProdSig :: Arity -> StrictSig
isTopSig :: StrictSig -> Bool
hasDemandEnvSig :: StrictSig -> Bool
splitStrictSig :: StrictSig -> ([Demand], DmdResult)
strictSigDmdEnv :: StrictSig -> DmdEnv
increaseStrictSigArity :: Int -> StrictSig -> StrictSig
etaExpandStrictSig :: Arity -> StrictSig -> StrictSig
seqDemand :: Demand -> ()
seqDemandList :: [Demand] -> ()
seqDmdType :: DmdType -> ()
seqStrictSig :: StrictSig -> ()
evalDmd :: Demand
cleanEvalDmd :: CleanDemand
cleanEvalProdDmd :: Arity -> CleanDemand
isStrictDmd :: JointDmd (Str s) (Use u) -> Bool
splitDmdTy :: DmdType -> (Demand, DmdType)
splitFVs :: Bool -> DmdEnv -> (DmdEnv, DmdEnv)
deferAfterIO :: DmdType -> DmdType
postProcessUnsat :: DmdShell -> DmdType -> DmdType
postProcessDmdType :: DmdShell -> DmdType -> BothDmdArg
splitProdDmd_maybe :: Demand -> Maybe [Demand]
peelCallDmd :: CleanDemand -> (CleanDemand, DmdShell)
peelManyCalls :: Int -> CleanDemand -> DmdShell
mkCallDmd :: CleanDemand -> CleanDemand
mkWorkerDemand :: Int -> Demand
dmdTransformSig :: StrictSig -> CleanDemand -> DmdType
dmdTransformDataConSig :: Arity -> StrictSig -> CleanDemand -> DmdType
dmdTransformDictSelSig :: StrictSig -> CleanDemand -> DmdType
argOneShots :: Demand -> [OneShotInfo]
argsOneShots :: StrictSig -> Arity -> [[OneShotInfo]]
saturatedByOneShots :: Int -> Demand -> Bool
trimToType :: Demand -> TypeShape -> Demand
data TypeShape
TsFun :: TypeShape -> TypeShape
TsProd :: [TypeShape] -> TypeShape
TsUnk :: TypeShape
useCount :: Use u -> Count
isUsedOnce :: JointDmd (Str s) (Use u) -> Bool
reuseEnv :: DmdEnv -> DmdEnv
killUsageDemand :: DynFlags -> Demand -> Demand
killUsageSig :: DynFlags -> StrictSig -> StrictSig
zapUsageDemand :: Demand -> Demand
zapUsageEnvSig :: StrictSig -> StrictSig

-- | Remove all 1* information (but not C1 information) from the demand
zapUsedOnceDemand :: Demand -> Demand

-- | Remove all 1* information (but not C1 information) from the strictness
--   signature
zapUsedOnceSig :: StrictSig -> StrictSig
strictifyDictDmd :: Type -> Demand -> Demand
strictifyDmd :: Demand -> Demand
instance GHC.Classes.Eq Demand.StrictSig
instance GHC.Show.Show Demand.CPRResult
instance GHC.Classes.Eq Demand.CPRResult
instance GHC.Show.Show r => GHC.Show.Show (Demand.Termination r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Demand.Termination r)
instance GHC.Show.Show Demand.UseDmd
instance GHC.Classes.Eq Demand.UseDmd
instance GHC.Show.Show u => GHC.Show.Show (Demand.Use u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Demand.Use u)
instance GHC.Show.Show Demand.Count
instance GHC.Classes.Eq Demand.Count
instance GHC.Show.Show Demand.StrDmd
instance GHC.Classes.Eq Demand.StrDmd
instance GHC.Show.Show s => GHC.Show.Show (Demand.Str s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Demand.Str s)
instance GHC.Show.Show Demand.ExnStr
instance GHC.Classes.Eq Demand.ExnStr
instance (GHC.Show.Show s, GHC.Show.Show u) => GHC.Show.Show (Demand.JointDmd s u)
instance (GHC.Classes.Eq s, GHC.Classes.Eq u) => GHC.Classes.Eq (Demand.JointDmd s u)
instance Outputable.Outputable Demand.StrictSig
instance Binary.Binary Demand.StrictSig
instance GHC.Classes.Eq Demand.DmdType
instance Outputable.Outputable Demand.DmdType
instance Binary.Binary Demand.DmdType
instance Binary.Binary Demand.DmdResult
instance Outputable.Outputable Demand.CPRResult
instance Binary.Binary Demand.CPRResult
instance Outputable.Outputable r => Outputable.Outputable (Demand.Termination r)
instance Outputable.Outputable Demand.TypeShape
instance Outputable.Outputable Demand.ArgUse
instance Outputable.Outputable Demand.UseDmd
instance Binary.Binary Demand.ArgUse
instance Binary.Binary Demand.UseDmd
instance Outputable.Outputable Demand.Count
instance Binary.Binary Demand.Count
instance Outputable.Outputable Demand.StrDmd
instance Outputable.Outputable Demand.ArgStr
instance Binary.Binary Demand.StrDmd
instance Binary.Binary Demand.ArgStr
instance Binary.Binary Demand.ExnStr
instance (Outputable.Outputable s, Outputable.Outputable u) => Outputable.Outputable (Demand.JointDmd s u)
instance (Binary.Binary s, Binary.Binary u) => Binary.Binary (Demand.JointDmd s u)

module ConLike

-- | A constructor-like thing
data ConLike
RealDataCon :: DataCon -> ConLike
PatSynCon :: PatSyn -> ConLike

-- | Number of arguments
conLikeArity :: ConLike -> Arity

-- | Names of fields used for selectors
conLikeFieldLabels :: ConLike -> [FieldLabel]

-- | Returns just the instantiated <i>value</i> argument types of a
--   <a>ConLike</a>, (excluding dictionary args)
conLikeInstOrigArgTys :: ConLike -> [Type] -> [Type]

-- | Existentially quantified type/coercion variables
conLikeExTyCoVars :: ConLike -> [TyCoVar]
conLikeName :: ConLike -> Name

-- | The "stupid theta" of the <a>ConLike</a>, such as <tt>data Eq a</tt>
--   in:
--   
--   <pre>
--   data Eq a =&gt; T a = ...
--   </pre>
--   
--   It is empty for <a>PatSynCon</a> as they do not allow such contexts.
conLikeStupidTheta :: ConLike -> ThetaType

-- | Returns the <a>Id</a> of the wrapper. This is also known as the
--   builder in some contexts. The value is Nothing only in the case of
--   unidirectional pattern synonyms.
conLikeWrapId_maybe :: ConLike -> Maybe Id

-- | Returns the strictness information for each constructor
conLikeImplBangs :: ConLike -> [HsImplBang]

-- | The "full signature" of the <a>ConLike</a> returns, in order:
--   
--   1) The universally quantified type variables
--   
--   2) The existentially quantified type/coercion variables
--   
--   3) The equality specification
--   
--   4) The provided theta (the constraints provided by a match)
--   
--   5) The required theta (the constraints required for a match)
--   
--   6) The original argument types (i.e. before any change of the
--   representation of the type)
--   
--   7) The original result type
conLikeFullSig :: ConLike -> ([TyVar], [TyCoVar], [EqSpec], ThetaType, ThetaType, [Type], Type)

-- | Returns the type of the whole pattern
conLikeResTy :: ConLike -> [Type] -> Type

-- | Extract the type for any given labelled field of the <a>ConLike</a>
conLikeFieldType :: ConLike -> FieldLabelString -> Type

-- | The ConLikes that have *all* the given fields
conLikesWithFields :: [ConLike] -> [FieldLabelString] -> [ConLike]
conLikeIsInfix :: ConLike -> Bool
instance GHC.Classes.Eq ConLike.ConLike
instance Unique.Uniquable ConLike.ConLike
instance Name.NamedThing ConLike.ConLike
instance Outputable.Outputable ConLike.ConLike
instance Outputable.OutputableBndr ConLike.ConLike
instance Data.Data.Data ConLike.ConLike


-- | CoreSyn holds all the main data types for use by for the Glasgow
--   Haskell Compiler midsection
module CoreSyn

-- | This is the data type that represents GHCs core intermediate language.
--   Currently GHC uses System FC
--   <a>https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions/</a>
--   for this purpose, which is closely related to the simpler and better
--   known System F <a>http://en.wikipedia.org/wiki/System_F</a>.
--   
--   We get from Haskell source to this Core language in a number of
--   stages:
--   
--   <ol>
--   <li>The source code is parsed into an abstract syntax tree, which is
--   represented by the data type <a>HsExpr</a> with the names being
--   <a>RdrNames</a></li>
--   <li>This syntax tree is <i>renamed</i>, which attaches a <a>Unique</a>
--   to every <a>RdrName</a> (yielding a <a>Name</a>) to disambiguate
--   identifiers which are lexically identical. For example, this
--   program:</li>
--   </ol>
--   
--   <pre>
--   f x = let f x = x + 1
--         in f (x - 2)
--   </pre>
--   
--   Would be renamed by having <tt>Unique</tt>s attached so it looked
--   something like this:
--   
--   <pre>
--   f_1 x_2 = let f_3 x_4 = x_4 + 1
--             in f_3 (x_2 - 2)
--   </pre>
--   
--   But see Note [Shadowing] below.
--   
--   <ol>
--   <li>The resulting syntax tree undergoes type checking (which also
--   deals with instantiating type class arguments) to yield a
--   <a>HsExpr</a> type that has <a>Id</a> as it's names.</li>
--   <li>Finally the syntax tree is <i>desugared</i> from the expressive
--   <a>HsExpr</a> type into this <a>Expr</a> type, which has far fewer
--   constructors and hence is easier to perform optimization, analysis and
--   code generation on.</li>
--   </ol>
--   
--   The type parameter <tt>b</tt> is for the type of binders in the
--   expression tree.
--   
--   The language consists of the following elements:
--   
--   <ul>
--   <li>Variables See Note [Variable occurrences in Core]</li>
--   <li>Primitive literals</li>
--   <li>Applications: note that the argument may be a <a>Expr</a>. See
--   Note [CoreSyn let/app invariant] See Note [Levity polymorphism
--   invariants]</li>
--   <li>Lambda abstraction See Note [Levity polymorphism invariants]</li>
--   <li>Recursive and non recursive <tt>let</tt>s. Operationally this
--   corresponds to allocating a thunk for the things bound and then
--   executing the sub-expression.</li>
--   </ul>
--   
--   See Note [CoreSyn letrec invariant] See Note [CoreSyn let/app
--   invariant] See Note [Levity polymorphism invariants] See Note [CoreSyn
--   type and coercion invariant]
--   
--   <ul>
--   <li>Case expression. Operationally this corresponds to evaluating the
--   scrutinee (expression examined) to weak head normal form and then
--   examining at most one level of resulting constructor (i.e. you cannot
--   do nested pattern matching directly with this).</li>
--   </ul>
--   
--   The binder gets bound to the value of the scrutinee, and the
--   <a>Expr</a> must be that of all the case alternatives
--   
--   This is one of the more complicated elements of the Core language, and
--   comes with a number of restrictions:
--   
--   <ol>
--   <li>The list of alternatives may be empty; See Note [Empty case
--   alternatives]</li>
--   <li>The <a>DEFAULT</a> case alternative must be first in the list, if
--   it occurs at all.</li>
--   <li>The remaining cases are in order of increasing tag (for
--   <tt>DataAlts</tt>) or lit (for <tt>LitAlts</tt>). This makes finding
--   the relevant constructor easy, and makes comparison easier too.</li>
--   <li>The list of alternatives must be exhaustive. An <i>exhaustive</i>
--   case does not necessarily mention all constructors:</li>
--   </ol>
--   
--   <pre>
--        data Foo = Red | Green | Blue
--   ... case x of
--        Red   -&gt; True
--        other -&gt; f (case x of
--                        Green -&gt; ...
--                        Blue  -&gt; ... ) ...
--   
--   </pre>
--   
--   The inner case does not need a <tt>Red</tt> alternative, because
--   <tt>x</tt> can't be <tt>Red</tt> at that program point.
--   
--   <ol>
--   <li>Floating-point values must not be scrutinised against literals.
--   See Trac #9238 and Note [Rules for floating-point comparisons] in
--   PrelRules for rationale.</li>
--   </ol>
--   
--   <ul>
--   <li>Cast an expression to a particular type. This is used to implement
--   <tt>newtype</tt>s (a <tt>newtype</tt> constructor or destructor just
--   becomes a <a>Cast</a> in Core) and GADTs.</li>
--   <li>Notes. These allow general information to be added to expressions
--   in the syntax tree</li>
--   <li>A type: this should only show up at the top level of an Arg</li>
--   <li>A coercion</li>
--   </ul>
data Expr b
Var :: Id -> Expr b
Lit :: Literal -> Expr b
App :: Expr b -> Arg b -> Expr b
Lam :: b -> Expr b -> Expr b
Let :: Bind b -> Expr b -> Expr b
Case :: Expr b -> b -> Type -> [Alt b] -> Expr b
Cast :: Expr b -> Coercion -> Expr b
Tick :: Tickish Id -> Expr b -> Expr b
Type :: Type -> Expr b
Coercion :: Coercion -> Expr b
infixl 4 `App`

-- | A case split alternative. Consists of the constructor leading to the
--   alternative, the variables bound from the constructor, and the
--   expression to be executed given that binding. The default alternative
--   is <tt>(DEFAULT, [], rhs)</tt>
type Alt b = (AltCon, [b], Expr b)

-- | Binding, used for top level bindings in a module and local bindings in
--   a <tt>let</tt>.
data Bind b
NonRec :: b -> Expr b -> Bind b
Rec :: [(b, Expr b)] -> Bind b

-- | A case alternative constructor (i.e. pattern match)
data AltCon
DataAlt :: DataCon -> AltCon

-- | A literal: <tt>case e of { 1 -&gt; ... }</tt> Invariant: always an
--   *unlifted* literal See Note [Literal alternatives]
LitAlt :: Literal -> AltCon

-- | Trivial alternative: <tt>case e of { _ -&gt; ... }</tt>
DEFAULT :: AltCon

-- | Type synonym for expressions that occur in function argument
--   positions. Only <a>Arg</a> should contain a <a>Expr</a> at top level,
--   general <a>Expr</a> should not
type Arg b = Expr b

-- | Allows attaching extra information to points in expressions
data Tickish id

-- | An <tt>{--}</tt> profiling annotation, either automatically added by
--   the desugarer as a result of -auto-all, or added by the user.
ProfNote :: CostCentre -> !Bool -> !Bool -> Tickish id

-- | the cost centre
[profNoteCC] :: Tickish id -> CostCentre

-- | bump the entry count?
[profNoteCount] :: Tickish id -> !Bool

-- | scopes over the enclosed expression (i.e. not just a tick)
[profNoteScope] :: Tickish id -> !Bool

-- | A "tick" used by HPC to track the execution of each subexpression in
--   the original source code.
HpcTick :: Module -> !Int -> Tickish id
[tickModule] :: Tickish id -> Module
[tickId] :: Tickish id -> !Int

-- | A breakpoint for the GHCi debugger. This behaves like an HPC tick, but
--   has a list of free variables which will be available for inspection in
--   GHCi when the program stops at the breakpoint.
--   
--   NB. we must take account of these Ids when (a) counting free
--   variables, and (b) substituting (don't substitute for them)
Breakpoint :: !Int -> [id] -> Tickish id
[breakpointId] :: Tickish id -> !Int

-- | the order of this list is important: it matches the order of the lists
--   in the appropriate entry in HscTypes.ModBreaks.
--   
--   Careful about substitution! See Note [substTickish] in CoreSubst.
[breakpointFVs] :: Tickish id -> [id]

-- | A source note.
--   
--   Source notes are pure annotations: Their presence should neither
--   influence compilation nor execution. The semantics are given by
--   causality: The presence of a source note means that a local change in
--   the referenced source code span will possibly provoke the generated
--   code to change. On the flip-side, the functionality of annotated code
--   *must* be invariant against changes to all source code *except* the
--   spans referenced in the source notes (see "Causality of optimized
--   Haskell" paper for details).
--   
--   Therefore extending the scope of any given source note is always
--   valid. Note that it is still undesirable though, as this reduces their
--   usefulness for debugging and profiling. Therefore we will generally
--   try only to make use of this property where it is necessary to enable
--   optimizations.
SourceNote :: RealSrcSpan -> String -> Tickish id

-- | Source covered
[sourceSpan] :: Tickish id -> RealSrcSpan

-- | Name for source location (uses same names as CCs)
[sourceName] :: Tickish id -> String

-- | Specifies the scoping behaviour of ticks. This governs the behaviour
--   of ticks that care about the covered code and the cost associated with
--   it. Important for ticks relating to profiling.
data TickishScoping

-- | No scoping: The tick does not care about what code it covers.
--   Transformations can freely move code inside as well as outside without
--   any additional annotation obligations
NoScope :: TickishScoping

-- | Soft scoping: We want all code that is covered to stay covered. Note
--   that this scope type does not forbid transformations from happening,
--   as long as all results of the transformations are still covered by
--   this tick or a copy of it. For example
--   
--   let x = tick<a>...</a> (let y = foo in bar) in baz ===&gt; let x =
--   tick<a>...</a> bar; y = tick<a>...</a> foo in baz
--   
--   Is a valid transformation as far as "bar" and "foo" is concerned,
--   because both still are scoped over by the tick.
--   
--   Note though that one might object to the "let" not being covered by
--   the tick any more. However, we are generally lax with this - constant
--   costs don't matter too much, and given that the "let" was effectively
--   merged we can view it as having lost its identity anyway.
--   
--   Also note that this scoping behaviour allows floating a tick "upwards"
--   in pretty much any situation. For example:
--   
--   case foo of x -&gt; tick<a>...</a> bar ==&gt; tick<a>...</a> case foo
--   of x -&gt; bar
--   
--   While this is always leagl, we want to make a best effort to only make
--   us of this where it exposes transformation opportunities.
SoftScope :: TickishScoping

-- | Cost centre scoping: We don't want any costs to move to other
--   cost-centre stacks. This means we not only want no code or cost to get
--   moved out of their cost centres, but we also object to code getting
--   associated with new cost-centre ticks - or changing the order in which
--   they get applied.
--   
--   A rule of thumb is that we don't want any code to gain new
--   annotations. However, there are notable exceptions, for example:
--   
--   let f = y -&gt; foo in tick<a>...</a> ... (f x) ... ==&gt;
--   tick<a>...</a> ... foo[x/y] ...
--   
--   In-lining lambdas like this is always legal, because inlining a
--   function does not change the cost-centre stack when the function is
--   called.
CostCentreScope :: TickishScoping

-- | Governs the kind of expression that the tick gets placed on when
--   annotating for example using <tt>mkTick</tt>. If we find that we want
--   to put a tickish on an expression ruled out here, we try to float it
--   inwards until we find a suitable expression.
data TickishPlacement

-- | Place ticks exactly on run-time expressions. We can still move the
--   tick through pure compile-time constructs such as other ticks, casts
--   or type lambdas. This is the most restrictive placement rule for
--   ticks, as all tickishs have in common that they want to track runtime
--   processes. The only legal placement rule for counting ticks.
PlaceRuntime :: TickishPlacement

-- | As <tt>PlaceRuntime</tt>, but we float the tick through all lambdas.
--   This makes sense where there is little difference between annotating
--   the lambda and annotating the lambda's code.
PlaceNonLam :: TickishPlacement

-- | In addition to floating through lambdas, cost-centre style tickishs
--   can also be moved from constructors, non-function variables and
--   literals. For example:
--   
--   let x = scc<a>...</a> C (scc<a>...</a> y) (scc<a>...</a> 3) in ...
--   
--   Neither the constructor application, the variable or the literal are
--   likely to have any cost worth mentioning. And even if y names a thunk,
--   the call would not care about the evaluation context. Therefore
--   removing all annotations in the above example is safe.
PlaceCostCentre :: TickishPlacement
type CoreProgram = [CoreBind]

-- | Expressions where binders are <a>CoreBndr</a>s
type CoreExpr = Expr CoreBndr

-- | Case alternatives where binders are <a>CoreBndr</a>s
type CoreAlt = Alt CoreBndr

-- | Binding groups where binders are <a>CoreBndr</a>s
type CoreBind = Bind CoreBndr

-- | Argument expressions where binders are <a>CoreBndr</a>s
type CoreArg = Arg CoreBndr

-- | The common case for the type of binders and variables when we are
--   manipulating the Core language within GHC
type CoreBndr = Var
type TaggedExpr t = Expr (TaggedBndr t)
type TaggedAlt t = Alt (TaggedBndr t)
type TaggedBind t = Bind (TaggedBndr t)
type TaggedArg t = Arg (TaggedBndr t)

-- | Binders are <i>tagged</i> with a t
data TaggedBndr t
TB :: CoreBndr -> t -> TaggedBndr t
deTagExpr :: TaggedExpr t -> CoreExpr
type InId = Id
type InBind = CoreBind
type InExpr = CoreExpr
type InAlt = CoreAlt
type InArg = CoreArg
type InType = Type
type InKind = Kind
type InBndr = CoreBndr
type InVar = Var
type InCoercion = Coercion
type InTyVar = TyVar
type InCoVar = CoVar
type OutId = Id
type OutBind = CoreBind
type OutExpr = CoreExpr
type OutAlt = CoreAlt
type OutArg = CoreArg
type OutType = Type
type OutKind = Kind
type OutBndr = CoreBndr
type OutVar = Var
type OutCoercion = Coercion
type OutTyVar = TyVar
type OutCoVar = CoVar
type MOutCoercion = MCoercion
mkLet :: Bind b -> Expr b -> Expr b

-- | Bind all supplied binding groups over an expression in a nested let
--   expression. Assumes that the rhs satisfies the let/app invariant.
--   Prefer to use <a>mkCoreLets</a> if possible, which does guarantee the
--   invariant
mkLets :: [Bind b] -> Expr b -> Expr b

-- | <tt>mkLetNonRec bndr rhs body</tt> wraps <tt>body</tt> in a
--   <tt>let</tt> binding <tt>bndr</tt>.
mkLetNonRec :: b -> Expr b -> Expr b -> Expr b

-- | <tt>mkLetRec binds body</tt> wraps <tt>body</tt> in a <tt>let rec</tt>
--   with the given set of <tt>binds</tt> if binds is non-empty.
mkLetRec :: [(b, Expr b)] -> Expr b -> Expr b

-- | Bind all supplied binders over an expression in a nested lambda
--   expression. Prefer to use <a>mkCoreLams</a> if possible
mkLams :: [b] -> Expr b -> Expr b

-- | Apply a list of argument expressions to a function expression in a
--   nested fashion. Prefer to use <a>mkCoreApps</a> if possible
mkApps :: Expr b -> [Arg b] -> Expr b
infixl 4 `mkApps`

-- | Apply a list of type argument expressions to a function expression in
--   a nested fashion
mkTyApps :: Expr b -> [Type] -> Expr b
infixl 4 `mkTyApps`

-- | Apply a list of coercion argument expressions to a function expression
--   in a nested fashion
mkCoApps :: Expr b -> [Coercion] -> Expr b
infixl 4 `mkCoApps`

-- | Apply a list of type or value variables to a function expression in a
--   nested fashion
mkVarApps :: Expr b -> [Var] -> Expr b
infixl 4 `mkVarApps`
mkTyArg :: Type -> Expr b

-- | Create a machine integer literal expression of type <tt>Int#</tt> from
--   an <tt>Integer</tt>. If you want an expression of type <tt>Int</tt>
--   use <a>mkIntExpr</a>
mkIntLit :: DynFlags -> Integer -> Expr b

-- | Create a machine integer literal expression of type <tt>Int#</tt> from
--   an <tt>Int</tt>. If you want an expression of type <tt>Int</tt> use
--   <a>mkIntExpr</a>
mkIntLitInt :: DynFlags -> Int -> Expr b

-- | Create a machine word literal expression of type <tt>Word#</tt> from
--   an <tt>Integer</tt>. If you want an expression of type <tt>Word</tt>
--   use <a>mkWordExpr</a>
mkWordLit :: DynFlags -> Integer -> Expr b

-- | Create a machine word literal expression of type <tt>Word#</tt> from a
--   <tt>Word</tt>. If you want an expression of type <tt>Word</tt> use
--   <a>mkWordExpr</a>
mkWordLitWord :: DynFlags -> Word -> Expr b
mkWord64LitWord64 :: Word64 -> Expr b
mkInt64LitInt64 :: Int64 -> Expr b

-- | Create a machine character literal expression of type <tt>Char#</tt>.
--   If you want an expression of type <tt>Char</tt> use <a>mkCharExpr</a>
mkCharLit :: Char -> Expr b

-- | Create a machine string literal expression of type <tt>Addr#</tt>. If
--   you want an expression of type <tt>String</tt> use <a>mkStringExpr</a>
mkStringLit :: String -> Expr b

-- | Create a machine single precision literal expression of type
--   <tt>Float#</tt> from a <tt>Rational</tt>. If you want an expression of
--   type <tt>Float</tt> use <a>mkFloatExpr</a>
mkFloatLit :: Rational -> Expr b

-- | Create a machine single precision literal expression of type
--   <tt>Float#</tt> from a <tt>Float</tt>. If you want an expression of
--   type <tt>Float</tt> use <a>mkFloatExpr</a>
mkFloatLitFloat :: Float -> Expr b

-- | Create a machine double precision literal expression of type
--   <tt>Double#</tt> from a <tt>Rational</tt>. If you want an expression
--   of type <tt>Double</tt> use <a>mkDoubleExpr</a>
mkDoubleLit :: Rational -> Expr b

-- | Create a machine double precision literal expression of type
--   <tt>Double#</tt> from a <tt>Double</tt>. If you want an expression of
--   type <tt>Double</tt> use <a>mkDoubleExpr</a>
mkDoubleLitDouble :: Double -> Expr b

-- | Apply a list of argument expressions to a data constructor in a nested
--   fashion. Prefer to use <a>mkCoreConApps</a> if possible
mkConApp :: DataCon -> [Arg b] -> Expr b
mkConApp2 :: DataCon -> [Type] -> [Var] -> Expr b

-- | Create a binding group where a type variable is bound to a type. Per
--   <a>CoreSyn#type_let</a>, this can only be used to bind something in a
--   non-recursive <tt>let</tt> expression
mkTyBind :: TyVar -> Type -> CoreBind

-- | Create a binding group where a type variable is bound to a type. Per
--   <a>CoreSyn#type_let</a>, this can only be used to bind something in a
--   non-recursive <tt>let</tt> expression
mkCoBind :: CoVar -> Coercion -> CoreBind

-- | Convert a binder into either a <a>Expr</a> or <a>Expr</a> <a>Expr</a>
--   appropriately
varToCoreExpr :: CoreBndr -> Expr b
varsToCoreExprs :: [CoreBndr] -> [Expr b]
isId :: Var -> Bool

-- | Compares <a>AltCon</a>s within a single list of alternatives DEFAULT
--   comes out smallest, so that sorting by AltCon puts alternatives in the
--   order required by
cmpAltCon :: AltCon -> AltCon -> Ordering
cmpAlt :: (AltCon, a, b) -> (AltCon, a, b) -> Ordering
ltAlt :: (AltCon, a, b) -> (AltCon, a, b) -> Bool

-- | Extract every variable by this group
bindersOf :: Bind b -> [b]

-- | <a>bindersOf</a> applied to a list of binding groups
bindersOfBinds :: [Bind b] -> [b]
rhssOfBind :: Bind b -> [Expr b]
rhssOfAlts :: [Alt b] -> [Expr b]

-- | We often want to strip off leading lambdas before getting down to
--   business. Variants are <a>collectTyBinders</a>,
--   <a>collectValBinders</a>, and <a>collectTyAndValBinders</a>
collectBinders :: Expr b -> ([b], Expr b)
collectTyBinders :: CoreExpr -> ([TyVar], CoreExpr)
collectTyAndValBinders :: CoreExpr -> ([TyVar], [Id], CoreExpr)

-- | Strip off exactly N leading lambdas (type or value). Good for use with
--   join points.
collectNBinders :: Int -> Expr b -> ([b], Expr b)

-- | Takes a nested application expression and returns the function being
--   applied and the arguments to which it is applied
collectArgs :: Expr b -> (Expr b, [Arg b])

-- | Attempt to remove the last N arguments of a function call. Strip off
--   any ticks or coercions encountered along the way and any at the end.
stripNArgs :: Word -> Expr a -> Maybe (Expr a)

-- | Like <tt>collectArgs</tt>, but also collects looks through floatable
--   ticks if it means that we can find more arguments.
collectArgsTicks :: (Tickish Id -> Bool) -> Expr b -> (Expr b, [Arg b], [Tickish Id])

-- | Collapse all the bindings in the supplied groups into a single list of
--   lhs/rhs pairs suitable for binding in a <a>Rec</a> binding group
flattenBinds :: [Bind b] -> [(b, Expr b)]

-- | If the expression is a <a>Expr</a>, converts. Otherwise, panics. NB:
--   This does <i>not</i> convert <a>Expr</a> to <tt>CoercionTy</tt>.
exprToType :: CoreExpr -> Type

-- | If the expression is a <a>Expr</a>, converts.
exprToCoercion_maybe :: CoreExpr -> Maybe Coercion

-- | Determines the type resulting from applying an expression with given
--   type to a given argument expression
applyTypeToArg :: Type -> CoreExpr -> Type

-- | Returns <tt>True</tt> for value arguments, false for type args NB:
--   coercions are value arguments (zero width, to be sure, like State#,
--   but still value args).
isValArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Expr</a> expression
--   at its top level. Note this does NOT include <a>Expr</a>s.
isTypeArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Expr</a> expression
--   at its top level
isCoArg :: Expr b -> Bool

-- | Returns <tt>True</tt> iff the expression is a <a>Expr</a> or
--   <a>Expr</a> expression at its top level
isTyCoArg :: Expr b -> Bool

-- | The number of argument expressions that are values rather than types
--   at their top level
valArgCount :: [Arg b] -> Int

-- | The number of binders that bind values rather than types
valBndrCount :: [CoreBndr] -> Int

-- | Will this argument expression exist at runtime?
isRuntimeArg :: CoreExpr -> Bool

-- | Will this variable exist at runtime?
isRuntimeVar :: Var -> Bool

-- | A "counting tick" (where tickishCounts is True) is one that counts
--   evaluations in some way. We cannot discard a counting tick, and the
--   compiler should preserve the number of counting ticks as far as
--   possible.
--   
--   However, we still allow the simplifier to increase or decrease
--   sharing, so in practice the actual number of ticks may vary, except
--   that we never change the value from zero to non-zero or vice versa.
tickishCounts :: Tickish id -> Bool

-- | Returns the intended scoping rule for a Tickish
tickishScoped :: Tickish id -> TickishScoping

-- | Returns whether the tick scoping rule is at least as permissive as the
--   given scoping rule.
tickishScopesLike :: Tickish id -> TickishScoping -> Bool

-- | Returns <tt>True</tt> for ticks that can be floated upwards easily
--   even where it might change execution counts, such as:
--   
--   Just (tick<a>...</a> foo) ==&gt; tick<a>...</a> (Just foo)
--   
--   This is a combination of <tt>tickishSoftScope</tt> and
--   <tt>tickishCounts</tt>. Note that in principle splittable ticks can
--   become floatable using <tt>mkNoTick</tt> -- even though there's
--   currently no tickish for which that is the case.
tickishFloatable :: Tickish id -> Bool

-- | Returns <tt>True</tt> for a tick that is both counting <i>and</i>
--   scoping and can be split into its (tick, scope) parts using
--   <a>mkNoScope</a> and <tt>mkNoTick</tt> respectively.
tickishCanSplit :: Tickish id -> Bool
mkNoCount :: Tickish id -> Tickish id
mkNoScope :: Tickish id -> Tickish id

-- | Return <tt>True</tt> if this source annotation compiles to some
--   backend code. Without this flag, the tickish is seen as a simple
--   annotation that does not have any associated evaluation code.
--   
--   What this means that we are allowed to disregard the tick if doing so
--   means that we can skip generating any code in the first place. A
--   typical example is top-level bindings:
--   
--   foo = tick<a>...</a> y -&gt; ... ==&gt; foo = y -&gt; tick<a>...</a>
--   ...
--   
--   Here there is just no operational difference between the first and the
--   second version. Therefore code generation should simply translate the
--   code as if it found the latter.
tickishIsCode :: Tickish id -> Bool

-- | Placement behaviour we want for the ticks
tickishPlace :: Tickish id -> TickishPlacement

-- | Returns whether one tick "contains" the other one, therefore making
--   the second tick redundant.
tickishContains :: Eq b => Tickish b -> Tickish b -> Bool

-- | Records the <i>unfolding</i> of an identifier, which is approximately
--   the form the identifier would have if we substituted its definition in
--   for the identifier. This type should be treated as abstract everywhere
--   except in <a>CoreUnfold</a>
data Unfolding

-- | We have no information about the unfolding.
NoUnfolding :: Unfolding

-- | We have no information about the unfolding, because this <a>Id</a>
--   came from an <tt>hi-boot</tt> file. See Note [Inlining and hs-boot
--   files] in ToIface for what this is used for.
BootUnfolding :: Unfolding

-- | It ain't one of these constructors. <tt>OtherCon xs</tt> also
--   indicates that something has been evaluated and hence there's no point
--   in re-evaluating it. <tt>OtherCon []</tt> is used even for
--   non-data-type values to indicated evaluated-ness. Notably:
--   
--   <pre>
--   data C = C !(Int -&gt; Int)
--   case x of { C f -&gt; ... }
--   </pre>
--   
--   Here, <tt>f</tt> gets an <tt>OtherCon []</tt> unfolding.
OtherCon :: [AltCon] -> Unfolding
DFunUnfolding :: [Var] -> DataCon -> [CoreExpr] -> Unfolding
[df_bndrs] :: Unfolding -> [Var]
[df_con] :: Unfolding -> DataCon
[df_args] :: Unfolding -> [CoreExpr]

-- | An unfolding with redundant cached information. Parameters:
--   
--   uf_tmpl: Template used to perform unfolding; NB: Occurrence info is
--   guaranteed correct: see Note [OccInfo in unfoldings and rules]
--   
--   uf_is_top: Is this a top level binding?
--   
--   uf_is_value: <tt>exprIsHNF</tt> template (cached); it is ok to discard
--   a <a>seq</a> on this variable
--   
--   uf_is_work_free: Does this waste only a little work if we expand it
--   inside an inlining? Basically this is a cached version of
--   <tt>exprIsWorkFree</tt>
--   
--   uf_guidance: Tells us about the <i>size</i> of the unfolding template
CoreUnfolding :: CoreExpr -> UnfoldingSource -> Bool -> Bool -> Bool -> Bool -> Bool -> UnfoldingGuidance -> Unfolding
[uf_tmpl] :: Unfolding -> CoreExpr
[uf_src] :: Unfolding -> UnfoldingSource
[uf_is_top] :: Unfolding -> Bool
[uf_is_value] :: Unfolding -> Bool
[uf_is_conlike] :: Unfolding -> Bool
[uf_is_work_free] :: Unfolding -> Bool
[uf_expandable] :: Unfolding -> Bool
[uf_guidance] :: Unfolding -> UnfoldingGuidance

-- | <a>UnfoldingGuidance</a> says when unfolding should take place
data UnfoldingGuidance
UnfWhen :: Arity -> Bool -> Bool -> UnfoldingGuidance
[ug_arity] :: UnfoldingGuidance -> Arity
[ug_unsat_ok] :: UnfoldingGuidance -> Bool
[ug_boring_ok] :: UnfoldingGuidance -> Bool
UnfIfGoodArgs :: [Int] -> Int -> Int -> UnfoldingGuidance
[ug_args] :: UnfoldingGuidance -> [Int]
[ug_size] :: UnfoldingGuidance -> Int
[ug_res] :: UnfoldingGuidance -> Int
UnfNever :: UnfoldingGuidance
data UnfoldingSource
InlineRhs :: UnfoldingSource
InlineStable :: UnfoldingSource
InlineCompulsory :: UnfoldingSource

-- | There is no known <a>Unfolding</a>
noUnfolding :: Unfolding

-- | There is no known <a>Unfolding</a>, because this came from an hi-boot
--   file.
bootUnfolding :: Unfolding

-- | This unfolding marks the associated thing as being evaluated
evaldUnfolding :: Unfolding
mkOtherCon :: [AltCon] -> Unfolding
unSaturatedOk :: Bool
needSaturated :: Bool
boringCxtOk :: Bool
boringCxtNotOk :: Bool

-- | Retrieves the template of an unfolding: panics if none is known
unfoldingTemplate :: Unfolding -> CoreExpr
expandUnfolding_maybe :: Unfolding -> Maybe CoreExpr

-- | Retrieves the template of an unfolding if possible
--   maybeUnfoldingTemplate is used mainly wnen specialising, and we do
--   want to specialise DFuns, so it's important to return a template for
--   DFunUnfoldings
maybeUnfoldingTemplate :: Unfolding -> Maybe CoreExpr

-- | The constructors that the unfolding could never be: returns
--   <tt>[]</tt> if no information is available
otherCons :: Unfolding -> [AltCon]

-- | Determines if it is certainly the case that the unfolding will yield a
--   value (something in HNF): returns <tt>False</tt> if unsure
isValueUnfolding :: Unfolding -> Bool

-- | Determines if it possibly the case that the unfolding will yield a
--   value. Unlike <a>isValueUnfolding</a> it returns <tt>True</tt> for
--   <a>OtherCon</a>
isEvaldUnfolding :: Unfolding -> Bool

-- | Is the thing we will unfold into certainly cheap?
isCheapUnfolding :: Unfolding -> Bool
isExpandableUnfolding :: Unfolding -> Bool

-- | <tt>True</tt> if the unfolding is a constructor application, the
--   application of a CONLIKE function or <a>OtherCon</a>
isConLikeUnfolding :: Unfolding -> Bool
isCompulsoryUnfolding :: Unfolding -> Bool
isStableUnfolding :: Unfolding -> Bool
isFragileUnfolding :: Unfolding -> Bool

-- | Only returns False if there is no unfolding information available at
--   all
hasSomeUnfolding :: Unfolding -> Bool
isBootUnfolding :: Unfolding -> Bool
canUnfold :: Unfolding -> Bool
neverUnfoldGuidance :: UnfoldingGuidance -> Bool
isStableSource :: UnfoldingSource -> Bool

-- | Annotated core: allows annotation at every node in the tree
type AnnExpr bndr annot = (annot, AnnExpr' bndr annot)

-- | A clone of the <a>Expr</a> type but allowing annotation at every tree
--   node
data AnnExpr' bndr annot
AnnVar :: Id -> AnnExpr' bndr annot
AnnLit :: Literal -> AnnExpr' bndr annot
AnnLam :: bndr -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnApp :: AnnExpr bndr annot -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnCase :: AnnExpr bndr annot -> bndr -> Type -> [AnnAlt bndr annot] -> AnnExpr' bndr annot
AnnLet :: AnnBind bndr annot -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnCast :: AnnExpr bndr annot -> (annot, Coercion) -> AnnExpr' bndr annot
AnnTick :: Tickish Id -> AnnExpr bndr annot -> AnnExpr' bndr annot
AnnType :: Type -> AnnExpr' bndr annot
AnnCoercion :: Coercion -> AnnExpr' bndr annot

-- | A clone of the <a>Bind</a> type but allowing annotation at every tree
--   node
data AnnBind bndr annot
AnnNonRec :: bndr -> AnnExpr bndr annot -> AnnBind bndr annot
AnnRec :: [(bndr, AnnExpr bndr annot)] -> AnnBind bndr annot

-- | A clone of the <a>Alt</a> type but allowing annotation at every tree
--   node
type AnnAlt bndr annot = (AltCon, [bndr], AnnExpr bndr annot)

-- | Takes a nested application expression and returns the function being
--   applied and the arguments to which it is applied
collectAnnArgs :: AnnExpr b a -> (AnnExpr b a, [AnnExpr b a])
collectAnnArgsTicks :: (Tickish Var -> Bool) -> AnnExpr b a -> (AnnExpr b a, [AnnExpr b a], [Tickish Var])
deAnnotate :: AnnExpr bndr annot -> Expr bndr
deAnnotate' :: AnnExpr' bndr annot -> Expr bndr
deAnnAlt :: AnnAlt bndr annot -> Alt bndr
deAnnBind :: AnnBind b annot -> Bind b

-- | As <a>collectBinders</a> but for <a>AnnExpr</a> rather than
--   <a>Expr</a>
collectAnnBndrs :: AnnExpr bndr annot -> ([bndr], AnnExpr bndr annot)

-- | As <a>collectNBinders</a> but for <a>AnnExpr</a> rather than
--   <a>Expr</a>
collectNAnnBndrs :: Int -> AnnExpr bndr annot -> ([bndr], AnnExpr bndr annot)

-- | Is this instance an orphan? If it is not an orphan, contains an
--   <a>OccName</a> witnessing the instance's non-orphanhood. See Note
--   [Orphans]
data IsOrphan
IsOrphan :: IsOrphan
NotOrphan :: OccName -> IsOrphan

-- | Returns true if <a>IsOrphan</a> is orphan.
isOrphan :: IsOrphan -> Bool

-- | Returns true if <a>IsOrphan</a> is not an orphan.
notOrphan :: IsOrphan -> Bool
chooseOrphanAnchor :: NameSet -> IsOrphan

-- | A <a>CoreRule</a> is:
--   
--   <ul>
--   <li>"Local" if the function it is a rule for is defined in the same
--   module as the rule itself.</li>
--   <li>"Orphan" if nothing on the LHS is defined in the same module as
--   the rule itself</li>
--   </ul>
data CoreRule
Rule :: RuleName -> Activation -> Name -> [Maybe Name] -> [CoreBndr] -> [CoreExpr] -> CoreExpr -> Bool -> !Module -> !IsOrphan -> Bool -> CoreRule

-- | Name of the rule, for communication with the user
[ru_name] :: CoreRule -> RuleName

-- | When the rule is active
[ru_act] :: CoreRule -> Activation

-- | Name of the <a>Id</a> at the head of this rule
[ru_fn] :: CoreRule -> Name

-- | Name at the head of each argument to the left hand side
[ru_rough] :: CoreRule -> [Maybe Name]

-- | Variables quantified over
[ru_bndrs] :: CoreRule -> [CoreBndr]

-- | Left hand side arguments
[ru_args] :: CoreRule -> [CoreExpr]

-- | Right hand side of the rule Occurrence info is guaranteed correct See
--   Note [OccInfo in unfoldings and rules]
[ru_rhs] :: CoreRule -> CoreExpr

-- | <tt>True</tt> <a>=</a> this rule is auto-generated (notably by
--   Specialise or SpecConstr) <tt>False</tt> <a>=</a> generated at the
--   user's behest See Note [Trimming auto-rules] in TidyPgm for the sole
--   purpose of this field.
[ru_auto] :: CoreRule -> Bool

-- | <a>Module</a> the rule was defined in, used to test if we should see
--   an orphan rule.
[ru_origin] :: CoreRule -> !Module

-- | Whether or not the rule is an orphan.
[ru_orphan] :: CoreRule -> !IsOrphan

-- | <tt>True</tt> iff the fn at the head of the rule is defined in the
--   same module as the rule and is not an implicit <a>Id</a> (like a
--   record selector, class operation, or data constructor). This is
--   different from <a>ru_orphan</a>, where a rule can avoid being an
--   orphan if *any* Name in LHS of the rule was defined in the same module
--   as the rule.
[ru_local] :: CoreRule -> Bool

-- | Built-in rules are used for constant folding and suchlike. They have
--   no free variables. A built-in rule is always visible (there is no such
--   thing as an orphan built-in rule.)
BuiltinRule :: RuleName -> Name -> Int -> RuleFun -> CoreRule

-- | Name of the rule, for communication with the user
[ru_name] :: CoreRule -> RuleName

-- | Name of the <a>Id</a> at the head of this rule
[ru_fn] :: CoreRule -> Name

-- | Number of arguments that <a>ru_try</a> consumes, if it fires,
--   including type arguments
[ru_nargs] :: CoreRule -> Int

-- | This function does the rewrite. It given too many arguments, it simply
--   discards them; the returned <a>CoreExpr</a> is just the rewrite of
--   <a>ru_fn</a> applied to the first <a>ru_nargs</a> args
[ru_try] :: CoreRule -> RuleFun

-- | Gathers a collection of <a>CoreRule</a>s. Maps (the name of) an
--   <a>Id</a> to its rules
type RuleBase = NameEnv [CoreRule]
type RuleName = FastString
type RuleFun = DynFlags -> InScopeEnv -> Id -> [CoreExpr] -> Maybe CoreExpr
type IdUnfoldingFun = Id -> Unfolding
type InScopeEnv = (InScopeSet, IdUnfoldingFun)

-- | A full rule environment which we can apply rules from. Like a
--   <a>RuleBase</a>, but it also includes the set of visible orphans we
--   use to filter out orphan rules which are not visible (even though we
--   can see them...)
data RuleEnv
RuleEnv :: RuleBase -> ModuleSet -> RuleEnv
[re_base] :: RuleEnv -> RuleBase
[re_visible_orphs] :: RuleEnv -> ModuleSet
mkRuleEnv :: RuleBase -> [Module] -> RuleEnv
emptyRuleEnv :: RuleEnv

-- | The number of arguments the <a>ru_fn</a> must be applied to before the
--   rule can match on it
ruleArity :: CoreRule -> Int
ruleName :: CoreRule -> RuleName

-- | The <a>Name</a> of the <a>Id</a> at the head of the rule left hand
--   side
ruleIdName :: CoreRule -> Name
ruleActivation :: CoreRule -> Activation

-- | Set the <a>Name</a> of the <a>Id</a> at the head of the rule left hand
--   side
setRuleIdName :: Name -> CoreRule -> CoreRule
ruleModule :: CoreRule -> Maybe Module
isBuiltinRule :: CoreRule -> Bool
isLocalRule :: CoreRule -> Bool
isAutoRule :: CoreRule -> Bool
instance GHC.Classes.Eq CoreSyn.UnfoldingGuidance
instance Data.Data.Data CoreSyn.IsOrphan
instance GHC.Classes.Eq CoreSyn.TickishPlacement
instance GHC.Classes.Eq CoreSyn.TickishScoping
instance Data.Data.Data b => Data.Data.Data (CoreSyn.Bind b)
instance Data.Data.Data b => Data.Data.Data (CoreSyn.Expr b)
instance Data.Data.Data id => Data.Data.Data (CoreSyn.Tickish id)
instance GHC.Classes.Ord id => GHC.Classes.Ord (CoreSyn.Tickish id)
instance GHC.Classes.Eq id => GHC.Classes.Eq (CoreSyn.Tickish id)
instance Data.Data.Data CoreSyn.AltCon
instance GHC.Classes.Eq CoreSyn.AltCon
instance Outputable.Outputable b => Outputable.Outputable (CoreSyn.TaggedBndr b)
instance Binary.Binary CoreSyn.IsOrphan
instance GHC.Classes.Ord CoreSyn.AltCon
instance Outputable.Outputable CoreSyn.AltCon

module IdInfo

-- | Identifier Details
--   
--   The <a>IdDetails</a> of an <tt>Id</tt> give stable, and necessary,
--   information about the Id.
data IdDetails
VanillaId :: IdDetails

-- | The <tt>Id</tt> for a record selector
RecSelId :: RecSelParent -> Bool -> IdDetails
[sel_tycon] :: IdDetails -> RecSelParent
[sel_naughty] :: IdDetails -> Bool

-- | The <tt>Id</tt> is for a data constructor <i>worker</i>
DataConWorkId :: DataCon -> IdDetails

-- | The <tt>Id</tt> is for a data constructor <i>wrapper</i>
DataConWrapId :: DataCon -> IdDetails

-- | The <tt>Id</tt> is a superclass selector, or class operation of a
--   class
ClassOpId :: Class -> IdDetails

-- | The <tt>Id</tt> is for a primitive operator
PrimOpId :: PrimOp -> IdDetails

-- | The <tt>Id</tt> is for a foreign call. Type will be simple: no type
--   families, newtypes, etc
FCallId :: ForeignCall -> IdDetails

-- | The <tt>Id</tt> is for a HPC tick box (both traditional and binary)
TickBoxOpId :: TickBoxOp -> IdDetails

-- | A dictionary function. Bool = True <a>=</a> the class has only one
--   method, so may be implemented with a newtype, so it might be bad to be
--   strict on this dictionary
DFunId :: Bool -> IdDetails

-- | A coercion variable This only covers <i>un-lifted</i> coercions, of
--   type (t1 ~ t2), not their lifted variants
CoVarId :: IdDetails

-- | An <tt>Id</tt> for a join point taking n arguments Note [Join points]
--   in CoreSyn
JoinId :: JoinArity -> IdDetails
pprIdDetails :: IdDetails -> SDoc

-- | Just a synonym for <a>CoVarId</a>. Written separately so it can be
--   exported in the hs-boot file.
coVarDetails :: IdDetails

-- | Check if an <a>IdDetails</a> says <a>CoVarId</a>.
isCoVarDetails :: IdDetails -> Bool

-- | The number of arguments that a join point takes. Unlike the arity of a
--   function, this is a purely syntactic property and is fixed when the
--   join point is created (or converted from a value). Both type and value
--   arguments are counted.
type JoinArity = Int
isJoinIdDetails_maybe :: IdDetails -> Maybe JoinArity

-- | Recursive Selector Parent
data RecSelParent
RecSelData :: TyCon -> RecSelParent
RecSelPatSyn :: PatSyn -> RecSelParent

-- | Identifier Information
--   
--   An <a>IdInfo</a> gives <i>optional</i> information about an
--   <tt>Id</tt>. If present it never lies, but it may not be present, in
--   which case there is always a conservative assumption which can be
--   made.
--   
--   Two <tt>Id</tt>s may have different info even though they have the
--   same <tt>Unique</tt> (and are hence the same <tt>Id</tt>); for
--   example, one might lack the properties attached to the other.
--   
--   Most of the <a>IdInfo</a> gives information about the value, or
--   definition, of the <tt>Id</tt>, independent of its usage. Exceptions
--   to this are <a>demandInfo</a>, <a>occInfo</a>, <a>oneShotInfo</a> and
--   <a>callArityInfo</a>.
--   
--   Performance note: when we update <a>IdInfo</a>, we have to reallocate
--   this entire record, so it is a good idea not to let this data
--   structure get too big.
data IdInfo

-- | Basic <a>IdInfo</a> that carries no useful information whatsoever
vanillaIdInfo :: IdInfo

-- | More informative <a>IdInfo</a> we can use when we know the <tt>Id</tt>
--   has no CAF references
noCafIdInfo :: IdInfo

-- | If the <tt>Id</tt> is a lambda-bound variable then it may have
--   lambda-bound variable info. Sometimes we know whether the lambda
--   binding this variable is a "one-shot" lambda; that is, whether it is
--   applied at most once.
--   
--   This information may be useful in optimisation, as computations may
--   safely be floated inside such a lambda without risk of duplicating
--   work.
data OneShotInfo

-- | No information
NoOneShotInfo :: OneShotInfo

-- | The lambda is applied at most once.
OneShotLam :: OneShotInfo

-- | Info about a lambda-bound variable, if the <tt>Id</tt> is one
oneShotInfo :: IdInfo -> OneShotInfo

-- | It is always safe to assume that an <tt>Id</tt> has no lambda-bound
--   variable information
noOneShotInfo :: OneShotInfo
hasNoOneShotInfo :: OneShotInfo -> Bool
setOneShotInfo :: IdInfo -> OneShotInfo -> IdInfo
infixl 1 `setOneShotInfo`

-- | This is used to remove information on lambda binders that we have
--   setup as part of a lambda group, assuming they will be applied all at
--   once, but turn out to be part of an unsaturated lambda as in e.g:
--   
--   <pre>
--   (\x1. \x2. e) arg1
--   </pre>
zapLamInfo :: IdInfo -> Maybe IdInfo

-- | Zap info that depends on free variables
zapFragileInfo :: IdInfo -> Maybe IdInfo

-- | Remove all demand info on the <a>IdInfo</a>
zapDemandInfo :: IdInfo -> Maybe IdInfo

-- | Remove usage (but not strictness) info on the <a>IdInfo</a>
zapUsageInfo :: IdInfo -> Maybe IdInfo

-- | Remove usage environment info from the strictness signature on the
--   <a>IdInfo</a>
zapUsageEnvInfo :: IdInfo -> Maybe IdInfo
zapUsedOnceInfo :: IdInfo -> Maybe IdInfo
zapTailCallInfo :: IdInfo -> Maybe IdInfo
zapCallArityInfo :: IdInfo -> IdInfo
zapUnfolding :: Unfolding -> Unfolding

-- | Arity Information
--   
--   An <a>ArityInfo</a> of <tt>n</tt> tells us that partial application of
--   this <tt>Id</tt> to up to <tt>n-1</tt> value arguments does
--   essentially no work.
--   
--   That is not necessarily the same as saying that it has <tt>n</tt>
--   leading lambdas, because coerces may get in the way.
--   
--   The arity might increase later in the compilation process, if an extra
--   lambda floats up to the binding site.
type ArityInfo = Arity

-- | It is always safe to assume that an <tt>Id</tt> has an arity of 0
unknownArity :: Arity

-- | <tt>Id</tt> arity
arityInfo :: IdInfo -> ArityInfo
setArityInfo :: IdInfo -> ArityInfo -> IdInfo
infixl 1 `setArityInfo`
ppArityInfo :: Int -> SDoc

-- | How this is called. n <a>=</a> all calls have at least n arguments
callArityInfo :: IdInfo -> ArityInfo
setCallArityInfo :: IdInfo -> ArityInfo -> IdInfo
strictnessInfo :: IdInfo -> StrictSig
setStrictnessInfo :: IdInfo -> StrictSig -> IdInfo
infixl 1 `setStrictnessInfo`

-- | ID demand information
demandInfo :: IdInfo -> Demand
setDemandInfo :: IdInfo -> Demand -> IdInfo
infixl 1 `setDemandInfo`
pprStrictness :: StrictSig -> SDoc

-- | The <tt>Id</tt>s unfolding
unfoldingInfo :: IdInfo -> Unfolding
setUnfoldingInfo :: IdInfo -> Unfolding -> IdInfo
infixl 1 `setUnfoldingInfo`

-- | Inline Pragma Information
--   
--   Tells when the inlining is active. When it is active the thing may be
--   inlined, depending on how big it is.
--   
--   If there was an <tt>INLINE</tt> pragma, then as a separate matter, the
--   RHS will have been made to look small with a Core inline <tt>Note</tt>
--   
--   The default <a>InlinePragInfo</a> is <a>AlwaysActive</a>, so the info
--   serves entirely as a way to inhibit inlining until we want it
type InlinePragInfo = InlinePragma

-- | Any inline pragma atached to the <tt>Id</tt>
inlinePragInfo :: IdInfo -> InlinePragma
setInlinePragInfo :: IdInfo -> InlinePragma -> IdInfo
infixl 1 `setInlinePragInfo`

-- | identifier Occurrence Information
data OccInfo

-- | There are many occurrences, or unknown occurrences
ManyOccs :: !TailCallInfo -> OccInfo
[occ_tail] :: OccInfo -> !TailCallInfo

-- | Marks unused variables. Sometimes useful for lambda and case-bound
--   variables.
IAmDead :: OccInfo

-- | Occurs exactly once (per branch), not inside a rule
OneOcc :: !InsideLam -> !OneBranch -> !InterestingCxt -> !TailCallInfo -> OccInfo
[occ_in_lam] :: OccInfo -> !InsideLam
[occ_one_br] :: OccInfo -> !OneBranch
[occ_int_cxt] :: OccInfo -> !InterestingCxt
[occ_tail] :: OccInfo -> !TailCallInfo

-- | This identifier breaks a loop of mutually recursive functions. The
--   field marks whether it is only a loop breaker due to a reference in a
--   rule
IAmALoopBreaker :: !RulesOnly -> !TailCallInfo -> OccInfo
[occ_rules_only] :: OccInfo -> !RulesOnly
[occ_tail] :: OccInfo -> !TailCallInfo
isDeadOcc :: OccInfo -> Bool
isStrongLoopBreaker :: OccInfo -> Bool
isWeakLoopBreaker :: OccInfo -> Bool

-- | How the <tt>Id</tt> occurs in the program
occInfo :: IdInfo -> OccInfo
setOccInfo :: IdInfo -> OccInfo -> IdInfo
infixl 1 `setOccInfo`

-- | Inside Lambda
type InsideLam = Bool
type OneBranch = Bool
insideLam :: InsideLam
notInsideLam :: InsideLam
oneBranch :: OneBranch
notOneBranch :: OneBranch
data TailCallInfo
AlwaysTailCalled :: JoinArity -> TailCallInfo
NoTailCallInfo :: TailCallInfo
tailCallInfo :: OccInfo -> TailCallInfo
isAlwaysTailCalled :: OccInfo -> Bool

-- | Rule Information
--   
--   Records the specializations of this <tt>Id</tt> that we know about in
--   the form of rewrite <a>CoreRule</a>s that target them
data RuleInfo
RuleInfo :: [CoreRule] -> DVarSet -> RuleInfo

-- | Assume that no specilizations exist: always safe
emptyRuleInfo :: RuleInfo
isEmptyRuleInfo :: RuleInfo -> Bool

-- | Retrieve the locally-defined free variables of both the left and right
--   hand sides of the specialization rules
ruleInfoFreeVars :: RuleInfo -> DVarSet
ruleInfoRules :: RuleInfo -> [CoreRule]

-- | Change the name of the function the rule is keyed on on all of the
--   <a>CoreRule</a>s
setRuleInfoHead :: Name -> RuleInfo -> RuleInfo

-- | Specialisations of the <tt>Id</tt>s function which exist See Note
--   [Specialisations and RULES in IdInfo]
ruleInfo :: IdInfo -> RuleInfo
setRuleInfo :: IdInfo -> RuleInfo -> IdInfo
infixl 1 `setRuleInfo`

-- | Constant applicative form Information
--   
--   Records whether an <tt>Id</tt> makes Constant Applicative Form
--   references
data CafInfo

-- | Indicates that the <tt>Id</tt> is for either:
--   
--   <ol>
--   <li>A function or static constructor that refers to one or more CAFs,
--   or</li>
--   <li>A real live CAF</li>
--   </ol>
MayHaveCafRefs :: CafInfo

-- | A function or static constructor that refers to no CAFs.
NoCafRefs :: CafInfo
ppCafInfo :: CafInfo -> SDoc
mayHaveCafRefs :: CafInfo -> Bool

-- | <tt>Id</tt> CAF info
cafInfo :: IdInfo -> CafInfo
setCafInfo :: IdInfo -> CafInfo -> IdInfo
infixl 1 `setCafInfo`

-- | Tick box for Hpc-style coverage
data TickBoxOp
TickBox :: Module -> {-# UNPACK #-} !TickBoxId -> TickBoxOp
type TickBoxId = Int
data LevityInfo

-- | when applied, will this Id ever have a levity-polymorphic type?
levityInfo :: IdInfo -> LevityInfo

-- | Marks an IdInfo describing an Id that is never levity polymorphic
--   (even when applied). The Type is only there for checking that it's
--   really never levity polymorphic
setNeverLevPoly :: HasDebugCallStack => IdInfo -> Type -> IdInfo
infixl 1 `setNeverLevPoly`
setLevityInfoWithType :: IdInfo -> Type -> IdInfo
infixl 1 `setLevityInfoWithType`
isNeverLevPolyIdInfo :: IdInfo -> Bool
instance GHC.Classes.Eq IdInfo.LevityInfo
instance GHC.Classes.Ord IdInfo.CafInfo
instance GHC.Classes.Eq IdInfo.CafInfo
instance GHC.Classes.Eq IdInfo.RecSelParent
instance Outputable.Outputable IdInfo.LevityInfo
instance Outputable.Outputable IdInfo.IdDetails
instance Outputable.Outputable IdInfo.TickBoxOp
instance Outputable.Outputable IdInfo.CafInfo
instance Outputable.Outputable IdInfo.RecSelParent


-- | GHC uses several kinds of name internally:
--   
--   <ul>
--   <li><a>OccName</a>: see <a>OccName#name_types</a></li>
--   <li><a>RdrName</a>: see <a>RdrName#name_types</a></li>
--   <li><a>Name</a>: see <a>Name#name_types</a></li>
--   <li><a>Id</a> represents names that not only have a <a>Name</a> but
--   also a <a>Type</a> and some additional details (a <a>IdInfo</a> and
--   one of <a>LocalIdDetails</a> or <a>GlobalIdDetails</a>) that are
--   added, modified and inspected by various compiler passes. These
--   <a>Var</a> names may either be global or local, see
--   <a>Var#globalvslocal</a></li>
--   <li><a>Var</a>: see <a>Var#name_types</a></li>
--   </ul>
module Id

-- | Variable
--   
--   Essentially a typed <a>Name</a>, that may also contain some additional
--   information about the <a>Var</a> and its use sites.
data Var

-- | Identifier
type Id = Var
isId :: Var -> Bool
type InVar = Var
type InId = Id
type OutVar = Var
type OutId = Id

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>Var#globalvslocal</a>
mkGlobalId :: IdDetails -> Name -> Type -> IdInfo -> Id

-- | Make a global <a>Id</a> without any extra information at all
mkVanillaGlobal :: Name -> Type -> Id

-- | Make a global <a>Id</a> with no global information but some generic
--   <a>IdInfo</a>
mkVanillaGlobalWithInfo :: Name -> Type -> IdInfo -> Id

-- | For an explanation of global vs. local <a>Id</a>s, see
--   <a>Var#globalvslocal</a>
mkLocalId :: Name -> Type -> Id

-- | Make a local CoVar
mkLocalCoVar :: Name -> Type -> CoVar

-- | Like <a>mkLocalId</a>, but checks the type to see if it should make a
--   covar
mkLocalIdOrCoVar :: Name -> Type -> Id

-- | Make a local id, with the IdDetails set to CoVarId if the type
--   indicates so.
mkLocalIdOrCoVarWithInfo :: Name -> Type -> IdInfo -> Id
mkLocalIdWithInfo :: Name -> Type -> IdInfo -> Id

-- | Create a local <a>Id</a> that is marked as exported. This prevents
--   things attached to it from being removed as dead code. See Note
--   [Exported LocalIds]
mkExportedLocalId :: IdDetails -> Name -> Type -> Id
mkExportedVanillaId :: Name -> Type -> Id

-- | Create a system local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>Var#globalvslocal</a>) that are created by the compiler out of thin
--   air
mkSysLocal :: FastString -> Unique -> Type -> Id
mkSysLocalM :: MonadUnique m => FastString -> Type -> m Id

-- | Like <a>mkSysLocal</a>, but checks to see if we have a covar type
mkSysLocalOrCoVar :: FastString -> Unique -> Type -> Id
mkSysLocalOrCoVarM :: MonadUnique m => FastString -> Type -> m Id

-- | Create a user local <a>Id</a>. These are local <a>Id</a>s (see
--   <a>Var#globalvslocal</a>) with a name and location that the user might
--   recognize
mkUserLocal :: OccName -> Unique -> Type -> SrcSpan -> Id

-- | Like <a>mkUserLocal</a>, but checks if we have a coercion type
mkUserLocalOrCoVar :: OccName -> Unique -> Type -> SrcSpan -> Id

-- | Create a template local for a series of types
mkTemplateLocals :: [Type] -> [Id]

-- | Create a template local for a series of type, but start from a
--   specified template local
mkTemplateLocalsNum :: Int -> [Type] -> [Id]

-- | Create a <i>template local</i>: a family of system local <a>Id</a>s in
--   bijection with <tt>Int</tt>s, typically used in unfoldings
mkTemplateLocal :: Int -> Type -> Id

-- | Workers get local names. <a>CoreTidy</a> will externalise these if
--   necessary
mkWorkerId :: Unique -> Id -> Type -> Id
idName :: Id -> Name
idType :: Id -> Kind
idUnique :: Id -> Unique
idInfo :: HasDebugCallStack => Id -> IdInfo
idDetails :: Id -> IdDetails

-- | If the <a>Id</a> is that for a record selector, extract the
--   <a>sel_tycon</a>. Panic otherwise.
recordSelectorTyCon :: Id -> RecSelParent
setIdName :: Id -> Name -> Id
setIdUnique :: Id -> Unique -> Id

-- | Not only does this set the <a>Id</a> <a>Type</a>, it also evaluates
--   the type to try and reduce space usage
setIdType :: Id -> Type -> Id
setIdExported :: Id -> Id
setIdNotExported :: Id -> Id

-- | If it's a local, make it global
globaliseId :: Id -> Id
localiseId :: Id -> Id
setIdInfo :: Id -> IdInfo -> Id
lazySetIdInfo :: Id -> IdInfo -> Id
modifyIdInfo :: HasDebugCallStack => (IdInfo -> IdInfo) -> Id -> Id
maybeModifyIdInfo :: Maybe IdInfo -> Id -> Id
zapLamIdInfo :: Id -> Id
zapIdDemandInfo :: Id -> Id
zapIdUsageInfo :: Id -> Id
zapIdUsageEnvInfo :: Id -> Id
zapIdUsedOnceInfo :: Id -> Id
zapIdTailCallInfo :: Id -> Id
zapFragileIdInfo :: Id -> Id
zapIdStrictness :: Id -> Id
zapStableUnfolding :: Id -> Id
transferPolyIdInfo :: Id -> [Var] -> Id -> Id

-- | <a>isImplicitId</a> tells whether an <a>Id</a>s info is implied by
--   other declarations, so we don't need to put its signature in an
--   interface file, even if it's mentioned in some other interface
--   unfolding.
isImplicitId :: Id -> Bool
isDeadBinder :: Id -> Bool

-- | This predicate says whether the <a>Id</a> has a strict demand placed
--   on it or has a type such that it can always be evaluated strictly (i.e
--   an unlifted type, as of GHC 7.6). We need to check separately whether
--   the <a>Id</a> has a so-called "strict type" because if the demand for
--   the given <tt>id</tt> hasn't been computed yet but <tt>id</tt> has a
--   strict type, we still want <tt>isStrictId id</tt> to be <tt>True</tt>.
isStrictId :: Id -> Bool

-- | <tt>isExportedIdVar</tt> means "don't throw this away"
isExportedId :: Var -> Bool
isLocalId :: Var -> Bool
isGlobalId :: Var -> Bool
isRecordSelector :: Id -> Bool
isNaughtyRecordSelector :: Id -> Bool
isPatSynRecordSelector :: Id -> Bool
isDataConRecordSelector :: Id -> Bool
isClassOpId_maybe :: Id -> Maybe Class
isDFunId :: Id -> Bool
isPrimOpId :: Id -> Bool
isPrimOpId_maybe :: Id -> Maybe PrimOp
isFCallId :: Id -> Bool
isFCallId_maybe :: Id -> Maybe ForeignCall
isDataConWorkId :: Id -> Bool
isDataConWorkId_maybe :: Id -> Maybe DataCon
isDataConId_maybe :: Id -> Maybe DataCon

-- | Get from either the worker or the wrapper <a>Id</a> to the
--   <a>DataCon</a>. Currently used only in the desugarer.
--   
--   INVARIANT: <tt>idDataCon (dataConWrapId d) = d</tt>: remember,
--   <a>dataConWrapId</a> can return either the wrapper or the worker
idDataCon :: Id -> DataCon
isConLikeId :: Id -> Bool

-- | Returns true if an application to n args would diverge
isBottomingId :: Var -> Bool
idIsFrom :: Module -> Id -> Bool

-- | Returns <tt>True</tt> of an <a>Id</a> which may not have a binding,
--   even though it is defined in this module.
hasNoBinding :: Id -> Bool

-- | Dictionary Identifier
type DictId = EvId
isDictId :: Id -> Bool
isEvVar :: Var -> Bool
type JoinId = Id
isJoinId :: Var -> Bool
isJoinId_maybe :: Var -> Maybe JoinArity
idJoinArity :: JoinId -> JoinArity
asJoinId :: Id -> JoinArity -> JoinId
infixl 1 `asJoinId`
asJoinId_maybe :: Id -> Maybe JoinArity -> Id
infixl 1 `asJoinId_maybe`
zapJoinId :: Id -> Id
idInlinePragma :: Id -> InlinePragma
setInlinePragma :: Id -> InlinePragma -> Id
infixl 1 `setInlinePragma`
modifyInlinePragma :: Id -> (InlinePragma -> InlinePragma) -> Id
idInlineActivation :: Id -> Activation
setInlineActivation :: Id -> Activation -> Id
infixl 1 `setInlineActivation`
idRuleMatchInfo :: Id -> RuleMatchInfo

-- | Returns whether the lambda associated with the <a>Id</a> is certainly
--   applied at most once This one is the "business end", called
--   externally. It works on type variables as well as Ids, returning True
--   Its main purpose is to encapsulate the Horrible State Hack See Note
--   [The state-transformer hack] in CoreArity
isOneShotBndr :: Var -> Bool
isProbablyOneShotLambda :: Id -> Bool
setOneShotLambda :: Id -> Id
clearOneShotLambda :: Id -> Id
updOneShotInfo :: Id -> OneShotInfo -> Id
setIdOneShotInfo :: Id -> OneShotInfo -> Id
infixl 1 `setIdOneShotInfo`
isStateHackType :: Type -> Bool

-- | Should we apply the state hack to values of this <a>Type</a>?
stateHackOneShot :: OneShotInfo
typeOneShot :: Type -> OneShotInfo
idArity :: Id -> Arity
idCallArity :: Id -> Arity
idFunRepArity :: Id -> RepArity
idUnfolding :: Id -> Unfolding
realIdUnfolding :: Id -> Unfolding
idSpecialisation :: Id -> RuleInfo
idCoreRules :: Id -> [CoreRule]
idHasRules :: Id -> Bool
idCafInfo :: Id -> CafInfo
infixl 1 `idCafInfo`
idOneShotInfo :: Id -> OneShotInfo

-- | Like <a>idOneShotInfo</a>, but taking the Horrible State Hack in to
--   account See Note [The state-transformer hack] in CoreArity
idStateHackOneShotInfo :: Id -> OneShotInfo
idOccInfo :: Id -> OccInfo
isNeverLevPolyId :: Id -> Bool
setIdUnfolding :: Id -> Unfolding -> Id
infixl 1 `setIdUnfolding`
setCaseBndrEvald :: StrictnessMark -> Id -> Id
setIdArity :: Id -> Arity -> Id
infixl 1 `setIdArity`
setIdCallArity :: Id -> Arity -> Id
infixl 1 `setIdCallArity`
setIdSpecialisation :: Id -> RuleInfo -> Id
infixl 1 `setIdSpecialisation`
setIdCafInfo :: Id -> CafInfo -> Id
setIdOccInfo :: Id -> OccInfo -> Id
infixl 1 `setIdOccInfo`
zapIdOccInfo :: Id -> Id
setIdDemandInfo :: Id -> Demand -> Id
infixl 1 `setIdDemandInfo`
setIdStrictness :: Id -> StrictSig -> Id
infixl 1 `setIdStrictness`
idDemandInfo :: Id -> Demand
idStrictness :: Id -> StrictSig


-- | This module is about types that can be defined in Haskell, but which
--   must be wired into the compiler nonetheless. C.f module TysPrim
module TysWiredIn
mkWiredInTyConName :: BuiltInSyntax -> Module -> FastString -> Unique -> TyCon -> Name
mkWiredInIdName :: Module -> FastString -> Unique -> Id -> Name
mkFunKind :: Kind -> Kind -> Kind
mkForAllKind :: TyCoVar -> ArgFlag -> Kind -> Kind
wiredInTyCons :: [TyCon]

-- | Built-in syntax isn't "in scope" so these OccNames map to wired-in
--   Names with BuiltInSyntax. However, this should only be necessary while
--   resolving names produced by Template Haskell splices since we take
--   care to encode built-in syntax names specially in interface files. See
--   Note [Symbol table representation of names].
--   
--   Moreover, there is no need to include names of things that the user
--   can't write (e.g. type representation bindings like $tc(,,,)).
isBuiltInOcc_maybe :: OccName -> Maybe Name
boolTy :: Type
boolTyCon :: TyCon
boolTyCon_RDR :: RdrName
boolTyConName :: Name
trueDataCon :: DataCon
trueDataConId :: Id
true_RDR :: RdrName
falseDataCon :: DataCon
falseDataConId :: Id
false_RDR :: RdrName
promotedFalseDataCon :: TyCon
promotedTrueDataCon :: TyCon
orderingTyCon :: TyCon
ordLTDataCon :: DataCon
ordLTDataConId :: Id
ordEQDataCon :: DataCon
ordEQDataConId :: Id
ordGTDataCon :: DataCon
ordGTDataConId :: Id
promotedLTDataCon :: TyCon
promotedEQDataCon :: TyCon
promotedGTDataCon :: TyCon
boxingDataCon_maybe :: TyCon -> Maybe DataCon
charTyCon :: TyCon
charDataCon :: DataCon
charTyCon_RDR :: RdrName
charTy :: Type
stringTy :: Type
charTyConName :: Name
doubleTyCon :: TyCon
doubleDataCon :: DataCon
doubleTy :: Type
doubleTyConName :: Name
floatTyCon :: TyCon
floatDataCon :: DataCon
floatTy :: Type
floatTyConName :: Name
intTyCon :: TyCon
intDataCon :: DataCon
intTyCon_RDR :: RdrName
intDataCon_RDR :: RdrName
intTyConName :: Name
intTy :: Type
wordTyCon :: TyCon
wordDataCon :: DataCon
wordTyConName :: Name
wordTy :: Type
word8TyCon :: TyCon
word8DataCon :: DataCon
word8TyConName :: Name
word8Ty :: Type
listTyCon :: TyCon
listTyCon_RDR :: RdrName
listTyConName :: Name
listTyConKey :: Unique
nilDataCon :: DataCon
nilDataConName :: Name
nilDataConKey :: Unique
consDataCon_RDR :: RdrName
consDataCon :: DataCon
consDataConName :: Name
promotedNilDataCon :: TyCon
promotedConsDataCon :: TyCon
mkListTy :: Type -> Type

-- | Make a *promoted* list.
mkPromotedListTy :: Kind -> [Type] -> Type
maybeTyCon :: TyCon
maybeTyConName :: Name
nothingDataCon :: DataCon
nothingDataConName :: Name
promotedNothingDataCon :: TyCon
justDataCon :: DataCon
justDataConName :: Name
promotedJustDataCon :: TyCon

-- | Make a tuple type. The list of types should <i>not</i> include any
--   RuntimeRep specifications.
mkTupleTy :: Boxity -> [Type] -> Type

-- | Build the type of a small tuple that holds the specified type of thing
mkBoxedTupleTy :: [Type] -> Type
tupleTyCon :: Boxity -> Arity -> TyCon
tupleDataCon :: Boxity -> Arity -> DataCon
tupleTyConName :: TupleSort -> Arity -> Name
promotedTupleDataCon :: Boxity -> Arity -> TyCon
unitTyCon :: TyCon
unitDataCon :: DataCon
unitDataConId :: Id
unitTy :: Type
unitTyConKey :: Unique
pairTyCon :: TyCon
unboxedUnitTyCon :: TyCon
unboxedUnitDataCon :: DataCon

-- | Specialization of <a>unboxedTupleSumKind</a> for tuples
unboxedTupleKind :: [Type] -> Kind

-- | Specialization of <a>unboxedTupleSumKind</a> for sums
unboxedSumKind :: [Type] -> Kind
cTupleTyConName :: Arity -> Name
cTupleTyConNames :: [Name]
isCTupleTyConName :: Name -> Bool

-- | If the given name is that of a constraint tuple, return its arity.
--   Note that this is inefficient.
cTupleTyConNameArity_maybe :: Name -> Maybe Arity
cTupleDataConName :: Arity -> Name
cTupleDataConNames :: [Name]
anyTyCon :: TyCon
anyTy :: Type
anyTypeOfKind :: Kind -> Type
mkSumTy :: [Type] -> Type

-- | Type constructor for n-ary unboxed sum.
sumTyCon :: Arity -> TyCon

-- | Data constructor for i-th alternative of a n-ary unboxed sum.
sumDataCon :: ConTag -> Arity -> DataCon
typeNatKindCon :: TyCon
typeNatKind :: Kind
typeSymbolKindCon :: TyCon
typeSymbolKind :: Kind
isLiftedTypeKindTyConName :: Name -> Bool
liftedTypeKind :: Kind
constraintKind :: Kind
liftedTypeKindTyCon :: TyCon
constraintKindTyCon :: TyCon
liftedTypeKindTyConName :: Name
heqTyCon :: TyCon
heqTyConName :: Name
heqClass :: Class
heqDataCon :: DataCon
eqTyCon :: TyCon
eqTyConName :: Name
eqClass :: Class
eqDataCon :: DataCon
eqTyCon_RDR :: RdrName
coercibleTyCon :: TyCon
coercibleTyConName :: Name
coercibleDataCon :: DataCon
coercibleClass :: Class
runtimeRepTyCon :: TyCon
vecCountTyCon :: TyCon
vecElemTyCon :: TyCon
runtimeRepTy :: Type
liftedRepTy :: Type
liftedRepDataCon :: DataCon
liftedRepDataConTyCon :: TyCon
vecRepDataConTyCon :: TyCon
tupleRepDataConTyCon :: TyCon
sumRepDataConTyCon :: TyCon
liftedRepDataConTy :: Type
unliftedRepDataConTy :: Type
intRepDataConTy :: Type
int8RepDataConTy :: Type
int16RepDataConTy :: Type
word16RepDataConTy :: Type
wordRepDataConTy :: Type
int64RepDataConTy :: Type
word8RepDataConTy :: Type
word64RepDataConTy :: Type
addrRepDataConTy :: Type
floatRepDataConTy :: Type
doubleRepDataConTy :: Type
vec2DataConTy :: Type
vec4DataConTy :: Type
vec8DataConTy :: Type
vec16DataConTy :: Type
vec32DataConTy :: Type
vec64DataConTy :: Type
int8ElemRepDataConTy :: Type
int16ElemRepDataConTy :: Type
int32ElemRepDataConTy :: Type
int64ElemRepDataConTy :: Type
word8ElemRepDataConTy :: Type
word16ElemRepDataConTy :: Type
word32ElemRepDataConTy :: Type
word64ElemRepDataConTy :: Type
floatElemRepDataConTy :: Type
doubleElemRepDataConTy :: Type

module PrimOp
data PrimOp
CharGtOp :: PrimOp
CharGeOp :: PrimOp
CharEqOp :: PrimOp
CharNeOp :: PrimOp
CharLtOp :: PrimOp
CharLeOp :: PrimOp
OrdOp :: PrimOp
IntAddOp :: PrimOp
IntSubOp :: PrimOp
IntMulOp :: PrimOp
IntMulMayOfloOp :: PrimOp
IntQuotOp :: PrimOp
IntRemOp :: PrimOp
IntQuotRemOp :: PrimOp
AndIOp :: PrimOp
OrIOp :: PrimOp
XorIOp :: PrimOp
NotIOp :: PrimOp
IntNegOp :: PrimOp
IntAddCOp :: PrimOp
IntSubCOp :: PrimOp
IntGtOp :: PrimOp
IntGeOp :: PrimOp
IntEqOp :: PrimOp
IntNeOp :: PrimOp
IntLtOp :: PrimOp
IntLeOp :: PrimOp
ChrOp :: PrimOp
Int2WordOp :: PrimOp
Int2FloatOp :: PrimOp
Int2DoubleOp :: PrimOp
Word2FloatOp :: PrimOp
Word2DoubleOp :: PrimOp
ISllOp :: PrimOp
ISraOp :: PrimOp
ISrlOp :: PrimOp
Int8Extend :: PrimOp
Int8Narrow :: PrimOp
Int8NegOp :: PrimOp
Int8AddOp :: PrimOp
Int8SubOp :: PrimOp
Int8MulOp :: PrimOp
Int8QuotOp :: PrimOp
Int8RemOp :: PrimOp
Int8QuotRemOp :: PrimOp
Int8EqOp :: PrimOp
Int8GeOp :: PrimOp
Int8GtOp :: PrimOp
Int8LeOp :: PrimOp
Int8LtOp :: PrimOp
Int8NeOp :: PrimOp
Word8Extend :: PrimOp
Word8Narrow :: PrimOp
Word8NotOp :: PrimOp
Word8AddOp :: PrimOp
Word8SubOp :: PrimOp
Word8MulOp :: PrimOp
Word8QuotOp :: PrimOp
Word8RemOp :: PrimOp
Word8QuotRemOp :: PrimOp
Word8EqOp :: PrimOp
Word8GeOp :: PrimOp
Word8GtOp :: PrimOp
Word8LeOp :: PrimOp
Word8LtOp :: PrimOp
Word8NeOp :: PrimOp
Int16Extend :: PrimOp
Int16Narrow :: PrimOp
Int16NegOp :: PrimOp
Int16AddOp :: PrimOp
Int16SubOp :: PrimOp
Int16MulOp :: PrimOp
Int16QuotOp :: PrimOp
Int16RemOp :: PrimOp
Int16QuotRemOp :: PrimOp
Int16EqOp :: PrimOp
Int16GeOp :: PrimOp
Int16GtOp :: PrimOp
Int16LeOp :: PrimOp
Int16LtOp :: PrimOp
Int16NeOp :: PrimOp
Word16Extend :: PrimOp
Word16Narrow :: PrimOp
Word16NotOp :: PrimOp
Word16AddOp :: PrimOp
Word16SubOp :: PrimOp
Word16MulOp :: PrimOp
Word16QuotOp :: PrimOp
Word16RemOp :: PrimOp
Word16QuotRemOp :: PrimOp
Word16EqOp :: PrimOp
Word16GeOp :: PrimOp
Word16GtOp :: PrimOp
Word16LeOp :: PrimOp
Word16LtOp :: PrimOp
Word16NeOp :: PrimOp
WordAddOp :: PrimOp
WordAddCOp :: PrimOp
WordSubCOp :: PrimOp
WordAdd2Op :: PrimOp
WordSubOp :: PrimOp
WordMulOp :: PrimOp
WordMul2Op :: PrimOp
WordQuotOp :: PrimOp
WordRemOp :: PrimOp
WordQuotRemOp :: PrimOp
WordQuotRem2Op :: PrimOp
AndOp :: PrimOp
OrOp :: PrimOp
XorOp :: PrimOp
NotOp :: PrimOp
SllOp :: PrimOp
SrlOp :: PrimOp
Word2IntOp :: PrimOp
WordGtOp :: PrimOp
WordGeOp :: PrimOp
WordEqOp :: PrimOp
WordNeOp :: PrimOp
WordLtOp :: PrimOp
WordLeOp :: PrimOp
PopCnt8Op :: PrimOp
PopCnt16Op :: PrimOp
PopCnt32Op :: PrimOp
PopCnt64Op :: PrimOp
PopCntOp :: PrimOp
Pdep8Op :: PrimOp
Pdep16Op :: PrimOp
Pdep32Op :: PrimOp
Pdep64Op :: PrimOp
PdepOp :: PrimOp
Pext8Op :: PrimOp
Pext16Op :: PrimOp
Pext32Op :: PrimOp
Pext64Op :: PrimOp
PextOp :: PrimOp
Clz8Op :: PrimOp
Clz16Op :: PrimOp
Clz32Op :: PrimOp
Clz64Op :: PrimOp
ClzOp :: PrimOp
Ctz8Op :: PrimOp
Ctz16Op :: PrimOp
Ctz32Op :: PrimOp
Ctz64Op :: PrimOp
CtzOp :: PrimOp
BSwap16Op :: PrimOp
BSwap32Op :: PrimOp
BSwap64Op :: PrimOp
BSwapOp :: PrimOp
Narrow8IntOp :: PrimOp
Narrow16IntOp :: PrimOp
Narrow32IntOp :: PrimOp
Narrow8WordOp :: PrimOp
Narrow16WordOp :: PrimOp
Narrow32WordOp :: PrimOp
DoubleGtOp :: PrimOp
DoubleGeOp :: PrimOp
DoubleEqOp :: PrimOp
DoubleNeOp :: PrimOp
DoubleLtOp :: PrimOp
DoubleLeOp :: PrimOp
DoubleAddOp :: PrimOp
DoubleSubOp :: PrimOp
DoubleMulOp :: PrimOp
DoubleDivOp :: PrimOp
DoubleNegOp :: PrimOp
DoubleFabsOp :: PrimOp
Double2IntOp :: PrimOp
Double2FloatOp :: PrimOp
DoubleExpOp :: PrimOp
DoubleLogOp :: PrimOp
DoubleSqrtOp :: PrimOp
DoubleSinOp :: PrimOp
DoubleCosOp :: PrimOp
DoubleTanOp :: PrimOp
DoubleAsinOp :: PrimOp
DoubleAcosOp :: PrimOp
DoubleAtanOp :: PrimOp
DoubleSinhOp :: PrimOp
DoubleCoshOp :: PrimOp
DoubleTanhOp :: PrimOp
DoubleAsinhOp :: PrimOp
DoubleAcoshOp :: PrimOp
DoubleAtanhOp :: PrimOp
DoublePowerOp :: PrimOp
DoubleDecode_2IntOp :: PrimOp
DoubleDecode_Int64Op :: PrimOp
FloatGtOp :: PrimOp
FloatGeOp :: PrimOp
FloatEqOp :: PrimOp
FloatNeOp :: PrimOp
FloatLtOp :: PrimOp
FloatLeOp :: PrimOp
FloatAddOp :: PrimOp
FloatSubOp :: PrimOp
FloatMulOp :: PrimOp
FloatDivOp :: PrimOp
FloatNegOp :: PrimOp
FloatFabsOp :: PrimOp
Float2IntOp :: PrimOp
FloatExpOp :: PrimOp
FloatLogOp :: PrimOp
FloatSqrtOp :: PrimOp
FloatSinOp :: PrimOp
FloatCosOp :: PrimOp
FloatTanOp :: PrimOp
FloatAsinOp :: PrimOp
FloatAcosOp :: PrimOp
FloatAtanOp :: PrimOp
FloatSinhOp :: PrimOp
FloatCoshOp :: PrimOp
FloatTanhOp :: PrimOp
FloatAsinhOp :: PrimOp
FloatAcoshOp :: PrimOp
FloatAtanhOp :: PrimOp
FloatPowerOp :: PrimOp
Float2DoubleOp :: PrimOp
FloatDecode_IntOp :: PrimOp
NewArrayOp :: PrimOp
SameMutableArrayOp :: PrimOp
ReadArrayOp :: PrimOp
WriteArrayOp :: PrimOp
SizeofArrayOp :: PrimOp
SizeofMutableArrayOp :: PrimOp
IndexArrayOp :: PrimOp
UnsafeFreezeArrayOp :: PrimOp
UnsafeThawArrayOp :: PrimOp
CopyArrayOp :: PrimOp
CopyMutableArrayOp :: PrimOp
CloneArrayOp :: PrimOp
CloneMutableArrayOp :: PrimOp
FreezeArrayOp :: PrimOp
ThawArrayOp :: PrimOp
CasArrayOp :: PrimOp
NewSmallArrayOp :: PrimOp
SameSmallMutableArrayOp :: PrimOp
ReadSmallArrayOp :: PrimOp
WriteSmallArrayOp :: PrimOp
SizeofSmallArrayOp :: PrimOp
SizeofSmallMutableArrayOp :: PrimOp
IndexSmallArrayOp :: PrimOp
UnsafeFreezeSmallArrayOp :: PrimOp
UnsafeThawSmallArrayOp :: PrimOp
CopySmallArrayOp :: PrimOp
CopySmallMutableArrayOp :: PrimOp
CloneSmallArrayOp :: PrimOp
CloneSmallMutableArrayOp :: PrimOp
FreezeSmallArrayOp :: PrimOp
ThawSmallArrayOp :: PrimOp
CasSmallArrayOp :: PrimOp
NewByteArrayOp_Char :: PrimOp
NewPinnedByteArrayOp_Char :: PrimOp
NewAlignedPinnedByteArrayOp_Char :: PrimOp
MutableByteArrayIsPinnedOp :: PrimOp
ByteArrayIsPinnedOp :: PrimOp
ByteArrayContents_Char :: PrimOp
SameMutableByteArrayOp :: PrimOp
ShrinkMutableByteArrayOp_Char :: PrimOp
ResizeMutableByteArrayOp_Char :: PrimOp
UnsafeFreezeByteArrayOp :: PrimOp
SizeofByteArrayOp :: PrimOp
SizeofMutableByteArrayOp :: PrimOp
GetSizeofMutableByteArrayOp :: PrimOp
IndexByteArrayOp_Char :: PrimOp
IndexByteArrayOp_WideChar :: PrimOp
IndexByteArrayOp_Int :: PrimOp
IndexByteArrayOp_Word :: PrimOp
IndexByteArrayOp_Addr :: PrimOp
IndexByteArrayOp_Float :: PrimOp
IndexByteArrayOp_Double :: PrimOp
IndexByteArrayOp_StablePtr :: PrimOp
IndexByteArrayOp_Int8 :: PrimOp
IndexByteArrayOp_Int16 :: PrimOp
IndexByteArrayOp_Int32 :: PrimOp
IndexByteArrayOp_Int64 :: PrimOp
IndexByteArrayOp_Word8 :: PrimOp
IndexByteArrayOp_Word16 :: PrimOp
IndexByteArrayOp_Word32 :: PrimOp
IndexByteArrayOp_Word64 :: PrimOp
IndexByteArrayOp_Word8AsChar :: PrimOp
IndexByteArrayOp_Word8AsWideChar :: PrimOp
IndexByteArrayOp_Word8AsAddr :: PrimOp
IndexByteArrayOp_Word8AsFloat :: PrimOp
IndexByteArrayOp_Word8AsDouble :: PrimOp
IndexByteArrayOp_Word8AsStablePtr :: PrimOp
IndexByteArrayOp_Word8AsInt16 :: PrimOp
IndexByteArrayOp_Word8AsInt32 :: PrimOp
IndexByteArrayOp_Word8AsInt64 :: PrimOp
IndexByteArrayOp_Word8AsInt :: PrimOp
IndexByteArrayOp_Word8AsWord16 :: PrimOp
IndexByteArrayOp_Word8AsWord32 :: PrimOp
IndexByteArrayOp_Word8AsWord64 :: PrimOp
IndexByteArrayOp_Word8AsWord :: PrimOp
ReadByteArrayOp_Char :: PrimOp
ReadByteArrayOp_WideChar :: PrimOp
ReadByteArrayOp_Int :: PrimOp
ReadByteArrayOp_Word :: PrimOp
ReadByteArrayOp_Addr :: PrimOp
ReadByteArrayOp_Float :: PrimOp
ReadByteArrayOp_Double :: PrimOp
ReadByteArrayOp_StablePtr :: PrimOp
ReadByteArrayOp_Int8 :: PrimOp
ReadByteArrayOp_Int16 :: PrimOp
ReadByteArrayOp_Int32 :: PrimOp
ReadByteArrayOp_Int64 :: PrimOp
ReadByteArrayOp_Word8 :: PrimOp
ReadByteArrayOp_Word16 :: PrimOp
ReadByteArrayOp_Word32 :: PrimOp
ReadByteArrayOp_Word64 :: PrimOp
ReadByteArrayOp_Word8AsChar :: PrimOp
ReadByteArrayOp_Word8AsWideChar :: PrimOp
ReadByteArrayOp_Word8AsAddr :: PrimOp
ReadByteArrayOp_Word8AsFloat :: PrimOp
ReadByteArrayOp_Word8AsDouble :: PrimOp
ReadByteArrayOp_Word8AsStablePtr :: PrimOp
ReadByteArrayOp_Word8AsInt16 :: PrimOp
ReadByteArrayOp_Word8AsInt32 :: PrimOp
ReadByteArrayOp_Word8AsInt64 :: PrimOp
ReadByteArrayOp_Word8AsInt :: PrimOp
ReadByteArrayOp_Word8AsWord16 :: PrimOp
ReadByteArrayOp_Word8AsWord32 :: PrimOp
ReadByteArrayOp_Word8AsWord64 :: PrimOp
ReadByteArrayOp_Word8AsWord :: PrimOp
WriteByteArrayOp_Char :: PrimOp
WriteByteArrayOp_WideChar :: PrimOp
WriteByteArrayOp_Int :: PrimOp
WriteByteArrayOp_Word :: PrimOp
WriteByteArrayOp_Addr :: PrimOp
WriteByteArrayOp_Float :: PrimOp
WriteByteArrayOp_Double :: PrimOp
WriteByteArrayOp_StablePtr :: PrimOp
WriteByteArrayOp_Int8 :: PrimOp
WriteByteArrayOp_Int16 :: PrimOp
WriteByteArrayOp_Int32 :: PrimOp
WriteByteArrayOp_Int64 :: PrimOp
WriteByteArrayOp_Word8 :: PrimOp
WriteByteArrayOp_Word16 :: PrimOp
WriteByteArrayOp_Word32 :: PrimOp
WriteByteArrayOp_Word64 :: PrimOp
WriteByteArrayOp_Word8AsChar :: PrimOp
WriteByteArrayOp_Word8AsWideChar :: PrimOp
WriteByteArrayOp_Word8AsAddr :: PrimOp
WriteByteArrayOp_Word8AsFloat :: PrimOp
WriteByteArrayOp_Word8AsDouble :: PrimOp
WriteByteArrayOp_Word8AsStablePtr :: PrimOp
WriteByteArrayOp_Word8AsInt16 :: PrimOp
WriteByteArrayOp_Word8AsInt32 :: PrimOp
WriteByteArrayOp_Word8AsInt64 :: PrimOp
WriteByteArrayOp_Word8AsInt :: PrimOp
WriteByteArrayOp_Word8AsWord16 :: PrimOp
WriteByteArrayOp_Word8AsWord32 :: PrimOp
WriteByteArrayOp_Word8AsWord64 :: PrimOp
WriteByteArrayOp_Word8AsWord :: PrimOp
CompareByteArraysOp :: PrimOp
CopyByteArrayOp :: PrimOp
CopyMutableByteArrayOp :: PrimOp
CopyByteArrayToAddrOp :: PrimOp
CopyMutableByteArrayToAddrOp :: PrimOp
CopyAddrToByteArrayOp :: PrimOp
SetByteArrayOp :: PrimOp
AtomicReadByteArrayOp_Int :: PrimOp
AtomicWriteByteArrayOp_Int :: PrimOp
CasByteArrayOp_Int :: PrimOp
FetchAddByteArrayOp_Int :: PrimOp
FetchSubByteArrayOp_Int :: PrimOp
FetchAndByteArrayOp_Int :: PrimOp
FetchNandByteArrayOp_Int :: PrimOp
FetchOrByteArrayOp_Int :: PrimOp
FetchXorByteArrayOp_Int :: PrimOp
NewArrayArrayOp :: PrimOp
SameMutableArrayArrayOp :: PrimOp
UnsafeFreezeArrayArrayOp :: PrimOp
SizeofArrayArrayOp :: PrimOp
SizeofMutableArrayArrayOp :: PrimOp
IndexArrayArrayOp_ByteArray :: PrimOp
IndexArrayArrayOp_ArrayArray :: PrimOp
ReadArrayArrayOp_ByteArray :: PrimOp
ReadArrayArrayOp_MutableByteArray :: PrimOp
ReadArrayArrayOp_ArrayArray :: PrimOp
ReadArrayArrayOp_MutableArrayArray :: PrimOp
WriteArrayArrayOp_ByteArray :: PrimOp
WriteArrayArrayOp_MutableByteArray :: PrimOp
WriteArrayArrayOp_ArrayArray :: PrimOp
WriteArrayArrayOp_MutableArrayArray :: PrimOp
CopyArrayArrayOp :: PrimOp
CopyMutableArrayArrayOp :: PrimOp
AddrAddOp :: PrimOp
AddrSubOp :: PrimOp
AddrRemOp :: PrimOp
Addr2IntOp :: PrimOp
Int2AddrOp :: PrimOp
AddrGtOp :: PrimOp
AddrGeOp :: PrimOp
AddrEqOp :: PrimOp
AddrNeOp :: PrimOp
AddrLtOp :: PrimOp
AddrLeOp :: PrimOp
IndexOffAddrOp_Char :: PrimOp
IndexOffAddrOp_WideChar :: PrimOp
IndexOffAddrOp_Int :: PrimOp
IndexOffAddrOp_Word :: PrimOp
IndexOffAddrOp_Addr :: PrimOp
IndexOffAddrOp_Float :: PrimOp
IndexOffAddrOp_Double :: PrimOp
IndexOffAddrOp_StablePtr :: PrimOp
IndexOffAddrOp_Int8 :: PrimOp
IndexOffAddrOp_Int16 :: PrimOp
IndexOffAddrOp_Int32 :: PrimOp
IndexOffAddrOp_Int64 :: PrimOp
IndexOffAddrOp_Word8 :: PrimOp
IndexOffAddrOp_Word16 :: PrimOp
IndexOffAddrOp_Word32 :: PrimOp
IndexOffAddrOp_Word64 :: PrimOp
ReadOffAddrOp_Char :: PrimOp
ReadOffAddrOp_WideChar :: PrimOp
ReadOffAddrOp_Int :: PrimOp
ReadOffAddrOp_Word :: PrimOp
ReadOffAddrOp_Addr :: PrimOp
ReadOffAddrOp_Float :: PrimOp
ReadOffAddrOp_Double :: PrimOp
ReadOffAddrOp_StablePtr :: PrimOp
ReadOffAddrOp_Int8 :: PrimOp
ReadOffAddrOp_Int16 :: PrimOp
ReadOffAddrOp_Int32 :: PrimOp
ReadOffAddrOp_Int64 :: PrimOp
ReadOffAddrOp_Word8 :: PrimOp
ReadOffAddrOp_Word16 :: PrimOp
ReadOffAddrOp_Word32 :: PrimOp
ReadOffAddrOp_Word64 :: PrimOp
WriteOffAddrOp_Char :: PrimOp
WriteOffAddrOp_WideChar :: PrimOp
WriteOffAddrOp_Int :: PrimOp
WriteOffAddrOp_Word :: PrimOp
WriteOffAddrOp_Addr :: PrimOp
WriteOffAddrOp_Float :: PrimOp
WriteOffAddrOp_Double :: PrimOp
WriteOffAddrOp_StablePtr :: PrimOp
WriteOffAddrOp_Int8 :: PrimOp
WriteOffAddrOp_Int16 :: PrimOp
WriteOffAddrOp_Int32 :: PrimOp
WriteOffAddrOp_Int64 :: PrimOp
WriteOffAddrOp_Word8 :: PrimOp
WriteOffAddrOp_Word16 :: PrimOp
WriteOffAddrOp_Word32 :: PrimOp
WriteOffAddrOp_Word64 :: PrimOp
NewMutVarOp :: PrimOp
ReadMutVarOp :: PrimOp
WriteMutVarOp :: PrimOp
SameMutVarOp :: PrimOp
AtomicModifyMutVar2Op :: PrimOp
AtomicModifyMutVar_Op :: PrimOp
CasMutVarOp :: PrimOp
CatchOp :: PrimOp
RaiseOp :: PrimOp
RaiseIOOp :: PrimOp
MaskAsyncExceptionsOp :: PrimOp
MaskUninterruptibleOp :: PrimOp
UnmaskAsyncExceptionsOp :: PrimOp
MaskStatus :: PrimOp
AtomicallyOp :: PrimOp
RetryOp :: PrimOp
CatchRetryOp :: PrimOp
CatchSTMOp :: PrimOp
NewTVarOp :: PrimOp
ReadTVarOp :: PrimOp
ReadTVarIOOp :: PrimOp
WriteTVarOp :: PrimOp
SameTVarOp :: PrimOp
NewMVarOp :: PrimOp
TakeMVarOp :: PrimOp
TryTakeMVarOp :: PrimOp
PutMVarOp :: PrimOp
TryPutMVarOp :: PrimOp
ReadMVarOp :: PrimOp
TryReadMVarOp :: PrimOp
SameMVarOp :: PrimOp
IsEmptyMVarOp :: PrimOp
DelayOp :: PrimOp
WaitReadOp :: PrimOp
WaitWriteOp :: PrimOp
ForkOp :: PrimOp
ForkOnOp :: PrimOp
KillThreadOp :: PrimOp
YieldOp :: PrimOp
MyThreadIdOp :: PrimOp
LabelThreadOp :: PrimOp
IsCurrentThreadBoundOp :: PrimOp
NoDuplicateOp :: PrimOp
ThreadStatusOp :: PrimOp
MkWeakOp :: PrimOp
MkWeakNoFinalizerOp :: PrimOp
AddCFinalizerToWeakOp :: PrimOp
DeRefWeakOp :: PrimOp
FinalizeWeakOp :: PrimOp
TouchOp :: PrimOp
MakeStablePtrOp :: PrimOp
DeRefStablePtrOp :: PrimOp
EqStablePtrOp :: PrimOp
MakeStableNameOp :: PrimOp
EqStableNameOp :: PrimOp
StableNameToIntOp :: PrimOp
CompactNewOp :: PrimOp
CompactResizeOp :: PrimOp
CompactContainsOp :: PrimOp
CompactContainsAnyOp :: PrimOp
CompactGetFirstBlockOp :: PrimOp
CompactGetNextBlockOp :: PrimOp
CompactAllocateBlockOp :: PrimOp
CompactFixupPointersOp :: PrimOp
CompactAdd :: PrimOp
CompactAddWithSharing :: PrimOp
CompactSize :: PrimOp
ReallyUnsafePtrEqualityOp :: PrimOp
ParOp :: PrimOp
SparkOp :: PrimOp
SeqOp :: PrimOp
GetSparkOp :: PrimOp
NumSparks :: PrimOp
DataToTagOp :: PrimOp
TagToEnumOp :: PrimOp
AddrToAnyOp :: PrimOp
AnyToAddrOp :: PrimOp
MkApUpd0_Op :: PrimOp
NewBCOOp :: PrimOp
UnpackClosureOp :: PrimOp
GetApStackValOp :: PrimOp
GetCCSOfOp :: PrimOp
GetCurrentCCSOp :: PrimOp
ClearCCSOp :: PrimOp
TraceEventOp :: PrimOp
TraceEventBinaryOp :: PrimOp
TraceMarkerOp :: PrimOp
GetThreadAllocationCounter :: PrimOp
SetThreadAllocationCounter :: PrimOp
VecBroadcastOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecPackOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecUnpackOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecInsertOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecAddOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecSubOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecMulOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecDivOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecQuotOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecRemOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecNegOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteScalarByteArrayOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecIndexScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecReadScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
VecWriteScalarOffAddrOp :: PrimOpVecCat -> Length -> Width -> PrimOp
PrefetchByteArrayOp3 :: PrimOp
PrefetchMutableByteArrayOp3 :: PrimOp
PrefetchAddrOp3 :: PrimOp
PrefetchValueOp3 :: PrimOp
PrefetchByteArrayOp2 :: PrimOp
PrefetchMutableByteArrayOp2 :: PrimOp
PrefetchAddrOp2 :: PrimOp
PrefetchValueOp2 :: PrimOp
PrefetchByteArrayOp1 :: PrimOp
PrefetchMutableByteArrayOp1 :: PrimOp
PrefetchAddrOp1 :: PrimOp
PrefetchValueOp1 :: PrimOp
PrefetchByteArrayOp0 :: PrimOp
PrefetchMutableByteArrayOp0 :: PrimOp
PrefetchAddrOp0 :: PrimOp
PrefetchValueOp0 :: PrimOp
data PrimOpVecCat
IntVec :: PrimOpVecCat
WordVec :: PrimOpVecCat
FloatVec :: PrimOpVecCat
allThePrimOps :: [PrimOp]
primOpType :: PrimOp -> Type
primOpSig :: PrimOp -> ([TyVar], [Type], Type, Arity, StrictSig)
primOpTag :: PrimOp -> Int
maxPrimOpTag :: Int
primOpOcc :: PrimOp -> OccName
tagToEnumKey :: Unique
primOpOutOfLine :: PrimOp -> Bool
primOpCodeSize :: PrimOp -> Int
primOpOkForSpeculation :: PrimOp -> Bool
primOpOkForSideEffects :: PrimOp -> Bool
primOpIsCheap :: PrimOp -> Bool
primOpFixity :: PrimOp -> Maybe Fixity
getPrimOpResultInfo :: PrimOp -> PrimOpResultInfo
isComparisonPrimOp :: PrimOp -> Bool
data PrimOpResultInfo
ReturnsPrim :: PrimRep -> PrimOpResultInfo
ReturnsAlg :: TyCon -> PrimOpResultInfo
data PrimCall
PrimCall :: CLabelString -> UnitId -> PrimCall
instance Outputable.Outputable PrimOp.PrimCall
instance GHC.Classes.Eq PrimOp.PrimOp
instance GHC.Classes.Ord PrimOp.PrimOp
instance Outputable.Outputable PrimOp.PrimOp


-- | The Name Cache
module NameCache
lookupOrigNameCache :: OrigNameCache -> Module -> OccName -> Maybe Name
extendOrigNameCache :: OrigNameCache -> Name -> OrigNameCache
extendNameCache :: OrigNameCache -> Module -> OccName -> Name -> OrigNameCache

-- | Return a function to atomically update the name cache.
initNameCache :: UniqSupply -> [Name] -> NameCache

-- | The NameCache makes sure that there is just one Unique assigned for
--   each original name; i.e. (module-name, occ-name) pair and provides
--   something of a lookup mechanism for those names.
data NameCache
NameCache :: !UniqSupply -> !OrigNameCache -> NameCache

-- | Supply of uniques
[nsUniqs] :: NameCache -> !UniqSupply

-- | Ensures that one original name gets one unique
[nsNames] :: NameCache -> !OrigNameCache

-- | Per-module cache of original <a>OccName</a>s given <a>Name</a>s
type OrigNameCache = ModuleEnv (OccEnv Name)


-- | This is where we define a mapping from Uniques to their associated
--   known-key Names for things associated with tuples and sums. We use
--   this mapping while deserializing known-key Names in interface file
--   symbol tables, which are encoded as their Unique. See Note [Symbol
--   table representation of names] for details.
module KnownUniques

-- | Get the <a>Name</a> associated with a known-key <a>Unique</a>.
knownUniqueName :: Unique -> Maybe Name
mkSumTyConUnique :: Arity -> Unique
mkSumDataConUnique :: ConTagZ -> Arity -> Unique
mkTupleTyConUnique :: Boxity -> Arity -> Unique
mkTupleDataConUnique :: Boxity -> Arity -> Unique
mkCTupleTyConUnique :: Arity -> Unique
mkCTupleDataConUnique :: Arity -> Unique

module InteractiveEvalTypes
data Resume
Resume :: String -> ForeignRef (ResumeContext [HValueRef]) -> ([TyThing], GlobalRdrEnv) -> [Id] -> ForeignHValue -> Maybe BreakInfo -> SrcSpan -> String -> RemotePtr CostCentreStack -> [History] -> Int -> Resume
[resumeStmt] :: Resume -> String
[resumeContext] :: Resume -> ForeignRef (ResumeContext [HValueRef])
[resumeBindings] :: Resume -> ([TyThing], GlobalRdrEnv)
[resumeFinalIds] :: Resume -> [Id]
[resumeApStack] :: Resume -> ForeignHValue
[resumeBreakInfo] :: Resume -> Maybe BreakInfo
[resumeSpan] :: Resume -> SrcSpan
[resumeDecl] :: Resume -> String
[resumeCCS] :: Resume -> RemotePtr CostCentreStack
[resumeHistory] :: Resume -> [History]
[resumeHistoryIx] :: Resume -> Int
data History
History :: ForeignHValue -> BreakInfo -> [String] -> History
[historyApStack] :: History -> ForeignHValue
[historyBreakInfo] :: History -> BreakInfo
[historyEnclosingDecls] :: History -> [String]
data ExecResult
ExecComplete :: Either SomeException [Name] -> Word64 -> ExecResult
[execResult] :: ExecResult -> Either SomeException [Name]
[execAllocation] :: ExecResult -> Word64
ExecBreak :: [Name] -> Maybe BreakInfo -> ExecResult
[breakNames] :: ExecResult -> [Name]
[breakInfo] :: ExecResult -> Maybe BreakInfo
data SingleStep
RunToCompletion :: SingleStep
SingleStep :: SingleStep
RunAndLogSteps :: SingleStep
isStep :: SingleStep -> Bool
data ExecOptions
ExecOptions :: SingleStep -> String -> Int -> (ForeignHValue -> EvalExpr ForeignHValue) -> ExecOptions

-- | stepping mode
[execSingleStep] :: ExecOptions -> SingleStep

-- | filename (for errors)
[execSourceFile] :: ExecOptions -> String

-- | line number (for errors)
[execLineNumber] :: ExecOptions -> Int
[execWrap] :: ExecOptions -> ForeignHValue -> EvalExpr ForeignHValue
data BreakInfo
BreakInfo :: Module -> Int -> BreakInfo
[breakInfo_module] :: BreakInfo -> Module
[breakInfo_number] :: BreakInfo -> Int

module HsTypes

-- | Haskell Type
data HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnForall</a>,
--   <a>AnnDot</a>,<a>AnnDarrow</a> For details on above see note [Api
--   annotations] in ApiAnnotation</li>
--   </ul>
HsForAllTy :: XForAllTy pass -> [LHsTyVarBndr pass] -> LHsType pass -> HsType pass
[hst_xforall] :: HsType pass -> XForAllTy pass
[hst_bndrs] :: HsType pass -> [LHsTyVarBndr pass]
[hst_body] :: HsType pass -> LHsType pass
HsQualTy :: XQualTy pass -> LHsContext pass -> LHsType pass -> HsType pass
[hst_xqual] :: HsType pass -> XQualTy pass
[hst_ctxt] :: HsType pass -> LHsContext pass
[hst_body] :: HsType pass -> LHsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsTyVar :: XTyVar pass -> PromotionFlag -> Located (IdP pass) -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsAppTy :: XAppTy pass -> LHsType pass -> LHsType pass -> HsType pass
HsAppKindTy :: XAppKindTy pass -> LHsType pass -> LHsKind pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a>,</li>
--   </ul>
HsFunTy :: XFunTy pass -> LHsType pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
HsListTy :: XListTy pass -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(' or '(#'</tt>,
--   <a>AnnClose</a> <tt>')' or '#)'</tt></li>
--   </ul>
HsTupleTy :: XTupleTy pass -> HsTupleSort -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnClose</a> '#)'@</li>
--   </ul>
HsSumTy :: XSumTy pass -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsOpTy :: XOpTy pass -> LHsType pass -> Located (IdP pass) -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
HsParTy :: XParTy pass -> LHsType pass -> HsType pass

-- | <pre>
--   (?x :: ty)
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
HsIParamTy :: XIParamTy pass -> Located HsIPName -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsStarTy :: XStarTy pass -> Bool -> HsType pass

-- | <pre>
--   (ty :: kind)
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>,
--   <a>AnnDcolon</a>,<a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsKindSig :: XKindSig pass -> LHsType pass -> LHsKind pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'$('</tt>,
--   <a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsSpliceTy :: XSpliceTy pass -> HsSplice pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsDocTy :: XDocTy pass -> LHsType pass -> LHsDocString -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# UNPACK' or '{-#
--   NOUNPACK'</tt>, <a>AnnClose</a> <tt>'#-}'</tt> <a>AnnBang</a>
--   <tt>'!'</tt></li>
--   </ul>
HsBangTy :: XBangTy pass -> HsSrcBang -> LHsType pass -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{'</tt>, <a>AnnClose</a>
--   <tt>'}'</tt></li>
--   </ul>
HsRecTy :: XRecTy pass -> [LConDeclField pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>"'["</tt>,
--   <a>AnnClose</a> <tt>']'</tt></li>
--   </ul>
HsExplicitListTy :: XExplicitListTy pass -> PromotionFlag -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>"'("</tt>,
--   <a>AnnClose</a> <tt>')'</tt></li>
--   </ul>
HsExplicitTupleTy :: XExplicitTupleTy pass -> [LHsType pass] -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsTyLit :: XTyLit pass -> HsTyLit -> HsType pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : None</li>
--   </ul>
HsWildCardTy :: XWildCardTy pass -> HsType pass
XHsType :: XXType pass -> HsType pass
data NewHsTypeX
NHsCoreTy :: Type -> NewHsTypeX

-- | Located Haskell Type
type LHsType pass = Located (HsType pass) " May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma' when in a list"

-- | Haskell Kind
type HsKind pass = HsType pass

-- | Located Haskell Kind
type LHsKind pass = Located (HsKind pass) " 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnDcolon'"

-- | Haskell Type Variable Binder
data HsTyVarBndr pass
UserTyVar :: XUserTyVar pass -> Located (IdP pass) -> HsTyVarBndr pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnDcolon</a>,
--   <a>AnnClose</a></li>
--   </ul>
KindedTyVar :: XKindedTyVar pass -> Located (IdP pass) -> LHsKind pass -> HsTyVarBndr pass
XTyVarBndr :: XXTyVarBndr pass -> HsTyVarBndr pass

-- | Located Haskell Type Variable Binder
type LHsTyVarBndr pass = Located (HsTyVarBndr pass)

-- | Located Haskell Quantified Type Variables
data LHsQTyVars pass
HsQTvs :: XHsQTvs pass -> [LHsTyVarBndr pass] -> LHsQTyVars pass
[hsq_ext] :: LHsQTyVars pass -> XHsQTvs pass
[hsq_explicit] :: LHsQTyVars pass -> [LHsTyVarBndr pass]
XLHsQTyVars :: XXLHsQTyVars pass -> LHsQTyVars pass
data HsQTvsRn
HsQTvsRn :: [Name] -> NameSet -> HsQTvsRn
[hsq_implicit] :: HsQTvsRn -> [Name]
[hsq_dependent] :: HsQTvsRn -> NameSet

-- | Haskell Implicit Binders
data HsImplicitBndrs pass thing
HsIB :: XHsIB pass thing -> thing -> HsImplicitBndrs pass thing
[hsib_ext] :: HsImplicitBndrs pass thing -> XHsIB pass thing
[hsib_body] :: HsImplicitBndrs pass thing -> thing
XHsImplicitBndrs :: XXHsImplicitBndrs pass thing -> HsImplicitBndrs pass thing

-- | Haskell Wildcard Binders
data HsWildCardBndrs pass thing
HsWC :: XHsWC pass thing -> thing -> HsWildCardBndrs pass thing
[hswc_ext] :: HsWildCardBndrs pass thing -> XHsWC pass thing
[hswc_body] :: HsWildCardBndrs pass thing -> thing
XHsWildCardBndrs :: XXHsWildCardBndrs pass thing -> HsWildCardBndrs pass thing

-- | Located Haskell Signature Type
type LHsSigType pass = HsImplicitBndrs pass (LHsType pass)

-- | Located Haskell Signature Wildcard Type
type LHsSigWcType pass = HsWildCardBndrs pass (LHsSigType pass)

-- | Located Haskell Wildcard Type
type LHsWcType pass = HsWildCardBndrs pass (LHsType pass)

-- | Haskell Tuple Sort
data HsTupleSort
HsUnboxedTuple :: HsTupleSort
HsBoxedTuple :: HsTupleSort
HsConstraintTuple :: HsTupleSort
HsBoxedOrConstraintTuple :: HsTupleSort

-- | Haskell Context
type HsContext pass = [LHsType pass]

-- | Located Haskell Context
type LHsContext pass = Located (HsContext pass) " 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnUnit' For details on above see note [Api annotations] in ApiAnnotation"
noLHsContext :: LHsContext pass

-- | Haskell Type Literal
data HsTyLit
HsNumTy :: SourceText -> Integer -> HsTyLit
HsStrTy :: SourceText -> FastString -> HsTyLit

-- | These names are used early on to store the names of implicit
--   parameters. They completely disappear after type-checking.
newtype HsIPName
HsIPName :: FastString -> HsIPName
hsIPNameFS :: HsIPName -> FastString
data HsArg tm ty
HsValArg :: tm -> HsArg tm ty
HsTypeArg :: SrcSpan -> ty -> HsArg tm ty
HsArgPar :: SrcSpan -> HsArg tm ty
numVisibleArgs :: [HsArg tm ty] -> Arity
type LHsTypeArg p = HsArg (LHsType p) (LHsKind p)

-- | Located Bang Type
type LBangType pass = Located (BangType pass)

-- | Bang Type
type BangType pass = HsType pass

-- | Haskell Source Bang
--   
--   Bangs on data constructor arguments as the user wrote them in the
--   source code.
--   
--   <tt>(HsSrcBang _ SrcUnpack SrcLazy)</tt> and <tt>(HsSrcBang _
--   SrcUnpack NoSrcStrict)</tt> (without StrictData) makes no sense, we
--   emit a warning (in checkValidDataCon) and treat it like <tt>(HsSrcBang
--   _ NoSrcUnpack SrcLazy)</tt>
data HsSrcBang
HsSrcBang :: SourceText -> SrcUnpackedness -> SrcStrictness -> HsSrcBang

-- | Haskell Implementation Bang
--   
--   Bangs of data constructor arguments as generated by the compiler after
--   consulting HsSrcBang, flags, etc.
data HsImplBang

-- | Lazy field, or one with an unlifted type
HsLazy :: HsImplBang

-- | Strict but not unpacked field
HsStrict :: HsImplBang

-- | Strict and unpacked field co :: arg-ty ~ product-ty HsBang
HsUnpack :: Maybe Coercion -> HsImplBang

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie '~'
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {--} specified
SrcUnpack :: SrcUnpackedness

-- | {--} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness
getBangType :: LHsType a -> LHsType a
getBangStrictness :: LHsType a -> HsSrcBang

-- | Constructor Declaration Field
data ConDeclField pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
ConDeclField :: XConDeclField pass -> [LFieldOcc pass] -> LBangType pass -> Maybe LHsDocString -> ConDeclField pass
[cd_fld_ext] :: ConDeclField pass -> XConDeclField pass

-- | See Note [ConDeclField passs]
[cd_fld_names] :: ConDeclField pass -> [LFieldOcc pass]
[cd_fld_type] :: ConDeclField pass -> LBangType pass
[cd_fld_doc] :: ConDeclField pass -> Maybe LHsDocString
XConDeclField :: XXConDeclField pass -> ConDeclField pass

-- | Located Constructor Declaration Field
type LConDeclField pass = Located (ConDeclField pass) " May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma' when in a list"
pprConDeclFields :: OutputableBndrId (GhcPass p) => [LConDeclField (GhcPass p)] -> SDoc

-- | Haskell Constructor Details
data HsConDetails arg rec
PrefixCon :: [arg] -> HsConDetails arg rec
RecCon :: rec -> HsConDetails arg rec
InfixCon :: arg -> arg -> HsConDetails arg rec

-- | Field Occurrence
--   
--   Represents an *occurrence* of an unambiguous field. We store both the
--   <a>RdrName</a> the user originally wrote, and after the renamer, the
--   selector function.
data FieldOcc pass
FieldOcc :: XCFieldOcc pass -> Located RdrName -> FieldOcc pass
[extFieldOcc] :: FieldOcc pass -> XCFieldOcc pass

-- | See Note [Located RdrNames] in HsExpr
[rdrNameFieldOcc] :: FieldOcc pass -> Located RdrName
XFieldOcc :: XXFieldOcc pass -> FieldOcc pass

-- | Located Field Occurrence
type LFieldOcc pass = Located (FieldOcc pass)
mkFieldOcc :: Located RdrName -> FieldOcc GhcPs

-- | Ambiguous Field Occurrence
--   
--   Represents an *occurrence* of a field that is potentially ambiguous
--   after the renamer, with the ambiguity resolved by the typechecker. We
--   always store the <a>RdrName</a> that the user originally wrote, and
--   store the selector function after the renamer (for unambiguous
--   occurrences) or the typechecker (for ambiguous occurrences).
--   
--   See Note [HsRecField and HsRecUpdField] in HsPat and Note
--   [Disambiguating record fields] in TcExpr. See Note [Located RdrNames]
--   in HsExpr
data AmbiguousFieldOcc pass
Unambiguous :: XUnambiguous pass -> Located RdrName -> AmbiguousFieldOcc pass
Ambiguous :: XAmbiguous pass -> Located RdrName -> AmbiguousFieldOcc pass
XAmbiguousFieldOcc :: XXAmbiguousFieldOcc pass -> AmbiguousFieldOcc pass
mkAmbiguousFieldOcc :: Located RdrName -> AmbiguousFieldOcc GhcPs
rdrNameAmbiguousFieldOcc :: AmbiguousFieldOcc (GhcPass p) -> RdrName
selectorAmbiguousFieldOcc :: AmbiguousFieldOcc GhcTc -> Id
unambiguousFieldOcc :: AmbiguousFieldOcc GhcTc -> FieldOcc GhcTc
ambiguousFieldOcc :: FieldOcc GhcTc -> AmbiguousFieldOcc GhcTc
mkAnonWildCardTy :: HsType GhcPs
pprAnonWildCard :: SDoc
mkHsImplicitBndrs :: thing -> HsImplicitBndrs GhcPs thing
mkHsWildCardBndrs :: thing -> HsWildCardBndrs GhcPs thing
hsImplicitBody :: HsImplicitBndrs pass thing -> thing
mkEmptyImplicitBndrs :: thing -> HsImplicitBndrs GhcRn thing
mkEmptyWildCardBndrs :: thing -> HsWildCardBndrs GhcRn thing
mkHsQTvs :: [LHsTyVarBndr GhcPs] -> LHsQTyVars GhcPs
hsQTvExplicit :: LHsQTyVars pass -> [LHsTyVarBndr pass]
emptyLHsQTvs :: LHsQTyVars GhcRn
isEmptyLHsQTvs :: LHsQTyVars GhcRn -> Bool

-- | Does this <a>HsTyVarBndr</a> come with an explicit kind annotation?
isHsKindedTyVar :: HsTyVarBndr pass -> Bool

-- | Do all type variables in this <a>LHsQTyVars</a> come with kind
--   annotations?
hsTvbAllKinded :: LHsQTyVars pass -> Bool
isLHsForAllTy :: LHsType p -> Bool
hsScopedTvs :: LHsSigType GhcRn -> [Name]
hsWcScopedTvs :: LHsSigWcType GhcRn -> [Name]
dropWildCards :: LHsSigWcType pass -> LHsSigType pass
hsTyVarName :: HsTyVarBndr pass -> IdP pass
hsAllLTyVarNames :: LHsQTyVars GhcRn -> [Name]
hsLTyVarLocNames :: LHsQTyVars pass -> [Located (IdP pass)]
hsLTyVarName :: LHsTyVarBndr pass -> IdP pass
hsLTyVarLocName :: LHsTyVarBndr pass -> Located (IdP pass)
hsExplicitLTyVarNames :: LHsQTyVars pass -> [IdP pass]
splitLHsInstDeclTy :: LHsSigType GhcRn -> ([Name], LHsContext GhcRn, LHsType GhcRn)
getLHsInstDeclHead :: LHsSigType pass -> LHsType pass
getLHsInstDeclClass_maybe :: LHsSigType (GhcPass p) -> Maybe (Located (IdP (GhcPass p)))
splitLHsPatSynTy :: LHsType pass -> ([LHsTyVarBndr pass], LHsContext pass, [LHsTyVarBndr pass], LHsContext pass, LHsType pass)
splitLHsForAllTy :: LHsType pass -> ([LHsTyVarBndr pass], LHsType pass)
splitLHsQualTy :: LHsType pass -> (LHsContext pass, LHsType pass)
splitLHsSigmaTy :: LHsType pass -> ([LHsTyVarBndr pass], LHsContext pass, LHsType pass)
splitHsFunType :: LHsType GhcRn -> ([LHsType GhcRn], LHsType GhcRn)
splitHsAppTys :: HsType GhcRn -> (LHsType GhcRn, [LHsTypeArg GhcRn])
hsTyGetAppHead_maybe :: LHsType (GhcPass p) -> Maybe (Located (IdP (GhcPass p)))
mkHsOpTy :: LHsType (GhcPass p) -> Located (IdP (GhcPass p)) -> LHsType (GhcPass p) -> HsType (GhcPass p)
mkHsAppTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
mkHsAppTys :: LHsType (GhcPass p) -> [LHsType (GhcPass p)] -> LHsType (GhcPass p)
mkHsAppKindTy :: XAppKindTy (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
ignoreParens :: LHsType pass -> LHsType pass
hsSigType :: LHsSigType pass -> LHsType pass
hsSigWcType :: LHsSigWcType pass -> LHsType pass

-- | Convert a LHsTyVarBndr to an equivalent LHsType.
hsLTyVarBndrToType :: LHsTyVarBndr (GhcPass p) -> LHsType (GhcPass p)

-- | Convert a LHsTyVarBndrs to a list of types. Works on *type* variable
--   only, no kind vars.
hsLTyVarBndrsToTypes :: LHsQTyVars (GhcPass p) -> [LHsType (GhcPass p)]
pprHsType :: OutputableBndrId (GhcPass p) => HsType (GhcPass p) -> SDoc

-- | Prints a forall; When passed an empty list, prints <tt>forall.</tt>
--   only when <tt>-dppr-debug</tt>
pprHsForAll :: OutputableBndrId (GhcPass p) => [LHsTyVarBndr (GhcPass p)] -> LHsContext (GhcPass p) -> SDoc

-- | Version of <a>pprHsForAll</a> that can also print an extra-constraints
--   wildcard, e.g. <tt>_ =&gt; a -&gt; Bool</tt> or <tt>(Show a, _) =&gt;
--   a -&gt; String</tt>. This underscore will be printed when the 'Maybe
--   SrcSpan' argument is a <a>Just</a> containing the location of the
--   extra-constraints wildcard. A special function for this is needed, as
--   the extra-constraints wildcard is removed from the actual context and
--   type, and stored in a separate field, thus just printing the type will
--   not print the extra-constraints wildcard.
pprHsForAllExtra :: OutputableBndrId (GhcPass p) => Maybe SrcSpan -> [LHsTyVarBndr (GhcPass p)] -> LHsContext (GhcPass p) -> SDoc

-- | Version of <tt>pprHsForall</tt> or <tt>pprHsForallExtra</tt> that will
--   always print <tt>forall.</tt> when passed <tt>Just []</tt>. Prints
--   nothing if passed <a>Nothing</a>
pprHsExplicitForAll :: OutputableBndrId (GhcPass p) => Maybe [LHsTyVarBndr (GhcPass p)] -> SDoc
pprLHsContext :: OutputableBndrId (GhcPass p) => LHsContext (GhcPass p) -> SDoc

-- | <tt><a>hsTypeNeedsParens</a> p t</tt> returns <a>True</a> if the type
--   <tt>t</tt> needs parentheses under precedence <tt>p</tt>.
hsTypeNeedsParens :: PprPrec -> HsType pass -> Bool

-- | <tt><a>parenthesizeHsType</a> p ty</tt> checks if
--   <tt><a>hsTypeNeedsParens</a> p ty</tt> is true, and if so, surrounds
--   <tt>ty</tt> with an <a>HsParTy</a>. Otherwise, it simply returns
--   <tt>ty</tt>.
parenthesizeHsType :: PprPrec -> LHsType (GhcPass p) -> LHsType (GhcPass p)

-- | <tt><a>parenthesizeHsContext</a> p ctxt</tt> checks if <tt>ctxt</tt>
--   is a single constraint <tt>c</tt> such that
--   <tt><a>hsTypeNeedsParens</a> p c</tt> is true, and if so, surrounds
--   <tt>c</tt> with an <a>HsParTy</a> to form a parenthesized
--   <tt>ctxt</tt>. Otherwise, it simply returns <tt>ctxt</tt> unchanged.
parenthesizeHsContext :: PprPrec -> LHsContext (GhcPass p) -> LHsContext (GhcPass p)
instance (Data.Data.Data arg, Data.Data.Data rec) => Data.Data.Data (HsTypes.HsConDetails arg rec)
instance Data.Data.Data HsTypes.HsTupleSort
instance Data.Data.Data HsTypes.HsTyLit
instance Data.Data.Data HsTypes.NewHsTypeX
instance Data.Data.Data HsTypes.HsIPName
instance GHC.Classes.Eq HsTypes.HsIPName
instance Data.Data.Data HsTypes.HsQTvsRn
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, GHC.Classes.Eq (HsExtension.XCFieldOcc p)) => GHC.Classes.Eq (HsTypes.FieldOcc p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, GHC.Classes.Ord (HsExtension.XCFieldOcc p)) => GHC.Classes.Ord (HsTypes.FieldOcc p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass) => Outputable.Outputable (HsTypes.AmbiguousFieldOcc p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass) => Outputable.OutputableBndr (HsTypes.AmbiguousFieldOcc p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsTypes.LHsQTyVars p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsTypes.ConDeclField p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsTypes.HsType p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsTypes.HsTyVarBndr p)
instance Outputable.Outputable (HsTypes.FieldOcc pass)
instance (Outputable.Outputable tm, Outputable.Outputable ty) => Outputable.Outputable (HsTypes.HsArg tm ty)
instance (Outputable.Outputable arg, Outputable.Outputable rec) => Outputable.Outputable (HsTypes.HsConDetails arg rec)
instance Outputable.Outputable HsTypes.HsTyLit
instance Outputable.Outputable HsTypes.NewHsTypeX
instance Outputable.Outputable HsTypes.HsIPName
instance Outputable.OutputableBndr HsTypes.HsIPName
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, Outputable.Outputable thing) => Outputable.Outputable (HsTypes.HsWildCardBndrs p thing)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, Outputable.Outputable thing) => Outputable.Outputable (HsTypes.HsImplicitBndrs p thing)


-- | Bytecode assembler types
module ByteCodeTypes
data CompiledByteCode
CompiledByteCode :: [UnlinkedBCO] -> ItblEnv -> [FFIInfo] -> [RemotePtr ()] -> Maybe ModBreaks -> CompiledByteCode
[bc_bcos] :: CompiledByteCode -> [UnlinkedBCO]
[bc_itbls] :: CompiledByteCode -> ItblEnv
[bc_ffis] :: CompiledByteCode -> [FFIInfo]
[bc_strs] :: CompiledByteCode -> [RemotePtr ()]
[bc_breaks] :: CompiledByteCode -> Maybe ModBreaks
seqCompiledByteCode :: CompiledByteCode -> ()
newtype FFIInfo
FFIInfo :: RemotePtr C_ffi_cif -> FFIInfo
data UnlinkedBCO
UnlinkedBCO :: !Name -> {-# UNPACK #-} !Int -> !UArray Int Word16 -> !UArray Int Word64 -> !SizedSeq BCONPtr -> !SizedSeq BCOPtr -> UnlinkedBCO
[unlinkedBCOName] :: UnlinkedBCO -> !Name
[unlinkedBCOArity] :: UnlinkedBCO -> {-# UNPACK #-} !Int
[unlinkedBCOInstrs] :: UnlinkedBCO -> !UArray Int Word16
[unlinkedBCOBitmap] :: UnlinkedBCO -> !UArray Int Word64
[unlinkedBCOLits] :: UnlinkedBCO -> !SizedSeq BCONPtr
[unlinkedBCOPtrs] :: UnlinkedBCO -> !SizedSeq BCOPtr
data BCOPtr
BCOPtrName :: !Name -> BCOPtr
BCOPtrPrimOp :: !PrimOp -> BCOPtr
BCOPtrBCO :: !UnlinkedBCO -> BCOPtr
BCOPtrBreakArray :: BCOPtr
data BCONPtr
BCONPtrWord :: {-# UNPACK #-} !Word -> BCONPtr
BCONPtrLbl :: !FastString -> BCONPtr
BCONPtrItbl :: !Name -> BCONPtr
BCONPtrStr :: !ByteString -> BCONPtr
type ItblEnv = NameEnv (Name, ItblPtr)
newtype ItblPtr
ItblPtr :: RemotePtr StgInfoTable -> ItblPtr

-- | Information about a breakpoint that we know at code-generation time
data CgBreakInfo
CgBreakInfo :: [(Id, Word16)] -> Type -> CgBreakInfo
[cgb_vars] :: CgBreakInfo -> [(Id, Word16)]
[cgb_resty] :: CgBreakInfo -> Type

-- | All the information about the breakpoints for a module
data ModBreaks
ModBreaks :: ForeignRef BreakArray -> !Array BreakIndex SrcSpan -> !Array BreakIndex [OccName] -> !Array BreakIndex [String] -> !Array BreakIndex (RemotePtr CostCentre) -> IntMap CgBreakInfo -> ModBreaks

-- | The array of flags, one per breakpoint, indicating which breakpoints
--   are enabled.
[modBreaks_flags] :: ModBreaks -> ForeignRef BreakArray

-- | An array giving the source span of each breakpoint.
[modBreaks_locs] :: ModBreaks -> !Array BreakIndex SrcSpan

-- | An array giving the names of the free variables at each breakpoint.
[modBreaks_vars] :: ModBreaks -> !Array BreakIndex [OccName]

-- | An array giving the names of the declarations enclosing each
--   breakpoint.
[modBreaks_decls] :: ModBreaks -> !Array BreakIndex [String]

-- | Array pointing to cost centre for each breakpoint
[modBreaks_ccs] :: ModBreaks -> !Array BreakIndex (RemotePtr CostCentre)

-- | info about each breakpoint from the bytecode generator
[modBreaks_breakInfo] :: ModBreaks -> IntMap CgBreakInfo

-- | Breakpoint index
type BreakIndex = Int

-- | Construct an empty ModBreaks
emptyModBreaks :: ModBreaks

-- | C CostCentre type
data CCostCentre
instance Control.DeepSeq.NFData ByteCodeTypes.ItblPtr
instance GHC.Show.Show ByteCodeTypes.ItblPtr
instance Control.DeepSeq.NFData ByteCodeTypes.FFIInfo
instance GHC.Show.Show ByteCodeTypes.FFIInfo
instance Outputable.Outputable ByteCodeTypes.CompiledByteCode
instance Outputable.Outputable ByteCodeTypes.CgBreakInfo
instance Control.DeepSeq.NFData ByteCodeTypes.UnlinkedBCO
instance Control.DeepSeq.NFData ByteCodeTypes.BCOPtr
instance Outputable.Outputable ByteCodeTypes.UnlinkedBCO
instance Control.DeepSeq.NFData ByteCodeTypes.BCONPtr


-- | Functions to computing the statistics reflective of the "size" of a
--   Core expression
module CoreStats
coreBindsSize :: [CoreBind] -> Int

-- | A measure of the size of the expressions, strictly greater than 0
--   Counts *leaves*, not internal nodes. Types and coercions are not
--   counted.
exprSize :: CoreExpr -> Int
data CoreStats
CS :: !Int -> !Int -> !Int -> !Int -> !Int -> CoreStats
[cs_tm] :: CoreStats -> !Int
[cs_ty] :: CoreStats -> !Int
[cs_co] :: CoreStats -> !Int
[cs_vb] :: CoreStats -> !Int
[cs_jb] :: CoreStats -> !Int
coreBindsStats :: [CoreBind] -> CoreStats
exprStats :: CoreExpr -> CoreStats
instance Outputable.Outputable CoreStats.CoreStats

module PprCore
pprCoreExpr :: OutputableBndr b => Expr b -> SDoc
pprParendExpr :: OutputableBndr b => Expr b -> SDoc
pprCoreBinding :: OutputableBndr b => Bind b -> SDoc
pprCoreBindings :: OutputableBndr b => [Bind b] -> SDoc
pprCoreAlt :: OutputableBndr a => (AltCon, [a], Expr a) -> SDoc
pprCoreBindingWithSize :: CoreBind -> SDoc
pprCoreBindingsWithSize :: [CoreBind] -> SDoc
pprRules :: [CoreRule] -> SDoc
pprOptCo :: Coercion -> SDoc
instance Outputable.OutputableBndr b => Outputable.Outputable (CoreSyn.Bind b)
instance Outputable.OutputableBndr b => Outputable.Outputable (CoreSyn.Expr b)
instance Outputable.OutputableBndr Var.Var
instance Outputable.Outputable b => Outputable.OutputableBndr (CoreSyn.TaggedBndr b)
instance Outputable.Outputable CoreSyn.UnfoldingGuidance
instance Outputable.Outputable CoreSyn.UnfoldingSource
instance Outputable.Outputable CoreSyn.Unfolding
instance Outputable.Outputable CoreSyn.CoreRule
instance Outputable.Outputable id => Outputable.Outputable (CoreSyn.Tickish id)

module IfaceSyn
data IfaceDecl
IfaceId :: IfaceTopBndr -> IfaceType -> IfaceIdDetails -> IfaceIdInfo -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifType] :: IfaceDecl -> IfaceType
[ifIdDetails] :: IfaceDecl -> IfaceIdDetails
[ifIdInfo] :: IfaceDecl -> IfaceIdInfo
IfaceData :: IfaceTopBndr -> [IfaceTyConBinder] -> IfaceType -> Maybe CType -> [Role] -> IfaceContext -> IfaceConDecls -> Bool -> IfaceTyConParent -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceType
[ifCType] :: IfaceDecl -> Maybe CType
[ifRoles] :: IfaceDecl -> [Role]
[ifCtxt] :: IfaceDecl -> IfaceContext
[ifCons] :: IfaceDecl -> IfaceConDecls
[ifGadtSyntax] :: IfaceDecl -> Bool
[ifParent] :: IfaceDecl -> IfaceTyConParent
IfaceSynonym :: IfaceTopBndr -> [Role] -> [IfaceTyConBinder] -> IfaceKind -> IfaceType -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifRoles] :: IfaceDecl -> [Role]
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceKind
[ifSynRhs] :: IfaceDecl -> IfaceType
IfaceFamily :: IfaceTopBndr -> Maybe IfLclName -> [IfaceTyConBinder] -> IfaceKind -> IfaceFamTyConFlav -> Injectivity -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifResVar] :: IfaceDecl -> Maybe IfLclName
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifResKind] :: IfaceDecl -> IfaceKind
[ifFamFlav] :: IfaceDecl -> IfaceFamTyConFlav
[ifFamInj] :: IfaceDecl -> Injectivity
IfaceClass :: IfaceTopBndr -> [Role] -> [IfaceTyConBinder] -> [FunDep IfLclName] -> IfaceClassBody -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifRoles] :: IfaceDecl -> [Role]
[ifBinders] :: IfaceDecl -> [IfaceTyConBinder]
[ifFDs] :: IfaceDecl -> [FunDep IfLclName]
[ifBody] :: IfaceDecl -> IfaceClassBody
IfaceAxiom :: IfaceTopBndr -> IfaceTyCon -> Role -> [IfaceAxBranch] -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifTyCon] :: IfaceDecl -> IfaceTyCon
[ifRole] :: IfaceDecl -> Role
[ifAxBranches] :: IfaceDecl -> [IfaceAxBranch]
IfacePatSyn :: IfaceTopBndr -> Bool -> (IfExtName, Bool) -> Maybe (IfExtName, Bool) -> [IfaceForAllBndr] -> [IfaceForAllBndr] -> IfaceContext -> IfaceContext -> [IfaceType] -> IfaceType -> [FieldLabel] -> IfaceDecl
[ifName] :: IfaceDecl -> IfaceTopBndr
[ifPatIsInfix] :: IfaceDecl -> Bool
[ifPatMatcher] :: IfaceDecl -> (IfExtName, Bool)
[ifPatBuilder] :: IfaceDecl -> Maybe (IfExtName, Bool)
[ifPatUnivBndrs] :: IfaceDecl -> [IfaceForAllBndr]
[ifPatExBndrs] :: IfaceDecl -> [IfaceForAllBndr]
[ifPatProvCtxt] :: IfaceDecl -> IfaceContext
[ifPatReqCtxt] :: IfaceDecl -> IfaceContext
[ifPatArgs] :: IfaceDecl -> [IfaceType]
[ifPatTy] :: IfaceDecl -> IfaceType
[ifFieldLabels] :: IfaceDecl -> [FieldLabel]
data IfaceFamTyConFlav
IfaceDataFamilyTyCon :: IfaceFamTyConFlav
IfaceOpenSynFamilyTyCon :: IfaceFamTyConFlav

-- | Name of associated axiom and branches for pretty printing purposes, or
--   <a>Nothing</a> for an empty closed family without an axiom See Note
--   [Pretty printing via IfaceSyn] in PprTyThing
IfaceClosedSynFamilyTyCon :: Maybe (IfExtName, [IfaceAxBranch]) -> IfaceFamTyConFlav
IfaceAbstractClosedSynFamilyTyCon :: IfaceFamTyConFlav
IfaceBuiltInSynFamTyCon :: IfaceFamTyConFlav
data IfaceClassOp
IfaceClassOp :: IfaceTopBndr -> IfaceType -> Maybe (DefMethSpec IfaceType) -> IfaceClassOp
data IfaceAT
IfaceAT :: IfaceDecl -> Maybe IfaceType -> IfaceAT
data IfaceConDecl
IfCon :: IfaceTopBndr -> Bool -> Bool -> [IfaceBndr] -> [IfaceForAllBndr] -> IfaceEqSpec -> IfaceContext -> [IfaceType] -> [FieldLabel] -> [IfaceBang] -> [IfaceSrcBang] -> IfaceConDecl
[ifConName] :: IfaceConDecl -> IfaceTopBndr
[ifConWrapper] :: IfaceConDecl -> Bool
[ifConInfix] :: IfaceConDecl -> Bool
[ifConExTCvs] :: IfaceConDecl -> [IfaceBndr]
[ifConUserTvBinders] :: IfaceConDecl -> [IfaceForAllBndr]
[ifConEqSpec] :: IfaceConDecl -> IfaceEqSpec
[ifConCtxt] :: IfaceConDecl -> IfaceContext
[ifConArgTys] :: IfaceConDecl -> [IfaceType]
[ifConFields] :: IfaceConDecl -> [FieldLabel]
[ifConStricts] :: IfaceConDecl -> [IfaceBang]
[ifConSrcStricts] :: IfaceConDecl -> [IfaceSrcBang]
data IfaceConDecls
IfAbstractTyCon :: IfaceConDecls
IfDataTyCon :: [IfaceConDecl] -> IfaceConDecls
IfNewTyCon :: IfaceConDecl -> IfaceConDecls
type IfaceEqSpec = [(IfLclName, IfaceType)]
data IfaceExpr
IfaceLcl :: IfLclName -> IfaceExpr
IfaceExt :: IfExtName -> IfaceExpr
IfaceType :: IfaceType -> IfaceExpr
IfaceCo :: IfaceCoercion -> IfaceExpr
IfaceTuple :: TupleSort -> [IfaceExpr] -> IfaceExpr
IfaceLam :: IfaceLamBndr -> IfaceExpr -> IfaceExpr
IfaceApp :: IfaceExpr -> IfaceExpr -> IfaceExpr
IfaceCase :: IfaceExpr -> IfLclName -> [IfaceAlt] -> IfaceExpr
IfaceECase :: IfaceExpr -> IfaceType -> IfaceExpr
IfaceLet :: IfaceBinding -> IfaceExpr -> IfaceExpr
IfaceCast :: IfaceExpr -> IfaceCoercion -> IfaceExpr
IfaceLit :: Literal -> IfaceExpr
IfaceFCall :: ForeignCall -> IfaceType -> IfaceExpr
IfaceTick :: IfaceTickish -> IfaceExpr -> IfaceExpr
type IfaceAlt = (IfaceConAlt, [IfLclName], IfaceExpr)
data IfaceLetBndr
IfLetBndr :: IfLclName -> IfaceType -> IfaceIdInfo -> IfaceJoinInfo -> IfaceLetBndr
data IfaceJoinInfo
IfaceNotJoinPoint :: IfaceJoinInfo
IfaceJoinPoint :: JoinArity -> IfaceJoinInfo
data IfaceBinding
IfaceNonRec :: IfaceLetBndr -> IfaceExpr -> IfaceBinding
IfaceRec :: [(IfaceLetBndr, IfaceExpr)] -> IfaceBinding
data IfaceConAlt
IfaceDefault :: IfaceConAlt
IfaceDataAlt :: IfExtName -> IfaceConAlt
IfaceLitAlt :: Literal -> IfaceConAlt
data IfaceIdInfo
NoInfo :: IfaceIdInfo
HasInfo :: [IfaceInfoItem] -> IfaceIdInfo
data IfaceIdDetails
IfVanillaId :: IfaceIdDetails
IfRecSelId :: Either IfaceTyCon IfaceDecl -> Bool -> IfaceIdDetails
IfDFunId :: IfaceIdDetails
data IfaceUnfolding
IfCoreUnfold :: Bool -> IfaceExpr -> IfaceUnfolding
IfCompulsory :: IfaceExpr -> IfaceUnfolding
IfInlineRule :: Arity -> Bool -> Bool -> IfaceExpr -> IfaceUnfolding
IfDFunUnfold :: [IfaceBndr] -> [IfaceExpr] -> IfaceUnfolding
data IfaceInfoItem
HsArity :: Arity -> IfaceInfoItem
HsStrictness :: StrictSig -> IfaceInfoItem
HsInline :: InlinePragma -> IfaceInfoItem
HsUnfold :: Bool -> IfaceUnfolding -> IfaceInfoItem
HsNoCafRefs :: IfaceInfoItem
HsLevity :: IfaceInfoItem
data IfaceRule
IfaceRule :: RuleName -> Activation -> [IfaceBndr] -> IfExtName -> [IfaceExpr] -> IfaceExpr -> Bool -> IsOrphan -> IfaceRule
[ifRuleName] :: IfaceRule -> RuleName
[ifActivation] :: IfaceRule -> Activation
[ifRuleBndrs] :: IfaceRule -> [IfaceBndr]
[ifRuleHead] :: IfaceRule -> IfExtName
[ifRuleArgs] :: IfaceRule -> [IfaceExpr]
[ifRuleRhs] :: IfaceRule -> IfaceExpr
[ifRuleAuto] :: IfaceRule -> Bool
[ifRuleOrph] :: IfaceRule -> IsOrphan
data IfaceAnnotation
IfaceAnnotation :: IfaceAnnTarget -> AnnPayload -> IfaceAnnotation
[ifAnnotatedTarget] :: IfaceAnnotation -> IfaceAnnTarget
[ifAnnotatedValue] :: IfaceAnnotation -> AnnPayload
type IfaceAnnTarget = AnnTarget OccName
data IfaceClsInst
IfaceClsInst :: IfExtName -> [Maybe IfaceTyCon] -> IfExtName -> OverlapFlag -> IsOrphan -> IfaceClsInst
[ifInstCls] :: IfaceClsInst -> IfExtName
[ifInstTys] :: IfaceClsInst -> [Maybe IfaceTyCon]
[ifDFun] :: IfaceClsInst -> IfExtName
[ifOFlag] :: IfaceClsInst -> OverlapFlag
[ifInstOrph] :: IfaceClsInst -> IsOrphan
data IfaceFamInst
IfaceFamInst :: IfExtName -> [Maybe IfaceTyCon] -> IfExtName -> IsOrphan -> IfaceFamInst
[ifFamInstFam] :: IfaceFamInst -> IfExtName
[ifFamInstTys] :: IfaceFamInst -> [Maybe IfaceTyCon]
[ifFamInstAxiom] :: IfaceFamInst -> IfExtName
[ifFamInstOrph] :: IfaceFamInst -> IsOrphan
data IfaceTickish
IfaceHpcTick :: Module -> Int -> IfaceTickish
IfaceSCC :: CostCentre -> Bool -> Bool -> IfaceTickish
IfaceSource :: RealSrcSpan -> String -> IfaceTickish
data IfaceClassBody
IfAbstractClass :: IfaceClassBody
IfConcreteClass :: IfaceContext -> [IfaceAT] -> [IfaceClassOp] -> BooleanFormula IfLclName -> IfaceClassBody
[ifClassCtxt] :: IfaceClassBody -> IfaceContext
[ifATs] :: IfaceClassBody -> [IfaceAT]
[ifSigs] :: IfaceClassBody -> [IfaceClassOp]
[ifMinDef] :: IfaceClassBody -> BooleanFormula IfLclName

-- | This corresponds to an HsImplBang; that is, the final implementation
--   decision about the data constructor arg
data IfaceBang
IfNoBang :: IfaceBang
IfStrict :: IfaceBang
IfUnpack :: IfaceBang
IfUnpackCo :: IfaceCoercion -> IfaceBang

-- | This corresponds to HsSrcBang
data IfaceSrcBang
IfSrcBang :: SrcUnpackedness -> SrcStrictness -> IfaceSrcBang

-- | Source Unpackedness
--   
--   What unpackedness the user requested
data SrcUnpackedness

-- | {--} specified
SrcUnpack :: SrcUnpackedness

-- | {--} specified
SrcNoUnpack :: SrcUnpackedness

-- | no unpack pragma
NoSrcUnpack :: SrcUnpackedness

-- | Source Strictness
--   
--   What strictness annotation the user wrote
data SrcStrictness

-- | Lazy, ie '~'
SrcLazy :: SrcStrictness

-- | Strict, ie <tt>!</tt>
SrcStrict :: SrcStrictness

-- | no strictness annotation
NoSrcStrict :: SrcStrictness
data IfaceAxBranch
IfaceAxBranch :: [IfaceTvBndr] -> [IfaceTvBndr] -> [IfaceIdBndr] -> IfaceAppArgs -> [Role] -> IfaceType -> [BranchIndex] -> IfaceAxBranch
[ifaxbTyVars] :: IfaceAxBranch -> [IfaceTvBndr]
[ifaxbEtaTyVars] :: IfaceAxBranch -> [IfaceTvBndr]
[ifaxbCoVars] :: IfaceAxBranch -> [IfaceIdBndr]
[ifaxbLHS] :: IfaceAxBranch -> IfaceAppArgs
[ifaxbRoles] :: IfaceAxBranch -> [Role]
[ifaxbRHS] :: IfaceAxBranch -> IfaceType
[ifaxbIncomps] :: IfaceAxBranch -> [BranchIndex]
data IfaceTyConParent
IfNoParent :: IfaceTyConParent
IfDataInstance :: IfExtName -> IfaceTyCon -> IfaceAppArgs -> IfaceTyConParent
data IfaceCompleteMatch
IfaceCompleteMatch :: [IfExtName] -> IfExtName -> IfaceCompleteMatch

-- | A binding top-level <a>Name</a> in an interface file (e.g. the name of
--   an <a>IfaceDecl</a>).
type IfaceTopBndr = Name
putIfaceTopBndr :: BinHandle -> IfaceTopBndr -> IO ()
getIfaceTopBndr :: BinHandle -> IO IfaceTopBndr
ifaceDeclImplicitBndrs :: IfaceDecl -> [OccName]
visibleIfConDecls :: IfaceConDecls -> [IfaceConDecl]
ifaceDeclFingerprints :: Fingerprint -> IfaceDecl -> [(OccName, Fingerprint)]
freeNamesIfDecl :: IfaceDecl -> NameSet
freeNamesIfRule :: IfaceRule -> NameSet
freeNamesIfFamInst :: IfaceFamInst -> NameSet

-- | Pretty Print an IfaceExpre
--   
--   The first argument should be a function that adds parens in context
--   that need an atomic value (e.g. function args)
pprIfaceExpr :: (SDoc -> SDoc) -> IfaceExpr -> SDoc
pprIfaceDecl :: ShowSub -> IfaceDecl -> SDoc
newtype AltPpr
AltPpr :: Maybe (OccName -> SDoc) -> AltPpr
data ShowSub
ShowSub :: ShowHowMuch -> ShowForAllFlag -> ShowSub
[ss_how_much] :: ShowSub -> ShowHowMuch
[ss_forall] :: ShowSub -> ShowForAllFlag
data ShowHowMuch

-- | Header information only, not rhs
ShowHeader :: AltPpr -> ShowHowMuch

-- | Show only some sub-components. Specifically,
--   
--   <ul>
--   <li><i>@[</i> @] Print all sub-components.</li>
--   <li><i><tt>(n:ns)</tt></i> Print sub-component <tt>n</tt> with
--   <tt>ShowSub = ns</tt>; elide other sub-components to <tt>...</tt> May
--   14: the list is max 1 element long at the moment</li>
--   </ul>
ShowSome :: [OccName] -> AltPpr -> ShowHowMuch

-- | Everything including GHC-internal information (used in --show-iface)
ShowIface :: ShowHowMuch
showToIface :: ShowSub
showToHeader :: ShowSub
instance Outputable.Outputable IfaceSyn.ShowHowMuch
instance Outputable.Outputable IfaceSyn.IfaceRule
instance Binary.Binary IfaceSyn.IfaceRule
instance Name.NamedThing IfaceSyn.IfaceDecl
instance OccName.HasOccName IfaceSyn.IfaceDecl
instance Outputable.Outputable IfaceSyn.IfaceDecl
instance Outputable.Outputable IfaceSyn.IfaceAT
instance Outputable.Outputable IfaceSyn.IfaceIdDetails
instance Binary.Binary IfaceSyn.IfaceDecl
instance Binary.Binary IfaceSyn.IfaceAT
instance Binary.Binary IfaceSyn.IfaceIdDetails
instance Outputable.Outputable IfaceSyn.IfaceExpr
instance Outputable.Outputable IfaceSyn.IfaceIdInfo
instance Outputable.Outputable IfaceSyn.IfaceInfoItem
instance Outputable.Outputable IfaceSyn.IfaceUnfolding
instance Binary.Binary IfaceSyn.IfaceIdInfo
instance Binary.Binary IfaceSyn.IfaceInfoItem
instance Binary.Binary IfaceSyn.IfaceUnfolding
instance Binary.Binary IfaceSyn.IfaceExpr
instance Binary.Binary IfaceSyn.IfaceBinding
instance Binary.Binary IfaceSyn.IfaceLetBndr
instance Outputable.Outputable IfaceSyn.IfaceJoinInfo
instance Binary.Binary IfaceSyn.IfaceJoinInfo
instance Outputable.Outputable IfaceSyn.IfaceConAlt
instance Binary.Binary IfaceSyn.IfaceConAlt
instance Binary.Binary IfaceSyn.IfaceTickish
instance Outputable.Outputable IfaceSyn.IfaceCompleteMatch
instance Binary.Binary IfaceSyn.IfaceCompleteMatch
instance Outputable.Outputable IfaceSyn.IfaceAnnotation
instance Binary.Binary IfaceSyn.IfaceAnnotation
instance Outputable.Outputable IfaceSyn.IfaceFamInst
instance Binary.Binary IfaceSyn.IfaceFamInst
instance Outputable.Outputable IfaceSyn.IfaceClsInst
instance Binary.Binary IfaceSyn.IfaceClsInst
instance Binary.Binary IfaceSyn.IfaceConDecls
instance Name.NamedThing IfaceSyn.IfaceConDecl
instance OccName.HasOccName IfaceSyn.IfaceConDecl
instance Binary.Binary IfaceSyn.IfaceConDecl
instance Binary.Binary IfaceSyn.IfaceSrcBang
instance Binary.Binary IfaceSyn.IfaceBang
instance Binary.Binary IfaceSyn.IfaceFamTyConFlav
instance Binary.Binary IfaceSyn.IfaceAxBranch
instance Name.NamedThing IfaceSyn.IfaceClassOp
instance OccName.HasOccName IfaceSyn.IfaceClassOp
instance Outputable.Outputable IfaceSyn.IfaceClassOp
instance Binary.Binary IfaceSyn.IfaceClassOp
instance Outputable.Outputable IfaceSyn.IfaceTyConParent
instance Binary.Binary IfaceSyn.IfaceTyConParent


-- | Various utilities for forcing Core structures
--   
--   It can often be useful to force various parts of the AST. This module
--   provides a number of <tt>seq</tt>-like functions to accomplish this.
module CoreSeq
seqExpr :: CoreExpr -> ()
seqExprs :: [CoreExpr] -> ()
seqUnfolding :: Unfolding -> ()
seqRules :: [CoreRule] -> ()

-- | Evaluate all the fields of the <a>IdInfo</a> that are generally
--   demanded by the compiler
megaSeqIdInfo :: IdInfo -> ()
seqRuleInfo :: RuleInfo -> ()
seqBinds :: [Bind CoreBndr] -> ()

module CoreMap

-- | <tt>CoreMap a</tt> is a map from <a>CoreExpr</a> to <tt>a</tt>. If you
--   are a client, this is the type you want.
data CoreMap a
emptyCoreMap :: CoreMap a
extendCoreMap :: CoreMap a -> CoreExpr -> a -> CoreMap a
lookupCoreMap :: CoreMap a -> CoreExpr -> Maybe a
foldCoreMap :: (a -> b -> b) -> b -> CoreMap a -> b

-- | <tt>TypeMap a</tt> is a map from <a>Expr</a> to <tt>a</tt>. If you are
--   a client, this is the type you want. The keys in this map may have
--   different kinds.
data TypeMap a
emptyTypeMap :: TypeMap a
extendTypeMap :: TypeMap a -> Type -> a -> TypeMap a
lookupTypeMap :: TypeMap a -> Type -> Maybe a
foldTypeMap :: (a -> b -> b) -> b -> TypeMap a -> b

-- | A <a>LooseTypeMap</a> doesn't do a kind-check. Thus, when lookup up (t
--   |&gt; g), you'll find entries inserted under (t), even if (g) is
--   non-reflexive.
data LooseTypeMap a
data CmEnv
lookupCME :: CmEnv -> Var -> Maybe BoundVar

-- | Extend a <a>TypeMap</a> with a type in the given context.
--   <tt>extendTypeMapWithScope m (mkDeBruijnContext [a,b,c]) t v</tt> is
--   equivalent to <tt>extendTypeMap m (forall a b c. t) v</tt>, but allows
--   reuse of the context over multiple insertions.
extendTypeMapWithScope :: TypeMap a -> CmEnv -> Type -> a -> TypeMap a
lookupTypeMapWithScope :: TypeMap a -> CmEnv -> Type -> Maybe a

-- | Construct a deBruijn environment with the given variables in scope.
--   e.g. <tt>mkDeBruijnEnv [a,b,c]</tt> constructs a context <tt>forall a
--   b c.</tt>
mkDeBruijnContext :: [Var] -> CmEnv
data MaybeMap m a
data ListMap m a
type LiteralMap a = Map Literal a
data GenMap m a
class TrieMap m where {
    type family Key m :: *;
}
emptyTM :: TrieMap m => m a
lookupTM :: forall b. TrieMap m => Key m -> m b -> Maybe b
alterTM :: forall b. TrieMap m => Key m -> XT b -> m b -> m b
mapTM :: TrieMap m => (a -> b) -> m a -> m b
foldTM :: TrieMap m => (a -> b -> b) -> m a -> b -> b
insertTM :: TrieMap m => Key m -> a -> m a -> m a
deleteTM :: TrieMap m => Key m -> m a -> m a
lkDFreeVar :: Var -> DVarEnv a -> Maybe a
xtDFreeVar :: Var -> XT a -> DVarEnv a -> DVarEnv a
lkDNamed :: NamedThing n => n -> DNameEnv a -> Maybe a
xtDNamed :: NamedThing n => n -> XT a -> DNameEnv a -> DNameEnv a
(>.>) :: (a -> b) -> (b -> c) -> a -> c
infixr 1 >.>
(|>) :: a -> (a -> b) -> b
infixr 1 |>
(|>>) :: TrieMap m2 => (XT (m2 a) -> m1 (m2 a) -> m1 (m2 a)) -> (m2 a -> m2 a) -> m1 (m2 a) -> m1 (m2 a)
infixr 1 |>>
instance TrieMap.TrieMap CoreMap.CoreMap
instance Outputable.Outputable a => Outputable.Outputable (CoreMap.CoreMap a)
instance TrieMap.TrieMap CoreMap.CoreMapX
instance TrieMap.TrieMap CoreMap.AltMap
instance TrieMap.TrieMap CoreMap.CoercionMap
instance TrieMap.TrieMap CoreMap.CoercionMapX
instance TrieMap.TrieMap CoreMap.TypeMap
instance TrieMap.TrieMap CoreMap.LooseTypeMap
instance TrieMap.TrieMap CoreMap.TypeMapX
instance Outputable.Outputable a => Outputable.Outputable (CoreMap.TypeMapG a)
instance TrieMap.TrieMap CoreMap.VarMap
instance GHC.Classes.Eq (CoreMap.DeBruijn CoreSyn.CoreExpr)
instance GHC.Classes.Eq (CoreMap.DeBruijn CoreSyn.CoreAlt)
instance GHC.Classes.Eq (CoreMap.DeBruijn TyCoRep.Coercion)
instance GHC.Classes.Eq (CoreMap.DeBruijn TyCoRep.Type)
instance GHC.Classes.Eq (CoreMap.DeBruijn a) => GHC.Classes.Eq (CoreMap.DeBruijn [a])
instance TrieMap.TrieMap CoreMap.TyLitMap

module FamInstEnv
data FamInst
FamInst :: CoAxiom Unbranched -> FamFlavor -> Name -> [Maybe Name] -> [TyVar] -> [CoVar] -> [Type] -> Type -> FamInst
[fi_axiom] :: FamInst -> CoAxiom Unbranched
[fi_flavor] :: FamInst -> FamFlavor
[fi_fam] :: FamInst -> Name
[fi_tcs] :: FamInst -> [Maybe Name]
[fi_tvs] :: FamInst -> [TyVar]
[fi_cvs] :: FamInst -> [CoVar]
[fi_tys] :: FamInst -> [Type]
[fi_rhs] :: FamInst -> Type
data FamFlavor
SynFamilyInst :: FamFlavor
DataFamilyInst :: TyCon -> FamFlavor
famInstAxiom :: FamInst -> CoAxiom Unbranched
famInstTyCon :: FamInst -> TyCon
famInstRHS :: FamInst -> Type
famInstsRepTyCons :: [FamInst] -> [TyCon]
famInstRepTyCon_maybe :: FamInst -> Maybe TyCon
dataFamInstRepTyCon :: FamInst -> TyCon
pprFamInst :: FamInst -> SDoc
pprFamInsts :: [FamInst] -> SDoc
mkImportedFamInst :: Name -> [Maybe Name] -> CoAxiom Unbranched -> FamInst
type FamInstEnvs = (FamInstEnv, FamInstEnv)
type FamInstEnv = UniqDFM FamilyInstEnv
emptyFamInstEnv :: FamInstEnv
emptyFamInstEnvs :: (FamInstEnv, FamInstEnv)
extendFamInstEnv :: FamInstEnv -> FamInst -> FamInstEnv
extendFamInstEnvList :: FamInstEnv -> [FamInst] -> FamInstEnv
famInstEnvElts :: FamInstEnv -> [FamInst]
famInstEnvSize :: FamInstEnv -> Int
familyInstances :: (FamInstEnv, FamInstEnv) -> TyCon -> [FamInst]
mkCoAxBranch :: [TyVar] -> [TyVar] -> [CoVar] -> [Type] -> Type -> [Role] -> SrcSpan -> CoAxBranch
mkBranchedCoAxiom :: Name -> TyCon -> [CoAxBranch] -> CoAxiom Branched
mkUnbranchedCoAxiom :: Name -> TyCon -> CoAxBranch -> CoAxiom Unbranched
mkSingleCoAxiom :: Role -> Name -> [TyVar] -> [TyVar] -> [CoVar] -> TyCon -> [Type] -> Type -> CoAxiom Unbranched

-- | Create a coercion constructor (axiom) suitable for the given newtype
--   <a>TyCon</a>. The <a>Name</a> should be that of a new coercion
--   <a>CoAxiom</a>, the <a>TyVar</a>s the arguments expected by the
--   <tt>newtype</tt> and the type the appropriate right hand side of the
--   <tt>newtype</tt>, with the free variables a subset of those
--   <a>TyVar</a>s.
mkNewTypeCoAxiom :: Name -> TyCon -> [TyVar] -> [Role] -> Type -> CoAxiom Unbranched
data FamInstMatch
FamInstMatch :: FamInst -> [Type] -> [Coercion] -> FamInstMatch
[fim_instance] :: FamInstMatch -> FamInst
[fim_tys] :: FamInstMatch -> [Type]
[fim_cos] :: FamInstMatch -> [Coercion]
lookupFamInstEnv :: FamInstEnvs -> TyCon -> [Type] -> [FamInstMatch]
lookupFamInstEnvConflicts :: FamInstEnvs -> FamInst -> [FamInstMatch]
lookupFamInstEnvByTyCon :: FamInstEnvs -> TyCon -> [FamInst]
isDominatedBy :: CoAxBranch -> [CoAxBranch] -> Bool

-- | Do an apartness check, as described in the "Closed Type Families"
--   paper (POPL '14). This should be used when determining if an equation
--   (<a>CoAxBranch</a>) of a closed type family can be used to reduce a
--   certain target type family application.
apartnessCheck :: [Type] -> CoAxBranch -> Bool

-- | Result of testing two type family equations for injectiviy.
data InjectivityCheckResult

-- | Either RHSs are distinct or unification of RHSs leads to unification
--   of LHSs
InjectivityAccepted :: InjectivityCheckResult

-- | RHSs unify but LHSs don't unify under that substitution. Relevant for
--   closed type families where equation after unification might be
--   overlpapped (in which case it is OK if they don't unify). Constructor
--   stores axioms after unification.
InjectivityUnified :: CoAxBranch -> CoAxBranch -> InjectivityCheckResult

-- | Check whether an open type family equation can be added to already
--   existing instance environment without causing conflicts with supplied
--   injectivity annotations. Returns list of conflicting axioms (type
--   instance declarations).
lookupFamInstEnvInjectivityConflicts :: [Bool] -> FamInstEnvs -> FamInst -> [CoAxBranch]

-- | Check whether two type family axioms don't violate injectivity
--   annotation.
injectiveBranches :: [Bool] -> CoAxBranch -> CoAxBranch -> InjectivityCheckResult
topNormaliseType :: FamInstEnvs -> Type -> Type

-- | Get rid of *outermost* (or toplevel) * type function redex * data
--   family redex * newtypes returning an appropriate Representational
--   coercion. Specifically, if topNormaliseType_maybe env ty = Just (co,
--   ty') then (a) co :: ty ~R ty' (b) ty' is not a newtype, and is not a
--   type-family or data-family redex
--   
--   However, ty' can be something like (Maybe (F ty)), where (F ty) is a
--   redex.
--   
--   Always operates homogeneously: the returned type has the same kind as
--   the original type, and the returned coercion is always homogeneous.
topNormaliseType_maybe :: FamInstEnvs -> Type -> Maybe (Coercion, Type)
normaliseType :: FamInstEnvs -> Role -> Type -> (Coercion, Type)
normaliseTcApp :: FamInstEnvs -> Role -> TyCon -> [Type] -> (Coercion, Type)

-- | Normalise arguments to a tycon
normaliseTcArgs :: FamInstEnvs -> Role -> TyCon -> [Type] -> (Coercion, [Type], CoercionN)
reduceTyFamApp_maybe :: FamInstEnvs -> Role -> TyCon -> [Type] -> Maybe (Coercion, Type)
flattenTys :: InScopeSet -> [Type] -> [Type]
instance GHC.Base.Monad FamInstEnv.NormM
instance GHC.Base.Functor FamInstEnv.NormM
instance GHC.Base.Applicative FamInstEnv.NormM
instance Outputable.Outputable FamInstEnv.FamInstMatch
instance Outputable.Outputable FamInstEnv.FamilyInstEnv
instance Name.NamedThing FamInstEnv.FamInst
instance Outputable.Outputable FamInstEnv.FamInst


-- | A module concerned with finding the free variables of an expression.
module CoreFVs

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a non-deterministic set.
exprFreeVars :: CoreExpr -> VarSet

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a deterministic set.
exprFreeVarsDSet :: CoreExpr -> DVarSet

-- | Find all locally-defined free Ids or type variables in an expression
--   returning a deterministically ordered list.
exprFreeVarsList :: CoreExpr -> [Var]

-- | Find all locally-defined free Ids in an expression
exprFreeIds :: CoreExpr -> IdSet

-- | Find all locally-defined free Ids in an expression returning a
--   deterministic set.
exprFreeIdsDSet :: CoreExpr -> DIdSet

-- | Find all locally-defined free Ids in an expression returning a
--   deterministically ordered list.
exprFreeIdsList :: CoreExpr -> [Id]

-- | Find all locally-defined free Ids in several expressions returning a
--   deterministic set.
exprsFreeIdsDSet :: [CoreExpr] -> DIdSet

-- | Find all locally-defined free Ids in several expressions returning a
--   deterministically ordered list.
exprsFreeIdsList :: [CoreExpr] -> [Id]

-- | Find all locally-defined free Ids or type variables in several
--   expressions returning a non-deterministic set.
exprsFreeVars :: [CoreExpr] -> VarSet

-- | Find all locally-defined free Ids or type variables in several
--   expressions returning a deterministically ordered list.
exprsFreeVarsList :: [CoreExpr] -> [Var]

-- | Find all locally defined free Ids in a binding group
bindFreeVars :: CoreBind -> VarSet

-- | Predicate on possible free variables: returns <tt>True</tt> iff the
--   variable is interesting
type InterestingVarFun = Var -> Bool

-- | Finds free variables in an expression selected by a predicate
exprSomeFreeVars :: InterestingVarFun -> CoreExpr -> VarSet

-- | Finds free variables in several expressions selected by a predicate
exprsSomeFreeVars :: InterestingVarFun -> [CoreExpr] -> VarSet

-- | Finds free variables in an expression selected by a predicate
--   returning a deterministically ordered list.
exprSomeFreeVarsList :: InterestingVarFun -> CoreExpr -> [Var]

-- | Finds free variables in several expressions selected by a predicate
--   returning a deterministically ordered list.
exprsSomeFreeVarsList :: InterestingVarFun -> [CoreExpr] -> [Var]
varTypeTyCoVars :: Var -> TyCoVarSet
varTypeTyCoFVs :: Var -> FV
idUnfoldingVars :: Id -> VarSet
idFreeVars :: Id -> VarSet
dIdFreeVars :: Id -> DVarSet
bndrRuleAndUnfoldingVarsDSet :: Id -> DVarSet
idFVs :: Id -> FV
idRuleVars :: Id -> VarSet
idRuleRhsVars :: (Activation -> Bool) -> Id -> VarSet
stableUnfoldingVars :: Unfolding -> Maybe VarSet

-- | Those variables free in the right hand side of a rule returned as a
--   non-deterministic set
ruleRhsFreeVars :: CoreRule -> VarSet

-- | Those variables free in the both the left right hand sides of a rule
--   returned as a non-deterministic set
ruleFreeVars :: CoreRule -> VarSet

-- | Those variables free in the right hand side of several rules
rulesFreeVars :: [CoreRule] -> VarSet

-- | Those variables free in the both the left right hand sides of rules
--   returned as a deterministic set
rulesFreeVarsDSet :: [CoreRule] -> DVarSet

-- | This finds all locally-defined free Ids on the left hand side of a
--   rule and returns them as a non-deterministic set
ruleLhsFreeIds :: CoreRule -> VarSet

-- | This finds all locally-defined free Ids on the left hand side of a
--   rule and returns them as a determinisitcally ordered list
ruleLhsFreeIdsList :: CoreRule -> [Var]
expr_fvs :: CoreExpr -> FV
orphNamesOfType :: Type -> NameSet
orphNamesOfCo :: Coercion -> NameSet
orphNamesOfAxiom :: CoAxiom br -> NameSet
orphNamesOfTypes :: [Type] -> NameSet
orphNamesOfCoCon :: CoAxiom br -> NameSet

-- | Finds the free <i>external</i> names of several expressions: see
--   <a>exprOrphNames</a> for details
exprsOrphNames :: [CoreExpr] -> NameSet

-- | orphNamesOfAxiom collects the names of the concrete types and type
--   constructors that make up the LHS of a type family instance, including
--   the family name itself.
--   
--   For instance, given `type family Foo a b`: `type instance Foo (F (G (H
--   a))) b = ...` would yield [Foo,F,G,H]
--   
--   Used in the implementation of ":info" in GHCi.
orphNamesOfFamInst :: FamInst -> NameSet
type FVAnn = DVarSet

-- | Every node in an expression annotated with its (non-global) free
--   variables, both Ids and TyVars, and type. NB: see Note [The FVAnn
--   invariant]
type CoreExprWithFVs = AnnExpr Id FVAnn
type CoreExprWithFVs' = AnnExpr' Id FVAnn

-- | Every node in a binding group annotated with its (non-global) free
--   variables, both Ids and TyVars, and type.
type CoreBindWithFVs = AnnBind Id FVAnn

-- | Every node in an expression annotated with its (non-global) free
--   variables, both Ids and TyVars, and type.
type CoreAltWithFVs = AnnAlt Id FVAnn

-- | Annotate a <a>CoreExpr</a> with its (non-global) free type and value
--   variables at every tree node.
freeVars :: CoreExpr -> CoreExprWithFVs
freeVarsBind :: CoreBind -> DVarSet -> (CoreBindWithFVs, DVarSet)

-- | Inverse function to <a>freeVars</a>
freeVarsOf :: CoreExprWithFVs -> DIdSet

-- | Extract the vars reported in a FVAnn
freeVarsOfAnn :: FVAnn -> DIdSet

module TcType
type TcType = Type
type TcSigmaType = TcType
type TcRhoType = TcType
type TcTauType = TcType
type TcPredType = PredType
type TcThetaType = ThetaType

-- | Type variable that might be a metavariable
type TcTyVar = Var
type TcTyVarSet = TyVarSet
type TcDTyVarSet = DTyVarSet
type TcTyCoVarSet = TyCoVarSet
type TcDTyCoVarSet = DTyCoVarSet
type TcKind = Kind
type TcCoVar = CoVar
type TcTyCoVar = Var
type TcTyVarBinder = TyVarBinder
type TcTyCon = TyCon

-- | A type labeled <a>KnotTied</a> might have knot-tied tycons in it. See
--   Note [Type checking recursive type and class declarations] in
--   TcTyClsDecls
type KnotTied ty = ty

-- | An expected type to check against during type-checking. See Note
--   [ExpType] in TcMType, where you'll also find manipulators.
data ExpType
Check :: TcType -> ExpType
Infer :: !InferResult -> ExpType
data InferResult
IR :: Unique -> TcLevel -> Bool -> IORef (Maybe TcType) -> InferResult
[ir_uniq] :: InferResult -> Unique
[ir_lvl] :: InferResult -> TcLevel
[ir_inst] :: InferResult -> Bool
[ir_ref] :: InferResult -> IORef (Maybe TcType)
type ExpSigmaType = ExpType
type ExpRhoType = ExpType

-- | Make an <a>ExpType</a> suitable for checking.
mkCheckExpType :: TcType -> ExpType

-- | What to expect for an argument to a rebindable-syntax operator. Quite
--   like <a>Type</a>, but allows for holes to be filled in by tcSyntaxOp.
--   The callback called from tcSyntaxOp gets a list of types; the meaning
--   of these types is determined by a left-to-right depth-first traversal
--   of the <a>SyntaxOpType</a> tree. So if you pass in
--   
--   <pre>
--   SynAny `SynFun` (SynList `SynFun` SynType Int) `SynFun` SynAny
--   </pre>
--   
--   you'll get three types back: one for the first <a>SynAny</a>, the
--   <i>element</i> type of the list, and one for the last <a>SynAny</a>.
--   You don't get anything for the <a>SynType</a>, because you've said
--   positively that it should be an Int, and so it shall be.
--   
--   This is defined here to avoid defining it in TcExpr.hs-boot.
data SyntaxOpType

-- | Any type
SynAny :: SyntaxOpType

-- | A rho type, deeply skolemised or instantiated as appropriate
SynRho :: SyntaxOpType

-- | A list type. You get back the element type of the list
SynList :: SyntaxOpType

-- | A function.
SynFun :: SyntaxOpType -> SyntaxOpType -> SyntaxOpType

-- | A known type.
SynType :: ExpType -> SyntaxOpType
infixr 0 `SynFun`

-- | Like <a>SynType</a> but accepts a regular TcType
synKnownType :: TcType -> SyntaxOpType

-- | Like <a>mkFunTys</a> but for <a>SyntaxOpType</a>
mkSynFunTys :: [SyntaxOpType] -> ExpType -> SyntaxOpType
newtype TcLevel
TcLevel :: Int -> TcLevel
topTcLevel :: TcLevel
pushTcLevel :: TcLevel -> TcLevel
isTopTcLevel :: TcLevel -> Bool
strictlyDeeperThan :: TcLevel -> TcLevel -> Bool
sameDepthAs :: TcLevel -> TcLevel -> Bool
tcTypeLevel :: TcType -> TcLevel
tcTyVarLevel :: TcTyVar -> TcLevel
maxTcLevel :: TcLevel -> TcLevel -> TcLevel
promoteSkolem :: TcLevel -> TcTyVar -> TcTyVar

-- | Change the TcLevel in a skolem, extending a substitution
promoteSkolemX :: TcLevel -> TCvSubst -> TcTyVar -> (TCvSubst, TcTyVar)
promoteSkolemsX :: TcLevel -> TCvSubst -> [TcTyVar] -> (TCvSubst, [TcTyVar])
data UserTypeCtxt
FunSigCtxt :: Name -> Bool -> UserTypeCtxt
InfSigCtxt :: Name -> UserTypeCtxt
ExprSigCtxt :: UserTypeCtxt
KindSigCtxt :: UserTypeCtxt
TypeAppCtxt :: UserTypeCtxt
ConArgCtxt :: Name -> UserTypeCtxt
TySynCtxt :: Name -> UserTypeCtxt
PatSynCtxt :: Name -> UserTypeCtxt
PatSigCtxt :: UserTypeCtxt
RuleSigCtxt :: Name -> UserTypeCtxt
ResSigCtxt :: UserTypeCtxt
ForSigCtxt :: Name -> UserTypeCtxt
DefaultDeclCtxt :: UserTypeCtxt
InstDeclCtxt :: Bool -> UserTypeCtxt
SpecInstCtxt :: UserTypeCtxt
ThBrackCtxt :: UserTypeCtxt
GenSigCtxt :: UserTypeCtxt
GhciCtxt :: Bool -> UserTypeCtxt
ClassSCCtxt :: Name -> UserTypeCtxt
SigmaCtxt :: UserTypeCtxt
DataTyCtxt :: Name -> UserTypeCtxt
DerivClauseCtxt :: UserTypeCtxt
TyVarBndrKindCtxt :: Name -> UserTypeCtxt
DataKindCtxt :: Name -> UserTypeCtxt
TySynKindCtxt :: Name -> UserTypeCtxt
TyFamResKindCtxt :: Name -> UserTypeCtxt
pprUserTypeCtxt :: UserTypeCtxt -> SDoc
isSigMaybe :: UserTypeCtxt -> Maybe Name
data TcTyVarDetails
SkolemTv :: TcLevel -> Bool -> TcTyVarDetails
RuntimeUnk :: TcTyVarDetails
MetaTv :: MetaInfo -> IORef MetaDetails -> TcLevel -> TcTyVarDetails
[mtv_info] :: TcTyVarDetails -> MetaInfo
[mtv_ref] :: TcTyVarDetails -> IORef MetaDetails
[mtv_tclvl] :: TcTyVarDetails -> TcLevel
pprTcTyVarDetails :: TcTyVarDetails -> SDoc
vanillaSkolemTv :: TcTyVarDetails
superSkolemTv :: TcTyVarDetails
data MetaDetails
Flexi :: MetaDetails
Indirect :: TcType -> MetaDetails
data MetaInfo
TauTv :: MetaInfo
TyVarTv :: MetaInfo
FlatMetaTv :: MetaInfo
FlatSkolTv :: MetaInfo
isImmutableTyVar :: TyVar -> Bool
isSkolemTyVar :: TcTyVar -> Bool
isMetaTyVar :: TcTyVar -> Bool
isMetaTyVarTy :: TcType -> Bool
isTyVarTy :: Type -> Bool
tcIsTcTyVar :: TcTyVar -> Bool
isTyVarTyVar :: Var -> Bool
isOverlappableTyVar :: TcTyVar -> Bool
isTyConableTyVar :: TcTyVar -> Bool
isFskTyVar :: TcTyVar -> Bool
isFmvTyVar :: TcTyVar -> Bool

-- | True of both given and wanted flatten-skolems (fmv and fsk)
isFlattenTyVar :: TcTyVar -> Bool
isAmbiguousTyVar :: TcTyVar -> Bool
metaTyVarRef :: TyVar -> IORef MetaDetails
metaTyVarInfo :: TcTyVar -> MetaInfo
isFlexi :: MetaDetails -> Bool
isIndirect :: MetaDetails -> Bool
isRuntimeUnkSkol :: TyVar -> Bool
metaTyVarTcLevel :: TcTyVar -> TcLevel
setMetaTyVarTcLevel :: TcTyVar -> TcLevel -> TcTyVar
metaTyVarTcLevel_maybe :: TcTyVar -> Maybe TcLevel
isTouchableMetaTyVar :: TcLevel -> TcTyVar -> Bool
isFloatedTouchableMetaTyVar :: TcLevel -> TcTyVar -> Bool
findDupTyVarTvs :: [(Name, TcTyVar)] -> [(Name, Name)]
mkTyVarNamePairs :: [TyVar] -> [(Name, TyVar)]
mkPhiTy :: [PredType] -> Type -> Type

-- | Make a sigma ty where all type variables are <a>Inferred</a>. That is,
--   they cannot be used with visible type application.
mkInfSigmaTy :: [TyCoVar] -> [PredType] -> Type -> Type

-- | Make a sigma ty where all type variables are "specified". That is,
--   they can be used with visible type application
mkSpecSigmaTy :: [TyVar] -> [PredType] -> Type -> Type
mkSigmaTy :: [TyCoVarBinder] -> [PredType] -> Type -> Type
mkNakedAppTy :: Type -> Type -> Type
mkNakedAppTys :: Type -> [Type] -> Type
mkNakedCastTy :: Type -> Coercion -> Type
nakedSubstTy :: HasCallStack => TCvSubst -> TcType -> TcType

-- | Attempts to obtain the type variable underlying a <a>Type</a>, and
--   panics with the given message if this is not a type variable type. See
--   also <a>getTyVar_maybe</a>
getTyVar :: String -> Type -> TyVar
tcSplitForAllTy_maybe :: Type -> Maybe (TyVarBinder, Type)

-- | Like <a>tcSplitPiTys</a>, but splits off only named binders, returning
--   just the tycovars.
tcSplitForAllTys :: Type -> ([TyVar], Type)

-- | Splits a forall type into a list of <a>TyBinder</a>s and the inner
--   type. Always succeeds, even if it returns an empty list.
tcSplitPiTys :: Type -> ([TyBinder], Type)

-- | Splits a type into a TyBinder and a body, if possible. Panics
--   otherwise
tcSplitPiTy_maybe :: Type -> Maybe (TyBinder, Type)

-- | Like <a>tcSplitForAllTys</a>, but splits off only named binders.
tcSplitForAllVarBndrs :: Type -> ([TyVarBinder], Type)
tcSplitPhiTy :: Type -> (ThetaType, Type)
tcSplitPredFunTy_maybe :: Type -> Maybe (PredType, Type)
tcSplitFunTy_maybe :: Type -> Maybe (Type, Type)
tcSplitFunTys :: Type -> ([Type], Type)
tcFunArgTy :: Type -> Type
tcFunResultTy :: Type -> Type

-- | Strips off n *visible* arguments and returns the resulting type
tcFunResultTyN :: HasDebugCallStack => Arity -> Type -> Type

-- | Split off exactly the specified number argument types Returns (Left m)
--   if there are <tt>m</tt> missing arrows in the type (Right (tys,res))
--   if the type looks like t1 -&gt; ... -&gt; tn -&gt; res
tcSplitFunTysN :: Arity -> TcRhoType -> Either Arity ([TcSigmaType], TcSigmaType)
tcSplitTyConApp :: Type -> (TyCon, [Type])

-- | Split a type constructor application into its type constructor and
--   applied types. Note that this may fail in the case of a <a>FunTy</a>
--   with an argument of unknown kind <a>FunTy</a> (e.g. <tt>FunTy (a :: k)
--   Int</tt>. since the kind of <tt>a</tt> isn't of the form <tt>TYPE
--   rep</tt>). Consequently, you may need to zonk your type before using
--   this function.
--   
--   If you only need the <a>TyCon</a>, consider using
--   <tt>tcTyConAppTyCon_maybe</tt>.
tcSplitTyConApp_maybe :: HasCallStack => Type -> Maybe (TyCon, [Type])

-- | Like <tt>tcSplitTyConApp</tt> but doesn't look through type synonyms.
tcRepSplitTyConApp :: HasCallStack => Type -> (TyCon, [Type])

-- | Like <a>tcSplitTyConApp_maybe</a> but doesn't look through type
--   synonyms.
tcRepSplitTyConApp_maybe :: HasCallStack => Type -> Maybe (TyCon, [Type])

-- | Like <a>tcRepSplitTyConApp_maybe</a>, but returns <a>Nothing</a> if,
--   
--   <ol>
--   <li>the type is structurally not a type constructor application,
--   or</li>
--   <li>the type is a function type (e.g. application of <a>funTyCon</a>),
--   but we currently don't even enough information to fully determine its
--   RuntimeRep variables. For instance, <tt>FunTy (a :: k) Int</tt>.</li>
--   </ol>
--   
--   By contrast <a>tcRepSplitTyConApp_maybe</a> panics in the second case.
--   
--   The behavior here is needed during canonicalization; see Note [FunTy
--   and decomposing tycon applications] in TcCanonical for details.
tcRepSplitTyConApp_maybe' :: HasCallStack => Type -> Maybe (TyCon, [Type])
tcTyConAppTyCon :: Type -> TyCon

-- | Like <a>tcRepSplitTyConApp_maybe</a>, but only returns the
--   <a>TyCon</a>.
tcTyConAppTyCon_maybe :: Type -> Maybe TyCon
tcTyConAppArgs :: Type -> [Type]
tcSplitAppTy_maybe :: Type -> Maybe (Type, Type)
tcSplitAppTy :: Type -> (Type, Type)
tcSplitAppTys :: Type -> (Type, [Type])

-- | Does the AppTy split as in <tt>tcSplitAppTy_maybe</tt>, but assumes
--   that any coreView stuff is already done. Refuses to look through (c
--   =&gt; t)
tcRepSplitAppTy_maybe :: Type -> Maybe (Type, Type)

-- | Returns the number of arguments in the given type, without looking
--   through synonyms. This is used only for error reporting. We don't look
--   through synonyms because of #11313.
tcRepGetNumAppTys :: Type -> Arity

-- | If the type is a tyvar, possibly under a cast, returns it, along with
--   the coercion. Thus, the co is :: kind tv ~N kind type
tcGetCastedTyVar_maybe :: Type -> Maybe (TyVar, CoercionN)
tcGetTyVar_maybe :: Type -> Maybe TyVar
tcGetTyVar :: String -> Type -> TyVar
nextRole :: Type -> Role

-- | Split a sigma type into its parts.
tcSplitSigmaTy :: Type -> ([TyVar], ThetaType, Type)

-- | Split a sigma type into its parts, going underneath as many
--   <tt>ForAllTy</tt>s as possible. For example, given this type synonym:
--   
--   <pre>
--   type Traversal s t a b = forall f. Applicative f =&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   if you called <tt>tcSplitSigmaTy</tt> on this type:
--   
--   <pre>
--   forall s t a b. Each s t a b =&gt; Traversal s t a b
--   </pre>
--   
--   then it would return <tt>([s,t,a,b], [Each s t a b], Traversal s t a
--   b)</tt>. But if you instead called <tt>tcSplitNestedSigmaTys</tt> on
--   the type, it would return <tt>([s,t,a,b,f], [Each s t a b, Applicative
--   f], (a -&gt; f b) -&gt; s -&gt; f t)</tt>.
tcSplitNestedSigmaTys :: Type -> ([TyVar], ThetaType, Type)
tcDeepSplitSigmaTy_maybe :: TcSigmaType -> Maybe ([TcType], [TyVar], ThetaType, TcSigmaType)

-- | Type equality on source types. Does not look through <tt>newtypes</tt>
--   or <a>PredType</a>s, but it does look through type synonyms. This
--   first checks that the kinds of the types are equal and then checks
--   whether the types are equal, ignoring casts and coercions. (The kind
--   check is a recursive call, but since all kinds have type
--   <tt>Type</tt>, there is no need to check the types of kinds.) See also
--   Note [Non-trivial definitional equality] in TyCoRep.
eqType :: Type -> Type -> Bool

-- | Type equality on lists of types, looking through type synonyms but not
--   newtypes.
eqTypes :: [Type] -> [Type] -> Bool
nonDetCmpType :: Type -> Type -> Ordering
nonDetCmpTypes :: [Type] -> [Type] -> Ordering

-- | Compare types with respect to a (presumably) non-empty <a>RnEnv2</a>.
eqTypeX :: RnEnv2 -> Type -> Type -> Bool

-- | Like <tt>pickyEqTypeVis</tt>, but returns a Bool for convenience
pickyEqType :: TcType -> TcType -> Bool
tcEqType :: HasDebugCallStack => TcType -> TcType -> Bool
tcEqKind :: HasDebugCallStack => TcKind -> TcKind -> Bool

-- | Just like <a>tcEqType</a>, but will return True for types of different
--   kinds as long as their non-coercion structure is identical.
tcEqTypeNoKindCheck :: TcType -> TcType -> Bool

-- | Like <a>tcEqType</a>, but returns information about whether the
--   difference is visible in the case of a mismatch. <tt>Nothing</tt> :
--   the types are equal <tt>Just True</tt> : the types differ, and the
--   point of difference is visible <tt>Just False</tt> : the types differ,
--   and the point of difference is invisible
tcEqTypeVis :: TcType -> TcType -> Maybe Bool
isSigmaTy :: TcType -> Bool
isRhoTy :: TcType -> Bool

-- | Like <a>isRhoTy</a>, but also says <a>True</a> for <a>Infer</a> types
isRhoExpTy :: ExpType -> Bool
isOverloadedTy :: Type -> Bool

-- | Does a type represent a floating-point number?
isFloatingTy :: Type -> Bool
isDoubleTy :: Type -> Bool
isFloatTy :: Type -> Bool
isIntTy :: Type -> Bool
isWordTy :: Type -> Bool

-- | Is a type <a>String</a>?
isStringTy :: Type -> Bool
isIntegerTy :: Type -> Bool
isBoolTy :: Type -> Bool
isUnitTy :: Type -> Bool
isCharTy :: Type -> Bool

-- | Is a type a <tt>CallStack</tt>?
isCallStackTy :: Type -> Bool

-- | Is a <a>PredType</a> a <tt>CallStack</tt> implicit parameter?
--   
--   If so, return the name of the parameter.
isCallStackPred :: Class -> [Type] -> Maybe FastString
hasIPPred :: PredType -> Bool
isTauTy :: Type -> Bool
isTauTyCon :: TyCon -> Bool
tcIsTyVarTy :: Type -> Bool

-- | Is this a ForAllTy with a named binder?
tcIsForAllTy :: Type -> Bool
isPredTy :: Type -> Bool
isTyVarClassPred :: PredType -> Bool

-- | Does the given tyvar appear at the head of a chain of applications (a
--   t1 ... tn)
isTyVarHead :: TcTyVar -> TcType -> Bool

-- | Is the equality a ~r ...a.... definitely insoluble or not? a ~r Maybe
--   a -- Definitely insoluble a ~N ...(F a)... -- Not definitely insoluble
--   -- Perhaps (F a) reduces to Int a ~R ...(N a)... -- Not definitely
--   insoluble -- Perhaps newtype N a = MkN Int See Note [Occurs check
--   error] in TcCanonical for the motivation for this function.
isInsolubleOccursCheck :: EqRel -> TcTyVar -> TcType -> Bool
checkValidClsArgs :: Bool -> Class -> [KindOrType] -> Bool
hasTyVarHead :: Type -> Bool
isRigidTy :: TcType -> Bool
deNoteType :: Type -> Type
orphNamesOfType :: Type -> NameSet
orphNamesOfCo :: Coercion -> NameSet
orphNamesOfTypes :: [Type] -> NameSet
orphNamesOfCoCon :: CoAxiom br -> NameSet
getDFunTyKey :: Type -> OccName
evVarPred :: EvVar -> PredType
mkMinimalBySCs :: forall a. (a -> PredType) -> [a] -> [a]
transSuperClasses :: PredType -> [PredType]

-- | When inferring types, should we quantify over a given predicate?
--   Generally true of classes; generally false of equality constraints.
--   Equality constraints that mention quantified type variables and
--   implicit variables complicate the story. See Notes [Inheriting
--   implicit parameters] and [Quantifying over equality constraints]
pickQuantifiablePreds :: TyVarSet -> TcThetaType -> TcThetaType
pickCapturedPreds :: TyVarSet -> TcThetaType -> TcThetaType
immSuperClasses :: Class -> [Type] -> [PredType]
boxEqPred :: EqRel -> Type -> Type -> Maybe (Class, [Type])
isImprovementPred :: PredType -> Bool

-- | Finds outermost type-family applications occurring in a type, after
--   expanding synonyms. In the list (F, tys) that is returned we guarantee
--   that tys matches F's arity. For example, given type family F a :: *
--   -&gt; * (arity 1) calling tcTyFamInsts on (Maybe (F Int Bool) will
--   return (F, [Int]), not (F, [Int,Bool])
--   
--   This is important for its use in deciding termination of type
--   instances (see Trac #11581). E.g. type instance G [Int] = ...(F Int
--   <a>type</a>)... we don't need to take <a>type</a> into account when
--   asking if the calls on the RHS are smaller than the LHS
tcTyFamInsts :: Type -> [(TyCon, [Type])]

-- | Like <a>tcTyFamInsts</a>, except that the output records whether the
--   type family and its arguments occur as an <i>invisible</i> argument in
--   some type application. This information is useful because it helps GHC
--   know when to turn on <tt>-fprint-explicit-kinds</tt> during error
--   reporting so that users can actually see the type family being
--   mentioned.
--   
--   As an example, consider:
--   
--   <pre>
--   class C a
--   data T (a :: k)
--   type family F a :: k
--   instance C (T @(F Int) (F Bool))
--   </pre>
--   
--   There are two occurrences of the type family <tt>F</tt> in that
--   <tt>C</tt> instance, so <tt><a>tcTyFamInstsAndVis</a> (C (T @(F Int)
--   (F Bool)))</tt> will return:
--   
--   <pre>
--   [ (<a>True</a>,  F, [Int])
--   , (<a>False</a>, F, [Bool]) ]
--   </pre>
--   
--   <tt>F Int</tt> is paired with <a>True</a> since it appears as an
--   <i>invisible</i> argument to <tt>C</tt>, whereas <tt>F Bool</tt> is
--   paired with <a>False</a> since it appears an a <i>visible</i> argument
--   to <tt>C</tt>.
--   
--   See also <tt>Note [Kind arguments in error messages]</tt> in
--   <a>TcErrors</a>.
tcTyFamInstsAndVis :: Type -> [(Bool, TyCon, [Type])]

-- | In an application of a <a>TyCon</a> to some arguments, find the
--   outermost occurrences of type family applications within the
--   arguments. This function will not consider the <a>TyCon</a> itself
--   when checking for type family applications.
--   
--   See <a>tcTyFamInstsAndVis</a> for more details on how this works (as
--   this function is called inside of <a>tcTyFamInstsAndVis</a>).
tcTyConAppTyFamInstsAndVis :: TyCon -> [Type] -> [(Bool, TyCon, [Type])]

-- | Check that a type does not contain any type family applications.
isTyFamFree :: Type -> Bool
exactTyCoVarsOfType :: Type -> TyCoVarSet
exactTyCoVarsOfTypes :: [Type] -> TyVarSet
anyRewritableTyVar :: Bool -> EqRel -> (EqRel -> TcTyVar -> Bool) -> TcType -> Bool
isFFIArgumentTy :: DynFlags -> Safety -> Type -> Validity
isFFIImportResultTy :: DynFlags -> Type -> Validity
isFFIExportResultTy :: Type -> Validity
isFFIExternalTy :: Type -> Validity
isFFIDynTy :: Type -> Type -> Validity
isFFIPrimArgumentTy :: DynFlags -> Type -> Validity
isFFIPrimResultTy :: DynFlags -> Type -> Validity
isFFILabelTy :: Type -> Validity
isFFITy :: Type -> Bool
isFunPtrTy :: Type -> Bool
tcSplitIOType_maybe :: Type -> Maybe (TyCon, Type)

-- | The key type representing kinds in the compiler.
type Kind = Type
typeKind :: HasDebugCallStack => Type -> Kind
tcTypeKind :: HasDebugCallStack => Type -> Kind
liftedTypeKind :: Kind
constraintKind :: Kind

-- | This version considers Constraint to be the same as *. Returns True if
--   the argument is equivalent to Type/Constraint and False otherwise. See
--   Note [Kind Constraint and kind Type]
isLiftedTypeKind :: Kind -> Bool

-- | Returns True if the kind classifies unlifted types and False
--   otherwise. Note that this returns False for levity-polymorphic kinds,
--   which may be specialized to a kind that classifies unlifted types.
isUnliftedTypeKind :: Kind -> Bool

-- | Does this classify a type allowed to have values? Responds True to
--   things like *, #, TYPE Lifted, TYPE v, Constraint.
--   
--   True of any sub-kind of OpenTypeKind
classifiesTypeWithValues :: Kind -> Bool
data Type

-- | A type of the form <tt>p</tt> of kind <tt>Constraint</tt> represents a
--   value whose type is the Haskell predicate <tt>p</tt>, where a
--   predicate is what occurs before the <tt>=&gt;</tt> in a Haskell type.
--   
--   We use <a>PredType</a> as documentation to mark those types that we
--   guarantee to have this kind.
--   
--   It can be expanded into its representation, but:
--   
--   <ul>
--   <li>The type checker must treat it as opaque</li>
--   <li>The rest of the compiler treats it as transparent</li>
--   </ul>
--   
--   Consider these examples:
--   
--   <pre>
--   f :: (Eq a) =&gt; a -&gt; Int
--   g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int
--   h :: (r\l) =&gt; {r} =&gt; {l::Int | r}
--   </pre>
--   
--   Here the <tt>Eq a</tt> and <tt>?x :: Int -&gt; Int</tt> and
--   <tt>rl</tt> are all called "predicates"
type PredType = Type

-- | A collection of <a>PredType</a>s
type ThetaType = [PredType]

-- | A <a>TyCoBinder</a> represents an argument to a function. TyCoBinders
--   can be dependent (<a>Named</a>) or nondependent (<a>Anon</a>). They
--   may also be visible or not. See Note [TyCoBinders]
data TyCoBinder

-- | Argument Flag
--   
--   Is something required to appear in source Haskell (<a>Required</a>),
--   permitted by request (<a>Specified</a>) (visible type application), or
--   prohibited entirely from appearing in source Haskell
--   (<a>Inferred</a>)? See Note [VarBndrs, TyCoVarBinders, TyConBinders,
--   and visibility] in TyCoRep
data ArgFlag
Inferred :: ArgFlag
Specified :: ArgFlag
Required :: ArgFlag

-- | Like <a>mkTyCoForAllTy</a>, but does not check the occurrence of the
--   binder See Note [Unused coercion variable in ForAllTy]
mkForAllTy :: TyCoVar -> ArgFlag -> Type -> Type

-- | Wraps foralls over the type using the provided <a>TyCoVar</a>s from
--   left to right
mkForAllTys :: [TyCoVarBinder] -> Type -> Type

-- | Like mkForAllTys, but assumes all variables are dependent and
--   Inferred, a common case
mkTyCoInvForAllTys :: [TyCoVar] -> Type -> Type

-- | Like mkForAllTys, but assumes all variables are dependent and
--   Specified, a common case
mkSpecForAllTys :: [TyVar] -> Type -> Type

-- | Make a dependent forall over an Inferred variablem
mkTyCoInvForAllTy :: TyCoVar -> Type -> Type

-- | Like mkTyCoInvForAllTy, but tv should be a tyvar
mkInvForAllTy :: TyVar -> Type -> Type

-- | Like <a>mkTyCoInvForAllTys</a>, but tvs should be a list of tyvar
mkInvForAllTys :: [TyVar] -> Type -> Type

-- | Make an arrow type
mkFunTy :: Type -> Type -> Type
infixr 3 `mkFunTy`

-- | Make nested arrow types
mkFunTys :: [Type] -> Type -> Type

-- | A key function: builds a <a>TyConApp</a> or <a>FunTy</a> as
--   appropriate to its arguments. Applies its arguments to the constructor
--   from left to right.
mkTyConApp :: TyCon -> [Type] -> Type

-- | Applies a type to another, as in e.g. <tt>k a</tt>
mkAppTy :: Type -> Type -> Type
mkAppTys :: Type -> [Type] -> Type

-- | Create the plain type constructor type which has been applied to no
--   type arguments at all.
mkTyConTy :: TyCon -> Type
mkTyVarTy :: TyVar -> Type
mkTyVarTys :: [TyVar] -> [Type]
mkTyCoVarTy :: TyCoVar -> Type
mkTyCoVarTys :: [TyCoVar] -> [Type]
isClassPred :: PredType -> Bool
isEqPred :: PredType -> Bool
isNomEqPred :: PredType -> Bool
isIPPred :: PredType -> Bool
mkClassPred :: Class -> [Type] -> PredType
isDictLikeTy :: Type -> Bool
tcSplitDFunTy :: Type -> ([TyVar], [Type], Class, [Type])
tcSplitDFunHead :: Type -> (Class, [Type])
tcSplitMethodTy :: Type -> ([TyVar], PredType, Type)

-- | Is a tyvar of type <a>RuntimeRep</a>?
isRuntimeRepVar :: TyVar -> Bool

-- | Tests whether the given kind (which should look like <tt>TYPE x</tt>)
--   is something other than a constructor tree (that is, constructors at
--   every node). E.g. True of TYPE k, TYPE (F Int) False of TYPE
--   'LiftedRep
isKindLevPoly :: Kind -> Bool

-- | Does this binder bind a visible argument?
isVisibleBinder :: TyCoBinder -> Bool

-- | Does this binder bind an invisible argument?
isInvisibleBinder :: TyCoBinder -> Bool

-- | Type &amp; coercion substitution
--   
--   The following invariants must hold of a <a>TCvSubst</a>:
--   
--   <ol>
--   <li>The in-scope set is needed <i>only</i> to guide the generation of
--   fresh uniques</li>
--   <li>In particular, the <i>kind</i> of the type variables in the
--   in-scope set is not relevant</li>
--   <li>The substitution is only applied ONCE! This is because in general
--   such application will not reach a fixed point.</li>
--   </ol>
data TCvSubst
TCvSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> TCvSubst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type
emptyTCvSubst :: TCvSubst
mkEmptyTCvSubst :: InScopeSet -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
zipTvSubst :: [TyVar] -> [Type] -> TCvSubst

-- | Generates the in-scope set for the <a>TCvSubst</a> from the types in
--   the incoming environment. No CoVars, please!
mkTvSubstPrs :: [(TyVar, Type)] -> TCvSubst
notElemTCvSubst :: Var -> TCvSubst -> Bool
unionTCvSubst :: TCvSubst -> TCvSubst -> TCvSubst
getTvSubstEnv :: TCvSubst -> TvSubstEnv
setTvSubstEnv :: TCvSubst -> TvSubstEnv -> TCvSubst
getTCvInScope :: TCvSubst -> InScopeSet
extendTCvInScope :: TCvSubst -> Var -> TCvSubst
extendTCvInScopeList :: TCvSubst -> [Var] -> TCvSubst
extendTCvInScopeSet :: TCvSubst -> VarSet -> TCvSubst
extendTvSubstAndInScope :: TCvSubst -> TyVar -> Type -> TCvSubst
lookupTyVar :: TCvSubst -> TyVar -> Maybe Type
extendTCvSubst :: TCvSubst -> TyCoVar -> Type -> TCvSubst
substTyVarBndr :: HasCallStack => TCvSubst -> TyVar -> (TCvSubst, TyVar)
extendTvSubst :: TCvSubst -> TyVar -> Type -> TCvSubst
isInScope :: Var -> TCvSubst -> Bool
mkTCvSubst :: InScopeSet -> (TvSubstEnv, CvSubstEnv) -> TCvSubst

-- | Make a TCvSubst with specified tyvar subst and empty covar subst
mkTvSubst :: InScopeSet -> TvSubstEnv -> TCvSubst
zipTyEnv :: [TyVar] -> [Type] -> TvSubstEnv
zipCoEnv :: [CoVar] -> [Coercion] -> CvSubstEnv

-- | Substitute within a <a>Type</a> The substitution has to satisfy the
--   invariants described in Note [The substitution invariant].
substTy :: HasCallStack => TCvSubst -> Type -> Type

-- | Substitute within several <a>Type</a>s The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTys :: HasCallStack => TCvSubst -> [Type] -> [Type]

-- | Type substitution, see <a>zipTvSubst</a>
substTyWith :: HasCallStack => [TyVar] -> [Type] -> Type -> Type

-- | Substitute covars within a type
substTyWithCoVars :: [CoVar] -> [Coercion] -> Type -> Type

-- | Substitute within a <a>Type</a> after adding the free variables of the
--   type to the in-scope set. This is useful for the case when the free
--   variables aren't already in the in-scope set or easily available. See
--   also Note [The substitution invariant].
substTyAddInScope :: TCvSubst -> Type -> Type

-- | Substitute within a <a>Type</a> disabling the sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyUnchecked :: TCvSubst -> Type -> Type

-- | Substitute within several <a>Type</a>s disabling the sanity checks.
--   The problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substTysUnchecked to substTys and remove this
--   function. Please don't use in new code.
substTysUnchecked :: TCvSubst -> [Type] -> [Type]

-- | Substitute within a <a>ThetaType</a> disabling the sanity checks. The
--   problems that the sanity checks in substTys catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substThetaUnchecked to substTheta and remove this
--   function. Please don't use in new code.
substThetaUnchecked :: TCvSubst -> ThetaType -> ThetaType

-- | Type substitution, see <a>zipTvSubst</a>. Disables sanity checks. The
--   problems that the sanity checks in substTy catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substTyUnchecked to substTy and remove this function. Please
--   don't use in new code.
substTyWithUnchecked :: [TyVar] -> [Type] -> Type -> Type

-- | Substitute within a <a>Coercion</a> disabling sanity checks. The
--   problems that the sanity checks in substCo catch are described in Note
--   [The substitution invariant]. The goal of #11371 is to migrate all the
--   calls of substCoUnchecked to substCo and remove this function. Please
--   don't use in new code.
substCoUnchecked :: TCvSubst -> Coercion -> Coercion

-- | Coercion substitution, see <a>zipTvSubst</a>. Disables sanity checks.
--   The problems that the sanity checks in substCo catch are described in
--   Note [The substitution invariant]. The goal of #11371 is to migrate
--   all the calls of substCoUnchecked to substCo and remove this function.
--   Please don't use in new code.
substCoWithUnchecked :: [TyVar] -> [Type] -> Coercion -> Coercion

-- | Substitute within a <a>ThetaType</a> The substitution has to satisfy
--   the invariants described in Note [The substitution invariant].
substTheta :: HasCallStack => TCvSubst -> ThetaType -> ThetaType

-- | See <a>Type#type_classification</a> for what an unlifted type is.
--   Panics on levity polymorphic types.
isUnliftedType :: HasDebugCallStack => Type -> Bool
isUnboxedTupleType :: Type -> Bool

-- | Returns true of types that are opaque to Haskell.
isPrimitiveType :: Type -> Bool

-- | Gives the typechecker view of a type. This unwraps synonyms but leaves
--   <tt>Constraint</tt> alone. c.f. coreView, which turns Constraint into
--   TYPE LiftedRep. Returns Nothing if no unwrapping happens. See also
--   Note [coreView vs tcView]
tcView :: Type -> Maybe Type

-- | This function Strips off the <i>top layer only</i> of a type synonym
--   application (if any) its underlying representation type. Returns
--   Nothing if there is nothing to look through. This function considers
--   <tt>Constraint</tt> to be a synonym of <tt>TYPE LiftedRep</tt>.
--   
--   By being non-recursive and inlined, this case analysis gets
--   efficiently joined onto the case analysis that the caller is already
--   doing
coreView :: Type -> Maybe Type
tyCoVarsOfType :: Type -> TyCoVarSet
tyCoVarsOfTypes :: [Type] -> TyCoVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a non-deterministic set.
closeOverKinds :: TyVarSet -> TyVarSet

-- | The worker for <a>tyCoFVsOfType</a> and <tt>tyCoFVsOfTypeList</tt>.
--   The previous implementation used <a>unionVarSet</a> which is O(n+m)
--   and can make the function quadratic. It's exported, so that it can be
--   composed with other functions that compute free variables. See Note
--   [FV naming conventions] in FV.
--   
--   Eta-expanded because that makes it run faster (apparently) See Note
--   [FV eta expansion] in FV for explanation.
tyCoFVsOfType :: Type -> FV
tyCoFVsOfTypes :: [Type] -> FV

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in a
--   deterministic set. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in FV.
tyCoVarsOfTypeDSet :: Type -> DTyCoVarSet

-- | Returns free variables of types, including kind variables as a
--   deterministic set. For type synonyms it does <i>not</i> expand the
--   synonym.
tyCoVarsOfTypesDSet :: [Type] -> DTyCoVarSet

-- | Add the kind variables free in the kinds of the tyvars in the given
--   set. Returns a deterministic set.
closeOverKindsDSet :: DTyVarSet -> DTyVarSet

-- | <a>tyCoFVsOfType</a> that returns free variables of a type in
--   deterministic order. For explanation of why using <a>VarSet</a> is not
--   deterministic see Note [Deterministic FV] in FV.
tyCoVarsOfTypeList :: Type -> [TyCoVar]

-- | Returns free variables of types, including kind variables as a
--   deterministically ordered list. For type synonyms it does <i>not</i>
--   expand the synonym.
tyCoVarsOfTypesList :: [Type] -> [TyCoVar]

-- | Returns True if this type has no free variables. Should be the same as
--   isEmptyVarSet . tyCoVarsOfType, but faster in the non-forall case.
noFreeVarsOfType :: Type -> Bool
pprKind :: Kind -> SDoc
pprParendKind :: Kind -> SDoc
pprSigmaType :: Type -> SDoc
pprType :: Type -> SDoc
pprParendType :: Type -> SDoc
pprTypeApp :: TyCon -> [Type] -> SDoc
pprTyThingCategory :: TyThing -> SDoc
tyThingCategory :: TyThing -> String
pprTheta :: ThetaType -> SDoc
pprParendTheta :: ThetaType -> SDoc
pprThetaArrowTy :: ThetaType -> SDoc
pprClassPred :: Class -> [Type] -> SDoc
pprTCvBndr :: TyCoVarBinder -> SDoc
pprTCvBndrs :: [TyCoVarBinder] -> SDoc
type TypeSize = IntWithInf
sizeType :: Type -> TypeSize
sizeTypes :: [Type] -> TypeSize

-- | Do a topological sort on a list of tyvars, so that binders occur
--   before occurrences E.g. given [ a::k, k::*, b::k ] it'll return a
--   well-scoped list [ k::*, a::k, b::k ]
--   
--   This is a deterministic sorting operation (that is, doesn't depend on
--   Uniques).
--   
--   It is also meant to be stable: that is, variables should not be
--   reordered unnecessarily. This is specified in Note [ScopedSort] See
--   also Note [Ordering of implicit variables] in RnTypes
scopedSort :: [TyCoVar] -> [TyCoVar]

-- | For every arg a tycon can take, the returned list says True if the
--   argument is taken visibly, and False otherwise. Ends with an infinite
--   tail of Trues to allow for oversaturation.
tcTyConVisibilities :: TyCon -> [Bool]

-- | If the tycon is applied to the types, is the next argument visible?
isNextTyConArgVisible :: TyCon -> [Type] -> Bool

-- | Should this type be applied to a visible argument?
isNextArgVisible :: TcType -> Bool
instance GHC.Classes.Ord TcType.TcLevel
instance GHC.Classes.Eq TcType.TcLevel
instance Outputable.Outputable TcType.ExpType
instance Outputable.Outputable TcType.InferResult
instance Outputable.Outputable TcType.TcLevel
instance Outputable.Outputable TcType.MetaDetails

module InstEnv

-- | Dictionary Function Identifier
type DFunId = Id
type InstMatch = (ClsInst, [DFunInstType])
type ClsInstLookupResult = ([InstMatch], [ClsInst], [InstMatch])

-- | The semantics allowed for overlapping instances for a particular
--   instance. See Note [Safe Haskell isSafeOverlap] (in <a>hs</a>) for a
--   explanation of the <a>isSafeOverlap</a> field.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# OVERLAPPABLE'</tt>
--   or <tt>'{-# OVERLAPPING'</tt> or <tt>'{-# OVERLAPS'</tt> or <tt>'{-#
--   INCOHERENT'</tt>, <a>AnnClose</a> <tt>`#-}`</tt>,</li>
--   </ul>
data OverlapFlag
OverlapFlag :: OverlapMode -> Bool -> OverlapFlag
[overlapMode] :: OverlapFlag -> OverlapMode
[isSafeOverlap] :: OverlapFlag -> Bool
data OverlapMode

-- | This instance must not overlap another <a>NoOverlap</a> instance.
--   However, it may be overlapped by <a>Overlapping</a> instances, and it
--   may overlap <a>Overlappable</a> instances.
NoOverlap :: SourceText -> OverlapMode

-- | Silently ignore this instance if you find a more specific one that
--   matches the constraint you are trying to resolve
--   
--   Example: constraint (Foo [Int]) instance Foo [Int] instance {--} Foo
--   [a]
--   
--   Since the second instance has the Overlappable flag, the first
--   instance will be chosen (otherwise its ambiguous which to choose)
Overlappable :: SourceText -> OverlapMode

-- | Silently ignore any more general instances that may be used to solve
--   the constraint.
--   
--   Example: constraint (Foo [Int]) instance {--} Foo [Int] instance Foo
--   [a]
--   
--   Since the first instance has the Overlapping flag, the second---more
--   general---instance will be ignored (otherwise it is ambiguous which to
--   choose)
Overlapping :: SourceText -> OverlapMode

-- | Equivalent to having both <a>Overlapping</a> and <a>Overlappable</a>
--   flags.
Overlaps :: SourceText -> OverlapMode

-- | Behave like Overlappable and Overlapping, and in addition pick an an
--   arbitrary one if there are multiple matching candidates, and don't
--   worry about later instantiation
--   
--   Example: constraint (Foo [b]) instance {-# INCOHERENT -} Foo [Int]
--   instance Foo [a] Without the Incoherent flag, we'd complain that
--   instantiating <tt>b</tt> would change which instance was chosen. See
--   also note [Incoherent instances] in InstEnv
Incoherent :: SourceText -> OverlapMode
setOverlapModeMaybe :: OverlapFlag -> Maybe OverlapMode -> OverlapFlag

-- | A type-class instance. Note that there is some tricky laziness at work
--   here. See Note [ClsInst laziness and the rough-match fields] for more
--   details.
data ClsInst
ClsInst :: Name -> [Maybe Name] -> Name -> [TyVar] -> Class -> [Type] -> DFunId -> OverlapFlag -> IsOrphan -> ClsInst

-- | Class name
[is_cls_nm] :: ClsInst -> Name

-- | Top of type args
[is_tcs] :: ClsInst -> [Maybe Name]

-- | <tt>is_dfun_name = idName . is_dfun</tt>.
--   
--   We use <a>is_dfun_name</a> for the visibility check,
--   <a>instIsVisible</a>, which needs to know the <a>Module</a> which the
--   dictionary is defined in. However, we cannot use the <a>Module</a>
--   attached to <a>is_dfun</a> since doing so would mean we would
--   potentially pull in an entire interface file unnecessarily. This was
--   the cause of #12367.
[is_dfun_name] :: ClsInst -> Name
[is_tvs] :: ClsInst -> [TyVar]
[is_cls] :: ClsInst -> Class
[is_tys] :: ClsInst -> [Type]
[is_dfun] :: ClsInst -> DFunId
[is_flag] :: ClsInst -> OverlapFlag
[is_orphan] :: ClsInst -> IsOrphan
type DFunInstType = Maybe Type
pprInstance :: ClsInst -> SDoc
pprInstanceHdr :: ClsInst -> SDoc
pprInstances :: [ClsInst] -> SDoc
instanceHead :: ClsInst -> ([TyVar], Class, [Type])
instanceSig :: ClsInst -> ([TyVar], [Type], Class, [Type])
mkLocalInstance :: DFunId -> OverlapFlag -> [TyVar] -> Class -> [Type] -> ClsInst
mkImportedInstance :: Name -> [Maybe Name] -> Name -> DFunId -> OverlapFlag -> IsOrphan -> ClsInst
instanceDFunId :: ClsInst -> DFunId
tidyClsInstDFun :: (DFunId -> DFunId) -> ClsInst -> ClsInst
instanceRoughTcs :: ClsInst -> [Maybe Name]

-- | A fuzzy comparison function for class instances, intended for sorting
--   instances before displaying them to the user.
fuzzyClsInstCmp :: ClsInst -> ClsInst -> Ordering

-- | Collects the names of concrete types and type constructors that make
--   up the head of a class instance. For instance, given `class Foo a b`:
--   
--   `instance Foo (Either (Maybe Int) a) Bool` would yield [Either, Maybe,
--   Int, Bool]
--   
--   Used in the implementation of ":info" in GHCi.
--   
--   The <a>tcSplitSigmaTy</a> is because of instance Foo a =&gt; Baz T
--   where ... The decl is an orphan if Baz and T are both not locally
--   defined, even if Foo *is* locally defined
orphNamesOfClsInst :: ClsInst -> NameSet

-- | <a>InstEnvs</a> represents the combination of the global type class
--   instance environment, the local type class instance environment, and
--   the set of transitively reachable orphan modules (according to what
--   modules have been directly imported) used to test orphan instance
--   visibility.
data InstEnvs
InstEnvs :: InstEnv -> InstEnv -> VisibleOrphanModules -> InstEnvs
[ie_global] :: InstEnvs -> InstEnv
[ie_local] :: InstEnvs -> InstEnv
[ie_visible] :: InstEnvs -> VisibleOrphanModules

-- | Set of visible orphan modules, according to what modules have been
--   directly imported. This is based off of the dep_orphs field, which
--   records transitively reachable orphan modules (modules that define
--   orphan instances).
type VisibleOrphanModules = ModuleSet
type InstEnv = UniqDFM ClsInstEnv
emptyInstEnv :: InstEnv
extendInstEnv :: InstEnv -> ClsInst -> InstEnv
deleteFromInstEnv :: InstEnv -> ClsInst -> InstEnv
deleteDFunFromInstEnv :: InstEnv -> DFunId -> InstEnv

-- | True when when the instance heads are the same e.g. both are Eq
--   [(a,b)] Used for overriding in GHCi Obviously should be insenstive to
--   alpha-renaming
identicalClsInstHead :: ClsInst -> ClsInst -> Bool
extendInstEnvList :: InstEnv -> [ClsInst] -> InstEnv

-- | Look up an instance in the given instance environment. The given class
--   application must match exactly one instance and the match may not
--   contain any flexi type variables. If the lookup is unsuccessful, yield
--   'Left errorMessage'.
lookupUniqueInstEnv :: InstEnvs -> Class -> [Type] -> Either MsgDoc (ClsInst, [Type])

-- | See Note [Rules for instance lookup] ^ See Note [Safe Haskell
--   Overlapping Instances] in TcSimplify ^ See Note [Safe Haskell
--   Overlapping Instances Implementation] in TcSimplify
lookupInstEnv :: Bool -> InstEnvs -> Class -> [Type] -> ClsInstLookupResult
instEnvElts :: InstEnv -> [ClsInst]

-- | Checks for an exact match of ClsInst in the instance environment. We
--   use this when we do signature checking in TcRnDriver
memberInstEnv :: InstEnv -> ClsInst -> Bool

-- | Test if an instance is visible, by checking that its origin module is
--   in <a>VisibleOrphanModules</a>. See Note [Instance lookup and orphan
--   instances]
instIsVisible :: VisibleOrphanModules -> ClsInst -> Bool
classInstances :: InstEnvs -> Class -> [ClsInst]
instanceBindFun :: TyCoVar -> BindFlag
instanceCantMatch :: [Maybe Name] -> [Maybe Name] -> Bool
roughMatchTcs :: [Type] -> [Maybe Name]
isOverlappable :: ClsInst -> Bool
isOverlapping :: ClsInst -> Bool
isIncoherent :: ClsInst -> Bool
instance Data.Data.Data InstEnv.ClsInst
instance Outputable.Outputable InstEnv.ClsInstEnv
instance Name.NamedThing InstEnv.ClsInst
instance Outputable.Outputable InstEnv.ClsInst

module OptCoercion

-- | optCoercion applies a substitution to a coercion, *and* optimises it
--   to reduce its size
optCoercion :: DynFlags -> TCvSubst -> Coercion -> NormalCo

-- | Check to make sure that an AxInstCo is internally consistent. Returns
--   the conflicting branch, if it exists See Note [Conflict checking with
--   AxiomInstCo]
checkAxInstCo :: Coercion -> Maybe CoAxBranch

module TcEvidence
data HsWrapper
WpHole :: HsWrapper
WpCompose :: HsWrapper -> HsWrapper -> HsWrapper
WpFun :: HsWrapper -> HsWrapper -> TcType -> SDoc -> HsWrapper
WpCast :: TcCoercionR -> HsWrapper
WpEvLam :: EvVar -> HsWrapper
WpEvApp :: EvTerm -> HsWrapper
WpTyLam :: TyVar -> HsWrapper
WpTyApp :: KindOrType -> HsWrapper
WpLet :: TcEvBinds -> HsWrapper
(<.>) :: HsWrapper -> HsWrapper -> HsWrapper
mkWpTyApps :: [Type] -> HsWrapper
mkWpEvApps :: [EvTerm] -> HsWrapper
mkWpEvVarApps :: [EvVar] -> HsWrapper
mkWpTyLams :: [TyVar] -> HsWrapper
mkWpLams :: [Var] -> HsWrapper
mkWpLet :: TcEvBinds -> HsWrapper
mkWpCastN :: TcCoercionN -> HsWrapper
mkWpCastR :: TcCoercionR -> HsWrapper
collectHsWrapBinders :: HsWrapper -> ([Var], HsWrapper)
mkWpFun :: HsWrapper -> HsWrapper -> TcType -> TcType -> SDoc -> HsWrapper

-- | <tt>mkWpFuns [(ty1, wrap1), (ty2, wrap2)] ty_res wrap_res</tt>, where
--   <tt>wrap1 :: ty1 "-&gt;" ty1'</tt> and <tt>wrap2 :: ty2 "-&gt;"
--   ty2'</tt>, <tt>wrap3 :: ty3 "-&gt;" ty3'</tt> and <tt>ty_res</tt> is
--   <i>either</i> <tt>ty3</tt> or <tt>ty3'</tt>, gives a wrapper <tt>(ty1'
--   -&gt; ty2' -&gt; ty3) "-&gt;" (ty1 -&gt; ty2 -&gt; ty3')</tt>. Notice
--   that the result wrapper goes the other way round to all the others.
--   This is a result of sub-typing contravariance. The SDoc is a
--   description of what you were doing when you called mkWpFuns.
mkWpFuns :: [(TcType, HsWrapper)] -> TcType -> HsWrapper -> SDoc -> HsWrapper
idHsWrapper :: HsWrapper
isIdHsWrapper :: HsWrapper -> Bool
pprHsWrapper :: HsWrapper -> (Bool -> SDoc) -> SDoc
data TcEvBinds
TcEvBinds :: EvBindsVar -> TcEvBinds
EvBinds :: Bag EvBind -> TcEvBinds
data EvBindsVar
EvBindsVar :: Unique -> IORef EvBindMap -> IORef CoVarSet -> EvBindsVar
[ebv_uniq] :: EvBindsVar -> Unique
[ebv_binds] :: EvBindsVar -> IORef EvBindMap
[ebv_tcvs] :: EvBindsVar -> IORef CoVarSet
CoEvBindsVar :: Unique -> IORef CoVarSet -> EvBindsVar
[ebv_uniq] :: EvBindsVar -> Unique
[ebv_tcvs] :: EvBindsVar -> IORef CoVarSet
newtype EvBindMap
EvBindMap :: DVarEnv EvBind -> EvBindMap
[ev_bind_varenv] :: EvBindMap -> DVarEnv EvBind
emptyEvBindMap :: EvBindMap
extendEvBinds :: EvBindMap -> EvBind -> EvBindMap
lookupEvBind :: EvBindMap -> EvVar -> Maybe EvBind
evBindMapBinds :: EvBindMap -> Bag EvBind
foldEvBindMap :: (EvBind -> a -> a) -> a -> EvBindMap -> a
filterEvBindMap :: (EvBind -> Bool) -> EvBindMap -> EvBindMap
isEmptyEvBindMap :: EvBindMap -> Bool
data EvBind
EvBind :: EvVar -> EvTerm -> Bool -> EvBind
[eb_lhs] :: EvBind -> EvVar
[eb_rhs] :: EvBind -> EvTerm
[eb_is_given] :: EvBind -> Bool
emptyTcEvBinds :: TcEvBinds
isEmptyTcEvBinds :: TcEvBinds -> Bool
mkGivenEvBind :: EvVar -> EvTerm -> EvBind
mkWantedEvBind :: EvVar -> EvTerm -> EvBind
evBindVar :: EvBind -> EvVar
isCoEvBindsVar :: EvBindsVar -> Bool
data EvTerm
EvExpr :: EvExpr -> EvTerm
EvTypeable :: Type -> EvTypeable -> EvTerm
EvFun :: [TyVar] -> [EvVar] -> TcEvBinds -> EvVar -> EvTerm
[et_tvs] :: EvTerm -> [TyVar]
[et_given] :: EvTerm -> [EvVar]
[et_binds] :: EvTerm -> TcEvBinds
[et_body] :: EvTerm -> EvVar
type EvExpr = CoreExpr

-- | Any sort of evidence Id, including coercions
evId :: EvId -> EvExpr
evCoercion :: TcCoercion -> EvTerm

-- | d |&gt; co
evCast :: EvExpr -> TcCoercion -> EvTerm
evDFunApp :: DFunId -> [Type] -> [EvExpr] -> EvTerm
evDataConApp :: DataCon -> [Type] -> [EvExpr] -> EvTerm
evSelector :: Id -> [Type] -> [EvExpr] -> EvExpr
mkEvCast :: EvExpr -> TcCoercion -> EvTerm
evVarsOfTerm :: EvTerm -> VarSet
mkEvScSelectors :: Class -> [TcType] -> [(TcPredType, EvExpr)]
evTypeable :: Type -> EvTypeable -> EvTerm
findNeededEvVars :: EvBindMap -> VarSet -> VarSet
evTermCoercion :: EvTerm -> TcCoercion
evTermCoercion_maybe :: EvTerm -> Maybe TcCoercion

-- | Evidence for <tt>CallStack</tt> implicit parameters.
data EvCallStack
EvCsEmpty :: EvCallStack

-- | <tt>EvCsPushCall name loc stk</tt> represents a call to <tt>name</tt>,
--   occurring at <tt>loc</tt>, in a calling context <tt>stk</tt>.
EvCsPushCall :: Name -> RealSrcSpan -> EvExpr -> EvCallStack

-- | Instructions on how to make a <tt>Typeable</tt> dictionary. See Note
--   [Typeable evidence terms]
data EvTypeable

-- | Dictionary for <tt>Typeable T</tt> where <tt>T</tt> is a type
--   constructor with all of its kind variables saturated. The
--   <tt>[EvTerm]</tt> is <tt>Typeable</tt> evidence for the applied
--   kinds..
EvTypeableTyCon :: TyCon -> [EvTerm] -> EvTypeable

-- | Dictionary for <tt>Typeable (s t)</tt>, given a dictionaries for
--   <tt>s</tt> and <tt>t</tt>.
EvTypeableTyApp :: EvTerm -> EvTerm -> EvTypeable

-- | Dictionary for <tt>Typeable (s -&gt; t)</tt>, given a dictionaries for
--   <tt>s</tt> and <tt>t</tt>.
EvTypeableTrFun :: EvTerm -> EvTerm -> EvTypeable

-- | Dictionary for a type literal, e.g. <tt>Typeable "foo"</tt> or
--   <tt>Typeable 3</tt> The <a>EvTerm</a> is evidence of, e.g.,
--   <tt>KnownNat 3</tt> (see Trac #10348)
EvTypeableTyLit :: EvTerm -> EvTypeable
type TcCoercion = Coercion
type TcCoercionR = CoercionR
type TcCoercionN = CoercionN
type TcCoercionP = CoercionP

-- | A coercion to be filled in by the type-checker. See Note [Coercion
--   holes]
data CoercionHole
data Role
Nominal :: Role
Representational :: Role
Phantom :: Role
data LeftOrRight
CLeft :: LeftOrRight
CRight :: LeftOrRight
pickLR :: LeftOrRight -> (a, a) -> a
mkTcReflCo :: Role -> TcType -> TcCoercion
mkTcNomReflCo :: TcType -> TcCoercionN
mkTcRepReflCo :: TcType -> TcCoercionR
mkTcTyConAppCo :: Role -> TyCon -> [TcCoercion] -> TcCoercion
mkTcAppCo :: TcCoercion -> TcCoercionN -> TcCoercion
mkTcFunCo :: Role -> TcCoercion -> TcCoercion -> TcCoercion
mkTcAxInstCo :: Role -> CoAxiom br -> BranchIndex -> [TcType] -> [TcCoercion] -> TcCoercion
mkTcUnbranchedAxInstCo :: CoAxiom Unbranched -> [TcType] -> [TcCoercion] -> TcCoercionR
mkTcForAllCo :: TyVar -> TcCoercionN -> TcCoercion -> TcCoercion
mkTcForAllCos :: [(TyVar, TcCoercionN)] -> TcCoercion -> TcCoercion
mkTcSymCo :: TcCoercion -> TcCoercion
mkTcTransCo :: TcCoercion -> TcCoercion -> TcCoercion
mkTcNthCo :: Role -> Int -> TcCoercion -> TcCoercion
mkTcLRCo :: LeftOrRight -> TcCoercion -> TcCoercion
mkTcSubCo :: TcCoercionN -> TcCoercionR
maybeTcSubCo :: EqRel -> TcCoercion -> TcCoercion
tcDowngradeRole :: Role -> Role -> TcCoercion -> TcCoercion
mkTcAxiomRuleCo :: CoAxiomRule -> [TcCoercion] -> TcCoercionR
mkTcGReflRightCo :: Role -> TcType -> TcCoercionN -> TcCoercion
mkTcGReflLeftCo :: Role -> TcType -> TcCoercionN -> TcCoercion
mkTcPhantomCo :: TcCoercionN -> TcType -> TcType -> TcCoercionP
mkTcCoherenceLeftCo :: Role -> TcType -> TcCoercionN -> TcCoercion -> TcCoercion
mkTcCoherenceRightCo :: Role -> TcType -> TcCoercionN -> TcCoercion -> TcCoercion
mkTcKindCo :: TcCoercion -> TcCoercionN
tcCoercionKind :: TcCoercion -> Pair TcType
coVarsOfTcCo :: TcCoercion -> TcTyCoVarSet
mkTcCoVarCo :: CoVar -> TcCoercion
isTcReflCo :: TcCoercion -> Bool

-- | This version does a slow check, calculating the related types and
--   seeing if they are equal.
isTcReflexiveCo :: TcCoercion -> Bool
tcCoercionRole :: TcCoercion -> Role

-- | Create a <a>Expr</a> that unwraps an implicit-parameter or
--   overloaded-label dictionary to expose the underlying value. We expect
--   the <a>Expr</a> to have the form `IP sym ty` or `IsLabel sym ty`, and
--   return a <a>Expr</a> `co :: IP sym ty ~ ty` or `co :: IsLabel sym ty ~
--   Proxy# sym -&gt; ty`. See also Note [Type-checking overloaded labels]
--   in TcExpr.
unwrapIP :: Type -> CoercionR

-- | Create a <a>Expr</a> that wraps a value in an implicit-parameter
--   dictionary. See <a>unwrapIP</a>.
wrapIP :: Type -> CoercionR
instance Data.Data.Data TcEvidence.EvCallStack
instance Data.Data.Data TcEvidence.EvTerm
instance Data.Data.Data TcEvidence.EvTypeable
instance Outputable.Outputable TcEvidence.EvCallStack
instance Data.Data.Data TcEvidence.HsWrapper
instance Outputable.Outputable TcEvidence.HsWrapper
instance Data.Data.Data TcEvidence.TcEvBinds
instance Outputable.Outputable TcEvidence.EvBindMap
instance Outputable.Outputable TcEvidence.TcEvBinds
instance Outputable.Outputable TcEvidence.EvBindsVar
instance Unique.Uniquable TcEvidence.EvBindsVar
instance Outputable.Outputable TcEvidence.EvBind
instance Outputable.Outputable TcEvidence.EvTerm
instance Outputable.Outputable TcEvidence.EvTypeable

module HsBinds

-- | Haskell Local Bindings
type HsLocalBinds id = HsLocalBindsLR id id

-- | Located Haskell local bindings
type LHsLocalBinds id = Located (HsLocalBinds id)

-- | Haskell Local Bindings with separate Left and Right identifier types
--   
--   Bindings in a 'let' expression or a 'where' clause
data HsLocalBindsLR idL idR

-- | Haskell Value Bindings
HsValBinds :: XHsValBinds idL idR -> HsValBindsLR idL idR -> HsLocalBindsLR idL idR

-- | Haskell Implicit Parameter Bindings
HsIPBinds :: XHsIPBinds idL idR -> HsIPBinds idR -> HsLocalBindsLR idL idR

-- | Empty Local Bindings
EmptyLocalBinds :: XEmptyLocalBinds idL idR -> HsLocalBindsLR idL idR
XHsLocalBindsLR :: XXHsLocalBindsLR idL idR -> HsLocalBindsLR idL idR
type LHsLocalBindsLR idL idR = Located (HsLocalBindsLR idL idR)

-- | Haskell Value Bindings
type HsValBinds id = HsValBindsLR id id

-- | Haskell Value bindings with separate Left and Right identifier types
--   (not implicit parameters) Used for both top level and nested bindings
--   May contain pattern synonym bindings
data HsValBindsLR idL idR

-- | Value Bindings In
--   
--   Before renaming RHS; idR is always RdrName Not dependency analysed
--   Recursive by default
ValBinds :: XValBinds idL idR -> LHsBindsLR idL idR -> [LSig idR] -> HsValBindsLR idL idR

-- | Value Bindings Out
--   
--   After renaming RHS; idR can be Name or Id Dependency analysed, later
--   bindings in the list may depend on earlier ones.
XValBindsLR :: XXValBindsLR idL idR -> HsValBindsLR idL idR
data NHsValBindsLR idL
NValBinds :: [(RecFlag, LHsBinds idL)] -> [LSig GhcRn] -> NHsValBindsLR idL

-- | Located Haskell Binding
type LHsBind id = LHsBindLR id id

-- | Located Haskell Bindings
type LHsBinds id = LHsBindsLR id id

-- | Haskell Binding
type HsBind id = HsBindLR id id

-- | Located Haskell Bindings with separate Left and Right identifier types
type LHsBindsLR idL idR = Bag (LHsBindLR idL idR)

-- | Located Haskell Binding with separate Left and Right identifier types
type LHsBindLR idL idR = Located (HsBindLR idL idR)

-- | Haskell Binding with separate Left and Right id's
data HsBindLR idL idR

-- | Function-like Binding
--   
--   FunBind is used for both functions <tt>f x = e</tt> and variables
--   <tt>f = x -&gt; e</tt> and strict variables <tt>!x = x + 1</tt>
--   
--   Reason 1: Special case for type inference: see <a>tcMonoBinds</a>.
--   
--   Reason 2: Instance decls can only have FunBinds, which is convenient.
--   If you change this, you'll need to change e.g. rnMethodBinds
--   
--   But note that the form <tt>f :: a-&gt;a = ...</tt> parses as a pattern
--   binding, just like <tt>(f :: a -&gt; a) = ... </tt>
--   
--   Strict bindings have their strictness recorded in the
--   <a>SrcStrictness</a> of their <tt>MatchContext</tt>. See Note [FunBind
--   vs PatBind] for details about the relationship between FunBind and
--   PatBind.
--   
--   <a>AnnKeywordId</a>s
--   
--   <ul>
--   <li><a>AnnFunId</a>, attached to each element of fun_matches</li>
--   <li><a>AnnEqual</a>,<a>AnnWhere</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a>,</li>
--   </ul>
FunBind :: XFunBind idL idR -> Located (IdP idL) -> MatchGroup idR (LHsExpr idR) -> HsWrapper -> [Tickish Id] -> HsBindLR idL idR

-- | After the renamer, this contains the locally-bound free variables of
--   this defn. See Note [Bind free vars]
[fun_ext] :: HsBindLR idL idR -> XFunBind idL idR
[fun_id] :: HsBindLR idL idR -> Located (IdP idL)

-- | The payload
[fun_matches] :: HsBindLR idL idR -> MatchGroup idR (LHsExpr idR)

-- | Coercion from the type of the MatchGroup to the type of the Id.
--   Example:
--   
--   <pre>
--   f :: Int -&gt; forall a. a -&gt; a
--   f x y = y
--   </pre>
--   
--   Then the MatchGroup will have type (Int -&gt; a' -&gt; a') (with a
--   free type variable a'). The coercion will take a CoreExpr of this type
--   and convert it to a CoreExpr of type Int -&gt; forall a'. a' -&gt; a'
--   Notice that the coercion captures the free a'.
[fun_co_fn] :: HsBindLR idL idR -> HsWrapper

-- | Ticks to put on the rhs, if any
[fun_tick] :: HsBindLR idL idR -> [Tickish Id]

-- | Pattern Binding
--   
--   The pattern is never a simple variable; That case is done by FunBind.
--   See Note [FunBind vs PatBind] for details about the relationship
--   between FunBind and PatBind.
PatBind :: XPatBind idL idR -> LPat idL -> GRHSs idR (LHsExpr idR) -> ([Tickish Id], [[Tickish Id]]) -> HsBindLR idL idR

-- | See Note [Bind free vars]
[pat_ext] :: HsBindLR idL idR -> XPatBind idL idR
[pat_lhs] :: HsBindLR idL idR -> LPat idL
[pat_rhs] :: HsBindLR idL idR -> GRHSs idR (LHsExpr idR)

-- | Ticks to put on the rhs, if any, and ticks to put on the bound
--   variables.
[pat_ticks] :: HsBindLR idL idR -> ([Tickish Id], [[Tickish Id]])

-- | Variable Binding
--   
--   Dictionary binding and suchlike. All VarBinds are introduced by the
--   type checker
VarBind :: XVarBind idL idR -> IdP idL -> LHsExpr idR -> Bool -> HsBindLR idL idR
[var_ext] :: HsBindLR idL idR -> XVarBind idL idR
[var_id] :: HsBindLR idL idR -> IdP idL

-- | Located only for consistency
[var_rhs] :: HsBindLR idL idR -> LHsExpr idR

-- | True <a>=</a> inline this binding regardless (used for implication
--   constraints only)
[var_inline] :: HsBindLR idL idR -> Bool

-- | Abstraction Bindings
AbsBinds :: XAbsBinds idL idR -> [TyVar] -> [EvVar] -> [ABExport idL] -> [TcEvBinds] -> LHsBinds idL -> Bool -> HsBindLR idL idR
[abs_ext] :: HsBindLR idL idR -> XAbsBinds idL idR
[abs_tvs] :: HsBindLR idL idR -> [TyVar]

-- | Includes equality constraints
[abs_ev_vars] :: HsBindLR idL idR -> [EvVar]

-- | AbsBinds only gets used when idL = idR after renaming, but these need
--   to be idL's for the collect... code in HsUtil to have the right type
[abs_exports] :: HsBindLR idL idR -> [ABExport idL]

-- | Evidence bindings Why a list? See TcInstDcls Note [Typechecking plan
--   for instance declarations]
[abs_ev_binds] :: HsBindLR idL idR -> [TcEvBinds]

-- | Typechecked user bindings
[abs_binds] :: HsBindLR idL idR -> LHsBinds idL
[abs_sig] :: HsBindLR idL idR -> Bool

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnPattern</a>,
--   <a>AnnLarrow</a>,<a>AnnEqual</a>, <a>AnnWhere</a> <a>AnnOpen</a>
--   <tt>'{'</tt>,<a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
PatSynBind :: XPatSynBind idL idR -> PatSynBind idL idR -> HsBindLR idL idR
XHsBindsLR :: XXHsBindsLR idL idR -> HsBindLR idL idR
data NPatBindTc
NPatBindTc :: NameSet -> Type -> NPatBindTc

-- | Free variables
[pat_fvs] :: NPatBindTc -> NameSet

-- | Type of the GRHSs
[pat_rhs_ty] :: NPatBindTc -> Type

-- | Abtraction Bindings Export
data ABExport p
ABE :: XABE p -> IdP p -> IdP p -> HsWrapper -> TcSpecPrags -> ABExport p
[abe_ext] :: ABExport p -> XABE p

-- | Any INLINE pragma is attached to this Id
[abe_poly] :: ABExport p -> IdP p
[abe_mono] :: ABExport p -> IdP p

-- | See Note [ABExport wrapper] Shape: (forall abs_tvs. abs_ev_vars =&gt;
--   abe_mono) ~ abe_poly
[abe_wrap] :: ABExport p -> HsWrapper

-- | SPECIALISE pragmas
[abe_prags] :: ABExport p -> TcSpecPrags
XABExport :: XXABExport p -> ABExport p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnPattern</a>,
--   <a>AnnEqual</a>,<a>AnnLarrow</a> <a>AnnWhere</a>,<a>AnnOpen</a>
--   <tt>'{'</tt>, <a>AnnClose</a> <tt>'}'</tt>,</li>
--   </ul>
--   
--   Pattern Synonym binding
data PatSynBind idL idR
PSB :: XPSB idL idR -> Located (IdP idL) -> HsPatSynDetails (Located (IdP idR)) -> LPat idR -> HsPatSynDir idR -> PatSynBind idL idR

-- | Post renaming, FVs. See Note [Bind free vars]
[psb_ext] :: PatSynBind idL idR -> XPSB idL idR

-- | Name of the pattern synonym
[psb_id] :: PatSynBind idL idR -> Located (IdP idL)

-- | Formal parameter names
[psb_args] :: PatSynBind idL idR -> HsPatSynDetails (Located (IdP idR))

-- | Right-hand side
[psb_def] :: PatSynBind idL idR -> LPat idR

-- | Directionality
[psb_dir] :: PatSynBind idL idR -> HsPatSynDir idR
XPatSynBind :: XXPatSynBind idL idR -> PatSynBind idL idR
pprLHsBinds :: (OutputableBndrId (GhcPass idL), OutputableBndrId (GhcPass idR)) => LHsBindsLR (GhcPass idL) (GhcPass idR) -> SDoc
pprLHsBindsForUser :: (OutputableBndrId (GhcPass idL), OutputableBndrId (GhcPass idR), OutputableBndrId (GhcPass id2)) => LHsBindsLR (GhcPass idL) (GhcPass idR) -> [LSig (GhcPass id2)] -> [SDoc]
pprDeclList :: [SDoc] -> SDoc
emptyLocalBinds :: HsLocalBindsLR (GhcPass a) (GhcPass b)
isEmptyLocalBindsTc :: HsLocalBindsLR (GhcPass a) GhcTc -> Bool
isEmptyLocalBindsPR :: HsLocalBindsLR (GhcPass a) (GhcPass b) -> Bool
eqEmptyLocalBinds :: HsLocalBindsLR a b -> Bool
isEmptyValBinds :: HsValBindsLR (GhcPass a) (GhcPass b) -> Bool
emptyValBindsIn :: HsValBindsLR (GhcPass a) (GhcPass b)
emptyValBindsOut :: HsValBindsLR (GhcPass a) (GhcPass b)
emptyLHsBinds :: LHsBindsLR idL idR
isEmptyLHsBinds :: LHsBindsLR idL idR -> Bool
plusHsValBinds :: HsValBinds (GhcPass a) -> HsValBinds (GhcPass a) -> HsValBinds (GhcPass a)
ppr_monobind :: (OutputableBndrId (GhcPass idL), OutputableBndrId (GhcPass idR)) => HsBindLR (GhcPass idL) (GhcPass idR) -> SDoc
pprTicks :: SDoc -> SDoc -> SDoc

-- | Haskell Implicit Parameter Bindings
data HsIPBinds id
IPBinds :: XIPBinds id -> [LIPBind id] -> HsIPBinds id
XHsIPBinds :: XXHsIPBinds id -> HsIPBinds id
isEmptyIPBindsPR :: HsIPBinds (GhcPass p) -> Bool
isEmptyIPBindsTc :: HsIPBinds GhcTc -> Bool

-- | Located Implicit Parameter Binding
--   
--   May have <a>AnnKeywordId</a> : <a>AnnSemi</a> when in a list
type LIPBind id = Located (IPBind id)

-- | Implicit parameter bindings.
--   
--   These bindings start off as (Left "x") in the parser and stay that way
--   until after type-checking when they are replaced with (Right d), where
--   "d" is the name of the dictionary holding the evidence for the
--   implicit parameter.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a></li>
--   </ul>
data IPBind id
IPBind :: XCIPBind id -> Either (Located HsIPName) (IdP id) -> LHsExpr id -> IPBind id
XIPBind :: XXIPBind id -> IPBind id

-- | Located Signature
type LSig pass = Located (Sig pass)

-- | Signatures and pragmas
data Sig pass

-- | An ordinary type signature
--   
--   <pre>
--   f :: Num a =&gt; a -&gt; a
--   </pre>
--   
--   After renaming, this list of Names contains the named wildcards
--   brought into scope by this signature. For a signature <tt>_ -&gt; _a
--   -&gt; Bool</tt>, the renamer will leave the unnamed wildcard
--   <tt>_</tt> untouched, and the named wildcard <tt>_a</tt> is then
--   replaced with fresh meta vars in the type. Their names are stored in
--   the type signature that brought them into scope, in this third field
--   to be more specific.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a>, <a>AnnComma</a></li>
--   </ul>
TypeSig :: XTypeSig pass -> [Located (IdP pass)] -> LHsSigWcType pass -> Sig pass

-- | A pattern synonym type signature
--   
--   <pre>
--   pattern Single :: () =&gt; (Show a) =&gt; a -&gt; [a]
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnPattern</a>,
--   <a>AnnDcolon</a>,<a>AnnForall</a> <a>AnnDot</a>,<a>AnnDarrow</a></li>
--   </ul>
PatSynSig :: XPatSynSig pass -> [Located (IdP pass)] -> LHsSigType pass -> Sig pass

-- | A signature for a class method False: ordinary class-method signature
--   True: generic-default class method signature e.g. class C a where op
--   :: a -&gt; a -- Ordinary default op :: Eq a =&gt; a -&gt; a -- Generic
--   default No wildcards allowed here
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDefault</a>, <a>AnnDcolon</a></li>
--   </ul>
ClassOpSig :: XClassOpSig pass -> Bool -> [Located (IdP pass)] -> LHsSigType pass -> Sig pass

-- | A type signature in generated code, notably the code generated for
--   record selectors. We simply record the desired Id itself, replete with
--   its name, type and IdDetails. Otherwise it's just like a type
--   signature: there should be an accompanying binding
IdSig :: XIdSig pass -> Id -> Sig pass

-- | An ordinary fixity declaration
--   
--   <pre>
--   infixl 8 ***
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnInfix</a>, <a>AnnVal</a></li>
--   </ul>
FixSig :: XFixSig pass -> FixitySig pass -> Sig pass

-- | An inline pragma
--   
--   <pre>
--   {#- INLINE f #-}
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# INLINE'</tt> and
--   <tt>'['</tt>, <a>AnnClose</a>,<a>AnnOpen</a>,
--   <a>AnnVal</a>,<a>AnnTilde</a>, <a>AnnClose</a></li>
--   </ul>
InlineSig :: XInlineSig pass -> Located (IdP pass) -> InlinePragma -> Sig pass

-- | A specialisation pragma
--   
--   <pre>
--   {-# SPECIALISE f :: Int -&gt; Int #-}
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnOpen</a> <tt>'{-#
--   SPECIALISE'</tt> and <tt>'['</tt>, <a>AnnTilde</a>, <a>AnnVal</a>,
--   <a>AnnClose</a> <tt>']'</tt> and <tt>'#-}'</tt>, <a>AnnDcolon</a></li>
--   </ul>
SpecSig :: XSpecSig pass -> Located (IdP pass) -> [LHsSigType pass] -> InlinePragma -> Sig pass

-- | A specialisation pragma for instance declarations only
--   
--   <pre>
--   {-# SPECIALISE instance Eq [Int] #-}
--   </pre>
--   
--   (Class tys); should be a specialisation of the current instance
--   declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnInstance</a>,<a>AnnClose</a></li>
--   </ul>
SpecInstSig :: XSpecInstSig pass -> SourceText -> LHsSigType pass -> Sig pass

-- | A minimal complete definition pragma
--   
--   <pre>
--   {-# MINIMAL a | (b, c | (d | e)) #-}
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnVbar</a>,<a>AnnComma</a>, <a>AnnClose</a></li>
--   </ul>
MinimalSig :: XMinimalSig pass -> SourceText -> LBooleanFormula (Located (IdP pass)) -> Sig pass

-- | A "set cost centre" pragma for declarations
--   
--   <pre>
--   {-# SCC funName #-}
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# SCC funName "cost_centre_name" #-}
--   </pre>
SCCFunSig :: XSCCFunSig pass -> SourceText -> Located (IdP pass) -> Maybe (Located StringLiteral) -> Sig pass

-- | A complete match pragma
--   
--   <pre>
--   {-# COMPLETE C, D [:: T] #-}
--   </pre>
--   
--   Used to inform the pattern match checker about additional complete
--   matchings which, for example, arise from pattern synonym definitions.
CompleteMatchSig :: XCompleteMatchSig pass -> SourceText -> Located [Located (IdP pass)] -> Maybe (Located (IdP pass)) -> Sig pass
XSig :: XXSig pass -> Sig pass

-- | Located Fixity Signature
type LFixitySig pass = Located (FixitySig pass)

-- | Fixity Signature
data FixitySig pass
FixitySig :: XFixitySig pass -> [Located (IdP pass)] -> Fixity -> FixitySig pass
XFixitySig :: XXFixitySig pass -> FixitySig pass

-- | Type checker Specialisation Pragmas
--   
--   <a>TcSpecPrags</a> conveys <tt>SPECIALISE</tt> pragmas from the type
--   checker to the desugarer
data TcSpecPrags

-- | Super-specialised: a default method should be macro-expanded at every
--   call site
IsDefaultMethod :: TcSpecPrags
SpecPrags :: [LTcSpecPrag] -> TcSpecPrags

-- | Located Type checker Specification Pragmas
type LTcSpecPrag = Located TcSpecPrag

-- | Type checker Specification Pragma
data TcSpecPrag

-- | The Id to be specialised, a wrapper that specialises the polymorphic
--   function, and inlining spec for the specialised function
SpecPrag :: Id -> HsWrapper -> InlinePragma -> TcSpecPrag
noSpecPrags :: TcSpecPrags
hasSpecPrags :: TcSpecPrags -> Bool
isDefaultMethod :: TcSpecPrags -> Bool
isFixityLSig :: LSig name -> Bool
isTypeLSig :: LSig name -> Bool
isSpecLSig :: LSig name -> Bool
isSpecInstLSig :: LSig name -> Bool
isPragLSig :: LSig name -> Bool
isInlineLSig :: LSig name -> Bool
isMinimalLSig :: LSig name -> Bool
isSCCFunSig :: LSig name -> Bool
isCompleteMatchSig :: LSig name -> Bool
hsSigDoc :: Sig name -> SDoc
ppr_sig :: OutputableBndrId (GhcPass p) => Sig (GhcPass p) -> SDoc
pragBrackets :: SDoc -> SDoc

-- | Using SourceText in case the pragma was spelled differently or used
--   mixed case
pragSrcBrackets :: SourceText -> String -> SDoc -> SDoc
pprVarSig :: OutputableBndr id => [id] -> SDoc -> SDoc
pprSpec :: OutputableBndr id => id -> SDoc -> InlinePragma -> SDoc
pprTcSpecPrags :: TcSpecPrags -> SDoc
pprMinimalSig :: OutputableBndr name => LBooleanFormula (Located name) -> SDoc

-- | Haskell Pattern Synonym Details
type HsPatSynDetails arg = HsConDetails arg [RecordPatSynField arg]

-- | Record Pattern Synonym Field
data RecordPatSynField a
RecordPatSynField :: a -> a -> RecordPatSynField a
[recordPatSynSelectorId] :: RecordPatSynField a -> a
[recordPatSynPatVar] :: RecordPatSynField a -> a

-- | Haskell Pattern Synonym Direction
data HsPatSynDir id
Unidirectional :: HsPatSynDir id
ImplicitBidirectional :: HsPatSynDir id
ExplicitBidirectional :: MatchGroup id (LHsExpr id) -> HsPatSynDir id
instance Data.Data.Data a => Data.Data.Data (HsBinds.RecordPatSynField a)
instance Data.Data.Data HsBinds.TcSpecPrags
instance Data.Data.Data HsBinds.TcSpecPrag
instance Data.Data.Data HsBinds.NPatBindTc
instance (idL Data.Type.Equality.~ HsExtension.GhcPass pl, idR Data.Type.Equality.~ HsExtension.GhcPass pr, HsExtension.OutputableBndrId idL, HsExtension.OutputableBndrId idR) => Outputable.Outputable (HsBinds.HsLocalBindsLR idL idR)
instance (idL Data.Type.Equality.~ HsExtension.GhcPass pl, idR Data.Type.Equality.~ HsExtension.GhcPass pr, HsExtension.OutputableBndrId idL, HsExtension.OutputableBndrId idR) => Outputable.Outputable (HsBinds.HsValBindsLR idL idR)
instance (idL Data.Type.Equality.~ HsExtension.GhcPass pl, idR Data.Type.Equality.~ HsExtension.GhcPass pr, HsExtension.OutputableBndrId idL, HsExtension.OutputableBndrId idR) => Outputable.Outputable (HsBinds.HsBindLR idL idR)
instance (idR Data.Type.Equality.~ HsExtension.GhcPass pr, HsExtension.OutputableBndrId idL, HsExtension.OutputableBndrId idR, Outputable.Outputable (HsExtension.XXPatSynBind idL idR)) => Outputable.Outputable (HsBinds.PatSynBind idL idR)
instance GHC.Base.Functor HsBinds.RecordPatSynField
instance Outputable.Outputable a => Outputable.Outputable (HsBinds.RecordPatSynField a)
instance Data.Foldable.Foldable HsBinds.RecordPatSynField
instance Data.Traversable.Traversable HsBinds.RecordPatSynField
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsBinds.ABExport p)
instance Outputable.Outputable HsBinds.TcSpecPrag
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsBinds.Sig p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsBinds.FixitySig p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsBinds.HsIPBinds p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsBinds.IPBind p)

module HsPat

-- | Pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnBang</a></li>
--   </ul>
data Pat p

-- | Wildcard Pattern The sole reason for a type on a WildPat is to support
--   hsPatType :: Pat Id -&gt; Type
WildPat :: XWildPat p -> Pat p

-- | Variable Pattern
VarPat :: XVarPat p -> Located (IdP p) -> Pat p

-- | Lazy Pattern ^ - <a>AnnKeywordId</a> : <a>AnnTilde</a>
LazyPat :: XLazyPat p -> LPat p -> Pat p

-- | As pattern ^ - <a>AnnKeywordId</a> : <a>AnnAt</a>
AsPat :: XAsPat p -> Located (IdP p) -> LPat p -> Pat p

-- | Parenthesised pattern See Note [Parens in HsSyn] in HsExpr ^ -
--   <a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt>
ParPat :: XParPat p -> LPat p -> Pat p

-- | Bang pattern ^ - <a>AnnKeywordId</a> : <a>AnnBang</a>
BangPat :: XBangPat p -> LPat p -> Pat p

-- | Syntactic List
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
ListPat :: XListPat p -> [LPat p] -> Pat p

-- | Tuple sub-patterns
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt> or
--   <tt>'(#'</tt>, <a>AnnClose</a> <tt>')'</tt> or <tt>'#)'</tt></li>
--   </ul>
TuplePat :: XTuplePat p -> [LPat p] -> Boxity -> Pat p

-- | Anonymous sum pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnClose</a> <tt>'#)'</tt></li>
--   </ul>
SumPat :: XSumPat p -> LPat p -> ConTag -> Arity -> Pat p

-- | Constructor Pattern In
ConPatIn :: Located (IdP p) -> HsConPatDetails p -> Pat p

-- | Constructor Pattern Out
ConPatOut :: Located ConLike -> [Type] -> [TyVar] -> [EvVar] -> TcEvBinds -> HsConPatDetails p -> HsWrapper -> Pat p
[pat_con] :: Pat p -> Located ConLike
[pat_arg_tys] :: Pat p -> [Type]
[pat_tvs] :: Pat p -> [TyVar]
[pat_dicts] :: Pat p -> [EvVar]
[pat_binds] :: Pat p -> TcEvBinds
[pat_args] :: Pat p -> HsConPatDetails p
[pat_wrap] :: Pat p -> HsWrapper

-- | View Pattern
ViewPat :: XViewPat p -> LHsExpr p -> LPat p -> Pat p

-- | Splice Pattern (Includes quasi-quotes)
SplicePat :: XSplicePat p -> HsSplice p -> Pat p

-- | Literal Pattern Used for *non-overloaded* literal patterns: Int, Int,
--   Char, String, etc.
LitPat :: XLitPat p -> HsLit p -> Pat p

-- | Natural Pattern
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnVal</a> <tt><a>+</a></tt></li>
--   </ul>
NPat :: XNPat p -> Located (HsOverLit p) -> Maybe (SyntaxExpr p) -> SyntaxExpr p -> Pat p

-- | n+k pattern
NPlusKPat :: XNPlusKPat p -> Located (IdP p) -> Located (HsOverLit p) -> HsOverLit p -> SyntaxExpr p -> SyntaxExpr p -> Pat p

-- | Pattern with a type signature
SigPat :: XSigPat p -> LPat p -> LHsSigWcType (NoGhcTc p) -> Pat p

-- | Coercion Pattern
CoPat :: XCoPat p -> HsWrapper -> Pat p -> Type -> Pat p

-- | Trees that Grow extension point for new constructors
XPat :: XXPat p -> Pat p
type InPat p = LPat p
type OutPat p = LPat p
type LPat p = Pat p
data ListPatTc
ListPatTc :: Type -> Maybe (Type, SyntaxExpr GhcTc) -> ListPatTc

-- | Haskell Constructor Pattern Details
type HsConPatDetails p = HsConDetails (LPat p) (HsRecFields p (LPat p))
hsConPatArgs :: HsConPatDetails p -> [LPat p]

-- | Haskell Record Fields
--   
--   HsRecFields is used only for patterns and expressions (not data type
--   declarations)
data HsRecFields p arg
HsRecFields :: [LHsRecField p arg] -> Maybe Int -> HsRecFields p arg
[rec_flds] :: HsRecFields p arg -> [LHsRecField p arg]
[rec_dotdot] :: HsRecFields p arg -> Maybe Int

-- | Haskell Record Field
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a>,</li>
--   </ul>
--   
--   For details on above see note [Api annotations] in ApiAnnotation
data HsRecField' id arg
HsRecField :: Located id -> arg -> Bool -> HsRecField' id arg
[hsRecFieldLbl] :: HsRecField' id arg -> Located id

-- | Filled in by renamer when punning
[hsRecFieldArg] :: HsRecField' id arg -> arg

-- | Note [Punning]
[hsRecPun] :: HsRecField' id arg -> Bool

-- | Located Haskell Record Field
type LHsRecField' p arg = Located (HsRecField' p arg)

-- | Haskell Record Field
type HsRecField p arg = HsRecField' (FieldOcc p) arg

-- | Located Haskell Record Field
type LHsRecField p arg = Located (HsRecField p arg)

-- | Haskell Record Update Field
type HsRecUpdField p = HsRecField' (AmbiguousFieldOcc p) (LHsExpr p)

-- | Located Haskell Record Update Field
type LHsRecUpdField p = Located (HsRecUpdField p)
hsRecFields :: HsRecFields p arg -> [XCFieldOcc p]
hsRecFieldSel :: HsRecField pass arg -> Located (XCFieldOcc pass)
hsRecFieldId :: HsRecField GhcTc arg -> Located Id
hsRecFieldsArgs :: HsRecFields p arg -> [arg]
hsRecUpdFieldId :: HsRecField' (AmbiguousFieldOcc GhcTc) arg -> Located Id
hsRecUpdFieldOcc :: HsRecField' (AmbiguousFieldOcc GhcTc) arg -> LFieldOcc GhcTc
hsRecUpdFieldRdr :: HsRecUpdField (GhcPass p) -> Located RdrName
mkPrefixConPat :: DataCon -> [OutPat (GhcPass p)] -> [Type] -> OutPat (GhcPass p)
mkCharLitPat :: SourceText -> Char -> OutPat (GhcPass p)
mkNilPat :: Type -> OutPat (GhcPass p)
looksLazyPatBind :: HsBind (GhcPass p) -> Bool
isBangedLPat :: LPat (GhcPass p) -> Bool

-- | <tt><a>patNeedsParens</a> p pat</tt> returns <a>True</a> if the
--   pattern <tt>pat</tt> needs parentheses under precedence <tt>p</tt>.
patNeedsParens :: PprPrec -> Pat p -> Bool

-- | <tt><a>parenthesizePat</a> p pat</tt> checks if
--   <tt><a>patNeedsParens</a> p pat</tt> is true, and if so, surrounds
--   <tt>pat</tt> with a <a>ParPat</a>. Otherwise, it simply returns
--   <tt>pat</tt>.
parenthesizePat :: PprPrec -> LPat (GhcPass p) -> LPat (GhcPass p)
isIrrefutableHsPat :: OutputableBndrId (GhcPass p) => LPat (GhcPass p) -> Bool
collectEvVarsPat :: Pat GhcTc -> Bag EvVar
collectEvVarsPats :: [Pat GhcTc] -> Bag EvVar
pprParendLPat :: OutputableBndrId (GhcPass p) => PprPrec -> LPat (GhcPass p) -> SDoc
pprConArgs :: OutputableBndrId (GhcPass p) => HsConPatDetails (GhcPass p) -> SDoc
instance Data.Traversable.Traversable (HsPat.HsRecFields p)
instance Data.Foldable.Foldable (HsPat.HsRecFields p)
instance GHC.Base.Functor (HsPat.HsRecFields p)
instance Data.Traversable.Traversable (HsPat.HsRecField' id)
instance Data.Foldable.Foldable (HsPat.HsRecField' id)
instance GHC.Base.Functor (HsPat.HsRecField' id)
instance (Data.Data.Data id, Data.Data.Data arg) => Data.Data.Data (HsPat.HsRecField' id arg)
instance SrcLoc.HasSrcSpan (HsPat.LPat (HsExtension.GhcPass p))
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsPat.Pat p)
instance Outputable.Outputable arg => Outputable.Outputable (HsPat.HsRecFields p arg)
instance (Outputable.Outputable p, Outputable.Outputable arg) => Outputable.Outputable (HsPat.HsRecField' p arg)


-- | Abstract syntax of global declarations.
--   
--   Definitions for: <tt>SynDecl</tt> and <tt>ConDecl</tt>,
--   <tt>ClassDecl</tt>, <tt>InstDecl</tt>, <tt>DefaultDecl</tt> and
--   <tt>ForeignDecl</tt>.
module HsDecls

-- | A Haskell Declaration
data HsDecl p

-- | Type or Class Declaration
TyClD :: XTyClD p -> TyClDecl p -> HsDecl p

-- | Instance declaration
InstD :: XInstD p -> InstDecl p -> HsDecl p

-- | Deriving declaration
DerivD :: XDerivD p -> DerivDecl p -> HsDecl p

-- | Value declaration
ValD :: XValD p -> HsBind p -> HsDecl p

-- | Signature declaration
SigD :: XSigD p -> Sig p -> HsDecl p

-- | 'default' declaration
DefD :: XDefD p -> DefaultDecl p -> HsDecl p

-- | Foreign declaration
ForD :: XForD p -> ForeignDecl p -> HsDecl p

-- | Warning declaration
WarningD :: XWarningD p -> WarnDecls p -> HsDecl p

-- | Annotation declaration
AnnD :: XAnnD p -> AnnDecl p -> HsDecl p

-- | Rule declaration
RuleD :: XRuleD p -> RuleDecls p -> HsDecl p

-- | Splice declaration (Includes quasi-quotes)
SpliceD :: XSpliceD p -> SpliceDecl p -> HsDecl p

-- | Documentation comment declaration
DocD :: XDocD p -> DocDecl -> HsDecl p

-- | Role annotation declaration
RoleAnnotD :: XRoleAnnotD p -> RoleAnnotDecl p -> HsDecl p
XHsDecl :: XXHsDecl p -> HsDecl p
type LHsDecl p = Located (HsDecl p) " When in a list this may have  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi' "

-- | Haskell Data type Definition
data HsDataDefn pass

-- | Declares a data type or newtype, giving its constructors <tt>
--   data/newtype T a = <a>constrs</a> data/newtype instance T [a] =
--   <a>constrs</a> </tt>
HsDataDefn :: XCHsDataDefn pass -> NewOrData -> LHsContext pass -> Maybe (Located CType) -> Maybe (LHsKind pass) -> [LConDecl pass] -> HsDeriving pass -> HsDataDefn pass
[dd_ext] :: HsDataDefn pass -> XCHsDataDefn pass
[dd_ND] :: HsDataDefn pass -> NewOrData

-- | Context
[dd_ctxt] :: HsDataDefn pass -> LHsContext pass
[dd_cType] :: HsDataDefn pass -> Maybe (Located CType)

-- | Optional kind signature.
--   
--   <tt>(Just k)</tt> for a GADT-style <tt>data</tt>, or <tt>data
--   instance</tt> decl, with explicit kind sig
--   
--   Always <tt>Nothing</tt> for H98-syntax decls
[dd_kindSig] :: HsDataDefn pass -> Maybe (LHsKind pass)

-- | Data constructors
--   
--   For <tt>data T a = T1 | T2 a</tt> the <a>LConDecl</a>s all have
--   <a>ConDeclH98</a>. For <tt>data T a where { T1 :: T a }</tt> the
--   <tt>LConDecls</tt> all have <a>ConDeclGADT</a>.
[dd_cons] :: HsDataDefn pass -> [LConDecl pass]

-- | Optional 'deriving' claues
[dd_derivs] :: HsDataDefn pass -> HsDeriving pass
XHsDataDefn :: XXHsDataDefn pass -> HsDataDefn pass

-- | Haskell Deriving clause
type HsDeriving pass = Located [LHsDerivingClause pass] " The optional @deriving@ clauses of a data declaration. "Clauses" is plural because one can specify multiple deriving clauses using the @-XDerivingStrategies@ language extension.  The list of 'LHsDerivingClause's corresponds to exactly what the user requested to derive, in order. If no deriving clauses were specified, the list is empty."
type LHsFunDep pass = Located (FunDep (Located (IdP pass)))

-- | A single <tt>deriving</tt> clause of a data declaration.
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDeriving</a>, <a>AnnStock</a>,
--   <a>AnnAnyClass</a>, <a>AnnNewtype</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
data HsDerivingClause pass
HsDerivingClause :: XCHsDerivingClause pass -> Maybe (LDerivStrategy pass) -> Located [LHsSigType pass] -> HsDerivingClause pass
[deriv_clause_ext] :: HsDerivingClause pass -> XCHsDerivingClause pass

-- | The user-specified strategy (if any) to use when deriving
--   <a>deriv_clause_tys</a>.
[deriv_clause_strategy] :: HsDerivingClause pass -> Maybe (LDerivStrategy pass)

-- | The types to derive.
--   
--   It uses <a>LHsSigType</a>s because, with
--   <tt>-XGeneralizedNewtypeDeriving</tt>, we can mention type variables
--   that aren't bound by the datatype, e.g.
--   
--   <pre>
--   data T b = ... deriving (C [a])
--   </pre>
--   
--   should produce a derived instance for <tt>C [a] (T b)</tt>.
[deriv_clause_tys] :: HsDerivingClause pass -> Located [LHsSigType pass]
XHsDerivingClause :: XXHsDerivingClause pass -> HsDerivingClause pass
type LHsDerivingClause pass = Located (HsDerivingClause pass)
data NewOrData

-- | <pre>
--   newtype Blah ...
--   </pre>
NewType :: NewOrData

-- | <pre>
--   data Blah ...
--   </pre>
DataType :: NewOrData

-- | Convert a <a>NewOrData</a> to a <a>TyConFlavour</a>
newOrDataToFlavour :: NewOrData -> TyConFlavour

-- | A type or class declaration.
data TyClDecl pass

-- | <pre>
--   type/data family T :: *-&gt;*
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnData</a>,
--   <a>AnnFamily</a>,<a>AnnDcolon</a>, <a>AnnWhere</a>,<a>AnnOpenP</a>,
--   <a>AnnDcolon</a>,<a>AnnCloseP</a>, <a>AnnEqual</a>,<a>AnnRarrow</a>,
--   <a>AnnVbar</a></li>
--   </ul>
FamDecl :: XFamDecl pass -> FamilyDecl pass -> TyClDecl pass
[tcdFExt] :: TyClDecl pass -> XFamDecl pass
[tcdFam] :: TyClDecl pass -> FamilyDecl pass

-- | <tt>type</tt> declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnEqual</a>,</li>
--   </ul>
SynDecl :: XSynDecl pass -> Located (IdP pass) -> LHsQTyVars pass -> LexicalFixity -> LHsType pass -> TyClDecl pass

-- | Post renameer, FVs
[tcdSExt] :: TyClDecl pass -> XSynDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> Located (IdP pass)

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity
[tcdRhs] :: TyClDecl pass -> LHsType pass

-- | <tt>data</tt> declaration
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnData</a>, <a>AnnFamily</a>,
--   <a>AnnNewType</a>, <a>AnnNewType</a>,<a>AnnDcolon</a>
--   <a>AnnWhere</a>,</li>
--   </ul>
DataDecl :: XDataDecl pass -> Located (IdP pass) -> LHsQTyVars pass -> LexicalFixity -> HsDataDefn pass -> TyClDecl pass

-- | Post renamer, CUSK flag, FVs
[tcdDExt] :: TyClDecl pass -> XDataDecl pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> Located (IdP pass)

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity
[tcdDataDefn] :: TyClDecl pass -> HsDataDefn pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnClass</a>,
--   <a>AnnWhere</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   <li>The tcdFDs will have <a>AnnVbar</a>, <a>AnnComma</a>
--   <a>AnnRarrow</a></li>
--   </ul>
ClassDecl :: XClassDecl pass -> LHsContext pass -> Located (IdP pass) -> LHsQTyVars pass -> LexicalFixity -> [LHsFunDep pass] -> [LSig pass] -> LHsBinds pass -> [LFamilyDecl pass] -> [LTyFamDefltEqn pass] -> [LDocDecl] -> TyClDecl pass

-- | Post renamer, FVs
[tcdCExt] :: TyClDecl pass -> XClassDecl pass

-- | Context...
[tcdCtxt] :: TyClDecl pass -> LHsContext pass

-- | Type constructor
[tcdLName] :: TyClDecl pass -> Located (IdP pass)

-- | Type variables; for an associated type these include outer binders
[tcdTyVars] :: TyClDecl pass -> LHsQTyVars pass

-- | Fixity used in the declaration
[tcdFixity] :: TyClDecl pass -> LexicalFixity

-- | Functional deps
[tcdFDs] :: TyClDecl pass -> [LHsFunDep pass]

-- | Methods' signatures
[tcdSigs] :: TyClDecl pass -> [LSig pass]

-- | Default methods
[tcdMeths] :: TyClDecl pass -> LHsBinds pass

-- | Associated types;
[tcdATs] :: TyClDecl pass -> [LFamilyDecl pass]

-- | Associated type defaults
[tcdATDefs] :: TyClDecl pass -> [LTyFamDefltEqn pass]

-- | Haddock docs
[tcdDocs] :: TyClDecl pass -> [LDocDecl]
XTyClDecl :: XXTyClDecl pass -> TyClDecl pass

-- | Located Declaration of a Type or Class
type LTyClDecl pass = Located (TyClDecl pass)
data DataDeclRn
DataDeclRn :: Bool -> NameSet -> DataDeclRn

-- | does this have a CUSK?
[tcdDataCusk] :: DataDeclRn -> Bool
[tcdFVs] :: DataDeclRn -> NameSet

-- | Type or Class Group
data TyClGroup pass
TyClGroup :: XCTyClGroup pass -> [LTyClDecl pass] -> [LRoleAnnotDecl pass] -> [LInstDecl pass] -> TyClGroup pass
[group_ext] :: TyClGroup pass -> XCTyClGroup pass
[group_tyclds] :: TyClGroup pass -> [LTyClDecl pass]
[group_roles] :: TyClGroup pass -> [LRoleAnnotDecl pass]
[group_instds] :: TyClGroup pass -> [LInstDecl pass]
XTyClGroup :: XXTyClGroup pass -> TyClGroup pass
mkTyClGroup :: [LTyClDecl (GhcPass p)] -> [LInstDecl (GhcPass p)] -> TyClGroup (GhcPass p)
emptyTyClGroup :: TyClGroup (GhcPass p)
tyClGroupTyClDecls :: [TyClGroup pass] -> [LTyClDecl pass]
tyClGroupInstDecls :: [TyClGroup pass] -> [LInstDecl pass]
tyClGroupRoleDecls :: [TyClGroup pass] -> [LRoleAnnotDecl pass]

-- | type class
isClassDecl :: TyClDecl pass -> Bool

-- | <tt>True</tt> <a>=</a> argument is a <tt>data</tt>/<tt>newtype</tt>
--   declaration.
isDataDecl :: TyClDecl pass -> Bool

-- | type or type instance declaration
isSynDecl :: TyClDecl pass -> Bool
tcdName :: TyClDecl pass -> IdP pass

-- | type/data family declaration
isFamilyDecl :: TyClDecl pass -> Bool

-- | type family declaration
isTypeFamilyDecl :: TyClDecl pass -> Bool

-- | data family declaration
isDataFamilyDecl :: TyClDecl pass -> Bool

-- | open type family info
isOpenTypeFamilyInfo :: FamilyInfo pass -> Bool

-- | closed type family info
isClosedTypeFamilyInfo :: FamilyInfo pass -> Bool
tyFamInstDeclName :: TyFamInstDecl pass -> IdP pass
tyFamInstDeclLName :: TyFamInstDecl pass -> Located (IdP pass)
countTyClDecls :: [TyClDecl pass] -> (Int, Int, Int, Int, Int)
pprTyClDeclFlavour :: TyClDecl (GhcPass p) -> SDoc
tyClDeclLName :: TyClDecl pass -> Located (IdP pass)
tyClDeclTyVars :: TyClDecl pass -> LHsQTyVars pass

-- | Does this declaration have a complete, user-supplied kind signature?
--   See Note [CUSKs: complete user-supplied kind signatures]
hsDeclHasCusk :: TyClDecl GhcRn -> Bool

-- | Does this family declaration have a complete, user-supplied kind
--   signature? See Note [CUSKs: complete user-supplied kind signatures]
famDeclHasCusk :: Maybe Bool -> FamilyDecl pass -> Bool

-- | type Family Declaration
data FamilyDecl pass
FamilyDecl :: XCFamilyDecl pass -> FamilyInfo pass -> Located (IdP pass) -> LHsQTyVars pass -> LexicalFixity -> LFamilyResultSig pass -> Maybe (LInjectivityAnn pass) -> FamilyDecl pass
[fdExt] :: FamilyDecl pass -> XCFamilyDecl pass
[fdInfo] :: FamilyDecl pass -> FamilyInfo pass
[fdLName] :: FamilyDecl pass -> Located (IdP pass)
[fdTyVars] :: FamilyDecl pass -> LHsQTyVars pass
[fdFixity] :: FamilyDecl pass -> LexicalFixity
[fdResultSig] :: FamilyDecl pass -> LFamilyResultSig pass
[fdInjectivityAnn] :: FamilyDecl pass -> Maybe (LInjectivityAnn pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnData</a>,
--   <a>AnnFamily</a>, <a>AnnWhere</a>, <a>AnnOpenP</a>, <a>AnnDcolon</a>,
--   <a>AnnCloseP</a>, <a>AnnEqual</a>, <a>AnnRarrow</a>,
--   <a>AnnVbar</a></li>
--   </ul>
XFamilyDecl :: XXFamilyDecl pass -> FamilyDecl pass

-- | Located type Family Declaration
type LFamilyDecl pass = Located (FamilyDecl pass)

-- | Instance Declaration
data InstDecl pass
ClsInstD :: XClsInstD pass -> ClsInstDecl pass -> InstDecl pass
[cid_d_ext] :: InstDecl pass -> XClsInstD pass
[cid_inst] :: InstDecl pass -> ClsInstDecl pass
DataFamInstD :: XDataFamInstD pass -> DataFamInstDecl pass -> InstDecl pass
[dfid_ext] :: InstDecl pass -> XDataFamInstD pass
[dfid_inst] :: InstDecl pass -> DataFamInstDecl pass
TyFamInstD :: XTyFamInstD pass -> TyFamInstDecl pass -> InstDecl pass
[tfid_ext] :: InstDecl pass -> XTyFamInstD pass
[tfid_inst] :: InstDecl pass -> TyFamInstDecl pass
XInstDecl :: XXInstDecl pass -> InstDecl pass

-- | Located Instance Declaration
type LInstDecl pass = Located (InstDecl pass)
data FamilyInfo pass
DataFamily :: FamilyInfo pass
OpenTypeFamily :: FamilyInfo pass

-- | <a>Nothing</a> if we're in an hs-boot file and the user said "type
--   family Foo x where .."
ClosedTypeFamily :: Maybe [LTyFamInstEqn pass] -> FamilyInfo pass

-- | Type Family Instance Declaration
newtype TyFamInstDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnInstance</a>,</li>
--   </ul>
TyFamInstDecl :: TyFamInstEqn pass -> TyFamInstDecl pass
[tfid_eqn] :: TyFamInstDecl pass -> TyFamInstEqn pass

-- | Located Type Family Instance Declaration
type LTyFamInstDecl pass = Located (TyFamInstDecl pass)
instDeclDataFamInsts :: [LInstDecl pass] -> [DataFamInstDecl pass]

-- | Data Family Instance Declaration
newtype DataFamInstDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnData</a>,
--   <a>AnnNewType</a>,<a>AnnInstance</a>, <a>AnnDcolon</a>
--   <a>AnnWhere</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
DataFamInstDecl :: FamInstEqn pass (HsDataDefn pass) -> DataFamInstDecl pass
[dfid_eqn] :: DataFamInstDecl pass -> FamInstEqn pass (HsDataDefn pass)

-- | Located Data Family Instance Declaration
type LDataFamInstDecl pass = Located (DataFamInstDecl pass)
pprDataFamInstFlavour :: DataFamInstDecl (GhcPass p) -> SDoc
pprHsFamInstLHS :: OutputableBndrId (GhcPass p) => IdP (GhcPass p) -> Maybe [LHsTyVarBndr (GhcPass p)] -> HsTyPats (GhcPass p) -> LexicalFixity -> LHsContext (GhcPass p) -> SDoc

-- | Family Instance Equation
type FamInstEqn pass rhs = HsImplicitBndrs pass (FamEqn pass (HsTyPats pass) rhs) " Here, the @pats@ are type patterns (with kind and type bndrs). See Note [Family instance declaration binders]"

-- | Located Family Instance Equation
type LFamInstEqn pass rhs = Located (FamInstEqn pass rhs)

-- | Family Equation
--   
--   One equation in a type family instance declaration, data family
--   instance declaration, or type family default. See Note [Type family
--   instance declarations in HsSyn] See Note [Family instance declaration
--   binders]
data FamEqn pass pats rhs

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnEqual</a></li>
--   </ul>
FamEqn :: XCFamEqn pass pats rhs -> Located (IdP pass) -> Maybe [LHsTyVarBndr pass] -> pats -> LexicalFixity -> rhs -> FamEqn pass pats rhs
[feqn_ext] :: FamEqn pass pats rhs -> XCFamEqn pass pats rhs
[feqn_tycon] :: FamEqn pass pats rhs -> Located (IdP pass)

-- | Optional quantified type vars
[feqn_bndrs] :: FamEqn pass pats rhs -> Maybe [LHsTyVarBndr pass]
[feqn_pats] :: FamEqn pass pats rhs -> pats

-- | Fixity used in the declaration
[feqn_fixity] :: FamEqn pass pats rhs -> LexicalFixity
[feqn_rhs] :: FamEqn pass pats rhs -> rhs
XFamEqn :: XXFamEqn pass pats rhs -> FamEqn pass pats rhs

-- | Type Family Instance Equation
type TyFamInstEqn pass = FamInstEqn pass (LHsType pass)

-- | Located Type Family Instance Equation
type LTyFamInstEqn pass = Located (TyFamInstEqn pass) " May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi' when in a list"

-- | Type Family Default Equation
type TyFamDefltEqn pass = FamEqn pass (LHsQTyVars pass) (LHsType pass)

-- | Located Type Family Default Equation
type LTyFamDefltEqn pass = Located (TyFamDefltEqn pass)

-- | Haskell Type Patterns
type HsTyPats pass = [LHsTypeArg pass]

-- | Located Class Instance Declaration
type LClsInstDecl pass = Located (ClsInstDecl pass)

-- | Class Instance Declaration
data ClsInstDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnInstance</a>, <a>AnnWhere</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a>,</li>
--   </ul>
ClsInstDecl :: XCClsInstDecl pass -> LHsSigType pass -> LHsBinds pass -> [LSig pass] -> [LTyFamInstDecl pass] -> [LDataFamInstDecl pass] -> Maybe (Located OverlapMode) -> ClsInstDecl pass
[cid_ext] :: ClsInstDecl pass -> XCClsInstDecl pass
[cid_poly_ty] :: ClsInstDecl pass -> LHsSigType pass
[cid_binds] :: ClsInstDecl pass -> LHsBinds pass
[cid_sigs] :: ClsInstDecl pass -> [LSig pass]
[cid_tyfam_insts] :: ClsInstDecl pass -> [LTyFamInstDecl pass]
[cid_datafam_insts] :: ClsInstDecl pass -> [LDataFamInstDecl pass]

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnClose</a>,</li>
--   </ul>
[cid_overlap_mode] :: ClsInstDecl pass -> Maybe (Located OverlapMode)
XClsInstDecl :: XXClsInstDecl pass -> ClsInstDecl pass

-- | Stand-alone 'deriving instance' declaration
data DerivDecl pass
DerivDecl :: XCDerivDecl pass -> LHsSigWcType pass -> Maybe (LDerivStrategy pass) -> Maybe (Located OverlapMode) -> DerivDecl pass
[deriv_ext] :: DerivDecl pass -> XCDerivDecl pass

-- | The instance type to derive.
--   
--   It uses an <a>LHsSigWcType</a> because the context is allowed to be a
--   single wildcard:
--   
--   <pre>
--   deriving instance _ =&gt; Eq (Foo a)
--   </pre>
--   
--   Which signifies that the context should be inferred.
[deriv_type] :: DerivDecl pass -> LHsSigWcType pass
[deriv_strategy] :: DerivDecl pass -> Maybe (LDerivStrategy pass)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDeriving</a>, <a>AnnInstance</a>,
--   <a>AnnStock</a>, <a>AnnAnyClass</a>, <a>AnnNewtype</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
[deriv_overlap_mode] :: DerivDecl pass -> Maybe (Located OverlapMode)
XDerivDecl :: XXDerivDecl pass -> DerivDecl pass

-- | Located stand-alone 'deriving instance' declaration
type LDerivDecl pass = Located (DerivDecl pass)

-- | Which technique the user explicitly requested when deriving an
--   instance.
data DerivStrategy pass

-- | GHC's "standard" strategy, which is to implement a custom instance for
--   the data type. This only works for certain types that GHC knows about
--   (e.g., <a>Eq</a>, <a>Show</a>, <a>Functor</a> when
--   <tt>-XDeriveFunctor</tt> is enabled, etc.)
StockStrategy :: DerivStrategy pass

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: DerivStrategy pass

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: DerivStrategy pass

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: XViaStrategy pass -> DerivStrategy pass

-- | A <a>Located</a> <a>DerivStrategy</a>.
type LDerivStrategy pass = Located (DerivStrategy pass)

-- | A short description of a <tt>DerivStrategy'</tt>.
derivStrategyName :: DerivStrategy a -> SDoc

-- | Located Rule Declarations
type LRuleDecls pass = Located (RuleDecls pass)

-- | Rule Declarations
data RuleDecls pass
HsRules :: XCRuleDecls pass -> SourceText -> [LRuleDecl pass] -> RuleDecls pass
[rds_ext] :: RuleDecls pass -> XCRuleDecls pass
[rds_src] :: RuleDecls pass -> SourceText
[rds_rules] :: RuleDecls pass -> [LRuleDecl pass]
XRuleDecls :: XXRuleDecls pass -> RuleDecls pass

-- | Rule Declaration
data RuleDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,<a>AnnTilde</a>,
--   <a>AnnVal</a>, <a>AnnClose</a>, <a>AnnForall</a>,<a>AnnDot</a>,
--   <a>AnnEqual</a>,</li>
--   </ul>
HsRule :: XHsRule pass -> Located (SourceText, RuleName) -> Activation -> Maybe [LHsTyVarBndr (NoGhcTc pass)] -> [LRuleBndr pass] -> Located (HsExpr pass) -> Located (HsExpr pass) -> RuleDecl pass

-- | After renamer, free-vars from the LHS and RHS
[rd_ext] :: RuleDecl pass -> XHsRule pass

-- | Note [Pragma source text] in BasicTypes
[rd_name] :: RuleDecl pass -> Located (SourceText, RuleName)
[rd_act] :: RuleDecl pass -> Activation

-- | Forall'd type vars
[rd_tyvs] :: RuleDecl pass -> Maybe [LHsTyVarBndr (NoGhcTc pass)]

-- | Forall'd term vars, before typechecking; after typechecking this
--   includes all forall'd vars
[rd_tmvs] :: RuleDecl pass -> [LRuleBndr pass]
[rd_lhs] :: RuleDecl pass -> Located (HsExpr pass)
[rd_rhs] :: RuleDecl pass -> Located (HsExpr pass)
XRuleDecl :: XXRuleDecl pass -> RuleDecl pass

-- | Located Rule Declaration
type LRuleDecl pass = Located (RuleDecl pass)
data HsRuleRn
HsRuleRn :: NameSet -> NameSet -> HsRuleRn

-- | Rule Binder
data RuleBndr pass
RuleBndr :: XCRuleBndr pass -> Located (IdP pass) -> RuleBndr pass
RuleBndrSig :: XRuleBndrSig pass -> Located (IdP pass) -> LHsSigWcType pass -> RuleBndr pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnDcolon</a>,<a>AnnClose</a></li>
--   </ul>
XRuleBndr :: XXRuleBndr pass -> RuleBndr pass

-- | Located Rule Binder
type LRuleBndr pass = Located (RuleBndr pass)
collectRuleBndrSigTys :: [RuleBndr pass] -> [LHsSigWcType pass]
flattenRuleDecls :: [LRuleDecls pass] -> [LRuleDecl pass]
pprFullRuleName :: Located (SourceText, RuleName) -> SDoc

-- | Default Declaration
data DefaultDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnDefault</a>,
--   <a>AnnOpen</a>,<a>AnnClose</a></li>
--   </ul>
DefaultDecl :: XCDefaultDecl pass -> [LHsType pass] -> DefaultDecl pass
XDefaultDecl :: XXDefaultDecl pass -> DefaultDecl pass

-- | Located Default Declaration
type LDefaultDecl pass = Located (DefaultDecl pass)
data SpliceExplicitFlag

-- | <a>=</a> $(f x y)
ExplicitSplice :: SpliceExplicitFlag

-- | <a>=</a> f x y, i.e. a naked top level expression
ImplicitSplice :: SpliceExplicitFlag

-- | Splice Declaration
data SpliceDecl p
SpliceDecl :: XSpliceDecl p -> Located (HsSplice p) -> SpliceExplicitFlag -> SpliceDecl p
XSpliceDecl :: XXSpliceDecl p -> SpliceDecl p

-- | Located Splice Declaration
type LSpliceDecl pass = Located (SpliceDecl pass)

-- | Foreign Declaration
data ForeignDecl pass
ForeignImport :: XForeignImport pass -> Located (IdP pass) -> LHsSigType pass -> ForeignImport -> ForeignDecl pass
[fd_i_ext] :: ForeignDecl pass -> XForeignImport pass
[fd_name] :: ForeignDecl pass -> Located (IdP pass)
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fi] :: ForeignDecl pass -> ForeignImport

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnForeign</a>,
--   <a>AnnImport</a>,<a>AnnExport</a>, <a>AnnDcolon</a></li>
--   </ul>
ForeignExport :: XForeignExport pass -> Located (IdP pass) -> LHsSigType pass -> ForeignExport -> ForeignDecl pass
[fd_e_ext] :: ForeignDecl pass -> XForeignExport pass
[fd_name] :: ForeignDecl pass -> Located (IdP pass)
[fd_sig_ty] :: ForeignDecl pass -> LHsSigType pass
[fd_fe] :: ForeignDecl pass -> ForeignExport
XForeignDecl :: XXForeignDecl pass -> ForeignDecl pass

-- | Located Foreign Declaration
type LForeignDecl pass = Located (ForeignDecl pass)
data ForeignImport
CImport :: Located CCallConv -> Located Safety -> Maybe Header -> CImportSpec -> Located SourceText -> ForeignImport
data ForeignExport
CExport :: Located CExportSpec -> Located SourceText -> ForeignExport
data CImportSpec
CLabel :: CLabelString -> CImportSpec
CFunction :: CCallTarget -> CImportSpec
CWrapper :: CImportSpec

-- | <pre>
--   data T b = forall a. Eq a =&gt; MkT a b
--     MkT :: forall b a. Eq a =&gt; MkT a b
--   
--   data T b where
--        MkT1 :: Int -&gt; T Int
--   
--   data T = Int <tt>MkT</tt> Int
--          | MkT2
--   
--   data T a where
--        Int <tt>MkT</tt> Int :: T Int
--   </pre>
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a>,
--   <a>AnnDotdot</a>,<a>AnnCLose</a>, <a>AnnEqual</a>,<a>AnnVbar</a>,
--   <a>AnnDarrow</a>,<a>AnnDarrow</a>, <a>AnnForall</a>,<a>AnnDot</a></li>
--   </ul>
--   
--   data Constructor Declaration
data ConDecl pass
ConDeclGADT :: XConDeclGADT pass -> [Located (IdP pass)] -> Located Bool -> LHsQTyVars pass -> Maybe (LHsContext pass) -> HsConDeclDetails pass -> LHsType pass -> Maybe LHsDocString -> ConDecl pass
[con_g_ext] :: ConDecl pass -> XConDeclGADT pass
[con_names] :: ConDecl pass -> [Located (IdP pass)]

-- | True <a>=</a> explicit forall False =&gt; hsq_explicit is empty
[con_forall] :: ConDecl pass -> Located Bool
[con_qvars] :: ConDecl pass -> LHsQTyVars pass

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; never InfixCon
[con_args] :: ConDecl pass -> HsConDeclDetails pass

-- | Result type
[con_res_ty] :: ConDecl pass -> LHsType pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe LHsDocString
ConDeclH98 :: XConDeclH98 pass -> Located (IdP pass) -> Located Bool -> [LHsTyVarBndr pass] -> Maybe (LHsContext pass) -> HsConDeclDetails pass -> Maybe LHsDocString -> ConDecl pass
[con_ext] :: ConDecl pass -> XConDeclH98 pass
[con_name] :: ConDecl pass -> Located (IdP pass)

-- | True <a>=</a> explicit forall False =&gt; hsq_explicit is empty
[con_forall] :: ConDecl pass -> Located Bool

-- | Existentials only
[con_ex_tvs] :: ConDecl pass -> [LHsTyVarBndr pass]

-- | User-written context (if any)
[con_mb_cxt] :: ConDecl pass -> Maybe (LHsContext pass)

-- | Arguments; never InfixCon
[con_args] :: ConDecl pass -> HsConDeclDetails pass

-- | A possible Haddock comment.
[con_doc] :: ConDecl pass -> Maybe LHsDocString
XConDecl :: XXConDecl pass -> ConDecl pass

-- | Located data Constructor Declaration
type LConDecl pass = Located (ConDecl pass) " May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi' when in a GADT constructor list"

-- | Haskell data Constructor Declaration Details
type HsConDeclDetails pass = HsConDetails (LBangType pass) (Located [LConDeclField pass])
hsConDeclArgTys :: HsConDeclDetails pass -> [LBangType pass]
hsConDeclTheta :: Maybe (LHsContext pass) -> [LHsType pass]
getConNames :: ConDecl pass -> [Located (IdP pass)]
getConArgs :: ConDecl pass -> HsConDeclDetails pass

-- | Documentation comment Declaration
data DocDecl
DocCommentNext :: HsDocString -> DocDecl
DocCommentPrev :: HsDocString -> DocDecl
DocCommentNamed :: String -> HsDocString -> DocDecl
DocGroup :: Int -> HsDocString -> DocDecl

-- | Located Documentation comment Declaration
type LDocDecl = Located (DocDecl)
docDeclDoc :: DocDecl -> HsDocString

-- | Warning pragma Declaration
data WarnDecl pass
Warning :: XWarning pass -> [Located (IdP pass)] -> WarningTxt -> WarnDecl pass
XWarnDecl :: XXWarnDecl pass -> WarnDecl pass

-- | Located Warning pragma Declaration
type LWarnDecl pass = Located (WarnDecl pass)

-- | Warning pragma Declarations
data WarnDecls pass
Warnings :: XWarnings pass -> SourceText -> [LWarnDecl pass] -> WarnDecls pass
[wd_ext] :: WarnDecls pass -> XWarnings pass
[wd_src] :: WarnDecls pass -> SourceText
[wd_warnings] :: WarnDecls pass -> [LWarnDecl pass]
XWarnDecls :: XXWarnDecls pass -> WarnDecls pass

-- | Located Warning Declarations
type LWarnDecls pass = Located (WarnDecls pass)

-- | Annotation Declaration
data AnnDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnType</a>
--   <a>AnnModule</a> <a>AnnClose</a></li>
--   </ul>
HsAnnotation :: XHsAnnotation pass -> SourceText -> AnnProvenance (IdP pass) -> Located (HsExpr pass) -> AnnDecl pass
XAnnDecl :: XXAnnDecl pass -> AnnDecl pass

-- | Located Annotation Declaration
type LAnnDecl pass = Located (AnnDecl pass)

-- | Annotation Provenance
data AnnProvenance name
ValueAnnProvenance :: Located name -> AnnProvenance name
TypeAnnProvenance :: Located name -> AnnProvenance name
ModuleAnnProvenance :: AnnProvenance name
annProvenanceName_maybe :: AnnProvenance name -> Maybe name

-- | Role Annotation Declaration
data RoleAnnotDecl pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnType</a>, <a>AnnRole</a></li>
--   </ul>
RoleAnnotDecl :: XCRoleAnnotDecl pass -> Located (IdP pass) -> [Located (Maybe Role)] -> RoleAnnotDecl pass
XRoleAnnotDecl :: XXRoleAnnotDecl pass -> RoleAnnotDecl pass

-- | Located Role Annotation Declaration
type LRoleAnnotDecl pass = Located (RoleAnnotDecl pass)
roleAnnotDeclName :: RoleAnnotDecl pass -> IdP pass

-- | type Family Result Signature
data FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> :</li>
--   </ul>
NoSig :: XNoSig pass -> FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenP</a>,<a>AnnDcolon</a>,
--   <a>AnnCloseP</a></li>
--   </ul>
KindSig :: XCKindSig pass -> LHsKind pass -> FamilyResultSig pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenP</a>,<a>AnnDcolon</a>,
--   <a>AnnCloseP</a>, <a>AnnEqual</a></li>
--   </ul>
TyVarSig :: XTyVarSig pass -> LHsTyVarBndr pass -> FamilyResultSig pass
XFamilyResultSig :: XXFamilyResultSig pass -> FamilyResultSig pass

-- | Located type Family Result Signature
type LFamilyResultSig pass = Located (FamilyResultSig pass)

-- | If the user supplied an injectivity annotation it is represented using
--   InjectivityAnn. At the moment this is a single injectivity condition -
--   see Note [Injectivity annotation]. `Located name` stores the LHS of
--   injectivity condition. `[Located name]` stores the RHS of injectivity
--   condition. Example:
--   
--   type family Foo a b c = r | r -&gt; a c where ...
--   
--   This will be represented as "InjectivityAnn <tt>r</tt> [<tt>a</tt>,
--   <tt>c</tt>]"
data InjectivityAnn pass

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a>, <a>AnnVbar</a></li>
--   </ul>
InjectivityAnn :: Located (IdP pass) -> [Located (IdP pass)] -> InjectivityAnn pass

-- | Located Injectivity Annotation
type LInjectivityAnn pass = Located (InjectivityAnn pass)

-- | Maybe return name of the result type variable
resultVariableName :: FamilyResultSig a -> Maybe (IdP a)

-- | Haskell Group
--   
--   A <a>HsDecl</a> is categorised into a <a>HsGroup</a> before being fed
--   to the renamer.
data HsGroup p
HsGroup :: XCHsGroup p -> HsValBinds p -> [LSpliceDecl p] -> [TyClGroup p] -> [LDerivDecl p] -> [LFixitySig p] -> [LDefaultDecl p] -> [LForeignDecl p] -> [LWarnDecls p] -> [LAnnDecl p] -> [LRuleDecls p] -> [LDocDecl] -> HsGroup p
[hs_ext] :: HsGroup p -> XCHsGroup p
[hs_valds] :: HsGroup p -> HsValBinds p
[hs_splcds] :: HsGroup p -> [LSpliceDecl p]
[hs_tyclds] :: HsGroup p -> [TyClGroup p]
[hs_derivds] :: HsGroup p -> [LDerivDecl p]
[hs_fixds] :: HsGroup p -> [LFixitySig p]
[hs_defds] :: HsGroup p -> [LDefaultDecl p]
[hs_fords] :: HsGroup p -> [LForeignDecl p]
[hs_warnds] :: HsGroup p -> [LWarnDecls p]
[hs_annds] :: HsGroup p -> [LAnnDecl p]
[hs_ruleds] :: HsGroup p -> [LRuleDecls p]
[hs_docs] :: HsGroup p -> [LDocDecl]
XHsGroup :: XXHsGroup p -> HsGroup p
emptyRdrGroup :: HsGroup (GhcPass p)
emptyRnGroup :: HsGroup (GhcPass p)
appendGroups :: HsGroup (GhcPass p) -> HsGroup (GhcPass p) -> HsGroup (GhcPass p)
hsGroupInstDecls :: HsGroup id -> [LInstDecl id]
instance Data.Data.Data HsDecls.DocDecl
instance Data.Data.Data HsDecls.HsRuleRn
instance Data.Data.Data HsDecls.ForeignExport
instance Data.Data.Data HsDecls.ForeignImport
instance Data.Data.Data HsDecls.CImportSpec
instance Data.Data.Data HsDecls.NewOrData
instance GHC.Classes.Eq HsDecls.NewOrData
instance Data.Data.Data HsDecls.DataDeclRn
instance GHC.Base.Functor HsDecls.AnnProvenance
instance Data.Foldable.Foldable HsDecls.AnnProvenance
instance Data.Traversable.Traversable HsDecls.AnnProvenance
instance Data.Data.Data pass => Data.Data.Data (HsDecls.AnnProvenance pass)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.HsDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.HsGroup p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.TyClGroup p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, Outputable.OutputableBndr (HsExtension.IdP p)) => Outputable.Outputable (HsDecls.RoleAnnotDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.AnnDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, Outputable.OutputableBndr (HsExtension.IdP p)) => Outputable.Outputable (HsDecls.WarnDecls p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, Outputable.OutputableBndr (HsExtension.IdP p)) => Outputable.Outputable (HsDecls.WarnDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.TyClDecl p)
instance Outputable.Outputable HsDecls.DocDecl
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.RuleDecls p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.RuleDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.RuleBndr p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.ForeignDecl p)
instance Outputable.Outputable HsDecls.ForeignExport
instance Outputable.Outputable HsDecls.ForeignImport
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.DefaultDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.InstDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.ClsInstDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.DataFamInstDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.HsDataDefn p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.HsDerivingClause p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.DerivDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.DerivStrategy p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.FamilyDecl p)
instance Outputable.Outputable (HsDecls.FamilyInfo pass)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.TyFamInstDecl p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.ConDecl p)
instance Outputable.Outputable HsDecls.NewOrData
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsDecls.SpliceDecl p)


-- | Abstract Haskell syntax for expressions.
module HsExpr

-- | Located Haskell Expression
type LHsExpr p = Located (HsExpr p) " May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma' when in a list"

-- | Post-Type checking Expression
--   
--   PostTcExpr is an evidence expression attached to the syntax tree by
--   the type checker (c.f. postTcType).
type PostTcExpr = HsExpr GhcTc

-- | Post-Type checking Table
--   
--   We use a PostTcTable where there are a bunch of pieces of evidence,
--   more than is convenient to keep individually.
type PostTcTable = [(Name, PostTcExpr)]

-- | Syntax Expression
--   
--   SyntaxExpr is like <a>PostTcExpr</a>, but it's filled in a little
--   earlier, by the renamer. It's used for rebindable syntax.
--   
--   E.g. <tt>(&gt;&gt;=)</tt> is filled in before the renamer by the
--   appropriate <a>Name</a> for <tt>(&gt;&gt;=)</tt>, and then
--   instantiated by the type checker with its type args etc
--   
--   This should desugar to
--   
--   <pre>
--   syn_res_wrap $ syn_expr (syn_arg_wraps[0] arg0)
--                           (syn_arg_wraps[1] arg1) ...
--   </pre>
--   
--   where the actual arguments come from elsewhere in the AST. This could
--   be defined using <tt>GhcPass p</tt> and such, but it's harder to get
--   it all to work out that way. (<a>noSyntaxExpr</a> is hard to write,
--   for example.)
data SyntaxExpr p
SyntaxExpr :: HsExpr p -> [HsWrapper] -> HsWrapper -> SyntaxExpr p
[syn_expr] :: SyntaxExpr p -> HsExpr p
[syn_arg_wraps] :: SyntaxExpr p -> [HsWrapper]
[syn_res_wrap] :: SyntaxExpr p -> HsWrapper

-- | This is used for rebindable-syntax pieces that are too polymorphic for
--   tcSyntaxOp (trS_fmap and the mzip in ParStmt)
noExpr :: HsExpr (GhcPass p)
noSyntaxExpr :: SyntaxExpr (GhcPass p)

-- | Make a 'SyntaxExpr (HsExpr _)', missing its HsWrappers.
mkSyntaxExpr :: HsExpr (GhcPass p) -> SyntaxExpr (GhcPass p)

-- | Make a 'SyntaxExpr Name' (the "rn" is because this is used in the
--   renamer), missing its HsWrappers.
mkRnSyntaxExpr :: Name -> SyntaxExpr GhcRn

-- | Command Syntax Table (for Arrow syntax)
type CmdSyntaxTable p = [(Name, HsExpr p)]

-- | An unbound variable; used for treating out-of-scope variables as
--   expression holes
--   
--   Either "x", "y" Plain OutOfScope or "_", "_x" A TrueExprHole
--   
--   Both forms indicate an out-of-scope variable, but the latter indicates
--   that the user <i>expects</i> it to be out of scope, and just wants GHC
--   to report its type
data UnboundVar

-- | An (unqualified) out-of-scope variable, together with the GlobalRdrEnv
--   with respect to which it is unbound
OutOfScope :: OccName -> GlobalRdrEnv -> UnboundVar

-- | A "true" expression hole (_ or _x)
TrueExprHole :: OccName -> UnboundVar
unboundVarOcc :: UnboundVar -> OccName

-- | A Haskell expression.
data HsExpr p

-- | Variable
HsVar :: XVar p -> Located (IdP p) -> HsExpr p

-- | Unbound variable; also used for "holes" (_ or _x). Turned from HsVar
--   to HsUnboundVar by the renamer, when it finds an out-of-scope variable
--   or hole. Turned into HsVar by type checker, to support deferred type
--   errors.
HsUnboundVar :: XUnboundVar p -> UnboundVar -> HsExpr p

-- | After typechecker only; must be different HsVar for pretty printing
HsConLikeOut :: XConLikeOut p -> ConLike -> HsExpr p

-- | Variable pointing to record selector Not in use after typechecking
HsRecFld :: XRecFld p -> AmbiguousFieldOcc p -> HsExpr p

-- | Overloaded label (Note [Overloaded labels] in GHC.OverloadedLabels)
--   <tt>Just id</tt> means <tt>RebindableSyntax</tt> is in use, and gives
--   the id of the in-scope <tt>fromLabel</tt>. NB: Not in use after
--   typechecking
HsOverLabel :: XOverLabel p -> Maybe (IdP p) -> FastString -> HsExpr p

-- | Implicit parameter (not in use after typechecking)
HsIPVar :: XIPVar p -> HsIPName -> HsExpr p

-- | Overloaded literals
HsOverLit :: XOverLitE p -> HsOverLit p -> HsExpr p

-- | Simple (non-overloaded) literals
HsLit :: XLitE p -> HsLit p -> HsExpr p

-- | Lambda abstraction. Currently always a single match
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>, <a>AnnRarrow</a>,</li>
--   </ul>
HsLam :: XLam p -> MatchGroup p (LHsExpr p) -> HsExpr p

-- | Lambda-case
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>,
--   <a>AnnCase</a>,<a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
HsLamCase :: XLamCase p -> MatchGroup p (LHsExpr p) -> HsExpr p

-- | Application
HsApp :: XApp p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Visible type application
--   
--   Explicit type argument; e.g f @Int x y NB: Has wildcards, but no
--   implicit quantification
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnAt</a>,</li>
--   </ul>
HsAppType :: XAppTypeE p -> LHsExpr p -> LHsWcType (NoGhcTc p) -> HsExpr p

-- | Operator applications: NB Bracketed ops such as (+) come out as Vars.
OpApp :: XOpApp p -> LHsExpr p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Negation operator. Contains the negated expression and the name of
--   <a>negate</a>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnMinus</a></li>
--   </ul>
NegApp :: XNegApp p -> LHsExpr p -> SyntaxExpr p -> HsExpr p

-- | Parenthesised expr; see Note [Parens in HsSyn]
HsPar :: XPar p -> LHsExpr p -> HsExpr p
SectionL :: XSectionL p -> LHsExpr p -> LHsExpr p -> HsExpr p
SectionR :: XSectionR p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Used for explicit tuples and sections thereof
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
ExplicitTuple :: XExplicitTuple p -> [LHsTupArg p] -> Boxity -> HsExpr p

-- | Used for unboxed sum types
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'(#'</tt>,
--   <a>AnnVbar</a>, <a>AnnClose</a> <tt>'#)'</tt>,</li>
--   </ul>
--   
--   There will be multiple <a>AnnVbar</a>, (1 - alternative) before the
--   expression, (arity - alternative) after it
ExplicitSum :: XExplicitSum p -> ConTag -> Arity -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnCase</a>, <a>AnnOf</a>,<a>AnnOpen</a>
--   <tt>'{'</tt>, <a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
HsCase :: XCase p -> LHsExpr p -> MatchGroup p (LHsExpr p) -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnIf</a>, <a>AnnSemi</a>,
--   <a>AnnThen</a>,<a>AnnSemi</a>, <a>AnnElse</a>,</li>
--   </ul>
HsIf :: XIf p -> Maybe (SyntaxExpr p) -> LHsExpr p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | Multi-way if
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnIf</a>
--   <a>AnnOpen</a>,<a>AnnClose</a>,</li>
--   </ul>
HsMultiIf :: XMultiIf p -> [LGRHS p (LHsExpr p)] -> HsExpr p

-- | let(rec)
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLet</a>, <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnClose</a> <tt>'}'</tt>,<a>AnnIn</a></li>
--   </ul>
HsLet :: XLet p -> LHsLocalBinds p -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDo</a>, <a>AnnOpen</a>,
--   <a>AnnSemi</a>, <a>AnnVbar</a>, <a>AnnClose</a></li>
--   </ul>
HsDo :: XDo p -> HsStmtContext Name -> Located [ExprLStmt p] -> HsExpr p

-- | Syntactic list: [a,b,c,...]
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>, <a>AnnClose</a>
--   <tt>']'</tt></li>
--   </ul>
ExplicitList :: XExplicitList p -> Maybe (SyntaxExpr p) -> [LHsExpr p] -> HsExpr p

-- | Record construction
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnDotdot</a>,<a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
RecordCon :: XRecordCon p -> Located (IdP p) -> HsRecordBinds p -> HsExpr p
[rcon_ext] :: HsExpr p -> XRecordCon p
[rcon_con_name] :: HsExpr p -> Located (IdP p)
[rcon_flds] :: HsExpr p -> HsRecordBinds p

-- | Record update
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnDotdot</a>,<a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
RecordUpd :: XRecordUpd p -> LHsExpr p -> [LHsRecUpdField p] -> HsExpr p
[rupd_ext] :: HsExpr p -> XRecordUpd p
[rupd_expr] :: HsExpr p -> LHsExpr p
[rupd_flds] :: HsExpr p -> [LHsRecUpdField p]

-- | Expression with an explicit type signature. <tt>e :: type</tt>
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDcolon</a></li>
--   </ul>
ExprWithTySig :: XExprWithTySig p -> LHsExpr p -> LHsSigWcType (NoGhcTc p) -> HsExpr p

-- | Arithmetic sequence
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'['</tt>,
--   <a>AnnComma</a>,<a>AnnDotdot</a>, <a>AnnClose</a> <tt>']'</tt></li>
--   </ul>
ArithSeq :: XArithSeq p -> Maybe (SyntaxExpr p) -> ArithSeqInfo p -> HsExpr p
HsSCC :: XSCC p -> SourceText -> StringLiteral -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'{-# CORE'</tt>,
--   <a>AnnVal</a>, <a>AnnClose</a> <tt>'#-}'</tt></li>
--   </ul>
HsCoreAnn :: XCoreAnn p -> SourceText -> StringLiteral -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>,
--   <a>AnnOpenE</a>,<a>AnnOpenEQ</a>,
--   <a>AnnClose</a>,<a>AnnCloseQ</a></li>
--   </ul>
HsBracket :: XBracket p -> HsBracket p -> HsExpr p
HsRnBracketOut :: XRnBracketOut p -> HsBracket GhcRn -> [PendingRnSplice] -> HsExpr p
HsTcBracketOut :: XTcBracketOut p -> HsBracket GhcRn -> [PendingTcSplice] -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnClose</a></li>
--   </ul>
HsSpliceE :: XSpliceE p -> HsSplice p -> HsExpr p

-- | <tt>proc</tt> notation for Arrows
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnProc</a>, <a>AnnRarrow</a></li>
--   </ul>
HsProc :: XProc p -> LPat p -> LHsCmdTop p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnStatic</a>,</li>
--   </ul>
HsStatic :: XStatic p -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>Annlarrowtail</a>,
--   <a>Annrarrowtail</a>,<a>AnnLarrowtail</a>, <a>AnnRarrowtail</a></li>
--   </ul>
HsArrApp :: XArrApp p -> LHsExpr p -> LHsExpr p -> HsArrAppType -> Bool -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenB</a> <tt>'(|'</tt>,
--   <a>AnnCloseB</a> <tt>'|)'</tt></li>
--   </ul>
HsArrForm :: XArrForm p -> LHsExpr p -> Maybe Fixity -> [LHsCmdTop p] -> HsExpr p
HsTick :: XTick p -> Tickish (IdP p) -> LHsExpr p -> HsExpr p
HsBinTick :: XBinTick p -> Int -> Int -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a>, <a>AnnOpen</a> <tt>'{-#
--   GENERATED'</tt>, <a>AnnVal</a>,<a>AnnVal</a>,
--   <a>AnnColon</a>,<a>AnnVal</a>, <a>AnnMinus</a>,
--   <a>AnnVal</a>,<a>AnnColon</a>, <a>AnnVal</a>, <a>AnnClose</a>
--   <tt>'#-}'</tt></li>
--   </ul>
HsTickPragma :: XTickPragma p -> SourceText -> (StringLiteral, (Int, Int), (Int, Int)) -> ((SourceText, SourceText), (SourceText, SourceText)) -> LHsExpr p -> HsExpr p
EWildPat :: XEWildPat p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnAt</a></li>
--   </ul>
EAsPat :: XEAsPat p -> Located (IdP p) -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRarrow</a></li>
--   </ul>
EViewPat :: XEViewPat p -> LHsExpr p -> LHsExpr p -> HsExpr p

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnTilde</a></li>
--   </ul>
ELazyPat :: XELazyPat p -> LHsExpr p -> HsExpr p
HsWrap :: XWrap p -> HsWrapper -> HsExpr p -> HsExpr p
XExpr :: XXExpr p -> HsExpr p

-- | Extra data fields for a <a>RecordCon</a>, added by the type checker
data RecordConTc
RecordConTc :: ConLike -> PostTcExpr -> RecordConTc
[rcon_con_like] :: RecordConTc -> ConLike
[rcon_con_expr] :: RecordConTc -> PostTcExpr

-- | Extra data fields for a <a>RecordUpd</a>, added by the type checker
data RecordUpdTc
RecordUpdTc :: [ConLike] -> [Type] -> [Type] -> HsWrapper -> RecordUpdTc
[rupd_cons] :: RecordUpdTc -> [ConLike]
[rupd_in_tys] :: RecordUpdTc -> [Type]
[rupd_out_tys] :: RecordUpdTc -> [Type]
[rupd_wrap] :: RecordUpdTc -> HsWrapper

-- | Located Haskell Tuple Argument
--   
--   <a>HsTupArg</a> is used for tuple sections <tt>(,a,)</tt> is
--   represented by <tt>ExplicitTuple [Missing ty1, Present a, Missing
--   ty3]</tt> Which in turn stands for <tt>(x:ty1 y:ty2. (x,a,y))</tt>
type LHsTupArg id = Located (HsTupArg id)

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnComma</a></li>
--   </ul>
--   
--   Haskell Tuple Argument
data HsTupArg id

-- | The argument
Present :: XPresent id -> LHsExpr id -> HsTupArg id

-- | The argument is missing, but this is its type
Missing :: XMissing id -> HsTupArg id

-- | Note [Trees that Grow] extension point
XTupArg :: XXTupArg id -> HsTupArg id
tupArgPresent :: LHsTupArg id -> Bool
pprLExpr :: OutputableBndrId (GhcPass p) => LHsExpr (GhcPass p) -> SDoc
pprExpr :: OutputableBndrId (GhcPass p) => HsExpr (GhcPass p) -> SDoc
isQuietHsExpr :: HsExpr id -> Bool
pprBinds :: (OutputableBndrId (GhcPass idL), OutputableBndrId (GhcPass idR)) => HsLocalBindsLR (GhcPass idL) (GhcPass idR) -> SDoc
ppr_lexpr :: OutputableBndrId (GhcPass p) => LHsExpr (GhcPass p) -> SDoc
ppr_expr :: forall p. OutputableBndrId (GhcPass p) => HsExpr (GhcPass p) -> SDoc
ppr_apps :: OutputableBndrId (GhcPass p) => HsExpr (GhcPass p) -> [Either (LHsExpr (GhcPass p)) (LHsWcType (NoGhcTc (GhcPass p)))] -> SDoc
pprExternalSrcLoc :: (StringLiteral, (Int, Int), (Int, Int)) -> SDoc
pprDebugParendExpr :: OutputableBndrId (GhcPass p) => PprPrec -> LHsExpr (GhcPass p) -> SDoc
pprParendLExpr :: OutputableBndrId (GhcPass p) => PprPrec -> LHsExpr (GhcPass p) -> SDoc
pprParendExpr :: OutputableBndrId (GhcPass p) => PprPrec -> HsExpr (GhcPass p) -> SDoc

-- | <tt><a>hsExprNeedsParens</a> p e</tt> returns <a>True</a> if the
--   expression <tt>e</tt> needs parentheses under precedence <tt>p</tt>.
hsExprNeedsParens :: PprPrec -> HsExpr p -> Bool

-- | <tt><a>parenthesizeHsExpr</a> p e</tt> checks if
--   <tt><a>hsExprNeedsParens</a> p e</tt> is true, and if so, surrounds
--   <tt>e</tt> with an <a>HsPar</a>. Otherwise, it simply returns
--   <tt>e</tt>.
parenthesizeHsExpr :: PprPrec -> LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
isAtomicHsExpr :: HsExpr id -> Bool

-- | Located Haskell Command (for arrow syntax)
type LHsCmd id = Located (HsCmd id)

-- | Haskell Command (e.g. a "statement" in an Arrow proc block)
data HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>Annlarrowtail</a>,
--   <a>Annrarrowtail</a>,<a>AnnLarrowtail</a>, <a>AnnRarrowtail</a></li>
--   </ul>
HsCmdArrApp :: XCmdArrApp id -> LHsExpr id -> LHsExpr id -> HsArrAppType -> Bool -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpenB</a> <tt>'(|'</tt>,
--   <a>AnnCloseB</a> <tt>'|)'</tt></li>
--   </ul>
HsCmdArrForm :: XCmdArrForm id -> LHsExpr id -> LexicalFixity -> Maybe Fixity -> [LHsCmdTop id] -> HsCmd id
HsCmdApp :: XCmdApp id -> LHsCmd id -> LHsExpr id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLam</a>, <a>AnnRarrow</a>,</li>
--   </ul>
HsCmdLam :: XCmdLam id -> MatchGroup id (LHsCmd id) -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnOpen</a> <tt>'('</tt>, <a>AnnClose</a>
--   <tt>')'</tt></li>
--   </ul>
HsCmdPar :: XCmdPar id -> LHsCmd id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnCase</a>, <a>AnnOf</a>,<a>AnnOpen</a>
--   <tt>'{'</tt>, <a>AnnClose</a> <tt>'}'</tt></li>
--   </ul>
HsCmdCase :: XCmdCase id -> LHsExpr id -> MatchGroup id (LHsCmd id) -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnIf</a>, <a>AnnSemi</a>,
--   <a>AnnThen</a>,<a>AnnSemi</a>, <a>AnnElse</a>,</li>
--   </ul>
HsCmdIf :: XCmdIf id -> Maybe (SyntaxExpr id) -> LHsExpr id -> LHsCmd id -> LHsCmd id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLet</a>, <a>AnnOpen</a> <tt>'{'</tt>,
--   <a>AnnClose</a> <tt>'}'</tt>,<a>AnnIn</a></li>
--   </ul>
HsCmdLet :: XCmdLet id -> LHsLocalBinds id -> LHsCmd id -> HsCmd id

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnDo</a>, <a>AnnOpen</a>,
--   <a>AnnSemi</a>, <a>AnnVbar</a>, <a>AnnClose</a></li>
--   </ul>
HsCmdDo :: XCmdDo id -> Located [CmdLStmt id] -> HsCmd id
HsCmdWrap :: XCmdWrap id -> HsWrapper -> HsCmd id -> HsCmd id
XCmd :: XXCmd id -> HsCmd id

-- | Haskell Array Application Type
data HsArrAppType
HsHigherOrderApp :: HsArrAppType
HsFirstOrderApp :: HsArrAppType

-- | Top-level command, introducing a new arrow. This may occur inside a
--   proc (where the stack is empty) or as an argument of a command-forming
--   operator.
--   
--   Located Haskell Top-level Command
type LHsCmdTop p = Located (HsCmdTop p)

-- | Haskell Top-level Command
data HsCmdTop p
HsCmdTop :: XCmdTop p -> LHsCmd p -> HsCmdTop p
XCmdTop :: XXCmdTop p -> HsCmdTop p
data CmdTopTc
CmdTopTc :: Type -> Type -> CmdSyntaxTable GhcTc -> CmdTopTc
pprLCmd :: OutputableBndrId (GhcPass p) => LHsCmd (GhcPass p) -> SDoc
pprCmd :: OutputableBndrId (GhcPass p) => HsCmd (GhcPass p) -> SDoc
isQuietHsCmd :: HsCmd id -> Bool
ppr_lcmd :: OutputableBndrId (GhcPass p) => LHsCmd (GhcPass p) -> SDoc
ppr_cmd :: forall p. OutputableBndrId (GhcPass p) => HsCmd (GhcPass p) -> SDoc
pprCmdArg :: OutputableBndrId (GhcPass p) => HsCmdTop (GhcPass p) -> SDoc

-- | Haskell Record Bindings
type HsRecordBinds p = HsRecFields p (LHsExpr p)
data MatchGroup p body
MG :: XMG p body -> Located [LMatch p body] -> Origin -> MatchGroup p body
[mg_ext] :: MatchGroup p body -> XMG p body
[mg_alts] :: MatchGroup p body -> Located [LMatch p body]
[mg_origin] :: MatchGroup p body -> Origin
XMatchGroup :: XXMatchGroup p body -> MatchGroup p body
data MatchGroupTc
MatchGroupTc :: [Type] -> Type -> MatchGroupTc
[mg_arg_tys] :: MatchGroupTc -> [Type]
[mg_res_ty] :: MatchGroupTc -> Type

-- | Located Match
--   
--   May have <a>AnnKeywordId</a> : <a>AnnSemi</a> when in a list
type LMatch id body = Located (Match id body)
data Match p body
Match :: XCMatch p body -> HsMatchContext (NameOrRdrName (IdP p)) -> [LPat p] -> GRHSs p body -> Match p body
[m_ext] :: Match p body -> XCMatch p body
[m_ctxt] :: Match p body -> HsMatchContext (NameOrRdrName (IdP p))
[m_pats] :: Match p body -> [LPat p]
[m_grhss] :: Match p body -> GRHSs p body
XMatch :: XXMatch p body -> Match p body
isInfixMatch :: Match id body -> Bool
isEmptyMatchGroup :: MatchGroup id body -> Bool

-- | Is there only one RHS in this list of matches?
isSingletonMatchGroup :: [LMatch id body] -> Bool
matchGroupArity :: MatchGroup id body -> Arity
hsLMatchPats :: LMatch id body -> [LPat id]

-- | Guarded Right-Hand Sides
--   
--   GRHSs are used both for pattern bindings and for Matches
--   
--   <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnVbar</a>,
--   <a>AnnEqual</a>,<a>AnnWhere</a>, <a>AnnOpen</a>,<a>AnnClose</a>
--   <a>AnnRarrow</a>,<a>AnnSemi</a></li>
--   </ul>
data GRHSs p body
GRHSs :: XCGRHSs p body -> [LGRHS p body] -> LHsLocalBinds p -> GRHSs p body
[grhssExt] :: GRHSs p body -> XCGRHSs p body

-- | Guarded RHSs
[grhssGRHSs] :: GRHSs p body -> [LGRHS p body]

-- | The where clause
[grhssLocalBinds] :: GRHSs p body -> LHsLocalBinds p
XGRHSs :: XXGRHSs p body -> GRHSs p body

-- | Located Guarded Right-Hand Side
type LGRHS id body = Located (GRHS id body)

-- | Guarded Right Hand Side.
data GRHS p body
GRHS :: XCGRHS p body -> [GuardLStmt p] -> body -> GRHS p body
XGRHS :: XXGRHS p body -> GRHS p body
pprMatches :: (OutputableBndrId (GhcPass idR), Outputable body) => MatchGroup (GhcPass idR) body -> SDoc
pprFunBind :: (OutputableBndrId (GhcPass idR), Outputable body) => MatchGroup (GhcPass idR) body -> SDoc
pprPatBind :: forall bndr p body. (OutputableBndrId (GhcPass bndr), OutputableBndrId (GhcPass p), Outputable body) => LPat (GhcPass bndr) -> GRHSs (GhcPass p) body -> SDoc
pprMatch :: (OutputableBndrId (GhcPass idR), Outputable body) => Match (GhcPass idR) body -> SDoc
pprGRHSs :: (OutputableBndrId (GhcPass idR), Outputable body) => HsMatchContext idL -> GRHSs (GhcPass idR) body -> SDoc
pprGRHS :: (OutputableBndrId (GhcPass idR), Outputable body) => HsMatchContext idL -> GRHS (GhcPass idR) body -> SDoc
pp_rhs :: Outputable body => HsMatchContext idL -> body -> SDoc

-- | Located <tt>do</tt> block Statement
type LStmt id body = Located (StmtLR id id body)

-- | Located Statement with separate Left and Right id's
type LStmtLR idL idR body = Located (StmtLR idL idR body)

-- | <tt>do</tt> block Statement
type Stmt id body = StmtLR id id body

-- | Command Located Statement
type CmdLStmt id = LStmt id (LHsCmd id)

-- | Command Statement
type CmdStmt id = Stmt id (LHsCmd id)

-- | Expression Located Statement
type ExprLStmt id = LStmt id (LHsExpr id)

-- | Expression Statement
type ExprStmt id = Stmt id (LHsExpr id)

-- | Guard Located Statement
type GuardLStmt id = LStmt id (LHsExpr id)

-- | Guard Statement
type GuardStmt id = Stmt id (LHsExpr id)

-- | Ghci Located Statement
type GhciLStmt id = LStmt id (LHsExpr id)

-- | Ghci Statement
type GhciStmt id = Stmt id (LHsExpr id)

-- | API Annotations when in qualifier lists or guards -
--   <a>AnnKeywordId</a> : <a>AnnVbar</a>, <a>AnnComma</a>,<a>AnnThen</a>,
--   <a>AnnBy</a>,<a>AnnBy</a>, <a>AnnGroup</a>,<a>AnnUsing</a>
data StmtLR idL idR body
LastStmt :: XLastStmt idL idR body -> body -> Bool -> SyntaxExpr idR -> StmtLR idL idR body
BindStmt :: XBindStmt idL idR body -> LPat idL -> body -> SyntaxExpr idR -> SyntaxExpr idR -> StmtLR idL idR body

-- | <a>ApplicativeStmt</a> represents an applicative expression built with
--   <a>&lt;$&gt;</a> and <a>&lt;*&gt;</a>. It is generated by the renamer,
--   and is desugared into the appropriate applicative expression by the
--   desugarer, but it is intended to be invisible in error messages.
--   
--   For full details, see Note [ApplicativeDo] in RnExpr
ApplicativeStmt :: XApplicativeStmt idL idR body -> [(SyntaxExpr idR, ApplicativeArg idL)] -> Maybe (SyntaxExpr idR) -> StmtLR idL idR body
BodyStmt :: XBodyStmt idL idR body -> body -> SyntaxExpr idR -> SyntaxExpr idR -> StmtLR idL idR body

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnLet</a> <a>AnnOpen</a>
--   <tt>'{'</tt>,<a>AnnClose</a> <tt>'}'</tt>,</li>
--   </ul>
LetStmt :: XLetStmt idL idR body -> LHsLocalBindsLR idL idR -> StmtLR idL idR body
ParStmt :: XParStmt idL idR body -> [ParStmtBlock idL idR] -> HsExpr idR -> SyntaxExpr idR -> StmtLR idL idR body
TransStmt :: XTransStmt idL idR body -> TransForm -> [ExprLStmt idL] -> [(IdP idR, IdP idR)] -> LHsExpr idR -> Maybe (LHsExpr idR) -> SyntaxExpr idR -> SyntaxExpr idR -> HsExpr idR -> StmtLR idL idR body
[trS_ext] :: StmtLR idL idR body -> XTransStmt idL idR body
[trS_form] :: StmtLR idL idR body -> TransForm
[trS_stmts] :: StmtLR idL idR body -> [ExprLStmt idL]
[trS_bndrs] :: StmtLR idL idR body -> [(IdP idR, IdP idR)]
[trS_using] :: StmtLR idL idR body -> LHsExpr idR
[trS_by] :: StmtLR idL idR body -> Maybe (LHsExpr idR)
[trS_ret] :: StmtLR idL idR body -> SyntaxExpr idR
[trS_bind] :: StmtLR idL idR body -> SyntaxExpr idR
[trS_fmap] :: StmtLR idL idR body -> HsExpr idR

-- | <ul>
--   <li><a>AnnKeywordId</a> : <a>AnnRec</a></li>
--   </ul>
RecStmt :: XRecStmt idL idR body -> [LStmtLR idL idR body] -> [IdP idR] -> [IdP idR] -> SyntaxExpr idR -> SyntaxExpr idR -> SyntaxExpr idR -> StmtLR idL idR body
[recS_ext] :: StmtLR idL idR body -> XRecStmt idL idR body
[recS_stmts] :: StmtLR idL idR body -> [LStmtLR idL idR body]
[recS_later_ids] :: StmtLR idL idR body -> [IdP idR]
[recS_rec_ids] :: StmtLR idL idR body -> [IdP idR]
[recS_bind_fn] :: StmtLR idL idR body -> SyntaxExpr idR
[recS_ret_fn] :: StmtLR idL idR body -> SyntaxExpr idR
[recS_mfix_fn] :: StmtLR idL idR body -> SyntaxExpr idR
XStmtLR :: XXStmtLR idL idR body -> StmtLR idL idR body
data RecStmtTc
RecStmtTc :: Type -> [PostTcExpr] -> [PostTcExpr] -> Type -> RecStmtTc
[recS_bind_ty] :: RecStmtTc -> Type
[recS_later_rets] :: RecStmtTc -> [PostTcExpr]
[recS_rec_rets] :: RecStmtTc -> [PostTcExpr]
[recS_ret_ty] :: RecStmtTc -> Type
data TransForm
ThenForm :: TransForm
GroupForm :: TransForm

-- | Parenthesised Statement Block
data ParStmtBlock idL idR
ParStmtBlock :: XParStmtBlock idL idR -> [ExprLStmt idL] -> [IdP idR] -> SyntaxExpr idR -> ParStmtBlock idL idR
XParStmtBlock :: XXParStmtBlock idL idR -> ParStmtBlock idL idR

-- | Applicative Argument
data ApplicativeArg idL
ApplicativeArgOne :: XApplicativeArgOne idL -> LPat idL -> LHsExpr idL -> Bool -> ApplicativeArg idL
ApplicativeArgMany :: XApplicativeArgMany idL -> [ExprLStmt idL] -> HsExpr idL -> LPat idL -> ApplicativeArg idL
XApplicativeArg :: XXApplicativeArg idL -> ApplicativeArg idL
pprStmt :: forall idL idR body. (OutputableBndrId (GhcPass idL), OutputableBndrId (GhcPass idR), Outputable body) => StmtLR (GhcPass idL) (GhcPass idR) body -> SDoc
pprTransformStmt :: OutputableBndrId (GhcPass p) => [IdP (GhcPass p)] -> LHsExpr (GhcPass p) -> Maybe (LHsExpr (GhcPass p)) -> SDoc
pprTransStmt :: Outputable body => Maybe body -> body -> TransForm -> SDoc
pprBy :: Outputable body => Maybe body -> SDoc
pprDo :: (OutputableBndrId (GhcPass p), Outputable body) => HsStmtContext any -> [LStmt (GhcPass p) body] -> SDoc
ppr_do_stmts :: (OutputableBndrId (GhcPass idL), OutputableBndrId (GhcPass idR), Outputable body) => [LStmtLR (GhcPass idL) (GhcPass idR) body] -> SDoc
pprComp :: (OutputableBndrId (GhcPass p), Outputable body) => [LStmt (GhcPass p) body] -> SDoc
pprQuals :: (OutputableBndrId (GhcPass p), Outputable body) => [LStmt (GhcPass p) body] -> SDoc

-- | Haskell Splice
data HsSplice id
HsTypedSplice :: XTypedSplice id -> SpliceDecoration -> IdP id -> LHsExpr id -> HsSplice id
HsUntypedSplice :: XUntypedSplice id -> SpliceDecoration -> IdP id -> LHsExpr id -> HsSplice id
HsQuasiQuote :: XQuasiQuote id -> IdP id -> IdP id -> SrcSpan -> FastString -> HsSplice id
HsSpliced :: XSpliced id -> ThModFinalizers -> HsSplicedThing id -> HsSplice id
HsSplicedT :: DelayedSplice -> HsSplice id
XSplice :: XXSplice id -> HsSplice id

-- | A splice can appear with various decorations wrapped around it. This
--   data type captures explicitly how it was originally written, for use
--   in the pretty printer.
data SpliceDecoration

-- | $( splice ) or $$( splice )
HasParens :: SpliceDecoration

-- | $splice or $$splice
HasDollar :: SpliceDecoration

-- | bare splice
NoParens :: SpliceDecoration
isTypedSplice :: HsSplice id -> Bool

-- | Finalizers produced by a splice with <a>addModFinalizer</a>
--   
--   See Note [Delaying modFinalizers in untyped splices] in RnSplice. For
--   how this is used.
newtype ThModFinalizers
ThModFinalizers :: [ForeignRef (Q ())] -> ThModFinalizers
data DelayedSplice
DelayedSplice :: TcLclEnv -> LHsExpr GhcRn -> TcType -> LHsExpr GhcTcId -> DelayedSplice

-- | Haskell Spliced Thing
--   
--   Values that can result from running a splice.
data HsSplicedThing id

-- | Haskell Spliced Expression
HsSplicedExpr :: HsExpr id -> HsSplicedThing id

-- | Haskell Spliced Type
HsSplicedTy :: HsType id -> HsSplicedThing id

-- | Haskell Spliced Pattern
HsSplicedPat :: Pat id -> HsSplicedThing id
type SplicePointName = Name

-- | Pending Renamer Splice
data PendingRnSplice
PendingRnSplice :: UntypedSpliceFlavour -> SplicePointName -> LHsExpr GhcRn -> PendingRnSplice
data UntypedSpliceFlavour
UntypedExpSplice :: UntypedSpliceFlavour
UntypedPatSplice :: UntypedSpliceFlavour
UntypedTypeSplice :: UntypedSpliceFlavour
UntypedDeclSplice :: UntypedSpliceFlavour

-- | Pending Type-checker Splice
data PendingTcSplice
PendingTcSplice :: SplicePointName -> LHsExpr GhcTc -> PendingTcSplice
pprPendingSplice :: OutputableBndrId (GhcPass p) => SplicePointName -> LHsExpr (GhcPass p) -> SDoc
pprSpliceDecl :: OutputableBndrId (GhcPass p) => HsSplice (GhcPass p) -> SpliceExplicitFlag -> SDoc
ppr_splice_decl :: OutputableBndrId (GhcPass p) => HsSplice (GhcPass p) -> SDoc
pprSplice :: OutputableBndrId (GhcPass p) => HsSplice (GhcPass p) -> SDoc
ppr_quasi :: OutputableBndr p => p -> p -> FastString -> SDoc
ppr_splice :: OutputableBndrId (GhcPass p) => SDoc -> IdP (GhcPass p) -> LHsExpr (GhcPass p) -> SDoc -> SDoc

-- | Haskell Bracket
data HsBracket p
ExpBr :: XExpBr p -> LHsExpr p -> HsBracket p
PatBr :: XPatBr p -> LPat p -> HsBracket p
DecBrL :: XDecBrL p -> [LHsDecl p] -> HsBracket p
DecBrG :: XDecBrG p -> HsGroup p -> HsBracket p
TypBr :: XTypBr p -> LHsType p -> HsBracket p
VarBr :: XVarBr p -> Bool -> IdP p -> HsBracket p
TExpBr :: XTExpBr p -> LHsExpr p -> HsBracket p
XBracket :: XXBracket p -> HsBracket p
isTypedBracket :: HsBracket id -> Bool
pprHsBracket :: OutputableBndrId (GhcPass p) => HsBracket (GhcPass p) -> SDoc
thBrackets :: SDoc -> SDoc -> SDoc
thTyBrackets :: SDoc -> SDoc

-- | Arithmetic Sequence Information
data ArithSeqInfo id
From :: LHsExpr id -> ArithSeqInfo id
FromThen :: LHsExpr id -> LHsExpr id -> ArithSeqInfo id
FromTo :: LHsExpr id -> LHsExpr id -> ArithSeqInfo id
FromThenTo :: LHsExpr id -> LHsExpr id -> LHsExpr id -> ArithSeqInfo id
pp_dotdot :: SDoc

-- | Haskell Match Context
--   
--   Context of a pattern match. This is more subtle than it would seem.
--   See Note [Varieties of pattern matches].
data HsMatchContext id

-- | A pattern matching on an argument of a function binding
FunRhs :: Located id -> LexicalFixity -> SrcStrictness -> HsMatchContext id

-- | function binder of <tt>f</tt>
[mc_fun] :: HsMatchContext id -> Located id

-- | fixing of <tt>f</tt>
[mc_fixity] :: HsMatchContext id -> LexicalFixity

-- | was <tt>f</tt> banged? See Note [FunBind vs PatBind]
[mc_strictness] :: HsMatchContext id -> SrcStrictness

-- | Patterns of a lambda
LambdaExpr :: HsMatchContext id

-- | Patterns and guards on a case alternative
CaseAlt :: HsMatchContext id

-- | Guards of a multi-way if alternative
IfAlt :: HsMatchContext id

-- | Patterns of a proc
ProcExpr :: HsMatchContext id

-- | A pattern binding eg [y] &lt;- e = e
PatBindRhs :: HsMatchContext id

-- | Guards of pattern bindings, e.g., (Just b) | Just _ &lt;- x = e |
--   otherwise = e'
PatBindGuards :: HsMatchContext id

-- | Record update [used only in DsExpr to tell matchWrapper what sort of
--   runtime error message to generate]
RecUpd :: HsMatchContext id

-- | Pattern of a do-stmt, list comprehension, pattern guard, etc
StmtCtxt :: HsStmtContext id -> HsMatchContext id

-- | A Template Haskell pattern splice
ThPatSplice :: HsMatchContext id

-- | A Template Haskell pattern quotation [p| (a,b) |]
ThPatQuote :: HsMatchContext id

-- | A pattern synonym declaration
PatSyn :: HsMatchContext id
isPatSynCtxt :: HsMatchContext id -> Bool

-- | Haskell Statement Context. It expects to be parameterised with one of
--   <tt>RdrName</tt>, <a>Name</a> or <tt>Id</tt>
data HsStmtContext id
ListComp :: HsStmtContext id
MonadComp :: HsStmtContext id

-- | do { ... }
DoExpr :: HsStmtContext id

-- | mdo { ... } ie recursive do-expression
MDoExpr :: HsStmtContext id

-- | do-notation in an arrow-command context
ArrowExpr :: HsStmtContext id

-- | A command-line Stmt in GHCi pat &lt;- rhs
GhciStmtCtxt :: HsStmtContext id

-- | Pattern guard for specified thing
PatGuard :: HsMatchContext id -> HsStmtContext id

-- | A branch of a parallel stmt
ParStmtCtxt :: HsStmtContext id -> HsStmtContext id

-- | A branch of a transform stmt
TransStmtCtxt :: HsStmtContext id -> HsStmtContext id
isComprehensionContext :: HsStmtContext id -> Bool

-- | Should pattern match failure in a <a>HsStmtContext</a> be desugared
--   using <tt>MonadFail</tt>?
isMonadFailStmtContext :: HsStmtContext id -> Bool
isMonadCompContext :: HsStmtContext id -> Bool
matchSeparator :: HsMatchContext id -> SDoc
pprMatchContext :: (Outputable (NameOrRdrName id), Outputable id) => HsMatchContext id -> SDoc
pprMatchContextNoun :: (Outputable (NameOrRdrName id), Outputable id) => HsMatchContext id -> SDoc
pprAStmtContext :: (Outputable id, Outputable (NameOrRdrName id)) => HsStmtContext id -> SDoc
pprStmtContext :: (Outputable id, Outputable (NameOrRdrName id)) => HsStmtContext id -> SDoc
matchContextErrString :: Outputable id => HsMatchContext id -> SDoc
pprMatchInCtxt :: (OutputableBndrId (GhcPass idR), Outputable (NameOrRdrName (NameOrRdrName (IdP (GhcPass idR)))), Outputable body) => Match (GhcPass idR) body -> SDoc
pprStmtInCtxt :: (OutputableBndrId (GhcPass idL), OutputableBndrId (GhcPass idR), Outputable body) => HsStmtContext (IdP (GhcPass idL)) -> StmtLR (GhcPass idL) (GhcPass idR) body -> SDoc
instance GHC.Base.Functor HsExpr.HsMatchContext
instance GHC.Base.Functor HsExpr.HsStmtContext
instance Data.Data.Data HsExpr.UntypedSpliceFlavour
instance GHC.Show.Show HsExpr.SpliceDecoration
instance GHC.Classes.Eq HsExpr.SpliceDecoration
instance Data.Data.Data HsExpr.SpliceDecoration
instance Data.Data.Data HsExpr.TransForm
instance Data.Data.Data HsExpr.MatchGroupTc
instance Data.Data.Data HsExpr.HsArrAppType
instance Data.Data.Data HsExpr.RecordUpdTc
instance Data.Data.Data HsExpr.UnboundVar
instance Data.Data.Data id => Data.Data.Data (HsExpr.HsMatchContext id)
instance Data.Data.Data id => Data.Data.Data (HsExpr.HsStmtContext id)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsExpr.SyntaxExpr p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsExpr.HsExpr p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsExpr.HsCmd p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsExpr.HsCmdTop p)
instance (idR Data.Type.Equality.~ HsExtension.GhcPass pr, HsExtension.OutputableBndrId idR, Outputable.Outputable body) => Outputable.Outputable (HsExpr.Match idR body)
instance (Outputable.Outputable (HsExpr.StmtLR idL idL (HsExpr.LHsExpr idL)), Outputable.Outputable (HsExtension.XXParStmtBlock idL idR)) => Outputable.Outputable (HsExpr.ParStmtBlock idL idR)
instance (idL Data.Type.Equality.~ HsExtension.GhcPass pl, idR Data.Type.Equality.~ HsExtension.GhcPass pr, HsExtension.OutputableBndrId idL, HsExtension.OutputableBndrId idR, Outputable.Outputable body) => Outputable.Outputable (HsExpr.StmtLR idL idR body)
instance Data.Data.Data HsExpr.DelayedSplice
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsExpr.HsSplicedThing p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsExpr.HsSplice p)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsExpr.HsBracket p)
instance Outputable.Outputable HsExpr.PendingRnSplice
instance Outputable.Outputable HsExpr.PendingTcSplice
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsExpr.ArithSeqInfo p)
instance Outputable.OutputableBndr id => Outputable.Outputable (HsExpr.HsMatchContext id)
instance (Outputable.Outputable p, Outputable.Outputable (PlaceHolder.NameOrRdrName p)) => Outputable.Outputable (HsExpr.HsStmtContext p)
instance Data.Data.Data HsExpr.ThModFinalizers
instance Outputable.Outputable HsExpr.SpliceDecoration
instance Outputable.Outputable HsExpr.UnboundVar

module HsUtils
mkHsPar :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsApp :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsAppType :: NoGhcTc (GhcPass id) ~ GhcRn => LHsExpr (GhcPass id) -> LHsWcType GhcRn -> LHsExpr (GhcPass id)
mkHsAppTypes :: LHsExpr GhcRn -> [LHsWcType GhcRn] -> LHsExpr GhcRn

-- | A simple case alternative with a single pattern, no binds, no guards;
--   pre-typechecking
mkHsCaseAlt :: LPat (GhcPass p) -> Located (body (GhcPass p)) -> LMatch (GhcPass p) (Located (body (GhcPass p)))
mkSimpleMatch :: HsMatchContext (NameOrRdrName (IdP (GhcPass p))) -> [LPat (GhcPass p)] -> Located (body (GhcPass p)) -> LMatch (GhcPass p) (Located (body (GhcPass p)))
unguardedGRHSs :: Located (body (GhcPass p)) -> GRHSs (GhcPass p) (Located (body (GhcPass p)))
unguardedRHS :: SrcSpan -> Located (body (GhcPass p)) -> [LGRHS (GhcPass p) (Located (body (GhcPass p)))]
mkMatchGroup :: XMG name (Located (body name)) ~ NoExt => Origin -> [LMatch name (Located (body name))] -> MatchGroup name (Located (body name))
mkMatch :: HsMatchContext (NameOrRdrName (IdP (GhcPass p))) -> [LPat (GhcPass p)] -> LHsExpr (GhcPass p) -> Located (HsLocalBinds (GhcPass p)) -> LMatch (GhcPass p) (LHsExpr (GhcPass p))

-- | Make a prefix, non-strict function <a>HsMatchContext</a>
mkPrefixFunRhs :: Located id -> HsMatchContext id
mkHsLam :: XMG (GhcPass p) (LHsExpr (GhcPass p)) ~ NoExt => [LPat (GhcPass p)] -> LHsExpr (GhcPass p) -> LHsExpr (GhcPass p)
mkHsIf :: LHsExpr (GhcPass p) -> LHsExpr (GhcPass p) -> LHsExpr (GhcPass p) -> HsExpr (GhcPass p)
mkHsWrap :: HsWrapper -> HsExpr (GhcPass id) -> HsExpr (GhcPass id)
mkLHsWrap :: HsWrapper -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsWrapCo :: TcCoercionN -> HsExpr (GhcPass id) -> HsExpr (GhcPass id)
mkHsWrapCoR :: TcCoercionR -> HsExpr (GhcPass id) -> HsExpr (GhcPass id)
mkLHsWrapCo :: TcCoercionN -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsDictLet :: TcEvBinds -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsLams :: [TyVar] -> [EvVar] -> LHsExpr GhcTc -> LHsExpr GhcTc
mkHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsDo :: HsStmtContext Name -> [ExprLStmt GhcPs] -> HsExpr GhcPs
mkHsComp :: HsStmtContext Name -> [ExprLStmt GhcPs] -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsWrapPat :: HsWrapper -> Pat (GhcPass id) -> Type -> Pat (GhcPass id)
mkHsWrapPatCo :: TcCoercionN -> Pat (GhcPass id) -> Type -> Pat (GhcPass id)
mkLHsPar :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
mkHsCmdWrap :: HsWrapper -> HsCmd (GhcPass p) -> HsCmd (GhcPass p)
mkLHsCmdWrap :: HsWrapper -> LHsCmd (GhcPass p) -> LHsCmd (GhcPass p)
nlHsTyApp :: IdP (GhcPass id) -> [Type] -> LHsExpr (GhcPass id)
nlHsTyApps :: IdP (GhcPass id) -> [Type] -> [LHsExpr (GhcPass id)] -> LHsExpr (GhcPass id)
nlHsVar :: IdP (GhcPass id) -> LHsExpr (GhcPass id)
nlHsDataCon :: DataCon -> LHsExpr GhcTc
nlHsLit :: HsLit (GhcPass p) -> LHsExpr (GhcPass p)
nlHsApp :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
nlHsApps :: IdP (GhcPass id) -> [LHsExpr (GhcPass id)] -> LHsExpr (GhcPass id)
nlHsSyntaxApps :: SyntaxExpr (GhcPass id) -> [LHsExpr (GhcPass id)] -> LHsExpr (GhcPass id)
nlHsIntLit :: Integer -> LHsExpr (GhcPass p)
nlHsVarApps :: IdP (GhcPass id) -> [IdP (GhcPass id)] -> LHsExpr (GhcPass id)
nlHsDo :: HsStmtContext Name -> [LStmt GhcPs (LHsExpr GhcPs)] -> LHsExpr GhcPs
nlHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> LHsExpr GhcPs
nlHsLam :: LMatch GhcPs (LHsExpr GhcPs) -> LHsExpr GhcPs
nlHsPar :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
nlHsIf :: LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id) -> LHsExpr (GhcPass id)
nlHsCase :: LHsExpr GhcPs -> [LMatch GhcPs (LHsExpr GhcPs)] -> LHsExpr GhcPs
nlList :: [LHsExpr GhcPs] -> LHsExpr GhcPs
mkLHsTupleExpr :: [LHsExpr (GhcPass a)] -> LHsExpr (GhcPass a)
mkLHsVarTuple :: [IdP (GhcPass a)] -> LHsExpr (GhcPass a)
missingTupArg :: HsTupArg GhcPs

-- | Converting a Type to an HsType RdrName This is needed to implement
--   GeneralizedNewtypeDeriving.
--   
--   Note that we use <a>getRdrName</a> extensively, which generates Exact
--   RdrNames rather than strings.
typeToLHsType :: Type -> LHsType GhcPs

-- | Lifts a "small" constructor into a "big" constructor by recursive
--   decompositon
mkChunkified :: ([a] -> a) -> [a] -> a

-- | Split a list into lists that are small enough to have a corresponding
--   tuple arity. The sub-lists of the result all have length &lt;=
--   <a>mAX_TUPLE_SIZE</a> But there may be more than <a>mAX_TUPLE_SIZE</a>
--   sub-lists
chunkify :: [a] -> [[a]]
mkFunBind :: Located RdrName -> [LMatch GhcPs (LHsExpr GhcPs)] -> HsBind GhcPs
mkVarBind :: IdP (GhcPass p) -> LHsExpr (GhcPass p) -> LHsBind (GhcPass p)
mkHsVarBind :: SrcSpan -> RdrName -> LHsExpr GhcPs -> LHsBind GhcPs
mk_easy_FunBind :: SrcSpan -> RdrName -> [LPat GhcPs] -> LHsExpr GhcPs -> LHsBind GhcPs
mkTopFunBind :: Origin -> Located Name -> [LMatch GhcRn (LHsExpr GhcRn)] -> HsBind GhcRn
mkPatSynBind :: Located RdrName -> HsPatSynDetails (Located RdrName) -> LPat GhcPs -> HsPatSynDir GhcPs -> HsBind GhcPs

-- | If any of the matches in the <a>FunBind</a> are infix, the
--   <a>FunBind</a> is considered infix.
isInfixFunBind :: HsBindLR id1 id2 -> Bool
mkHsIntegral :: IntegralLit -> HsOverLit GhcPs
mkHsFractional :: FractionalLit -> HsOverLit GhcPs
mkHsIsString :: SourceText -> FastString -> HsOverLit GhcPs
mkHsString :: String -> HsLit (GhcPass p)
mkHsStringPrimLit :: FastString -> HsLit (GhcPass p)
mkNPat :: Located (HsOverLit GhcPs) -> Maybe (SyntaxExpr GhcPs) -> Pat GhcPs
mkNPlusKPat :: Located RdrName -> Located (HsOverLit GhcPs) -> Pat GhcPs
nlVarPat :: IdP (GhcPass id) -> LPat (GhcPass id)
nlLitPat :: HsLit GhcPs -> LPat GhcPs
nlConVarPat :: RdrName -> [RdrName] -> LPat GhcPs
nlConVarPatName :: Name -> [Name] -> LPat GhcRn
nlConPat :: RdrName -> [LPat GhcPs] -> LPat GhcPs
nlConPatName :: Name -> [LPat GhcRn] -> LPat GhcRn
nlInfixConPat :: RdrName -> LPat GhcPs -> LPat GhcPs -> LPat GhcPs
nlNullaryConPat :: IdP (GhcPass p) -> LPat (GhcPass p)
nlWildConPat :: DataCon -> LPat GhcPs
nlWildPat :: LPat GhcPs
nlWildPatName :: LPat GhcRn
nlTuplePat :: [LPat GhcPs] -> Boxity -> LPat GhcPs
mkParPat :: LPat (GhcPass name) -> LPat (GhcPass name)
nlParPat :: LPat (GhcPass name) -> LPat (GhcPass name)
mkBigLHsVarTup :: [IdP (GhcPass id)] -> LHsExpr (GhcPass id)
mkBigLHsTup :: [LHsExpr (GhcPass id)] -> LHsExpr (GhcPass id)
mkBigLHsVarPatTup :: [IdP GhcRn] -> LPat GhcRn
mkBigLHsPatTup :: [LPat GhcRn] -> LPat GhcRn
mkHsAppTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
mkHsAppKindTy :: XAppKindTy (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
userHsTyVarBndrs :: SrcSpan -> [IdP (GhcPass p)] -> [LHsTyVarBndr (GhcPass p)]
userHsLTyVarBndrs :: SrcSpan -> [Located (IdP (GhcPass p))] -> [LHsTyVarBndr (GhcPass p)]
mkLHsSigType :: LHsType GhcPs -> LHsSigType GhcPs
mkLHsSigWcType :: LHsType GhcPs -> LHsSigWcType GhcPs
mkClassOpSigs :: [LSig GhcPs] -> [LSig GhcPs]
mkHsSigEnv :: forall a. (LSig GhcRn -> Maybe ([Located Name], a)) -> [LSig GhcRn] -> NameEnv a
nlHsAppTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsTyVar :: IdP (GhcPass p) -> LHsType (GhcPass p)
nlHsFunTy :: LHsType (GhcPass p) -> LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsParTy :: LHsType (GhcPass p) -> LHsType (GhcPass p)
nlHsTyConApp :: IdP (GhcPass p) -> [LHsType (GhcPass p)] -> LHsType (GhcPass p)
mkTransformStmt :: [ExprLStmt GhcPs] -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkTransformByStmt :: [ExprLStmt GhcPs] -> LHsExpr GhcPs -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkBodyStmt :: Located (bodyR GhcPs) -> StmtLR (GhcPass idL) GhcPs (Located (bodyR GhcPs))
mkBindStmt :: XBindStmt (GhcPass idL) (GhcPass idR) (Located (bodyR (GhcPass idR))) ~ NoExt => LPat (GhcPass idL) -> Located (bodyR (GhcPass idR)) -> StmtLR (GhcPass idL) (GhcPass idR) (Located (bodyR (GhcPass idR)))
mkTcBindStmt :: LPat GhcTc -> Located (bodyR GhcTc) -> StmtLR GhcTc GhcTc (Located (bodyR GhcTc))
mkLastStmt :: Located (bodyR (GhcPass idR)) -> StmtLR (GhcPass idL) (GhcPass idR) (Located (bodyR (GhcPass idR)))
emptyTransStmt :: StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkGroupUsingStmt :: [ExprLStmt GhcPs] -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
mkGroupByUsingStmt :: [ExprLStmt GhcPs] -> LHsExpr GhcPs -> LHsExpr GhcPs -> StmtLR GhcPs GhcPs (LHsExpr GhcPs)
emptyRecStmt :: StmtLR (GhcPass idL) GhcPs bodyR
emptyRecStmtName :: StmtLR GhcRn GhcRn bodyR
emptyRecStmtId :: StmtLR GhcTc GhcTc bodyR
mkRecStmt :: [LStmtLR (GhcPass idL) GhcPs bodyR] -> StmtLR (GhcPass idL) GhcPs bodyR
unitRecStmtTc :: RecStmtTc
mkHsSpliceTy :: SpliceDecoration -> LHsExpr GhcPs -> HsType GhcPs
mkHsSpliceE :: SpliceDecoration -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsSpliceTE :: SpliceDecoration -> LHsExpr GhcPs -> HsExpr GhcPs
mkUntypedSplice :: SpliceDecoration -> LHsExpr GhcPs -> HsSplice GhcPs
mkHsQuasiQuote :: RdrName -> SrcSpan -> FastString -> HsSplice GhcPs
unqualQuasiQuote :: RdrName

-- | Should we treat this as an unlifted bind? This will be true for any
--   bind that binds an unlifted variable, but we must be careful around
--   AbsBinds. See Note [Unlifted id check in isUnliftedHsBind]. For usage
--   information, see Note [Strict binds check] is DsBinds.
isUnliftedHsBind :: HsBind GhcTc -> Bool

-- | Is a binding a strict variable or pattern bind (e.g. <tt>!x =
--   ...</tt>)?
isBangedHsBind :: HsBind GhcTc -> Bool
collectLocalBinders :: HsLocalBindsLR (GhcPass idL) (GhcPass idR) -> [IdP (GhcPass idL)]
collectHsValBinders :: HsValBindsLR (GhcPass idL) (GhcPass idR) -> [IdP (GhcPass idL)]
collectHsBindListBinders :: [LHsBindLR (GhcPass p) idR] -> [IdP (GhcPass p)]
collectHsIdBinders :: HsValBindsLR (GhcPass idL) (GhcPass idR) -> [IdP (GhcPass idL)]
collectHsBindsBinders :: LHsBindsLR (GhcPass p) idR -> [IdP (GhcPass p)]
collectHsBindBinders :: (SrcSpanLess (LPat p) ~ Pat p, HasSrcSpan (LPat p)) => HsBindLR p idR -> [IdP p]
collectMethodBinders :: LHsBindsLR idL idR -> [Located (IdP idL)]
collectPatBinders :: LPat (GhcPass p) -> [IdP (GhcPass p)]
collectPatsBinders :: [LPat (GhcPass p)] -> [IdP (GhcPass p)]
collectLStmtsBinders :: [LStmtLR (GhcPass idL) (GhcPass idR) body] -> [IdP (GhcPass idL)]
collectStmtsBinders :: [StmtLR (GhcPass idL) (GhcPass idR) body] -> [IdP (GhcPass idL)]
collectLStmtBinders :: LStmtLR (GhcPass idL) (GhcPass idR) body -> [IdP (GhcPass idL)]
collectStmtBinders :: StmtLR (GhcPass idL) (GhcPass idR) body -> [IdP (GhcPass idL)]

-- | Returns all the <i>binding</i> names of the decl. The first one is
--   guaranteed to be the name of the decl. The first component represents
--   all binding names except record fields; the second represents field
--   occurrences. For record fields mentioned in multiple constructors, the
--   SrcLoc will be from the first occurrence.
--   
--   Each returned (Located name) has a SrcSpan for the <i>whole</i>
--   declaration. See Note [SrcSpan for binders]
hsLTyClDeclBinders :: Located (TyClDecl pass) -> ([Located (IdP pass)], [LFieldOcc pass])
hsTyClForeignBinders :: [TyClGroup GhcRn] -> [LForeignDecl GhcRn] -> [Name]
hsPatSynSelectors :: HsValBinds (GhcPass p) -> [IdP (GhcPass p)]
getPatSynBinds :: [(RecFlag, LHsBinds id)] -> [PatSynBind id id]
hsForeignDeclsBinders :: [LForeignDecl pass] -> [Located (IdP pass)]
hsGroupBinders :: HsGroup GhcRn -> [Name]
hsDataFamInstBinders :: DataFamInstDecl pass -> ([Located (IdP pass)], [LFieldOcc pass])
lStmtsImplicits :: [LStmtLR GhcRn (GhcPass idR) (Located (body (GhcPass idR)))] -> NameSet
hsValBindsImplicits :: HsValBindsLR GhcRn (GhcPass idR) -> NameSet
lPatImplicits :: LPat GhcRn -> NameSet

module HsInstances
instance Data.Data.Data (HsBinds.HsLocalBindsLR HsExtension.GhcPs HsExtension.GhcPs)
instance Data.Data.Data (HsBinds.HsLocalBindsLR HsExtension.GhcPs HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.HsLocalBindsLR HsExtension.GhcRn HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.HsLocalBindsLR HsExtension.GhcTc HsExtension.GhcTc)
instance Data.Data.Data (HsBinds.HsValBindsLR HsExtension.GhcPs HsExtension.GhcPs)
instance Data.Data.Data (HsBinds.HsValBindsLR HsExtension.GhcPs HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.HsValBindsLR HsExtension.GhcRn HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.HsValBindsLR HsExtension.GhcTc HsExtension.GhcTc)
instance Data.Data.Data (HsBinds.NHsValBindsLR HsExtension.GhcPs)
instance Data.Data.Data (HsBinds.NHsValBindsLR HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.NHsValBindsLR HsExtension.GhcTc)
instance Data.Data.Data (HsBinds.HsBindLR HsExtension.GhcPs HsExtension.GhcPs)
instance Data.Data.Data (HsBinds.HsBindLR HsExtension.GhcPs HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.HsBindLR HsExtension.GhcRn HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.HsBindLR HsExtension.GhcTc HsExtension.GhcTc)
instance Data.Data.Data (HsBinds.ABExport HsExtension.GhcPs)
instance Data.Data.Data (HsBinds.ABExport HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.ABExport HsExtension.GhcTc)
instance Data.Data.Data (HsBinds.PatSynBind HsExtension.GhcPs HsExtension.GhcPs)
instance Data.Data.Data (HsBinds.PatSynBind HsExtension.GhcPs HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.PatSynBind HsExtension.GhcRn HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.PatSynBind HsExtension.GhcTc HsExtension.GhcTc)
instance Data.Data.Data (HsBinds.HsIPBinds HsExtension.GhcPs)
instance Data.Data.Data (HsBinds.HsIPBinds HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.HsIPBinds HsExtension.GhcTc)
instance Data.Data.Data (HsBinds.IPBind HsExtension.GhcPs)
instance Data.Data.Data (HsBinds.IPBind HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.IPBind HsExtension.GhcTc)
instance Data.Data.Data (HsBinds.Sig HsExtension.GhcPs)
instance Data.Data.Data (HsBinds.Sig HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.Sig HsExtension.GhcTc)
instance Data.Data.Data (HsBinds.FixitySig HsExtension.GhcPs)
instance Data.Data.Data (HsBinds.FixitySig HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.FixitySig HsExtension.GhcTc)
instance Data.Data.Data (HsBinds.HsPatSynDir HsExtension.GhcPs)
instance Data.Data.Data (HsBinds.HsPatSynDir HsExtension.GhcRn)
instance Data.Data.Data (HsBinds.HsPatSynDir HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.HsDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.HsDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.HsDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.HsGroup HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.HsGroup HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.HsGroup HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.SpliceDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.SpliceDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.SpliceDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.TyClDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.TyClDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.TyClDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.TyClGroup HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.TyClGroup HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.TyClGroup HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.FamilyResultSig HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.FamilyResultSig HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.FamilyResultSig HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.FamilyDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.FamilyDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.FamilyDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.InjectivityAnn HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.InjectivityAnn HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.InjectivityAnn HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.FamilyInfo HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.FamilyInfo HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.FamilyInfo HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.HsDataDefn HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.HsDataDefn HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.HsDataDefn HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.HsDerivingClause HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.HsDerivingClause HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.HsDerivingClause HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.ConDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.ConDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.ConDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.TyFamInstDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.TyFamInstDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.TyFamInstDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.DataFamInstDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.DataFamInstDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.DataFamInstDecl HsExtension.GhcTc)
instance (Data.Data.Data pats, Data.Data.Data rhs) => Data.Data.Data (HsDecls.FamEqn HsExtension.GhcPs pats rhs)
instance (Data.Data.Data pats, Data.Data.Data rhs) => Data.Data.Data (HsDecls.FamEqn HsExtension.GhcRn pats rhs)
instance (Data.Data.Data pats, Data.Data.Data rhs) => Data.Data.Data (HsDecls.FamEqn HsExtension.GhcTc pats rhs)
instance Data.Data.Data (HsDecls.ClsInstDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.ClsInstDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.ClsInstDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.InstDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.InstDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.InstDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.DerivDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.DerivDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.DerivDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.DerivStrategy HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.DerivStrategy HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.DerivStrategy HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.DefaultDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.DefaultDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.DefaultDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.ForeignDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.ForeignDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.ForeignDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.RuleDecls HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.RuleDecls HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.RuleDecls HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.RuleDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.RuleDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.RuleDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.RuleBndr HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.RuleBndr HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.RuleBndr HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.WarnDecls HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.WarnDecls HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.WarnDecls HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.WarnDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.WarnDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.WarnDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.AnnDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.AnnDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.AnnDecl HsExtension.GhcTc)
instance Data.Data.Data (HsDecls.RoleAnnotDecl HsExtension.GhcPs)
instance Data.Data.Data (HsDecls.RoleAnnotDecl HsExtension.GhcRn)
instance Data.Data.Data (HsDecls.RoleAnnotDecl HsExtension.GhcTc)
instance Data.Data.Data (HsExpr.SyntaxExpr HsExtension.GhcPs)
instance Data.Data.Data (HsExpr.SyntaxExpr HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.SyntaxExpr HsExtension.GhcTc)
instance Data.Data.Data (HsExpr.HsExpr HsExtension.GhcPs)
instance Data.Data.Data (HsExpr.HsExpr HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.HsExpr HsExtension.GhcTc)
instance Data.Data.Data (HsExpr.HsTupArg HsExtension.GhcPs)
instance Data.Data.Data (HsExpr.HsTupArg HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.HsTupArg HsExtension.GhcTc)
instance Data.Data.Data (HsExpr.HsCmd HsExtension.GhcPs)
instance Data.Data.Data (HsExpr.HsCmd HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.HsCmd HsExtension.GhcTc)
instance Data.Data.Data (HsExpr.HsCmdTop HsExtension.GhcPs)
instance Data.Data.Data (HsExpr.HsCmdTop HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.HsCmdTop HsExtension.GhcTc)
instance Data.Data.Data body => Data.Data.Data (HsExpr.MatchGroup HsExtension.GhcPs body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.MatchGroup HsExtension.GhcRn body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.MatchGroup HsExtension.GhcTc body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.Match HsExtension.GhcPs body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.Match HsExtension.GhcRn body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.Match HsExtension.GhcTc body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.GRHSs HsExtension.GhcPs body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.GRHSs HsExtension.GhcRn body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.GRHSs HsExtension.GhcTc body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.GRHS HsExtension.GhcPs body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.GRHS HsExtension.GhcRn body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.GRHS HsExtension.GhcTc body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.StmtLR HsExtension.GhcPs HsExtension.GhcPs body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.StmtLR HsExtension.GhcPs HsExtension.GhcRn body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.StmtLR HsExtension.GhcRn HsExtension.GhcRn body)
instance Data.Data.Data body => Data.Data.Data (HsExpr.StmtLR HsExtension.GhcTc HsExtension.GhcTc body)
instance Data.Data.Data HsExpr.RecStmtTc
instance Data.Data.Data (HsExpr.ParStmtBlock HsExtension.GhcPs HsExtension.GhcPs)
instance Data.Data.Data (HsExpr.ParStmtBlock HsExtension.GhcPs HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.ParStmtBlock HsExtension.GhcRn HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.ParStmtBlock HsExtension.GhcTc HsExtension.GhcTc)
instance Data.Data.Data (HsExpr.ApplicativeArg HsExtension.GhcPs)
instance Data.Data.Data (HsExpr.ApplicativeArg HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.ApplicativeArg HsExtension.GhcTc)
instance Data.Data.Data (HsExpr.HsSplice HsExtension.GhcPs)
instance Data.Data.Data (HsExpr.HsSplice HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.HsSplice HsExtension.GhcTc)
instance Data.Data.Data (HsExpr.HsSplicedThing HsExtension.GhcPs)
instance Data.Data.Data (HsExpr.HsSplicedThing HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.HsSplicedThing HsExtension.GhcTc)
instance Data.Data.Data (HsExpr.HsBracket HsExtension.GhcPs)
instance Data.Data.Data (HsExpr.HsBracket HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.HsBracket HsExtension.GhcTc)
instance Data.Data.Data (HsExpr.ArithSeqInfo HsExtension.GhcPs)
instance Data.Data.Data (HsExpr.ArithSeqInfo HsExtension.GhcRn)
instance Data.Data.Data (HsExpr.ArithSeqInfo HsExtension.GhcTc)
instance Data.Data.Data HsExpr.RecordConTc
instance Data.Data.Data HsExpr.CmdTopTc
instance Data.Data.Data HsExpr.PendingRnSplice
instance Data.Data.Data HsExpr.PendingTcSplice
instance Data.Data.Data (HsLit.HsLit HsExtension.GhcPs)
instance Data.Data.Data (HsLit.HsLit HsExtension.GhcRn)
instance Data.Data.Data (HsLit.HsLit HsExtension.GhcTc)
instance Data.Data.Data (HsLit.HsOverLit HsExtension.GhcPs)
instance Data.Data.Data (HsLit.HsOverLit HsExtension.GhcRn)
instance Data.Data.Data (HsLit.HsOverLit HsExtension.GhcTc)
instance Data.Data.Data (HsPat.Pat HsExtension.GhcPs)
instance Data.Data.Data (HsPat.Pat HsExtension.GhcRn)
instance Data.Data.Data (HsPat.Pat HsExtension.GhcTc)
instance Data.Data.Data HsPat.ListPatTc
instance Data.Data.Data body => Data.Data.Data (HsPat.HsRecFields HsExtension.GhcPs body)
instance Data.Data.Data body => Data.Data.Data (HsPat.HsRecFields HsExtension.GhcRn body)
instance Data.Data.Data body => Data.Data.Data (HsPat.HsRecFields HsExtension.GhcTc body)
instance Data.Data.Data (HsTypes.LHsQTyVars HsExtension.GhcPs)
instance Data.Data.Data (HsTypes.LHsQTyVars HsExtension.GhcRn)
instance Data.Data.Data (HsTypes.LHsQTyVars HsExtension.GhcTc)
instance Data.Data.Data thing => Data.Data.Data (HsTypes.HsImplicitBndrs HsExtension.GhcPs thing)
instance Data.Data.Data thing => Data.Data.Data (HsTypes.HsImplicitBndrs HsExtension.GhcRn thing)
instance Data.Data.Data thing => Data.Data.Data (HsTypes.HsImplicitBndrs HsExtension.GhcTc thing)
instance Data.Data.Data thing => Data.Data.Data (HsTypes.HsWildCardBndrs HsExtension.GhcPs thing)
instance Data.Data.Data thing => Data.Data.Data (HsTypes.HsWildCardBndrs HsExtension.GhcRn thing)
instance Data.Data.Data thing => Data.Data.Data (HsTypes.HsWildCardBndrs HsExtension.GhcTc thing)
instance Data.Data.Data (HsTypes.HsTyVarBndr HsExtension.GhcPs)
instance Data.Data.Data (HsTypes.HsTyVarBndr HsExtension.GhcRn)
instance Data.Data.Data (HsTypes.HsTyVarBndr HsExtension.GhcTc)
instance Data.Data.Data (HsTypes.HsType HsExtension.GhcPs)
instance Data.Data.Data (HsTypes.HsType HsExtension.GhcRn)
instance Data.Data.Data (HsTypes.HsType HsExtension.GhcTc)
instance Data.Data.Data (HsTypes.HsArg (HsTypes.LHsType HsExtension.GhcPs) (HsTypes.LHsKind HsExtension.GhcPs))
instance Data.Data.Data (HsTypes.HsArg (HsTypes.LHsType HsExtension.GhcRn) (HsTypes.LHsKind HsExtension.GhcRn))
instance Data.Data.Data (HsTypes.HsArg (HsTypes.LHsType HsExtension.GhcTc) (HsTypes.LHsKind HsExtension.GhcTc))
instance Data.Data.Data (HsTypes.ConDeclField HsExtension.GhcPs)
instance Data.Data.Data (HsTypes.ConDeclField HsExtension.GhcRn)
instance Data.Data.Data (HsTypes.ConDeclField HsExtension.GhcTc)
instance Data.Data.Data (HsTypes.FieldOcc HsExtension.GhcPs)
instance Data.Data.Data (HsTypes.FieldOcc HsExtension.GhcRn)
instance Data.Data.Data (HsTypes.FieldOcc HsExtension.GhcTc)
instance Data.Data.Data (HsTypes.AmbiguousFieldOcc HsExtension.GhcPs)
instance Data.Data.Data (HsTypes.AmbiguousFieldOcc HsExtension.GhcRn)
instance Data.Data.Data (HsTypes.AmbiguousFieldOcc HsExtension.GhcTc)
instance Data.Data.Data (HsImpExp.ImportDecl HsExtension.GhcPs)
instance Data.Data.Data (HsImpExp.ImportDecl HsExtension.GhcRn)
instance Data.Data.Data (HsImpExp.ImportDecl HsExtension.GhcTc)
instance Data.Data.Data (HsImpExp.IE HsExtension.GhcPs)
instance Data.Data.Data (HsImpExp.IE HsExtension.GhcRn)
instance Data.Data.Data (HsImpExp.IE HsExtension.GhcTc)
instance GHC.Classes.Eq (HsImpExp.IE HsExtension.GhcPs)
instance GHC.Classes.Eq (HsImpExp.IE HsExtension.GhcRn)
instance GHC.Classes.Eq (HsImpExp.IE HsExtension.GhcTc)

module HsSyn
data Fixity

-- | Haskell Module
--   
--   All we actually declare here is the top-level structure for a module.
data HsModule pass

-- | <a>AnnKeywordId</a>s
--   
--   <ul>
--   <li><a>AnnModule</a>,<a>AnnWhere</a></li>
--   <li><a>AnnOpen</a>,<a>AnnSemi</a>, <a>AnnClose</a> for explicit braces
--   and semi around hsmodImports,hsmodDecls if this style is used.</li>
--   </ul>
HsModule :: Maybe (Located ModuleName) -> Maybe (Located [LIE pass]) -> [LImportDecl pass] -> [LHsDecl pass] -> Maybe (Located WarningTxt) -> Maybe LHsDocString -> HsModule pass

-- | <tt>Nothing</tt>: "module X where" is omitted (in which case the next
--   field is Nothing too)
[hsmodName] :: HsModule pass -> Maybe (Located ModuleName)

-- | Export list
--   
--   <ul>
--   <li><tt>Nothing</tt>: export list omitted, so export everything</li>
--   <li><tt>Just []</tt>: export <i>nothing</i></li>
--   <li><tt>Just [...]</tt>: as you would expect...</li>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a> ,<a>AnnClose</a></li>
--   </ul>
[hsmodExports] :: HsModule pass -> Maybe (Located [LIE pass])

-- | We snaffle interesting stuff out of the imported interfaces early on,
--   adding that info to TyDecls/etc; so this list is often empty,
--   downstream.
[hsmodImports] :: HsModule pass -> [LImportDecl pass]

-- | Type, class, value, and interface signature decls
[hsmodDecls] :: HsModule pass -> [LHsDecl pass]

-- | reason/explanation for warning/deprecation of this module
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a> ,<a>AnnClose</a></li>
--   </ul>
[hsmodDeprecMessage] :: HsModule pass -> Maybe (Located WarningTxt)

-- | Haddock module info and description, unparsed
--   
--   <ul>
--   <li><a>AnnKeywordId</a>s : <a>AnnOpen</a> ,<a>AnnClose</a></li>
--   </ul>
[hsmodHaddockModHeader] :: HsModule pass -> Maybe LHsDocString
instance Data.Data.Data (HsSyn.HsModule HsExtension.GhcPs)
instance Data.Data.Data (HsSyn.HsModule HsExtension.GhcRn)
instance Data.Data.Data (HsSyn.HsModule HsExtension.GhcTc)
instance (p Data.Type.Equality.~ HsExtension.GhcPass pass, HsExtension.OutputableBndrId p) => Outputable.Outputable (HsSyn.HsModule p)

module RdrHsSyn
mkHsOpApp :: LHsExpr GhcPs -> IdP GhcPs -> LHsExpr GhcPs -> HsExpr GhcPs
mkHsIntegral :: IntegralLit -> HsOverLit GhcPs
mkHsFractional :: FractionalLit -> HsOverLit GhcPs
mkHsIsString :: SourceText -> FastString -> HsOverLit GhcPs
mkHsDo :: HsStmtContext Name -> [ExprLStmt GhcPs] -> HsExpr GhcPs
mkSpliceDecl :: LHsExpr GhcPs -> HsDecl GhcPs
mkRoleAnnotDecl :: SrcSpan -> Located RdrName -> [Located (Maybe FastString)] -> P (LRoleAnnotDecl GhcPs)
mkClassDecl :: SrcSpan -> Located (Maybe (LHsContext GhcPs), LHsType GhcPs) -> Located (a, [LHsFunDep GhcPs]) -> OrdList (LHsDecl GhcPs) -> P (LTyClDecl GhcPs)
mkTyData :: SrcSpan -> NewOrData -> Maybe (Located CType) -> Located (Maybe (LHsContext GhcPs), LHsType GhcPs) -> Maybe (LHsKind GhcPs) -> [LConDecl GhcPs] -> HsDeriving GhcPs -> P (LTyClDecl GhcPs)
mkDataFamInst :: SrcSpan -> NewOrData -> Maybe (Located CType) -> (Maybe (LHsContext GhcPs), Maybe [LHsTyVarBndr GhcPs], LHsType GhcPs) -> Maybe (LHsKind GhcPs) -> [LConDecl GhcPs] -> HsDeriving GhcPs -> P (LInstDecl GhcPs)
mkTySynonym :: SrcSpan -> LHsType GhcPs -> LHsType GhcPs -> P (LTyClDecl GhcPs)
mkTyFamInstEqn :: Maybe [LHsTyVarBndr GhcPs] -> LHsType GhcPs -> LHsType GhcPs -> P (TyFamInstEqn GhcPs, [AddAnn])
mkTyFamInst :: SrcSpan -> TyFamInstEqn GhcPs -> P (LInstDecl GhcPs)
mkFamDecl :: SrcSpan -> FamilyInfo GhcPs -> LHsType GhcPs -> Located (FamilyResultSig GhcPs) -> Maybe (LInjectivityAnn GhcPs) -> P (LTyClDecl GhcPs)
mkLHsSigType :: LHsType GhcPs -> LHsSigType GhcPs
mkInlinePragma :: SourceText -> (InlineSpec, RuleMatchInfo) -> Maybe Activation -> InlinePragma
mkPatSynMatchGroup :: Located RdrName -> Located (OrdList (LHsDecl GhcPs)) -> P (MatchGroup GhcPs (LHsExpr GhcPs))
mkRecConstrOrUpdate :: LHsExpr GhcPs -> SrcSpan -> ([LHsRecField GhcPs (LHsExpr GhcPs)], Bool) -> P (HsExpr GhcPs)

-- | mkClassDecl builds a RdrClassDecl, filling in the names for tycon and
--   datacon by deriving them from the name of the class. We fill in the
--   names for the tycon and datacon corresponding to the class, by
--   deriving them from the name of the class itself. This saves recording
--   the names in the interface file (which would be equally good).
mkTyClD :: LTyClDecl (GhcPass p) -> LHsDecl (GhcPass p)
mkInstD :: LInstDecl (GhcPass p) -> LHsDecl (GhcPass p)
mkRdrRecordCon :: Located RdrName -> HsRecordBinds GhcPs -> HsExpr GhcPs
mkRdrRecordUpd :: LHsExpr GhcPs -> [LHsRecUpdField GhcPs] -> HsExpr GhcPs

-- | This rather gruesome function is used mainly by the parser. When
--   parsing:
--   
--   <pre>
--   data T a = T | T1 Int
--   </pre>
--   
--   we parse the data constructors as <i>types</i> because of parser
--   ambiguities, so then we need to change the <i>type constr</i> to a
--   <i>data constr</i>
--   
--   The exact-name case <i>can</i> occur when parsing:
--   
--   <pre>
--   data [] a = [] | a : [a]
--   </pre>
--   
--   For the exact-name case we return an original name.
setRdrNameSpace :: RdrName -> NameSpace -> RdrName

-- | Replaces constraint tuple names with corresponding boxed ones.
filterCTuple :: RdrName -> RdrName
cvBindGroup :: OrdList (LHsDecl GhcPs) -> P (HsValBinds GhcPs)
cvBindsAndSigs :: OrdList (LHsDecl GhcPs) -> P (LHsBinds GhcPs, [LSig GhcPs], [LFamilyDecl GhcPs], [LTyFamInstDecl GhcPs], [LDataFamInstDecl GhcPs], [LDocDecl])

-- | Function definitions are restructured here. Each is assumed to be
--   recursive initially, and non recursive definitions are discovered by
--   the dependency analyser.
cvTopDecls :: OrdList (LHsDecl GhcPs) -> [LHsDecl GhcPs]
placeHolderPunRhs :: LHsExpr GhcPs
mkImport :: Located CCallConv -> Located Safety -> (Located StringLiteral, Located RdrName, LHsSigType GhcPs) -> P (HsDecl GhcPs)
parseCImport :: Located CCallConv -> Located Safety -> FastString -> String -> Located SourceText -> Maybe ForeignImport
mkExport :: Located CCallConv -> (Located StringLiteral, Located RdrName, LHsSigType GhcPs) -> P (HsDecl GhcPs)
mkExtName :: RdrName -> CLabelString
mkGadtDecl :: [Located RdrName] -> LHsType GhcPs -> (ConDecl GhcPs, [AddAnn])
mkConDeclH98 :: Located RdrName -> Maybe [LHsTyVarBndr GhcPs] -> Maybe (LHsContext GhcPs) -> HsConDeclDetails GhcPs -> ConDecl GhcPs

-- | Take a type-family instance declaration and turn it into a type-family
--   default equation for a class declaration. We parse things as the
--   former and use this function to convert to the latter
--   
--   We use the Either monad because this also called from <a>Convert</a>.
--   
--   The <tt>P ()</tt> we return corresponds represents an action which
--   will add some necessary paren annotations to the parsing context.
--   Naturally, this is not something that the <a>Convert</a> use cares
--   about.
mkATDefault :: LTyFamInstDecl GhcPs -> Either (SrcSpan, SDoc) (LTyFamDefltEqn GhcPs, P ())

-- | Yield a parse error if we have a function applied directly to a do
--   block etc. and BlockArguments is not enabled.
checkBlockArguments :: LHsExpr GhcPs -> P ()

-- | Check if a fixity is valid. We support bypassing the usual bound
--   checks for some special operators.
checkPrecP :: Located (SourceText, Int) -> Located (OrdList (Located RdrName)) -> P ()

-- | Validate the context constraints and break up a context into a list of
--   predicates.
--   
--   <pre>
--   (Eq a, Ord b)        --&gt;  [Eq a, Ord b]
--   Eq a                 --&gt;  [Eq a]
--   (Eq a)               --&gt;  [Eq a]
--   (((Eq a)))           --&gt;  [Eq a]
--   </pre>
checkContext :: LHsType GhcPs -> P ([AddAnn], LHsContext GhcPs)
checkPattern :: SDoc -> LHsExpr GhcPs -> P (LPat GhcPs)
bang_RDR :: RdrName
isBangRdr :: RdrName -> Bool
checkPatterns :: SDoc -> [LHsExpr GhcPs] -> P [LPat GhcPs]

-- | Check for monad comprehensions
--   
--   If the flag MonadComprehensions is set, return a <a>MonadComp</a>
--   context, otherwise use the usual <a>ListComp</a> context
checkMonadComp :: P (HsStmtContext Name)
checkCommand :: LHsExpr GhcPs -> P (LHsCmd GhcPs)
checkValDef :: SDoc -> SrcStrictness -> LHsExpr GhcPs -> Maybe (LHsType GhcPs) -> Located (a, GRHSs GhcPs (LHsExpr GhcPs)) -> P ([AddAnn], HsBind GhcPs)
checkValSigLhs :: LHsExpr GhcPs -> P (Located RdrName)
checkDoAndIfThenElse :: LHsExpr GhcPs -> Bool -> LHsExpr GhcPs -> Bool -> LHsExpr GhcPs -> P ()
type LRuleTyTmVar = Located RuleTyTmVar

-- | Essentially a wrapper for a <tt>RuleBndr GhcPs</tt>
data RuleTyTmVar
RuleTyTmVar :: Located RdrName -> Maybe (LHsType GhcPs) -> RuleTyTmVar
mkRuleBndrs :: [LRuleTyTmVar] -> [LRuleBndr GhcPs]
mkRuleTyVarBndrs :: [LRuleTyTmVar] -> [LHsTyVarBndr GhcPs]
checkRuleTyVarBndrNames :: [LHsTyVarBndr GhcPs] -> P ()
checkRecordSyntax :: Outputable a => Located a -> P (Located a)

-- | Check if the gadt_constrlist is empty. Only raise parse error for
--   `data T where` to avoid affecting existing error message, see #8258.
checkEmptyGADTs :: Located ([AddAnn], [LConDecl GhcPs]) -> P (Located ([AddAnn], [LConDecl GhcPs]))
parseErrorSDoc :: SrcSpan -> SDoc -> P a

-- | Hint about bang patterns, assuming <tt>BangPatterns</tt> is off.
hintBangPat :: SrcSpan -> HsExpr GhcPs -> P ()

-- | Either an operator or an operand.
data TyEl
TyElOpr :: RdrName -> TyEl
TyElOpd :: HsType GhcPs -> TyEl
TyElKindApp :: SrcSpan -> LHsType GhcPs -> TyEl
TyElTilde :: TyEl
TyElBang :: TyEl
TyElUnpackedness :: ([AddAnn], SourceText, SrcUnpackedness) -> TyEl
TyElDocPrev :: HsDocString -> TyEl

-- | Merge a <i>reversed</i> and <i>non-empty</i> soup of operators and
--   operands into a type.
--   
--   User input: <tt>F x y + G a b * X</tt> Input to <a>mergeOps</a>: [X,
--   *, b, a, G, +, y, x, F] Output corresponds to what the user wrote
--   assuming all operators are of the same fixity and right-associative.
--   
--   It's a bit silly that we're doing it at all, as the renamer will have
--   to rearrange this, and it'd be easier to keep things separate.
--   
--   See Note [Parsing data constructors is hard]
mergeOps :: [Located TyEl] -> P (LHsType GhcPs)

-- | Merge a <i>reversed</i> and <i>non-empty</i> soup of operators and
--   operands into a data constructor.
--   
--   User input: <tt>C !A B -- ^ doc</tt> Input to <a>mergeDataCon</a>:
--   ["doc", B, !, A, C] Output: (C, PrefixCon [!A, B], "doc")
--   
--   See Note [Parsing data constructors is hard] See Note [isFunLhs vs
--   mergeDataCon]
mergeDataCon :: [Located TyEl] -> P (Located RdrName, HsConDeclDetails GhcPs, Maybe LHsDocString)
data ImpExpSubSpec
ImpExpAbs :: ImpExpSubSpec
ImpExpAll :: ImpExpSubSpec
ImpExpList :: [Located ImpExpQcSpec] -> ImpExpSubSpec
ImpExpAllWith :: [Located ImpExpQcSpec] -> ImpExpSubSpec
data ImpExpQcSpec
ImpExpQcName :: Located RdrName -> ImpExpQcSpec
ImpExpQcType :: Located RdrName -> ImpExpQcSpec
ImpExpQcWildcard :: ImpExpQcSpec
mkModuleImpExp :: Located ImpExpQcSpec -> ImpExpSubSpec -> P (IE GhcPs)
mkTypeImpExp :: Located RdrName -> P (Located RdrName)
mkImpExpSubSpec :: [Located ImpExpQcSpec] -> P ([AddAnn], ImpExpSubSpec)
checkImportSpec :: Located [LIE GhcPs] -> P (Located [LIE GhcPs])
forallSym :: Bool -> String
starSym :: Bool -> String
warnStarIsType :: SrcSpan -> P ()
failOpFewArgs :: Located RdrName -> P a
data SumOrTuple
Sum :: ConTag -> Arity -> LHsExpr GhcPs -> SumOrTuple
Tuple :: [LHsTupArg GhcPs] -> SumOrTuple
mkSumOrTuple :: Boxity -> SrcSpan -> SumOrTuple -> P (HsExpr GhcPs)
instance Outputable.Outputable RdrHsSyn.TyEl

module PmExpr

-- | Lifted expressions for pattern match checking.
data PmExpr
PmExprVar :: Name -> PmExpr
PmExprCon :: ConLike -> [PmExpr] -> PmExpr
PmExprLit :: PmLit -> PmExpr
PmExprEq :: PmExpr -> PmExpr -> PmExpr
PmExprOther :: HsExpr GhcTc -> PmExpr

-- | Literals (simple and overloaded ones) for pattern match checking.
data PmLit
PmSLit :: HsLit GhcTc -> PmLit
PmOLit :: Bool -> HsOverLit GhcTc -> PmLit

-- | Term equalities
type SimpleEq = (Id, PmExpr)
type ComplexEq = (PmExpr, PmExpr)

-- | Lift a <a>SimpleEq</a> to a <a>ComplexEq</a>
toComplex :: SimpleEq -> ComplexEq

-- | Equality between literals for pattern match checking.
eqPmLit :: PmLit -> PmLit -> Bool

-- | Expression <a>True</a>
truePmExpr :: PmExpr

-- | Expression <a>False</a>
falsePmExpr :: PmExpr

-- | Check whether a PmExpr is syntactically equal to term <a>True</a>.
isTruePmExpr :: PmExpr -> Bool

-- | Check whether a PmExpr is syntactically equal to term <a>False</a>.
isFalsePmExpr :: PmExpr -> Bool

-- | Check if an expression is lifted or not
isNotPmExprOther :: PmExpr -> Bool
lhsExprToPmExpr :: LHsExpr GhcTc -> PmExpr
hsExprToPmExpr :: HsExpr GhcTc -> PmExpr

-- | Substitute in a complex equality. We return (Left eq) if the
--   substitution affected the equality or (Right eq) if nothing happened.
substComplexEq :: Name -> PmExpr -> ComplexEq -> Either ComplexEq ComplexEq
filterComplex :: [ComplexEq] -> [PmNegLitCt]
pprPmExprWithParens :: PmExpr -> PmPprM SDoc
runPmPprM :: PmPprM a -> [PmNegLitCt] -> (a, [(SDoc, [PmLit])])
instance Outputable.Outputable PmExpr.PmExpr
instance Outputable.Outputable PmExpr.PmLit


-- | Types for the per-module compiler
module HscTypes

-- | HscEnv is like <tt>Session</tt>, except that some of the fields are
--   immutable. An HscEnv is used to compile a single module from plain
--   Haskell source code (after preprocessing) to either C, assembly or
--   C--. Things like the module graph don't change during a single
--   compilation.
--   
--   Historical note: "hsc" used to be the name of the compiler binary,
--   when there was a separate driver and compiler. To compile a single
--   module, the driver would invoke hsc on the source code... so nowadays
--   we think of hsc as the layer of the compiler that deals with compiling
--   a single module.
data HscEnv
HscEnv :: DynFlags -> [Target] -> ModuleGraph -> InteractiveContext -> HomePackageTable -> {-# UNPACK #-} !IORef ExternalPackageState -> {-# UNPACK #-} !IORef NameCache -> {-# UNPACK #-} !IORef FinderCache -> Maybe (Module, IORef TypeEnv) -> MVar (Maybe IServ) -> HscEnv

-- | The dynamic flag settings
[hsc_dflags] :: HscEnv -> DynFlags

-- | The targets (or roots) of the current session
[hsc_targets] :: HscEnv -> [Target]

-- | The module graph of the current session
[hsc_mod_graph] :: HscEnv -> ModuleGraph

-- | The context for evaluating interactive statements
[hsc_IC] :: HscEnv -> InteractiveContext

-- | The home package table describes already-compiled home-package
--   modules, <i>excluding</i> the module we are compiling right now. (In
--   one-shot mode the current module is the only home-package module, so
--   hsc_HPT is empty. All other modules count as "external-package"
--   modules. However, even in GHCi mode, hi-boot interfaces are
--   demand-loaded into the external-package table.)
--   
--   <a>hsc_HPT</a> is not mutable because we only demand-load external
--   packages; the home package is eagerly loaded, module by module, by the
--   compilation manager.
--   
--   The HPT may contain modules compiled earlier by <tt>--make</tt> but
--   not actually below the current module in the dependency graph.
--   
--   (This changes a previous invariant: changed Jan 05.)
[hsc_HPT] :: HscEnv -> HomePackageTable

-- | Information about the currently loaded external packages. This is
--   mutable because packages will be demand-loaded during a compilation
--   run as required.
[hsc_EPS] :: HscEnv -> {-# UNPACK #-} !IORef ExternalPackageState

-- | As with <a>hsc_EPS</a>, this is side-effected by compiling to reflect
--   sucking in interface files. They cache the state of external interface
--   files, in effect.
[hsc_NC] :: HscEnv -> {-# UNPACK #-} !IORef NameCache

-- | The cached result of performing finding in the file system
[hsc_FC] :: HscEnv -> {-# UNPACK #-} !IORef FinderCache

-- | Used for one-shot compilation only, to initialise the
--   <tt>IfGblEnv</tt>. See <a>tcg_type_env_var</a> for <a>TcGblEnv</a>.
--   See also Note [hsc_type_env_var hack]
[hsc_type_env_var] :: HscEnv -> Maybe (Module, IORef TypeEnv)

-- | interactive server process. Created the first time it is needed.
[hsc_iserv] :: HscEnv -> MVar (Maybe IServ)

-- | Retrieve the ExternalPackageState cache.
hscEPS :: HscEnv -> IO ExternalPackageState

-- | The <a>FinderCache</a> maps modules to the result of searching for
--   that module. It records the results of searching for modules along the
--   search path. On <tt>:load</tt>, we flush the entire contents of this
--   cache.
type FinderCache = InstalledModuleEnv InstalledFindResult

-- | The result of searching for an imported module.
--   
--   NB: FindResult manages both user source-import lookups (which can
--   result in <a>Module</a>) as well as direct imports for interfaces
--   (which always result in <a>InstalledModule</a>).
data FindResult

-- | The module was found
Found :: ModLocation -> Module -> FindResult

-- | The requested package was not found
NoPackage :: UnitId -> FindResult

-- | _Error_: both in multiple packages
FoundMultiple :: [(Module, ModuleOrigin)] -> FindResult

-- | Not found
NotFound :: [FilePath] -> Maybe UnitId -> [UnitId] -> [UnitId] -> [(UnitId, UnusablePackageReason)] -> [ModuleSuggestion] -> FindResult
[fr_paths] :: FindResult -> [FilePath]
[fr_pkg] :: FindResult -> Maybe UnitId
[fr_mods_hidden] :: FindResult -> [UnitId]
[fr_pkgs_hidden] :: FindResult -> [UnitId]
[fr_unusables] :: FindResult -> [(UnitId, UnusablePackageReason)]
[fr_suggestions] :: FindResult -> [ModuleSuggestion]
data InstalledFindResult
InstalledFound :: ModLocation -> InstalledModule -> InstalledFindResult
InstalledNoPackage :: InstalledUnitId -> InstalledFindResult
InstalledNotFound :: [FilePath] -> Maybe InstalledUnitId -> InstalledFindResult

-- | A compilation target.
--   
--   A target may be supplied with the actual text of the module. If so,
--   use this instead of the file contents (this is for use in an IDE where
--   the file hasn't been saved by the user yet).
data Target
Target :: TargetId -> Bool -> Maybe (StringBuffer, UTCTime) -> Target

-- | module or filename
[targetId] :: Target -> TargetId

-- | object code allowed?
[targetAllowObjCode] :: Target -> Bool

-- | in-memory text buffer?
[targetContents] :: Target -> Maybe (StringBuffer, UTCTime)
data TargetId

-- | A module name: search for the file
TargetModule :: ModuleName -> TargetId

-- | A filename: preprocess &amp; parse it to find the module name. If
--   specified, the Phase indicates how to compile this file (which phase
--   to start from). Nothing indicates the starting phase should be
--   determined from the suffix of the filename.
TargetFile :: FilePath -> Maybe Phase -> TargetId
pprTarget :: Target -> SDoc
pprTargetId :: TargetId -> SDoc

-- | Status of a compilation to hard-code
data HscStatus
HscNotGeneratingCode :: HscStatus
HscUpToDate :: HscStatus
HscUpdateBoot :: HscStatus
HscUpdateSig :: HscStatus
HscRecomp :: CgGuts -> ModSummary -> HscStatus
data IServ
IServ :: Pipe -> ProcessHandle -> IORef (UniqFM (Ptr ())) -> [HValueRef] -> IServ
[iservPipe] :: IServ -> Pipe
[iservProcess] :: IServ -> ProcessHandle
[iservLookupSymbolCache] :: IServ -> IORef (UniqFM (Ptr ()))
[iservPendingFrees] :: IServ -> [HValueRef]

-- | A ModuleGraph contains all the nodes from the home package (only).
--   There will be a node for each source module, plus a node for each
--   hi-boot module.
--   
--   The graph is not necessarily stored in topologically-sorted order. Use
--   <a>topSortModuleGraph</a> and <a>flattenSCC</a> to achieve this.
data ModuleGraph
emptyMG :: ModuleGraph
mkModuleGraph :: [ModSummary] -> ModuleGraph

-- | Add a ModSummary to ModuleGraph. Assumes that the new ModSummary is
--   not an element of the ModuleGraph.
extendMG :: ModuleGraph -> ModSummary -> ModuleGraph

-- | Map a function <tt>f</tt> over all the <tt>ModSummaries</tt>. To
--   preserve invariants <tt>f</tt> can't change the isBoot status.
mapMG :: (ModSummary -> ModSummary) -> ModuleGraph -> ModuleGraph
mgModSummaries :: ModuleGraph -> [ModSummary]
mgElemModule :: ModuleGraph -> Module -> Bool

-- | Look up a ModSummary in the ModuleGraph
mgLookupModule :: ModuleGraph -> Module -> Maybe ModSummary

-- | Determines whether a set of modules requires Template Haskell or Quasi
--   Quotes
--   
--   Note that if the session's <a>DynFlags</a> enabled Template Haskell
--   when <tt>depanal</tt> was called, then each module in the returned
--   module graph will have Template Haskell enabled whether it is actually
--   needed or not.
needsTemplateHaskellOrQQ :: ModuleGraph -> Bool
mgBootModules :: ModuleGraph -> ModuleSet
newtype Hsc a
Hsc :: (HscEnv -> WarningMessages -> IO (a, WarningMessages)) -> Hsc a
runHsc :: HscEnv -> Hsc a -> IO a
mkInteractiveHscEnv :: HscEnv -> HscEnv
runInteractiveHsc :: HscEnv -> Hsc a -> IO a

-- | The <a>ModDetails</a> is essentially a cache for information in the
--   <a>ModIface</a> for home modules only. Information relating to
--   packages will be loaded into global environments in
--   <a>ExternalPackageState</a>.
data ModDetails
ModDetails :: [AvailInfo] -> !TypeEnv -> ![ClsInst] -> ![FamInst] -> ![CoreRule] -> ![Annotation] -> [CompleteMatch] -> ModDetails
[md_exports] :: ModDetails -> [AvailInfo]

-- | Local type environment for this particular module Includes Ids,
--   TyCons, PatSyns
[md_types] :: ModDetails -> !TypeEnv

-- | <a>DFunId</a>s for the instances in this module
[md_insts] :: ModDetails -> ![ClsInst]
[md_fam_insts] :: ModDetails -> ![FamInst]

-- | Domain may include <a>Id</a>s from other modules
[md_rules] :: ModDetails -> ![CoreRule]

-- | Annotations present in this module: currently they only annotate
--   things also declared in this module
[md_anns] :: ModDetails -> ![Annotation]

-- | Complete match pragmas for this module
[md_complete_sigs] :: ModDetails -> [CompleteMatch]

-- | Constructs an empty ModDetails
emptyModDetails :: ModDetails

-- | A ModGuts is carried through the compiler, accumulating stuff as it
--   goes There is only one ModGuts at any time, the one for the module
--   being compiled right now. Once it is compiled, a <a>ModIface</a> and
--   <a>ModDetails</a> are extracted and the ModGuts is discarded.
data ModGuts
ModGuts :: !Module -> HscSource -> SrcSpan -> ![AvailInfo] -> !Dependencies -> ![Usage] -> !Bool -> !GlobalRdrEnv -> !FixityEnv -> ![TyCon] -> ![ClsInst] -> ![FamInst] -> ![PatSyn] -> ![CoreRule] -> !CoreProgram -> !ForeignStubs -> ![(ForeignSrcLang, FilePath)] -> !Warnings -> [Annotation] -> [CompleteMatch] -> !HpcInfo -> !Maybe ModBreaks -> InstEnv -> FamInstEnv -> SafeHaskellMode -> Bool -> !Maybe HsDocString -> !DeclDocMap -> !ArgDocMap -> ModGuts

-- | Module being compiled
[mg_module] :: ModGuts -> !Module

-- | Whether it's an hs-boot module
[mg_hsc_src] :: ModGuts -> HscSource

-- | For error messages from inner passes
[mg_loc] :: ModGuts -> SrcSpan

-- | What it exports
[mg_exports] :: ModGuts -> ![AvailInfo]

-- | What it depends on, directly or otherwise
[mg_deps] :: ModGuts -> !Dependencies

-- | What was used? Used for interfaces.
[mg_usages] :: ModGuts -> ![Usage]

-- | Did we run a TH splice?
[mg_used_th] :: ModGuts -> !Bool

-- | Top-level lexical environment
[mg_rdr_env] :: ModGuts -> !GlobalRdrEnv

-- | Fixities declared in this module. Used for creating interface files.
[mg_fix_env] :: ModGuts -> !FixityEnv

-- | TyCons declared in this module (includes TyCons for classes)
[mg_tcs] :: ModGuts -> ![TyCon]

-- | Class instances declared in this module
[mg_insts] :: ModGuts -> ![ClsInst]

-- | Family instances declared in this module
[mg_fam_insts] :: ModGuts -> ![FamInst]

-- | Pattern synonyms declared in this module
[mg_patsyns] :: ModGuts -> ![PatSyn]

-- | Before the core pipeline starts, contains See Note [Overall plumbing
--   for rules] in Rules.hs
[mg_rules] :: ModGuts -> ![CoreRule]

-- | Bindings for this module
[mg_binds] :: ModGuts -> !CoreProgram

-- | Foreign exports declared in this module
[mg_foreign] :: ModGuts -> !ForeignStubs

-- | Files to be compiled with the C compiler
[mg_foreign_files] :: ModGuts -> ![(ForeignSrcLang, FilePath)]

-- | Warnings declared in the module
[mg_warns] :: ModGuts -> !Warnings

-- | Annotations declared in this module
[mg_anns] :: ModGuts -> [Annotation]

-- | Complete Matches
[mg_complete_sigs] :: ModGuts -> [CompleteMatch]

-- | Coverage tick boxes in the module
[mg_hpc_info] :: ModGuts -> !HpcInfo

-- | Breakpoints for the module
[mg_modBreaks] :: ModGuts -> !Maybe ModBreaks

-- | Class instance environment for <i>home-package</i> modules (including
--   this one); c.f. <tt>tcg_inst_env</tt>
[mg_inst_env] :: ModGuts -> InstEnv

-- | Type-family instance environment for <i>home-package</i> modules
--   (including this one); c.f. <tt>tcg_fam_inst_env</tt>
[mg_fam_inst_env] :: ModGuts -> FamInstEnv

-- | Safe Haskell mode
[mg_safe_haskell] :: ModGuts -> SafeHaskellMode

-- | Do we need to trust our own package for Safe Haskell? See Note
--   [RnNames . Trust Own Package]
[mg_trust_pkg] :: ModGuts -> Bool

-- | Module header.
[mg_doc_hdr] :: ModGuts -> !Maybe HsDocString

-- | Docs on declarations.
[mg_decl_docs] :: ModGuts -> !DeclDocMap

-- | Docs on arguments.
[mg_arg_docs] :: ModGuts -> !ArgDocMap

-- | A restricted form of <a>ModGuts</a> for code generation purposes
data CgGuts
CgGuts :: !Module -> [TyCon] -> CoreProgram -> !ForeignStubs -> ![(ForeignSrcLang, FilePath)] -> ![InstalledUnitId] -> !HpcInfo -> !Maybe ModBreaks -> [SptEntry] -> CgGuts

-- | Module being compiled
[cg_module] :: CgGuts -> !Module

-- | Algebraic data types (including ones that started life as classes);
--   generate constructors and info tables. Includes newtypes, just for the
--   benefit of External Core
[cg_tycons] :: CgGuts -> [TyCon]

-- | The tidied main bindings, including previously-implicit bindings for
--   record and class selectors, and data constructor wrappers. But *not*
--   data constructor workers; reason: we regard them as part of the
--   code-gen of tycons
[cg_binds] :: CgGuts -> CoreProgram

-- | Foreign export stubs
[cg_foreign] :: CgGuts -> !ForeignStubs
[cg_foreign_files] :: CgGuts -> ![(ForeignSrcLang, FilePath)]

-- | Dependent packages, used to generate #includes for C code gen
[cg_dep_pkgs] :: CgGuts -> ![InstalledUnitId]

-- | Program coverage tick box information
[cg_hpc_info] :: CgGuts -> !HpcInfo

-- | Module breakpoints
[cg_modBreaks] :: CgGuts -> !Maybe ModBreaks

-- | Static pointer table entries for static forms defined in the module.
--   See Note [Grand plan for static forms] in StaticPtrTable
[cg_spt_entries] :: CgGuts -> [SptEntry]

-- | Foreign export stubs
data ForeignStubs

-- | We don't have any stubs
NoStubs :: ForeignStubs

-- | There are some stubs. Parameters:
--   
--   1) Header file prototypes for "foreign exported" functions
--   
--   2) C stubs to use when calling "foreign exported" functions
ForeignStubs :: SDoc -> SDoc -> ForeignStubs
appendStubC :: ForeignStubs -> SDoc -> ForeignStubs

-- | Records the modules directly imported by a module for extracting e.g.
--   usage information, and also to give better error message
type ImportedMods = ModuleEnv [ImportedBy]

-- | If a module was "imported" by the user, we associate it with more
--   detailed usage information <a>ImportedModsVal</a>; a module imported
--   by the system only gets used for usage information.
data ImportedBy
ImportedByUser :: ImportedModsVal -> ImportedBy
ImportedBySystem :: ImportedBy
importedByUser :: [ImportedBy] -> [ImportedModsVal]
data ImportedModsVal
ImportedModsVal :: ModuleName -> SrcSpan -> IsSafeImport -> Bool -> !GlobalRdrEnv -> Bool -> ImportedModsVal

-- | The name the module is imported with
[imv_name] :: ImportedModsVal -> ModuleName

-- | the source span of the whole import
[imv_span] :: ImportedModsVal -> SrcSpan

-- | whether this is a safe import
[imv_is_safe] :: ImportedModsVal -> IsSafeImport

-- | whether this is an "hiding" import
[imv_is_hiding] :: ImportedModsVal -> Bool

-- | all the things the module could provide NB. BangPattern here:
--   otherwise this leaks. (#15111)
[imv_all_exports] :: ImportedModsVal -> !GlobalRdrEnv

-- | whether this is a qualified import
[imv_qualified] :: ImportedModsVal -> Bool

-- | An entry to be inserted into a module's static pointer table. See Note
--   [Grand plan for static forms] in StaticPtrTable.
data SptEntry
SptEntry :: Id -> Fingerprint -> SptEntry

-- | Foreign formats supported by GHC via TH
data ForeignSrcLang

-- | C
LangC :: ForeignSrcLang

-- | C++
LangCxx :: ForeignSrcLang

-- | Objective C
LangObjc :: ForeignSrcLang

-- | Objective C++
LangObjcxx :: ForeignSrcLang

-- | Assembly language (.s)
LangAsm :: ForeignSrcLang

-- | Object (.o)
RawObject :: ForeignSrcLang

-- | A single node in a <a>ModuleGraph</a>. The nodes of the module graph
--   are one of:
--   
--   <ul>
--   <li>A regular Haskell source module</li>
--   <li>A hi-boot source module</li>
--   </ul>
data ModSummary
ModSummary :: Module -> HscSource -> ModLocation -> UTCTime -> Maybe UTCTime -> Maybe UTCTime -> Maybe UTCTime -> [(Maybe FastString, Located ModuleName)] -> [(Maybe FastString, Located ModuleName)] -> Maybe HsParsedModule -> FilePath -> DynFlags -> Maybe StringBuffer -> ModSummary

-- | Identity of the module
[ms_mod] :: ModSummary -> Module

-- | The module source either plain Haskell or hs-boot
[ms_hsc_src] :: ModSummary -> HscSource

-- | Location of the various files belonging to the module
[ms_location] :: ModSummary -> ModLocation

-- | Timestamp of source file
[ms_hs_date] :: ModSummary -> UTCTime

-- | Timestamp of object, if we have one
[ms_obj_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of hi file, if we *only* are typechecking (it is
--   <a>Nothing</a> otherwise. See Note [Recompilation checking in
--   -fno-code mode] and #9243
[ms_iface_date] :: ModSummary -> Maybe UTCTime

-- | Timestamp of hie file, if we have one
[ms_hie_date] :: ModSummary -> Maybe UTCTime

-- | Source imports of the module
[ms_srcimps] :: ModSummary -> [(Maybe FastString, Located ModuleName)]

-- | Non-source imports of the module from the module *text*
[ms_textual_imps] :: ModSummary -> [(Maybe FastString, Located ModuleName)]

-- | The parsed, nonrenamed source, if we have it. This is also used to
--   support "inline module syntax" in Backpack files.
[ms_parsed_mod] :: ModSummary -> Maybe HsParsedModule

-- | Filename of preprocessed source file
[ms_hspp_file] :: ModSummary -> FilePath

-- | Cached flags from <tt>OPTIONS</tt>, <tt>INCLUDE</tt> and
--   <tt>LANGUAGE</tt> pragmas in the modules source code
[ms_hspp_opts] :: ModSummary -> DynFlags

-- | The actual preprocessed source, if we have it
[ms_hspp_buf] :: ModSummary -> Maybe StringBuffer
ms_imps :: ModSummary -> [(Maybe FastString, Located ModuleName)]
ms_installed_mod :: ModSummary -> InstalledModule
ms_mod_name :: ModSummary -> ModuleName
showModMsg :: DynFlags -> HscTarget -> Bool -> ModSummary -> String

-- | Did this <a>ModSummary</a> originate from a hs-boot file?
isBootSummary :: ModSummary -> Bool
msHsFilePath :: ModSummary -> FilePath
msHiFilePath :: ModSummary -> FilePath
msObjFilePath :: ModSummary -> FilePath

-- | Indicates whether a given module's source has been modified since it
--   was last compiled.
data SourceModified

-- | the source has been modified
SourceModified :: SourceModified

-- | the source has not been modified. Compilation may or may not be
--   necessary, depending on whether any dependencies have changed since we
--   last compiled.
SourceUnmodified :: SourceModified

-- | the source has not been modified, and furthermore all of its
--   (transitive) dependencies are up to date; it definitely does not need
--   to be recompiled. This is important for two reasons: (a) we can omit
--   the version check in checkOldIface, and (b) if the module used TH
--   splices we don't need to force recompilation.
SourceUnmodifiedAndStable :: SourceModified
isTemplateHaskellOrQQNonBoot :: ModSummary -> Bool
data HscSource
HsSrcFile :: HscSource
HsBootFile :: HscSource
HsigFile :: HscSource
isHsBootOrSig :: HscSource -> Bool
isHsigFile :: HscSource -> Bool
hscSourceString :: HscSource -> String

-- | Helps us find information about modules in the home package
type HomePackageTable = DModuleNameEnv HomeModInfo

-- | Information about modules in the package being compiled
data HomeModInfo
HomeModInfo :: !ModIface -> !ModDetails -> !Maybe Linkable -> HomeModInfo

-- | The basic loaded interface file: every loaded module has one of these,
--   even if it is imported from another package
[hm_iface] :: HomeModInfo -> !ModIface

-- | Extra information that has been created from the <a>ModIface</a> for
--   the module, typically during typechecking
[hm_details] :: HomeModInfo -> !ModDetails

-- | The actual artifact we would like to link to access things in this
--   module.
--   
--   <a>hm_linkable</a> might be Nothing:
--   
--   <ol>
--   <li>If this is an .hs-boot module</li>
--   <li>Temporarily during compilation if we pruned away the old linkable
--   because it was out of date.</li>
--   </ol>
--   
--   After a complete compilation (<a>load</a>), all <a>hm_linkable</a>
--   fields in the <a>HomePackageTable</a> will be <tt>Just</tt>.
--   
--   When re-linking a module (<a>HscNoRecomp</a>), we construct the
--   <a>HomeModInfo</a> by building a new <a>ModDetails</a> from the old
--   <a>ModIface</a> (only).
[hm_linkable] :: HomeModInfo -> !Maybe Linkable

-- | Constructs an empty HomePackageTable
emptyHomePackageTable :: HomePackageTable
lookupHpt :: HomePackageTable -> ModuleName -> Maybe HomeModInfo
eltsHpt :: HomePackageTable -> [HomeModInfo]
filterHpt :: (HomeModInfo -> Bool) -> HomePackageTable -> HomePackageTable
allHpt :: (HomeModInfo -> Bool) -> HomePackageTable -> Bool
mapHpt :: (HomeModInfo -> HomeModInfo) -> HomePackageTable -> HomePackageTable
delFromHpt :: HomePackageTable -> ModuleName -> HomePackageTable
addToHpt :: HomePackageTable -> ModuleName -> HomeModInfo -> HomePackageTable
addListToHpt :: HomePackageTable -> [(ModuleName, HomeModInfo)] -> HomePackageTable
lookupHptDirectly :: HomePackageTable -> Unique -> Maybe HomeModInfo
listToHpt :: [(ModuleName, HomeModInfo)] -> HomePackageTable
hptCompleteSigs :: HscEnv -> [CompleteMatch]

-- | Find all the instance declarations (of classes and families) from the
--   Home Package Table filtered by the provided predicate function. Used
--   in <tt>tcRnImports</tt>, to select the instances that are in the
--   transitive closure of imports from the currently compiled module.
hptInstances :: HscEnv -> (ModuleName -> Bool) -> ([ClsInst], [FamInst])

-- | Get rules from modules "below" this one (in the dependency sense)
hptRules :: HscEnv -> [(ModuleName, IsBootInterface)] -> [CoreRule]
pprHPT :: HomePackageTable -> SDoc

-- | Information about other packages that we have slurped in by reading
--   their interface files
data ExternalPackageState
EPS :: !ModuleNameEnv (ModuleName, IsBootInterface) -> !PackageIfaceTable -> InstalledModuleEnv (UniqDSet ModuleName) -> !PackageTypeEnv -> !PackageInstEnv -> !PackageFamInstEnv -> !PackageRuleBase -> !PackageAnnEnv -> !PackageCompleteMatchMap -> !ModuleEnv FamInstEnv -> !EpsStats -> ExternalPackageState

-- | In OneShot mode (only), home-package modules accumulate in the
--   external package state, and are sucked in lazily. For these home-pkg
--   modules (only) we need to record which are boot modules. We set this
--   field after loading all the explicitly-imported interfaces, but before
--   doing anything else
--   
--   The <a>ModuleName</a> part is not necessary, but it's useful for debug
--   prints, and it's convenient because this field comes direct from
--   <a>imp_dep_mods</a>
[eps_is_boot] :: ExternalPackageState -> !ModuleNameEnv (ModuleName, IsBootInterface)

-- | The <a>ModIface</a>s for modules in external packages whose interfaces
--   we have opened. The declarations in these interface files are held in
--   the <tt>eps_decls</tt>, <a>eps_inst_env</a>, <a>eps_fam_inst_env</a>
--   and <tt>eps_rules</tt> fields of this record, not in the
--   <a>mi_decls</a> fields of the interface we have sucked in.
--   
--   What <i>is</i> in the PIT is:
--   
--   <ul>
--   <li>The Module</li>
--   <li>Fingerprint info</li>
--   <li>Its exports</li>
--   <li>Fixities</li>
--   <li>Deprecations and warnings</li>
--   </ul>
[eps_PIT] :: ExternalPackageState -> !PackageIfaceTable

-- | Cache for <a>mi_free_holes</a>. Ordinarily, we can rely on the
--   <a>eps_PIT</a> for this information, EXCEPT that when we do dependency
--   analysis, we need to look at the <a>Dependencies</a> of our imports to
--   determine what their precise free holes are
--   (<tt>moduleFreeHolesPrecise</tt>). We don't want to repeatedly reread
--   in the interface for every import, so cache it here. When the PIT gets
--   filled in we can drop these entries.
[eps_free_holes] :: ExternalPackageState -> InstalledModuleEnv (UniqDSet ModuleName)

-- | Result of typechecking all the external package interface files we
--   have sucked in. The domain of the mapping is external-package modules
[eps_PTE] :: ExternalPackageState -> !PackageTypeEnv

-- | The total <a>InstEnv</a> accumulated from all the external-package
--   modules
[eps_inst_env] :: ExternalPackageState -> !PackageInstEnv

-- | The total <a>FamInstEnv</a> accumulated from all the external-package
--   modules
[eps_fam_inst_env] :: ExternalPackageState -> !PackageFamInstEnv

-- | The total <tt>RuleEnv</tt> accumulated from all the external-package
--   modules
[eps_rule_base] :: ExternalPackageState -> !PackageRuleBase

-- | The total <a>AnnEnv</a> accumulated from all the external-package
--   modules
[eps_ann_env] :: ExternalPackageState -> !PackageAnnEnv

-- | The total <a>CompleteMatchMap</a> accumulated from all the
--   external-package modules
[eps_complete_matches] :: ExternalPackageState -> !PackageCompleteMatchMap

-- | The family instances accumulated from external packages, keyed off the
--   module that declared them
[eps_mod_fam_inst_env] :: ExternalPackageState -> !ModuleEnv FamInstEnv

-- | Stastics about what was loaded from external packages
[eps_stats] :: ExternalPackageState -> !EpsStats

-- | Accumulated statistics about what we are putting into the
--   <a>ExternalPackageState</a>. "In" means stuff that is just <i>read</i>
--   from interface files, "Out" means actually sucked in and type-checked
data EpsStats
EpsStats :: !Int -> EpsStats
[n_ifaces_in, n_decls_in, n_decls_out, n_rules_in, n_rules_out, n_insts_in, n_insts_out] :: EpsStats -> !Int

-- | Add stats for one newly-read interface
addEpsInStats :: EpsStats -> Int -> Int -> Int -> EpsStats
type PackageTypeEnv = TypeEnv

-- | Helps us find information about modules in the imported packages
type PackageIfaceTable = ModuleEnv ModIface

-- | Constructs an empty PackageIfaceTable
emptyPackageIfaceTable :: PackageIfaceTable

-- | Find the <a>ModIface</a> for a <a>Module</a>, searching in both the
--   loaded home and external package module information
lookupIfaceByModule :: DynFlags -> HomePackageTable -> PackageIfaceTable -> Module -> Maybe ModIface

-- | Constructs an empty ModIface
emptyModIface :: Module -> ModIface
lookupHptByModule :: HomePackageTable -> Module -> Maybe HomeModInfo
type PackageInstEnv = InstEnv
type PackageFamInstEnv = FamInstEnv
type PackageRuleBase = RuleBase
type PackageCompleteMatchMap = CompleteMatchMap
mkSOName :: Platform -> FilePath -> FilePath
mkHsSOName :: Platform -> FilePath -> FilePath
soExt :: Platform -> FilePath

-- | The supported metaprogramming result types
data MetaRequest
MetaE :: (LHsExpr GhcPs -> MetaResult) -> MetaRequest
MetaP :: (LPat GhcPs -> MetaResult) -> MetaRequest
MetaT :: (LHsType GhcPs -> MetaResult) -> MetaRequest
MetaD :: ([LHsDecl GhcPs] -> MetaResult) -> MetaRequest
MetaAW :: (Serialized -> MetaResult) -> MetaRequest

-- | data constructors not exported to ensure correct result type
data MetaResult
metaRequestE :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LHsExpr GhcPs)
metaRequestP :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LPat GhcPs)
metaRequestT :: Functor f => MetaHook f -> LHsExpr GhcTc -> f (LHsType GhcPs)
metaRequestD :: Functor f => MetaHook f -> LHsExpr GhcTc -> f [LHsDecl GhcPs]
metaRequestAW :: Functor f => MetaHook f -> LHsExpr GhcTc -> f Serialized
type MetaHook f = MetaRequest -> LHsExpr GhcTc -> f MetaResult

-- | Deal with gathering annotations in from all possible places and
--   combining them into a single <a>AnnEnv</a>
prepareAnnotations :: HscEnv -> Maybe ModGuts -> IO AnnEnv

-- | Interactive context, recording information about the state of the
--   context in which statements are executed in a GHCi session.
data InteractiveContext
InteractiveContext :: DynFlags -> Int -> [InteractiveImport] -> [TyThing] -> GlobalRdrEnv -> ([ClsInst], [FamInst]) -> FixityEnv -> Maybe [Type] -> [Resume] -> Name -> Name -> Maybe FilePath -> InteractiveContext

-- | The <a>DynFlags</a> used to evaluate interative expressions and
--   statements.
[ic_dflags] :: InteractiveContext -> DynFlags

-- | Each GHCi stmt or declaration brings some new things into scope. We
--   give them names like interactive:Ghci9.T, where the ic_index is the
--   '9'. The ic_mod_index is incremented whenever we add something to
--   ic_tythings See Note [The interactive package]
[ic_mod_index] :: InteractiveContext -> Int

-- | The GHCi top-level scope (ic_rn_gbl_env) is extended with these
--   imports
--   
--   This field is only stored here so that the client can retrieve it with
--   GHC.getContext. GHC itself doesn't use it, but does reset it to empty
--   sometimes (such as before a GHC.load). The context is set with
--   GHC.setContext.
[ic_imports] :: InteractiveContext -> [InteractiveImport]

-- | TyThings defined by the user, in reverse order of definition (ie most
--   recent at the front) See Note [ic_tythings]
[ic_tythings] :: InteractiveContext -> [TyThing]

-- | The cached <a>GlobalRdrEnv</a>, built by <a>setContext</a> and updated
--   regularly It contains everything in scope at the command line,
--   including everything in ic_tythings
[ic_rn_gbl_env] :: InteractiveContext -> GlobalRdrEnv

-- | All instances and family instances created during this session. These
--   are grabbed en masse after each update to be sure that proper
--   overlapping is retained. That is, rather than re-check the overlapping
--   each time we update the context, we just take the results from the
--   instance code that already does that.
[ic_instances] :: InteractiveContext -> ([ClsInst], [FamInst])

-- | Fixities declared in let statements
[ic_fix_env] :: InteractiveContext -> FixityEnv

-- | The current default types, set by a 'default' declaration
[ic_default] :: InteractiveContext -> Maybe [Type]

-- | The stack of breakpoint contexts
[ic_resume] :: InteractiveContext -> [Resume]

-- | The monad that GHCi is executing in
[ic_monad] :: InteractiveContext -> Name

-- | The function that is used for printing results of expressions in ghci
--   and -e mode.
[ic_int_print] :: InteractiveContext -> Name
[ic_cwd] :: InteractiveContext -> Maybe FilePath

-- | Constructs an empty InteractiveContext.
emptyInteractiveContext :: DynFlags -> InteractiveContext

-- | Get the PrintUnqualified function based on the flags and this
--   InteractiveContext
icPrintUnqual :: DynFlags -> InteractiveContext -> PrintUnqualified

-- | This function returns the list of visible TyThings (useful for e.g.
--   showBindings)
icInScopeTTs :: InteractiveContext -> [TyThing]

-- | Add TyThings to the GlobalRdrEnv, earlier ones in the list shadowing
--   later ones, and shadowing existing entries in the GlobalRdrEnv.
icExtendGblRdrEnv :: GlobalRdrEnv -> [TyThing] -> GlobalRdrEnv

-- | extendInteractiveContext is called with new TyThings recently defined
--   to update the InteractiveContext to include them. Ids are easily
--   removed when shadowed, but Classes and TyCons are not. Some work could
--   be done to determine whether they are entirely shadowed, but as you
--   could still have references to them (e.g. instances for classes or
--   values of the type for TyCons), it's not clear whether removing them
--   is even the appropriate behavior.
extendInteractiveContext :: InteractiveContext -> [TyThing] -> [ClsInst] -> [FamInst] -> Maybe [Type] -> FixityEnv -> InteractiveContext
extendInteractiveContextWithIds :: InteractiveContext -> [Id] -> InteractiveContext
substInteractiveContext :: InteractiveContext -> TCvSubst -> InteractiveContext
setInteractivePrintName :: InteractiveContext -> Name -> InteractiveContext
icInteractiveModule :: InteractiveContext -> Module
data InteractiveImport

-- | Bring the exports of a particular module (filtered by an import decl)
--   into scope
IIDecl :: ImportDecl GhcPs -> InteractiveImport

-- | Bring into scope the entire top-level envt of of this module,
--   including the things imported into it.
IIModule :: ModuleName -> InteractiveImport
setInteractivePackage :: HscEnv -> HscEnv

-- | Creates some functions that work out the best ways to format names for
--   the user according to a set of heuristics.
mkPrintUnqualified :: DynFlags -> GlobalRdrEnv -> PrintUnqualified
pprModulePrefix :: PprStyle -> Module -> OccName -> SDoc

-- | Creates a function for formatting packages based on two heuristics:
--   (1) don't qualify if the package in question is "main", and (2) only
--   qualify with a unit id if the package ID would be ambiguous.
mkQualPackage :: DynFlags -> QueryQualifyPackage

-- | Creates a function for formatting modules based on two heuristics: (1)
--   if the module is the current module, don't qualify, and (2) if there
--   is only one exposed package which exports this module, don't qualify.
mkQualModule :: DynFlags -> QueryQualifyModule

-- | A function which only qualifies package names if necessary; but
--   qualifies all other identifiers.
pkgQual :: DynFlags -> PrintUnqualified

-- | A <a>ModIface</a> plus a <a>ModDetails</a> summarises everything we
--   know about a compiled module. The <a>ModIface</a> is the stuff
--   *before* linking, and can be written out to an interface file. The
--   'ModDetails is after linking and can be completely recovered from just
--   the <a>ModIface</a>.
--   
--   When we read an interface file, we also construct a <a>ModIface</a>
--   from it, except that we explicitly make the <a>mi_decls</a> and a few
--   other fields empty; as when reading we consolidate the declarations
--   etc. into a number of indexed maps and environments in the
--   <a>ExternalPackageState</a>.
data ModIface
ModIface :: !Module -> !Maybe Module -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !Fingerprint -> !WhetherHasOrphans -> !WhetherHasFamInst -> !HscSource -> Dependencies -> [Usage] -> ![IfaceExport] -> !Fingerprint -> !Bool -> [(OccName, Fixity)] -> Warnings -> [IfaceAnnotation] -> [(Fingerprint, IfaceDecl)] -> !Maybe GlobalRdrEnv -> [IfaceClsInst] -> [IfaceFamInst] -> [IfaceRule] -> !Fingerprint -> (OccName -> Maybe WarningTxt) -> (OccName -> Maybe Fixity) -> (OccName -> Maybe (OccName, Fingerprint)) -> !AnyHpcUsage -> !IfaceTrustInfo -> !Bool -> [IfaceCompleteMatch] -> Maybe HsDocString -> DeclDocMap -> ArgDocMap -> ModIface

-- | Name of the module we are for
[mi_module] :: ModIface -> !Module

-- | Are we a sig of another mod?
[mi_sig_of] :: ModIface -> !Maybe Module

-- | Hash of the whole interface
[mi_iface_hash] :: ModIface -> !Fingerprint

-- | Hash of the ABI only
[mi_mod_hash] :: ModIface -> !Fingerprint

-- | Hash of the important flags used when compiling the module, excluding
--   optimisation flags
[mi_flag_hash] :: ModIface -> !Fingerprint

-- | Hash of optimisation flags
[mi_opt_hash] :: ModIface -> !Fingerprint

-- | Hash of hpc flags
[mi_hpc_hash] :: ModIface -> !Fingerprint

-- | Hash of plugins
[mi_plugin_hash] :: ModIface -> !Fingerprint

-- | Whether this module has orphans
[mi_orphan] :: ModIface -> !WhetherHasOrphans

-- | Whether this module has family instances. See Note [The type family
--   instance consistency story].
[mi_finsts] :: ModIface -> !WhetherHasFamInst

-- | Boot? Signature?
[mi_hsc_src] :: ModIface -> !HscSource

-- | The dependencies of the module. This is consulted for
--   directly-imported modules, but not for anything else (hence lazy)
[mi_deps] :: ModIface -> Dependencies

-- | Usages; kept sorted so that it's easy to decide whether to write a new
--   iface file (changing usages doesn't affect the hash of this module)
--   NOT STRICT! we read this field lazily from the interface file It is
--   *only* consulted by the recompilation checker
[mi_usages] :: ModIface -> [Usage]

-- | Exports Kept sorted by (mod,occ), to make version comparisons easier
--   Records the modules that are the declaration points for things
--   exported by this module, and the <a>OccName</a>s of those things
[mi_exports] :: ModIface -> ![IfaceExport]

-- | Hash of export list
[mi_exp_hash] :: ModIface -> !Fingerprint

-- | Module required TH splices when it was compiled. This disables
--   recompilation avoidance (see #481).
[mi_used_th] :: ModIface -> !Bool

-- | Fixities NOT STRICT! we read this field lazily from the interface file
[mi_fixities] :: ModIface -> [(OccName, Fixity)]

-- | Warnings NOT STRICT! we read this field lazily from the interface file
[mi_warns] :: ModIface -> Warnings

-- | Annotations NOT STRICT! we read this field lazily from the interface
--   file
[mi_anns] :: ModIface -> [IfaceAnnotation]

-- | Type, class and variable declarations The hash of an Id changes if its
--   fixity or deprecations change (as well as its type of course) Ditto
--   data constructors, class operations, except that the hash of the
--   parent class/tycon changes
[mi_decls] :: ModIface -> [(Fingerprint, IfaceDecl)]

-- | Binds all the things defined at the top level in the <i>original
--   source</i> code for this module. which is NOT the same as mi_exports,
--   nor mi_decls (which may contains declarations for things not actually
--   defined by the user). Used for GHCi and for inspecting the contents of
--   modules via the GHC API only.
--   
--   (We need the source file to figure out the top-level environment, if
--   we didn't compile this module from source then this field contains
--   <tt>Nothing</tt>).
--   
--   Strictly speaking this field should live in the <a>HomeModInfo</a>,
--   but that leads to more plumbing.
[mi_globals] :: ModIface -> !Maybe GlobalRdrEnv

-- | Sorted class instance
[mi_insts] :: ModIface -> [IfaceClsInst]

-- | Sorted family instances
[mi_fam_insts] :: ModIface -> [IfaceFamInst]

-- | Sorted rules
[mi_rules] :: ModIface -> [IfaceRule]

-- | Hash for orphan rules, class and family instances combined
[mi_orphan_hash] :: ModIface -> !Fingerprint

-- | Cached lookup for <a>mi_warns</a>
[mi_warn_fn] :: ModIface -> OccName -> Maybe WarningTxt

-- | Cached lookup for <a>mi_fixities</a>
[mi_fix_fn] :: ModIface -> OccName -> Maybe Fixity

-- | Cached lookup for <a>mi_decls</a>. The <tt>Nothing</tt> in
--   <a>mi_hash_fn</a> means that the thing isn't in decls. It's useful to
--   know that when seeing if we are up to date wrt. the old interface. The
--   <a>OccName</a> is the parent of the name, if it has one.
[mi_hash_fn] :: ModIface -> OccName -> Maybe (OccName, Fingerprint)

-- | True if this program uses Hpc at any point in the program.
[mi_hpc] :: ModIface -> !AnyHpcUsage

-- | Safe Haskell Trust information for this module.
[mi_trust] :: ModIface -> !IfaceTrustInfo

-- | Do we require the package this module resides in be trusted to trust
--   this module? This is used for the situation where a module is Safe (so
--   doesn't require the package be trusted itself) but imports some
--   trustworthy modules from its own package (which does require its own
--   package be trusted). See Note [RnNames . Trust Own Package]
[mi_trust_pkg] :: ModIface -> !Bool
[mi_complete_sigs] :: ModIface -> [IfaceCompleteMatch]

-- | Module header.
[mi_doc_hdr] :: ModIface -> Maybe HsDocString

-- | Docs on declarations.
[mi_decl_docs] :: ModIface -> DeclDocMap

-- | Docs on arguments.
[mi_arg_docs] :: ModIface -> ArgDocMap

-- | Constructs the cache for the <a>mi_warn_fn</a> field of a
--   <a>ModIface</a>
mkIfaceWarnCache :: Warnings -> OccName -> Maybe WarningTxt

-- | Constructs cache for the <a>mi_hash_fn</a> field of a <a>ModIface</a>
mkIfaceHashCache :: [(Fingerprint, IfaceDecl)] -> OccName -> Maybe (OccName, Fingerprint)

-- | Creates cached lookup for the <a>mi_fix_fn</a> field of
--   <a>ModIface</a>
mkIfaceFixCache :: [(OccName, Fixity)] -> OccName -> Maybe Fixity
emptyIfaceWarnCache :: OccName -> Maybe WarningTxt

-- | Old-style accessor for whether or not the ModIface came from an
--   hs-boot file.
mi_boot :: ModIface -> Bool

-- | Lookups up a (possibly cached) fixity from a <a>ModIface</a>. If one
--   cannot be found, <a>defaultFixity</a> is returned instead.
mi_fix :: ModIface -> OccName -> Fixity

-- | The semantic module for this interface; e.g., if it's a interface for
--   a signature, if <a>mi_module</a> is <tt>p[A=<a>A</a>]:A</tt>,
--   <a>mi_semantic_module</a> will be <tt><a>A</a></tt>.
mi_semantic_module :: ModIface -> Module

-- | The "precise" free holes, e.g., the signatures that this
--   <a>ModIface</a> depends on.
mi_free_holes :: ModIface -> UniqDSet ModuleName

-- | Given a set of free holes, and a unit identifier, rename the free
--   holes according to the instantiation of the unit identifier. For
--   example, if we have A and B free, and our unit identity is
--   <tt>p[A=<a>C</a>,B=impl:B]</tt>, the renamed free holes are just C.
renameFreeHoles :: UniqDSet ModuleName -> [(ModuleName, Module)] -> UniqDSet ModuleName

-- | Fixity environment mapping names to their fixities
type FixityEnv = NameEnv FixItem

-- | Fixity information for an <a>Name</a>. We keep the OccName in the
--   range so that we can generate an interface from it
data FixItem
FixItem :: OccName -> Fixity -> FixItem
lookupFixity :: FixityEnv -> Name -> Fixity
emptyFixityEnv :: FixityEnv

-- | A global typecheckable-thing, essentially anything that has a name.
--   Not to be confused with a <tt>TcTyThing</tt>, which is also a
--   typecheckable thing but in the *local* context. See <tt>TcEnv</tt> for
--   how to retrieve a <a>TyThing</a> given a <a>Name</a>.
data TyThing
AnId :: Id -> TyThing
AConLike :: ConLike -> TyThing
ATyCon :: TyCon -> TyThing
ACoAxiom :: CoAxiom Branched -> TyThing

-- | The Names that a TyThing should bring into scope. Used to build the
--   GlobalRdrEnv for the InteractiveContext.
tyThingAvailInfo :: TyThing -> [AvailInfo]

-- | Get the <a>TyCon</a> from a <a>TyThing</a> if it is a type constructor
--   thing. Panics otherwise
tyThingTyCon :: TyThing -> TyCon

-- | Get the <a>DataCon</a> from a <a>TyThing</a> if it is a data
--   constructor thing. Panics otherwise
tyThingDataCon :: TyThing -> DataCon

-- | Get the <a>ConLike</a> from a <a>TyThing</a> if it is a data
--   constructor thing. Panics otherwise
tyThingConLike :: TyThing -> ConLike

-- | Get the <a>Id</a> from a <a>TyThing</a> if it is a id *or* data
--   constructor thing. Panics otherwise
tyThingId :: TyThing -> Id

-- | Get the <a>CoAxiom</a> from a <a>TyThing</a> if it is a coercion axiom
--   thing. Panics otherwise
tyThingCoAxiom :: TyThing -> CoAxiom Branched

-- | tyThingParent_maybe x returns (Just p) when pprTyThingInContext should
--   print a declaration for p (albeit with some "..." in it) when asked to
--   show x It returns the *immediate* parent. So a datacon returns its
--   tycon but the tycon could be the associated type of a class, so it in
--   turn might have a parent.
tyThingParent_maybe :: TyThing -> Maybe TyThing
tyThingsTyCoVars :: [TyThing] -> TyCoVarSet

-- | Determine the <a>TyThing</a>s brought into scope by another
--   <a>TyThing</a> <i>other</i> than itself. For example, Id's don't have
--   any implicit TyThings as they just bring themselves into scope, but
--   classes bring their dictionary datatype, type constructor and some
--   selector functions into scope, just for a start!
implicitTyThings :: TyThing -> [TyThing]
implicitTyConThings :: TyCon -> [TyThing]
implicitClassThings :: Class -> [TyThing]

-- | Returns <tt>True</tt> if there should be no interface-file declaration
--   for this thing on its own: either it is built-in, or it is part of
--   some other declaration, or it is generated implicitly by some other
--   declaration.
isImplicitTyThing :: TyThing -> Bool

-- | A map from <a>Name</a>s to <a>TyThing</a>s, constructed by
--   typechecking local declarations or interface files
type TypeEnv = NameEnv TyThing

-- | Find the <a>TyThing</a> for the given <a>Name</a> by using all the
--   resources at our disposal: the compiled modules in the
--   <a>HomePackageTable</a> and the compiled modules in other packages
--   that live in <a>PackageTypeEnv</a>. Note that this does NOT look up
--   the <a>TyThing</a> in the module being compiled: you have to do that
--   yourself, if desired
lookupType :: DynFlags -> HomePackageTable -> PackageTypeEnv -> Name -> Maybe TyThing

-- | As <a>lookupType</a>, but with a marginally easier-to-use interface if
--   you have a <a>HscEnv</a>
lookupTypeHscEnv :: HscEnv -> Name -> IO (Maybe TyThing)
mkTypeEnv :: [TyThing] -> TypeEnv
emptyTypeEnv :: TypeEnv
typeEnvFromEntities :: [Id] -> [TyCon] -> [FamInst] -> TypeEnv
mkTypeEnvWithImplicits :: [TyThing] -> TypeEnv
extendTypeEnv :: TypeEnv -> TyThing -> TypeEnv
extendTypeEnvList :: TypeEnv -> [TyThing] -> TypeEnv
extendTypeEnvWithIds :: TypeEnv -> [Id] -> TypeEnv
plusTypeEnv :: TypeEnv -> TypeEnv -> TypeEnv
lookupTypeEnv :: TypeEnv -> Name -> Maybe TyThing
typeEnvElts :: TypeEnv -> [TyThing]
typeEnvTyCons :: TypeEnv -> [TyCon]
typeEnvIds :: TypeEnv -> [Id]
typeEnvPatSyns :: TypeEnv -> [PatSyn]
typeEnvDataCons :: TypeEnv -> [DataCon]
typeEnvCoAxioms :: TypeEnv -> [CoAxiom Branched]
typeEnvClasses :: TypeEnv -> [Class]

-- | Class that abstracts out the common ability of the monads in GHC to
--   lookup a <a>TyThing</a> in the monadic environment by <a>Name</a>.
--   Provides a number of related convenience functions for accessing
--   particular kinds of <a>TyThing</a>
class Monad m => MonadThings m
lookupThing :: MonadThings m => Name -> m TyThing
lookupId :: MonadThings m => Name -> m Id
lookupDataCon :: MonadThings m => Name -> m DataCon
lookupTyCon :: MonadThings m => Name -> m TyCon

-- | Records whether a module has orphans. An "orphan" is one of:
--   
--   <ul>
--   <li>An instance declaration in a module other than the definition
--   module for one of the type constructors or classes in the instance
--   head</li>
--   <li>A transformation rule in a module other than the one defining the
--   function in the head of the rule</li>
--   </ul>
type WhetherHasOrphans = Bool

-- | Did this module originate from a *-boot file?
type IsBootInterface = Bool

-- | Records modules for which changes may force recompilation of this
--   module See wiki:
--   <a>http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance</a>
--   
--   This differs from Dependencies. A module X may be in the dep_mods of
--   this module (via an import chain) but if we don't use anything from X
--   it won't appear in our Usage
data Usage

-- | Module from another package
UsagePackageModule :: Module -> Fingerprint -> IsSafeImport -> Usage

-- | External package module depended on
[usg_mod] :: Usage -> Module

-- | Cached module fingerprint
[usg_mod_hash] :: Usage -> Fingerprint

-- | Was this module imported as a safe import
[usg_safe] :: Usage -> IsSafeImport

-- | Module from the current package | A file upon which the module
--   depends, e.g. a CPP #include, or using TH's <tt>addDependentFile</tt>
UsageHomeModule :: ModuleName -> Fingerprint -> [(OccName, Fingerprint)] -> Maybe Fingerprint -> IsSafeImport -> Usage

-- | Name of the module
[usg_mod_name] :: Usage -> ModuleName

-- | Cached module fingerprint
[usg_mod_hash] :: Usage -> Fingerprint

-- | Entities we depend on, sorted by occurrence name and fingerprinted.
--   NB: usages are for parent names only, e.g. type constructors but not
--   the associated data constructors.
[usg_entities] :: Usage -> [(OccName, Fingerprint)]

-- | Fingerprint for the export list of this module, if we directly
--   imported it (and hence we depend on its export list)
[usg_exports] :: Usage -> Maybe Fingerprint

-- | Was this module imported as a safe import
[usg_safe] :: Usage -> IsSafeImport
UsageFile :: FilePath -> Fingerprint -> Usage

-- | External file dependency. From a CPP #include or TH addDependentFile.
--   Should be absolute.
[usg_file_path] :: Usage -> FilePath

-- | <a>Fingerprint</a> of the file contents.
[usg_file_hash] :: Usage -> Fingerprint

-- | A requirement which was merged into this one.
UsageMergedRequirement :: Module -> Fingerprint -> Usage

-- | External package module depended on
[usg_mod] :: Usage -> Module

-- | Cached module fingerprint
[usg_mod_hash] :: Usage -> Fingerprint

-- | Dependency information about ALL modules and packages below this one
--   in the import hierarchy.
--   
--   Invariant: the dependencies of a module <tt>M</tt> never includes
--   <tt>M</tt>.
--   
--   Invariant: none of the lists contain duplicates.
data Dependencies
Deps :: [(ModuleName, IsBootInterface)] -> [(InstalledUnitId, Bool)] -> [Module] -> [Module] -> [ModuleName] -> Dependencies

-- | All home-package modules transitively below this one I.e. modules that
--   this one imports, or that are in the dep_mods of those
--   directly-imported modules
[dep_mods] :: Dependencies -> [(ModuleName, IsBootInterface)]

-- | All packages transitively below this module I.e. packages to which
--   this module's direct imports belong, or that are in the dep_pkgs of
--   those modules The bool indicates if the package is required to be
--   trusted when the module is imported as a safe import (Safe Haskell).
--   See Note [RnNames . Tracking Trust Transitively]
[dep_pkgs] :: Dependencies -> [(InstalledUnitId, Bool)]

-- | Transitive closure of orphan modules (whether home or external pkg).
--   
--   (Possible optimization: don't include family instance orphans as they
--   are anyway included in <a>dep_finsts</a>. But then be careful about
--   code which relies on dep_orphs having the complete list!) This does
--   NOT include us, unlike <tt>imp_orphs</tt>.
[dep_orphs] :: Dependencies -> [Module]

-- | Transitive closure of depended upon modules which contain family
--   instances (whether home or external). This is used by
--   <tt>checkFamInstConsistency</tt>. This does NOT include us, unlike
--   <tt>imp_finsts</tt>. See Note [The type family instance consistency
--   story].
[dep_finsts] :: Dependencies -> [Module]

-- | All the plugins used while compiling this module.
[dep_plgins] :: Dependencies -> [ModuleName]
noDependencies :: Dependencies
updNameCache :: IORef NameCache -> (NameCache -> (NameCache, c)) -> IO c

-- | The original names declared of a certain module that are exported
type IfaceExport = AvailInfo

-- | Warning information for a module
data Warnings

-- | Nothing deprecated
NoWarnings :: Warnings

-- | Whole module deprecated
WarnAll :: WarningTxt -> Warnings

-- | Some specific things deprecated
WarnSome :: [(OccName, WarningTxt)] -> Warnings

-- | Warning Text
--   
--   reason/explanation from a WARNING or DEPRECATED pragma
data WarningTxt
WarningTxt :: Located SourceText -> [Located StringLiteral] -> WarningTxt
DeprecatedTxt :: Located SourceText -> [Located StringLiteral] -> WarningTxt
plusWarns :: Warnings -> Warnings -> Warnings

-- | Information we can use to dynamically link modules into the compiler
data Linkable
LM :: UTCTime -> Module -> [Unlinked] -> Linkable

-- | Time at which this linkable was built (i.e. when the bytecodes were
--   produced, or the mod date on the files)
[linkableTime] :: Linkable -> UTCTime

-- | The linkable module itself
[linkableModule] :: Linkable -> Module

-- | Those files and chunks of code we have yet to link.
--   
--   INVARIANT: A valid linkable always has at least one <a>Unlinked</a>
--   item. If this list is empty, the Linkable represents a fake linkable,
--   which is generated in HscNothing mode to avoid recompiling modules.
--   
--   ToDo: Do items get removed from this list when they get linked?
[linkableUnlinked] :: Linkable -> [Unlinked]
isObjectLinkable :: Linkable -> Bool
linkableObjs :: Linkable -> [FilePath]

-- | Objects which have yet to be linked by the compiler
data Unlinked

-- | An object file (.o)
DotO :: FilePath -> Unlinked

-- | Static archive file (.a)
DotA :: FilePath -> Unlinked

-- | Dynamically linked library file (.so, .dll, .dylib)
DotDLL :: FilePath -> Unlinked

-- | A byte-code object, lives only in memory. Also carries some static
--   pointer table entries which should be loaded along with the BCOs. See
--   Note [Grant plan for static forms] in StaticPtrTable.
BCOs :: CompiledByteCode -> [SptEntry] -> Unlinked
data CompiledByteCode

-- | Is this an actual file on disk we can link in somehow?
isObject :: Unlinked -> Bool

-- | Retrieve the filename of the linkable if possible. Panic if it is a
--   byte-code object
nameOfObject :: Unlinked -> FilePath

-- | Is this a bytecode linkable with no file on disk?
isInterpretable :: Unlinked -> Bool

-- | Retrieve the compiled byte-code if possible. Panic if it is a
--   file-based linkable
byteCodeOfObject :: Unlinked -> CompiledByteCode

-- | Information about a modules use of Haskell Program Coverage
data HpcInfo
HpcInfo :: Int -> Int -> HpcInfo
[hpcInfoTickCount] :: HpcInfo -> Int
[hpcInfoHash] :: HpcInfo -> Int
NoHpcInfo :: AnyHpcUsage -> HpcInfo

-- | Is hpc used anywhere on the module *tree*?
[hpcUsed] :: HpcInfo -> AnyHpcUsage
emptyHpcInfo :: AnyHpcUsage -> HpcInfo

-- | Find out if HPC is used by this module or any of the modules it
--   depends upon
isHpcUsed :: HpcInfo -> AnyHpcUsage

-- | This is used to signal if one of my imports used HPC instrumentation
--   even if there is no module-local HPC usage
type AnyHpcUsage = Bool

-- | All the information about the breakpoints for a module
data ModBreaks
ModBreaks :: ForeignRef BreakArray -> !Array BreakIndex SrcSpan -> !Array BreakIndex [OccName] -> !Array BreakIndex [String] -> !Array BreakIndex (RemotePtr CostCentre) -> IntMap CgBreakInfo -> ModBreaks

-- | The array of flags, one per breakpoint, indicating which breakpoints
--   are enabled.
[modBreaks_flags] :: ModBreaks -> ForeignRef BreakArray

-- | An array giving the source span of each breakpoint.
[modBreaks_locs] :: ModBreaks -> !Array BreakIndex SrcSpan

-- | An array giving the names of the free variables at each breakpoint.
[modBreaks_vars] :: ModBreaks -> !Array BreakIndex [OccName]

-- | An array giving the names of the declarations enclosing each
--   breakpoint.
[modBreaks_decls] :: ModBreaks -> !Array BreakIndex [String]

-- | Array pointing to cost centre for each breakpoint
[modBreaks_ccs] :: ModBreaks -> !Array BreakIndex (RemotePtr CostCentre)

-- | info about each breakpoint from the bytecode generator
[modBreaks_breakInfo] :: ModBreaks -> IntMap CgBreakInfo

-- | Construct an empty ModBreaks
emptyModBreaks :: ModBreaks

-- | Safe Haskell information for <a>ModIface</a> Simply a wrapper around
--   SafeHaskellMode to sepperate iface and flags
data IfaceTrustInfo
getSafeMode :: IfaceTrustInfo -> SafeHaskellMode
setSafeMode :: SafeHaskellMode -> IfaceTrustInfo
noIfaceTrustInfo :: IfaceTrustInfo
trustInfoToNum :: IfaceTrustInfo -> Word8
numToTrustInfo :: Word8 -> IfaceTrustInfo

-- | Is an import a safe import?
type IsSafeImport = Bool
data HsParsedModule
HsParsedModule :: Located (HsModule GhcPs) -> [FilePath] -> ApiAnns -> HsParsedModule
[hpm_module] :: HsParsedModule -> Located (HsModule GhcPs)

-- | extra source files (e.g. from #includes). The lexer collects these
--   from '# <a>file</a> <a>line</a>' pragmas, which the C preprocessor
--   leaves behind. These files and their timestamps are stored in the .hi
--   file, so that we can force recompilation if any of them change (#3589)
[hpm_src_files] :: HsParsedModule -> [FilePath]
[hpm_annotations] :: HsParsedModule -> ApiAnns

-- | A source error is an error that is caused by one or more errors in the
--   source code. A <a>SourceError</a> is thrown by many functions in the
--   compilation pipeline. Inside GHC these errors are merely printed via
--   <a>log_action</a>, but API clients may treat them differently, for
--   example, insert them into a list box. If you want the default
--   behaviour, use the idiom:
--   
--   <pre>
--   handleSourceError printExceptionAndWarnings $ do
--     ... api calls that may fail ...
--   </pre>
--   
--   The <a>SourceError</a>s error messages can be accessed via
--   <a>srcErrorMessages</a>. This list may be empty if the compiler failed
--   due to <tt>-Werror</tt> (<a>Opt_WarnIsError</a>).
--   
--   See <tt>printExceptionAndWarnings</tt> for more information on what to
--   take care of when writing a custom error handler.
data SourceError

-- | An error thrown if the GHC API is used in an incorrect fashion.
data GhcApiError
mkSrcErr :: ErrorMessages -> SourceError
srcErrorMessages :: SourceError -> ErrorMessages
mkApiErr :: DynFlags -> SDoc -> GhcApiError
throwOneError :: MonadIO m => ErrMsg -> m ab

-- | Perform the given action and call the exception handler if the action
--   throws a <a>SourceError</a>. See <a>SourceError</a> for more
--   information.
handleSourceError :: ExceptionMonad m => (SourceError -> m a) -> m a -> m a
handleFlagWarnings :: DynFlags -> [Warn] -> IO ()

-- | Given a bag of warnings, turn them into an exception if -Werror is
--   enabled, or print them out otherwise.
printOrThrowWarnings :: DynFlags -> Bag WarnMsg -> IO ()

-- | A list of conlikes which represents a complete pattern match. These
--   arise from <tt>COMPLETE</tt> signatures.
data CompleteMatch
CompleteMatch :: [Name] -> Name -> CompleteMatch

-- | The ConLikes that form a covering family (e.g. Nothing, Just)
[completeMatchConLikes] :: CompleteMatch -> [Name]

-- | The TyCon that they cover (e.g. Maybe)
[completeMatchTyCon] :: CompleteMatch -> Name

-- | A map keyed by the <a>completeMatchTyCon</a>.
type CompleteMatchMap = UniqFM [CompleteMatch]
mkCompleteMatchMap :: [CompleteMatch] -> CompleteMatchMap
extendCompleteMatchMap :: CompleteMatchMap -> [CompleteMatch] -> CompleteMatchMap
instance GHC.Classes.Eq HscTypes.Usage
instance GHC.Classes.Eq HscTypes.Dependencies
instance GHC.Classes.Eq HscTypes.Warnings
instance GHC.Classes.Eq HscTypes.TargetId
instance GHC.Base.Functor HscTypes.Hsc
instance GHC.Base.Applicative HscTypes.Hsc
instance GHC.Base.Monad HscTypes.Hsc
instance Control.Monad.IO.Class.MonadIO HscTypes.Hsc
instance DynFlags.HasDynFlags HscTypes.Hsc
instance Outputable.Outputable HscTypes.CompleteMatch
instance Outputable.Outputable HscTypes.Linkable
instance Outputable.Outputable HscTypes.Unlinked
instance Outputable.Outputable HscTypes.ModSummary
instance Binary.Binary HscTypes.ModIface
instance Outputable.Outputable HscTypes.IfaceTrustInfo
instance Binary.Binary HscTypes.IfaceTrustInfo
instance Binary.Binary HscTypes.Usage
instance Binary.Binary HscTypes.Dependencies
instance Outputable.Outputable HscTypes.FixItem
instance Binary.Binary HscTypes.Warnings
instance Outputable.Outputable HscTypes.InteractiveImport
instance Outputable.Outputable HscTypes.SptEntry
instance Outputable.Outputable HscTypes.Target
instance Outputable.Outputable HscTypes.TargetId
instance GHC.Show.Show HscTypes.GhcApiError
instance GHC.Exception.Type.Exception HscTypes.GhcApiError
instance GHC.Show.Show HscTypes.SourceError
instance GHC.Exception.Type.Exception HscTypes.SourceError

module TcRnTypes
type TcRnIf a b = IOEnv (Env a b)
type TcRn = TcRnIf TcGblEnv TcLclEnv

-- | Historical "type-checking monad" (now it's just <a>TcRn</a>).
type TcM = TcRn

-- | Historical "renaming monad" (now it's just <a>TcRn</a>).
type RnM = TcRn
type IfM lcl = TcRnIf IfGblEnv lcl
type IfL = IfM IfLclEnv
type IfG = IfM ()

-- | Type alias for <a>IORef</a>; the convention is we'll use this for
--   mutable bits of data in <a>TcGblEnv</a> which are updated during
--   typechecking and returned at the end.
type TcRef a = IORef a
data Env gbl lcl
Env :: !HscEnv -> {-# UNPACK #-} !IORef UniqSupply -> gbl -> lcl -> Env gbl lcl
[env_top] :: Env gbl lcl -> !HscEnv
[env_us] :: Env gbl lcl -> {-# UNPACK #-} !IORef UniqSupply
[env_gbl] :: Env gbl lcl -> gbl
[env_lcl] :: Env gbl lcl -> lcl

-- | <a>TcGblEnv</a> describes the top-level of the module at the point at
--   which the typechecker is finished work. It is this structure that is
--   handed on to the desugarer For state that needs to be updated during
--   the typechecking phase and returned at end, use a <a>TcRef</a> (=
--   <a>IORef</a>).
data TcGblEnv
TcGblEnv :: Module -> Module -> HscSource -> GlobalRdrEnv -> Maybe [Type] -> FixityEnv -> RecFieldEnv -> TypeEnv -> TcRef TypeEnv -> !InstEnv -> !FamInstEnv -> AnnEnv -> [AvailInfo] -> ImportAvails -> DefUses -> TcRef [GlobalRdrElt] -> TcRef NameSet -> TcRef Bool -> TcRef Bool -> TcRef (Set RealSrcSpan) -> TcRef OccSet -> [(Module, Fingerprint)] -> Maybe [(Located (IE GhcRn), Avails)] -> [LImportDecl GhcRn] -> Maybe (HsGroup GhcRn) -> TcRef [FilePath] -> TcRef [LHsDecl GhcPs] -> TcRef [(ForeignSrcLang, FilePath)] -> TcRef NameSet -> TcRef [(TcLclEnv, ThModFinalizers)] -> TcRef [String] -> TcRef (Map TypeRep Dynamic) -> TcRef (Maybe (ForeignRef (IORef QState))) -> Bag EvBind -> Maybe Id -> LHsBinds GhcTc -> NameSet -> [LTcSpecPrag] -> Warnings -> [Annotation] -> [TyCon] -> [ClsInst] -> [FamInst] -> [LRuleDecl GhcTc] -> [LForeignDecl GhcTc] -> [PatSyn] -> Maybe LHsDocString -> !AnyHpcUsage -> SelfBootInfo -> Maybe Name -> TcRef (Bool, WarningMessages) -> [TcPluginSolver] -> RealSrcSpan -> TcRef WantedConstraints -> [CompleteMatch] -> TcRef CostCentreState -> TcGblEnv

-- | Module being compiled
[tcg_mod] :: TcGblEnv -> Module

-- | If a signature, the backing module See also Note [Identity versus
--   semantic module]
[tcg_semantic_mod] :: TcGblEnv -> Module

-- | What kind of module (regular Haskell, hs-boot, hsig)
[tcg_src] :: TcGblEnv -> HscSource

-- | Top level envt; used during renaming
[tcg_rdr_env] :: TcGblEnv -> GlobalRdrEnv

-- | Types used for defaulting. <tt>Nothing</tt> =&gt; no <tt>default</tt>
--   decl
[tcg_default] :: TcGblEnv -> Maybe [Type]

-- | Just for things in this module
[tcg_fix_env] :: TcGblEnv -> FixityEnv

-- | Just for things in this module See Note [The interactive package] in
--   HscTypes
[tcg_field_env] :: TcGblEnv -> RecFieldEnv

-- | Global type env for the module we are compiling now. All TyCons and
--   Classes (for this module) end up in here right away, along with their
--   derived constructors, selectors.
--   
--   (Ids defined in this module start in the local envt, though they move
--   to the global envt during zonking)
--   
--   NB: for what "things in this module" means, see Note [The interactive
--   package] in HscTypes
[tcg_type_env] :: TcGblEnv -> TypeEnv
[tcg_type_env_var] :: TcGblEnv -> TcRef TypeEnv

-- | Instance envt for all <i>home-package</i> modules; Includes the dfuns
--   in tcg_insts NB. BangPattern is to fix a leak, see #15111
[tcg_inst_env] :: TcGblEnv -> !InstEnv

-- | Ditto for family instances NB. BangPattern is to fix a leak, see
--   #15111
[tcg_fam_inst_env] :: TcGblEnv -> !FamInstEnv

-- | And for annotations
[tcg_ann_env] :: TcGblEnv -> AnnEnv

-- | What is exported
[tcg_exports] :: TcGblEnv -> [AvailInfo]

-- | Information about what was imported from where, including things bound
--   in this module. Also store Safe Haskell info here about transitive
--   trusted package requirements.
--   
--   There are not many uses of this field, so you can grep for all them.
--   
--   The ImportAvails records information about the following things:
--   
--   <ol>
--   <li>All of the modules you directly imported (tcRnImports)</li>
--   <li>The orphans (only!) of all imported modules in a GHCi session
--   (runTcInteractive)</li>
--   <li>The module that instantiated a signature</li>
--   <li>Each of the signatures that merged in</li>
--   </ol>
--   
--   It is used in the following ways: - imp_orphs is used to determine
--   what orphan modules should be visible in the context
--   (tcVisibleOrphanMods) - imp_finsts is used to determine what family
--   instances should be visible (tcExtendLocalFamInstEnv) - To resolve the
--   meaning of the export list of a module (tcRnExports) - imp_mods is
--   used to compute usage info (mkIfaceTc, deSugar) - imp_trust_own_pkg is
--   used for Safe Haskell in interfaces (mkIfaceTc, as well as in HscMain)
--   - To create the Dependencies field in interface (mkDependencies)
[tcg_imports] :: TcGblEnv -> ImportAvails

-- | What is defined in this module and what is used.
[tcg_dus] :: TcGblEnv -> DefUses

-- | Records occurrences of imported entities One entry for each
--   occurrence; but may have different GREs for the same Name See Note
--   [Tracking unused binding and imports]
[tcg_used_gres] :: TcGblEnv -> TcRef [GlobalRdrElt]

-- | Locally-defined top-level names to keep alive.
--   
--   "Keep alive" means give them an Exported flag, so that the simplifier
--   does not discard them as dead code, and so that they are exposed in
--   the interface file (but not to export to the user).
--   
--   Some things, like dict-fun Ids and default-method Ids are "born" with
--   the Exported flag on, for exactly the above reason, but some we only
--   discover as we go. Specifically:
--   
--   <ul>
--   <li>The to/from functions for generic data types</li>
--   <li>Top-level variables appearing free in the RHS of an orphan
--   rule</li>
--   <li>Top-level variables appearing free in a TH bracket</li>
--   </ul>
[tcg_keep] :: TcGblEnv -> TcRef NameSet

-- | <tt>True</tt> <a>=</a> Template Haskell syntax used.
--   
--   We need this so that we can generate a dependency on the Template
--   Haskell package, because the desugarer is going to emit loads of
--   references to TH symbols. The reference is implicit rather than
--   explicit, so we have to zap a mutable variable.
[tcg_th_used] :: TcGblEnv -> TcRef Bool

-- | <tt>True</tt> <a>=</a> A Template Haskell splice was used.
--   
--   Splices disable recompilation avoidance (see #481)
[tcg_th_splice_used] :: TcGblEnv -> TcRef Bool

-- | Locations of the top-level splices; used for providing details on
--   scope in error messages for out-of-scope variables
[tcg_th_top_level_locs] :: TcGblEnv -> TcRef (Set RealSrcSpan)

-- | Allows us to choose unique DFun names.
[tcg_dfun_n] :: TcGblEnv -> TcRef OccSet

-- | The requirements we merged with; we always have to recompile if any of
--   these changed.
[tcg_merged] :: TcGblEnv -> [(Module, Fingerprint)]
[tcg_rn_exports] :: TcGblEnv -> Maybe [(Located (IE GhcRn), Avails)]
[tcg_rn_imports] :: TcGblEnv -> [LImportDecl GhcRn]

-- | Renamed decls, maybe. <tt>Nothing</tt> <a>=</a> Don't retain renamed
--   decls.
[tcg_rn_decls] :: TcGblEnv -> Maybe (HsGroup GhcRn)

-- | dependencies from addDependentFile
[tcg_dependent_files] :: TcGblEnv -> TcRef [FilePath]

-- | Top-level declarations from addTopDecls
[tcg_th_topdecls] :: TcGblEnv -> TcRef [LHsDecl GhcPs]

-- | Foreign files emitted from TH.
[tcg_th_foreign_files] :: TcGblEnv -> TcRef [(ForeignSrcLang, FilePath)]

-- | Exact names bound in top-level declarations in tcg_th_topdecls
[tcg_th_topnames] :: TcGblEnv -> TcRef NameSet

-- | Template Haskell module finalizers.
--   
--   They can use particular local environments.
[tcg_th_modfinalizers] :: TcGblEnv -> TcRef [(TcLclEnv, ThModFinalizers)]

-- | Core plugins added by Template Haskell code.
[tcg_th_coreplugins] :: TcGblEnv -> TcRef [String]
[tcg_th_state] :: TcGblEnv -> TcRef (Map TypeRep Dynamic)

-- | Template Haskell state
[tcg_th_remote_state] :: TcGblEnv -> TcRef (Maybe (ForeignRef (IORef QState)))
[tcg_ev_binds] :: TcGblEnv -> Bag EvBind
[tcg_tr_module] :: TcGblEnv -> Maybe Id
[tcg_binds] :: TcGblEnv -> LHsBinds GhcTc
[tcg_sigs] :: TcGblEnv -> NameSet
[tcg_imp_specs] :: TcGblEnv -> [LTcSpecPrag]
[tcg_warns] :: TcGblEnv -> Warnings
[tcg_anns] :: TcGblEnv -> [Annotation]
[tcg_tcs] :: TcGblEnv -> [TyCon]
[tcg_insts] :: TcGblEnv -> [ClsInst]
[tcg_fam_insts] :: TcGblEnv -> [FamInst]
[tcg_rules] :: TcGblEnv -> [LRuleDecl GhcTc]
[tcg_fords] :: TcGblEnv -> [LForeignDecl GhcTc]
[tcg_patsyns] :: TcGblEnv -> [PatSyn]

-- | Maybe Haddock header docs
[tcg_doc_hdr] :: TcGblEnv -> Maybe LHsDocString

-- | <tt>True</tt> if any part of the prog uses hpc instrumentation. NB.
--   BangPattern is to fix a leak, see #15111
[tcg_hpc] :: TcGblEnv -> !AnyHpcUsage

-- | Whether this module has a corresponding hi-boot file
[tcg_self_boot] :: TcGblEnv -> SelfBootInfo

-- | The Name of the main function, if this module is the main module.
[tcg_main] :: TcGblEnv -> Maybe Name

-- | Has the typechecker inferred this module as -XSafe (Safe Haskell) See
--   Note [Safe Haskell Overlapping Instances Implementation], although
--   this is used for more than just that failure case.
[tcg_safeInfer] :: TcGblEnv -> TcRef (Bool, WarningMessages)

-- | A list of user-defined plugins for the constraint solver.
[tcg_tc_plugins] :: TcGblEnv -> [TcPluginSolver]

-- | The RealSrcSpan this module came from
[tcg_top_loc] :: TcGblEnv -> RealSrcSpan

-- | Wanted constraints of static forms. See Note [Constraints in static
--   forms].
[tcg_static_wc] :: TcGblEnv -> TcRef WantedConstraints

-- | Tracking indices for cost centre annotations
[tcg_complete_matches] :: TcGblEnv -> [CompleteMatch]
[tcg_cc_st] :: TcGblEnv -> TcRef CostCentreState
data TcLclEnv
TcLclEnv :: RealSrcSpan -> [ErrCtxt] -> TcLevel -> ThStage -> ThBindEnv -> ArrowCtxt -> LocalRdrEnv -> TcTypeEnv -> TcBinderStack -> TcRef TcTyVarSet -> TcRef WantedConstraints -> TcRef Messages -> TcLclEnv
[tcl_loc] :: TcLclEnv -> RealSrcSpan
[tcl_ctxt] :: TcLclEnv -> [ErrCtxt]
[tcl_tclvl] :: TcLclEnv -> TcLevel
[tcl_th_ctxt] :: TcLclEnv -> ThStage
[tcl_th_bndrs] :: TcLclEnv -> ThBindEnv
[tcl_arrow_ctxt] :: TcLclEnv -> ArrowCtxt
[tcl_rdr] :: TcLclEnv -> LocalRdrEnv
[tcl_env] :: TcLclEnv -> TcTypeEnv
[tcl_bndrs] :: TcLclEnv -> TcBinderStack
[tcl_tyvars] :: TcLclEnv -> TcRef TcTyVarSet
[tcl_lie] :: TcLclEnv -> TcRef WantedConstraints
[tcl_errs] :: TcLclEnv -> TcRef Messages
data IfGblEnv
IfGblEnv :: SDoc -> Maybe (Module, IfG TypeEnv) -> IfGblEnv
[if_doc] :: IfGblEnv -> SDoc
[if_rec_types] :: IfGblEnv -> Maybe (Module, IfG TypeEnv)
data IfLclEnv
IfLclEnv :: Module -> Bool -> SDoc -> Maybe NameShape -> Maybe TypeEnv -> FastStringEnv TyVar -> FastStringEnv Id -> IfLclEnv
[if_mod] :: IfLclEnv -> Module
[if_boot] :: IfLclEnv -> Bool
[if_loc] :: IfLclEnv -> SDoc
[if_nsubst] :: IfLclEnv -> Maybe NameShape
[if_implicits_env] :: IfLclEnv -> Maybe TypeEnv
[if_tv_env] :: IfLclEnv -> FastStringEnv TyVar
[if_id_env] :: IfLclEnv -> FastStringEnv Id
tcVisibleOrphanMods :: TcGblEnv -> ModuleSet

-- | <a>FrontendResult</a> describes the result of running the frontend of
--   a Haskell module. Usually, you'll get a <a>FrontendTypecheck</a>,
--   since running the frontend involves typechecking a program, but for an
--   hs-boot merge you'll just get a ModIface, since no actual typechecking
--   occurred.
--   
--   This data type really should be in HscTypes, but it needs to have a
--   TcGblEnv which is only defined here.
data FrontendResult
FrontendTypecheck :: TcGblEnv -> FrontendResult
type ErrCtxt = (Bool, TidyEnv -> TcM (TidyEnv, MsgDoc))
type RecFieldEnv = NameEnv [FieldLabel]

-- | <a>ImportAvails</a> summarises what was imported from where,
--   irrespective of whether the imported things are actually used or not.
--   It is used:
--   
--   <ul>
--   <li>when processing the export list,</li>
--   <li>when constructing usage info for the interface file,</li>
--   <li>to identify the list of directly imported modules for
--   initialisation purposes and for optimised overlap checking of family
--   instances,</li>
--   <li>when figuring out what things are really unused</li>
--   </ul>
data ImportAvails
ImportAvails :: ImportedMods -> ModuleNameEnv (ModuleName, IsBootInterface) -> Set InstalledUnitId -> Set InstalledUnitId -> Bool -> [Module] -> [Module] -> ImportAvails

-- | Domain is all directly-imported modules
--   
--   See the documentation on ImportedModsVal in HscTypes for the meaning
--   of the fields.
--   
--   We need a full ModuleEnv rather than a ModuleNameEnv here, because we
--   might be importing modules of the same name from different packages.
--   (currently not the case, but might be in the future).
[imp_mods] :: ImportAvails -> ImportedMods

-- | Home-package modules needed by the module being compiled
--   
--   It doesn't matter whether any of these dependencies are actually
--   <i>used</i> when compiling the module; they are listed if they are
--   below it at all. For example, suppose M imports A which imports X.
--   Then compiling M might not need to consult X.hi, but X is still listed
--   in M's dependencies.
[imp_dep_mods] :: ImportAvails -> ModuleNameEnv (ModuleName, IsBootInterface)

-- | Packages needed by the module being compiled, whether directly, or via
--   other modules in this package, or via modules imported from other
--   packages.
[imp_dep_pkgs] :: ImportAvails -> Set InstalledUnitId

-- | This is strictly a subset of imp_dep_pkgs and records the packages the
--   current module needs to trust for Safe Haskell compilation to succeed.
--   A package is required to be trusted if we are dependent on a
--   trustworthy module in that package. While perhaps making imp_dep_pkgs
--   a tuple of (UnitId, Bool) where True for the bool indicates the
--   package is required to be trusted is the more logical design, doing so
--   complicates a lot of code not concerned with Safe Haskell. See Note
--   [RnNames . Tracking Trust Transitively]
[imp_trust_pkgs] :: ImportAvails -> Set InstalledUnitId

-- | Do we require that our own package is trusted? This is to handle
--   efficiently the case where a Safe module imports a Trustworthy module
--   that resides in the same package as it. See Note [RnNames . Trust Own
--   Package]
[imp_trust_own_pkg] :: ImportAvails -> Bool

-- | Orphan modules below us in the import tree (and maybe including us for
--   imported modules)
[imp_orphs] :: ImportAvails -> [Module]

-- | Family instance modules below us in the import tree (and maybe
--   including us for imported modules)
[imp_finsts] :: ImportAvails -> [Module]
emptyImportAvails :: ImportAvails

-- | Union two ImportAvails
--   
--   This function is a key part of Import handling, basically for each
--   import we create a separate ImportAvails structure and then union them
--   all together with this function.
plusImportAvails :: ImportAvails -> ImportAvails -> ImportAvails
data WhereFrom
ImportByUser :: IsBootInterface -> WhereFrom
ImportBySystem :: WhereFrom
ImportByPlugin :: WhereFrom
mkModDeps :: [(ModuleName, IsBootInterface)] -> ModuleNameEnv (ModuleName, IsBootInterface)
modDepsElts :: ModuleNameEnv (ModuleName, IsBootInterface) -> [(ModuleName, IsBootInterface)]
type TcTypeEnv = NameEnv TcTyThing
type TcBinderStack = [TcBinder]
data TcBinder
TcIdBndr :: TcId -> TopLevelFlag -> TcBinder
TcIdBndr_ExpType :: Name -> ExpType -> TopLevelFlag -> TcBinder
TcTvBndr :: Name -> TyVar -> TcBinder

-- | A typecheckable thing available in a local context. Could be
--   <a>AGlobal</a> <a>TyThing</a>, but also lexically scoped variables,
--   etc. See <tt>TcEnv</tt> for how to retrieve a <a>TyThing</a> given a
--   <a>Name</a>.
data TcTyThing
AGlobal :: TyThing -> TcTyThing
ATcId :: TcId -> IdBindingInfo -> TcTyThing
[tct_id] :: TcTyThing -> TcId
[tct_info] :: TcTyThing -> IdBindingInfo
ATyVar :: Name -> TcTyVar -> TcTyThing
ATcTyCon :: TyCon -> TcTyThing
APromotionErr :: PromotionErr -> TcTyThing
data PromotionErr
TyConPE :: PromotionErr
ClassPE :: PromotionErr
FamDataConPE :: PromotionErr
ConstrainedDataConPE :: PredType -> PromotionErr
PatSynPE :: PromotionErr
PatSynExPE :: PromotionErr
RecDataConPE :: PromotionErr
NoDataKindsTC :: PromotionErr
NoDataKindsDC :: PromotionErr

-- | IdBindingInfo describes how an Id is bound.
--   
--   It is used for the following purposes: a) for static forms in
--   TcExpr.checkClosedInStaticForm and b) to figure out when a nested
--   binding can be generalised, in TcBinds.decideGeneralisationPlan.
data IdBindingInfo
NotLetBound :: IdBindingInfo
ClosedLet :: IdBindingInfo
NonClosedLet :: RhsNames -> ClosedTypeId -> IdBindingInfo
type ClosedTypeId = Bool
type RhsNames = NameSet

-- | IsGroupClosed describes a group of mutually-recursive bindings
data IsGroupClosed
IsGroupClosed :: NameEnv RhsNames -> ClosedTypeId -> IsGroupClosed
data SelfBootInfo
NoSelfBoot :: SelfBootInfo
SelfBoot :: ModDetails -> NameSet -> SelfBootInfo
[sb_mds] :: SelfBootInfo -> ModDetails
[sb_tcs] :: SelfBootInfo -> NameSet
pprTcTyThingCategory :: TcTyThing -> SDoc
pprPECategory :: PromotionErr -> SDoc

-- | A list of conlikes which represents a complete pattern match. These
--   arise from <tt>COMPLETE</tt> signatures.
data CompleteMatch
CompleteMatch :: [Name] -> Name -> CompleteMatch

-- | The ConLikes that form a covering family (e.g. Nothing, Just)
[completeMatchConLikes] :: CompleteMatch -> [Name]

-- | The TyCon that they cover (e.g. Maybe)
[completeMatchTyCon] :: CompleteMatch -> Name
type DsM = TcRnIf DsGblEnv DsLclEnv
data DsLclEnv
DsLclEnv :: DsMetaEnv -> RealSrcSpan -> Bag EvVar -> Bag SimpleEq -> IORef Int -> DsLclEnv
[dsl_meta] :: DsLclEnv -> DsMetaEnv
[dsl_loc] :: DsLclEnv -> RealSrcSpan
[dsl_dicts] :: DsLclEnv -> Bag EvVar
[dsl_tm_cs] :: DsLclEnv -> Bag SimpleEq
[dsl_pm_iter] :: DsLclEnv -> IORef Int
data DsGblEnv
DsGblEnv :: Module -> FamInstEnv -> PrintUnqualified -> IORef Messages -> (IfGblEnv, IfLclEnv) -> CompleteMatchMap -> IORef CostCentreState -> DsGblEnv
[ds_mod] :: DsGblEnv -> Module
[ds_fam_inst_env] :: DsGblEnv -> FamInstEnv
[ds_unqual] :: DsGblEnv -> PrintUnqualified
[ds_msgs] :: DsGblEnv -> IORef Messages
[ds_if_env] :: DsGblEnv -> (IfGblEnv, IfLclEnv)
[ds_complete_matches] :: DsGblEnv -> CompleteMatchMap
[ds_cc_st] :: DsGblEnv -> IORef CostCentreState
type DsMetaEnv = NameEnv DsMetaVal
data DsMetaVal
DsBound :: Id -> DsMetaVal
DsSplice :: HsExpr GhcTc -> DsMetaVal

-- | A map keyed by the <a>completeMatchTyCon</a>.
type CompleteMatchMap = UniqFM [CompleteMatch]
mkCompleteMatchMap :: [CompleteMatch] -> CompleteMatchMap
extendCompleteMatchMap :: CompleteMatchMap -> [CompleteMatch] -> CompleteMatchMap
data ThStage
Splice :: SpliceType -> ThStage
RunSplice :: TcRef [ForeignRef (Q ())] -> ThStage
Comp :: ThStage
Brack :: ThStage -> PendingStuff -> ThStage
data SpliceType
Typed :: SpliceType
Untyped :: SpliceType
data PendingStuff
RnPendingUntyped :: TcRef [PendingRnSplice] -> PendingStuff
RnPendingTyped :: PendingStuff
TcPending :: TcRef [PendingTcSplice] -> TcRef WantedConstraints -> PendingStuff
topStage :: ThStage
topAnnStage :: ThStage
topSpliceStage :: ThStage
type ThLevel = Int
impLevel :: ThLevel
outerLevel :: ThLevel
thLevel :: ThStage -> ThLevel

-- | Foreign formats supported by GHC via TH
data ForeignSrcLang

-- | C
LangC :: ForeignSrcLang

-- | C++
LangCxx :: ForeignSrcLang

-- | Objective C
LangObjc :: ForeignSrcLang

-- | Objective C++
LangObjcxx :: ForeignSrcLang

-- | Assembly language (.s)
LangAsm :: ForeignSrcLang

-- | Object (.o)
RawObject :: ForeignSrcLang
data ArrowCtxt
NoArrowCtxt :: ArrowCtxt
ArrowCtxt :: LocalRdrEnv -> TcRef WantedConstraints -> ArrowCtxt
type TcSigFun = Name -> Maybe TcSigInfo
data TcSigInfo
TcIdSig :: TcIdSigInfo -> TcSigInfo
TcPatSynSig :: TcPatSynInfo -> TcSigInfo
data TcIdSigInfo
CompleteSig :: TcId -> UserTypeCtxt -> SrcSpan -> TcIdSigInfo
[sig_bndr] :: TcIdSigInfo -> TcId
[sig_ctxt] :: TcIdSigInfo -> UserTypeCtxt
[sig_loc] :: TcIdSigInfo -> SrcSpan
PartialSig :: Name -> LHsSigWcType GhcRn -> UserTypeCtxt -> SrcSpan -> TcIdSigInfo
[psig_name] :: TcIdSigInfo -> Name
[psig_hs_ty] :: TcIdSigInfo -> LHsSigWcType GhcRn
[sig_ctxt] :: TcIdSigInfo -> UserTypeCtxt
[sig_loc] :: TcIdSigInfo -> SrcSpan
data TcIdSigInst
TISI :: TcIdSigInfo -> [(Name, TcTyVar)] -> TcThetaType -> TcSigmaType -> [(Name, TcTyVar)] -> Maybe TcType -> TcIdSigInst
[sig_inst_sig] :: TcIdSigInst -> TcIdSigInfo
[sig_inst_skols] :: TcIdSigInst -> [(Name, TcTyVar)]
[sig_inst_theta] :: TcIdSigInst -> TcThetaType
[sig_inst_tau] :: TcIdSigInst -> TcSigmaType
[sig_inst_wcs] :: TcIdSigInst -> [(Name, TcTyVar)]
[sig_inst_wcx] :: TcIdSigInst -> Maybe TcType
data TcPatSynInfo
TPSI :: Name -> [TyVarBinder] -> [TyVar] -> TcThetaType -> [TyVar] -> TcThetaType -> TcSigmaType -> TcPatSynInfo
[patsig_name] :: TcPatSynInfo -> Name
[patsig_implicit_bndrs] :: TcPatSynInfo -> [TyVarBinder]
[patsig_univ_bndrs] :: TcPatSynInfo -> [TyVar]
[patsig_req] :: TcPatSynInfo -> TcThetaType
[patsig_ex_bndrs] :: TcPatSynInfo -> [TyVar]
[patsig_prov] :: TcPatSynInfo -> TcThetaType
[patsig_body_ty] :: TcPatSynInfo -> TcSigmaType
isPartialSig :: TcIdSigInst -> Bool

-- | No signature or a partial signature
hasCompleteSig :: TcSigFun -> Name -> Bool
data QCInst
QCI :: CtEvidence -> [TcTyVar] -> TcPredType -> Bool -> QCInst
[qci_ev] :: QCInst -> CtEvidence
[qci_tvs] :: QCInst -> [TcTyVar]
[qci_pred] :: QCInst -> TcPredType
[qci_pend_sc] :: QCInst -> Bool
isPendingScInst :: QCInst -> Maybe QCInst
type Xi = Type
data Ct
CDictCan :: CtEvidence -> Class -> [Xi] -> Bool -> Ct
[cc_ev] :: Ct -> CtEvidence
[cc_class] :: Ct -> Class
[cc_tyargs] :: Ct -> [Xi]
[cc_pend_sc] :: Ct -> Bool
CIrredCan :: CtEvidence -> Bool -> Ct
[cc_ev] :: Ct -> CtEvidence
[cc_insol] :: Ct -> Bool
CTyEqCan :: CtEvidence -> TcTyVar -> TcType -> EqRel -> Ct
[cc_ev] :: Ct -> CtEvidence
[cc_tyvar] :: Ct -> TcTyVar
[cc_rhs] :: Ct -> TcType
[cc_eq_rel] :: Ct -> EqRel
CFunEqCan :: CtEvidence -> TyCon -> [Xi] -> TcTyVar -> Ct
[cc_ev] :: Ct -> CtEvidence
[cc_fun] :: Ct -> TyCon
[cc_tyargs] :: Ct -> [Xi]
[cc_fsk] :: Ct -> TcTyVar
CNonCanonical :: CtEvidence -> Ct
[cc_ev] :: Ct -> CtEvidence
CHoleCan :: CtEvidence -> Hole -> Ct
[cc_ev] :: Ct -> CtEvidence
[cc_hole] :: Ct -> Hole
CQuantCan :: QCInst -> Ct
type Cts = Bag Ct
emptyCts :: Cts
andCts :: Cts -> Cts -> Cts
andManyCts :: [Cts] -> Cts
pprCts :: Cts -> SDoc
singleCt :: Ct -> Cts
listToCts :: [Ct] -> Cts
ctsElts :: Cts -> [Ct]
consCts :: Ct -> Cts -> Cts
snocCts :: Cts -> Ct -> Cts
extendCtsList :: Cts -> [Ct] -> Cts
isEmptyCts :: Cts -> Bool
isCTyEqCan :: Ct -> Bool
isCFunEqCan :: Ct -> Bool
isPendingScDict :: Ct -> Maybe Ct

-- | True if taking superclasses of givens, or of wanteds (to perhaps
--   expose more equalities or functional dependencies) might help to solve
--   this constraint. See Note [When superclasses help]
superClassesMightHelp :: WantedConstraints -> Bool
getPendingWantedScs :: Cts -> ([Ct], Cts)
isCDictCan_Maybe :: Ct -> Maybe Class
isCFunEqCan_maybe :: Ct -> Maybe (TyCon, [Type])
isCNonCanonical :: Ct -> Bool
isWantedCt :: Ct -> Bool
isDerivedCt :: Ct -> Bool
isGivenCt :: Ct -> Bool
isHoleCt :: Ct -> Bool
isOutOfScopeCt :: Ct -> Bool
isExprHoleCt :: Ct -> Bool
isTypeHoleCt :: Ct -> Bool
isUserTypeErrorCt :: Ct -> Bool

-- | A constraint is considered to be a custom type error, if it contains
--   custom type errors anywhere in it. See Note [Custom type errors in
--   constraints]
getUserTypeErrorMsg :: Ct -> Maybe Type
ctEvidence :: Ct -> CtEvidence
ctLoc :: Ct -> CtLoc
setCtLoc :: Ct -> CtLoc -> Ct
ctPred :: Ct -> PredType

-- | Get the flavour of the given <a>Ct</a>
ctFlavour :: Ct -> CtFlavour

-- | Get the equality relation for the given <a>Ct</a>
ctEqRel :: Ct -> EqRel
ctOrigin :: Ct -> CtOrigin
ctEvId :: Ct -> EvVar

-- | Makes a new equality predicate with the same role as the given
--   evidence.
mkTcEqPredLikeEv :: CtEvidence -> TcType -> TcType -> TcType
mkNonCanonical :: CtEvidence -> Ct
mkNonCanonicalCt :: Ct -> Ct
mkGivens :: CtLoc -> [EvId] -> [Ct]
mkIrredCt :: CtEvidence -> Ct
mkInsolubleCt :: CtEvidence -> Ct
ctEvPred :: CtEvidence -> TcPredType
ctEvLoc :: CtEvidence -> CtLoc
ctEvOrigin :: CtEvidence -> CtOrigin

-- | Get the equality relation relevant for a <a>CtEvidence</a>
ctEvEqRel :: CtEvidence -> EqRel
ctEvExpr :: CtEvidence -> EvExpr
ctEvTerm :: CtEvidence -> EvTerm
ctEvCoercion :: HasDebugCallStack => CtEvidence -> Coercion
ctEvEvId :: CtEvidence -> EvVar

-- | Returns free variables of constraints as a non-deterministic set
tyCoVarsOfCt :: Ct -> TcTyCoVarSet

-- | Returns free variables of a bag of constraints as a non-deterministic
--   set. See Note [Deterministic FV] in FV.
tyCoVarsOfCts :: Cts -> TcTyCoVarSet

-- | Returns free variables of constraints as a deterministically ordered.
--   list. See Note [Deterministic FV] in FV.
tyCoVarsOfCtList :: Ct -> [TcTyCoVar]

-- | Returns free variables of a bag of constraints as a deterministically
--   odered list. See Note [Deterministic FV] in FV.
tyCoVarsOfCtsList :: Cts -> [TcTyCoVar]
data WantedConstraints
WC :: Cts -> Bag Implication -> WantedConstraints
[wc_simple] :: WantedConstraints -> Cts
[wc_impl] :: WantedConstraints -> Bag Implication
insolubleWC :: WantedConstraints -> Bool
emptyWC :: WantedConstraints
isEmptyWC :: WantedConstraints -> Bool

-- | Checks whether a the given wanted constraints are solved, i.e. that
--   there are no simple constraints left and all the implications are
--   solved.
isSolvedWC :: WantedConstraints -> Bool
andWC :: WantedConstraints -> WantedConstraints -> WantedConstraints
unionsWC :: [WantedConstraints] -> WantedConstraints
mkSimpleWC :: [CtEvidence] -> WantedConstraints
mkImplicWC :: Bag Implication -> WantedConstraints
addInsols :: WantedConstraints -> Bag Ct -> WantedConstraints
insolublesOnly :: WantedConstraints -> WantedConstraints
addSimples :: WantedConstraints -> Bag Ct -> WantedConstraints
addImplics :: WantedConstraints -> Bag Implication -> WantedConstraints

-- | Returns free variables of WantedConstraints as a non-deterministic
--   set. See Note [Deterministic FV] in FV.
tyCoVarsOfWC :: WantedConstraints -> TyCoVarSet
dropDerivedWC :: WantedConstraints -> WantedConstraints
dropDerivedSimples :: Cts -> Cts

-- | Returns free variables of WantedConstraints as a deterministically
--   ordered list. See Note [Deterministic FV] in FV.
tyCoVarsOfWCList :: WantedConstraints -> [TyCoVar]
insolubleCt :: Ct -> Bool
insolubleEqCt :: Ct -> Bool
isDroppableCt :: Ct -> Bool
insolubleImplic :: Implication -> Bool
arisesFromGivens :: Ct -> Bool
data Implication
Implic :: TcLevel -> [TcTyVar] -> SkolemInfo -> Maybe SDoc -> [EvVar] -> Bool -> Env TcGblEnv TcLclEnv -> WantedConstraints -> EvBindsVar -> VarSet -> VarSet -> ImplicStatus -> Implication
[ic_tclvl] :: Implication -> TcLevel
[ic_skols] :: Implication -> [TcTyVar]
[ic_info] :: Implication -> SkolemInfo
[ic_telescope] :: Implication -> Maybe SDoc
[ic_given] :: Implication -> [EvVar]
[ic_no_eqs] :: Implication -> Bool
[ic_env] :: Implication -> Env TcGblEnv TcLclEnv
[ic_wanted] :: Implication -> WantedConstraints
[ic_binds] :: Implication -> EvBindsVar
[ic_need_inner] :: Implication -> VarSet
[ic_need_outer] :: Implication -> VarSet
[ic_status] :: Implication -> ImplicStatus

-- | Create a new <a>Implication</a> with as many sensible defaults for its
--   fields as possible. Note that the <a>ic_tclvl</a>, <a>ic_binds</a>,
--   and <a>ic_info</a> fields do <i>not</i> have sensible defaults, so
--   they are initialized with lazy thunks that will <a>panic</a> if
--   forced, so one should take care to initialize these fields after
--   creation.
--   
--   This is monadic purely to look up the <a>Env</a>, which is used to
--   initialize <a>ic_env</a>.
newImplication :: TcM Implication
implicationPrototype :: Implication

-- | Retrieve the enclosed <a>TcLclEnv</a> from an <a>Implication</a>.
implicLclEnv :: Implication -> TcLclEnv

-- | Retrieve the enclosed <a>DynFlags</a> from an <a>Implication</a>.
implicDynFlags :: Implication -> DynFlags
data ImplicStatus
IC_Solved :: [EvVar] -> ImplicStatus
[ics_dead] :: ImplicStatus -> [EvVar]
IC_Insoluble :: ImplicStatus
IC_BadTelescope :: ImplicStatus
IC_Unsolved :: ImplicStatus
isInsolubleStatus :: ImplicStatus -> Bool
isSolvedStatus :: ImplicStatus -> Bool

-- | See Note [SubGoalDepth]
data SubGoalDepth
initialSubGoalDepth :: SubGoalDepth
maxSubGoalDepth :: SubGoalDepth -> SubGoalDepth -> SubGoalDepth
bumpSubGoalDepth :: SubGoalDepth -> SubGoalDepth
subGoalDepthExceeded :: DynFlags -> SubGoalDepth -> Bool
data CtLoc
CtLoc :: CtOrigin -> TcLclEnv -> Maybe TypeOrKind -> !SubGoalDepth -> CtLoc
[ctl_origin] :: CtLoc -> CtOrigin
[ctl_env] :: CtLoc -> TcLclEnv
[ctl_t_or_k] :: CtLoc -> Maybe TypeOrKind
[ctl_depth] :: CtLoc -> !SubGoalDepth
ctLocSpan :: CtLoc -> RealSrcSpan
ctLocEnv :: CtLoc -> TcLclEnv
ctLocLevel :: CtLoc -> TcLevel
ctLocOrigin :: CtLoc -> CtOrigin
ctLocTypeOrKind_maybe :: CtLoc -> Maybe TypeOrKind
ctLocDepth :: CtLoc -> SubGoalDepth
bumpCtLocDepth :: CtLoc -> CtLoc
isGivenLoc :: CtLoc -> Bool
setCtLocOrigin :: CtLoc -> CtOrigin -> CtLoc
updateCtLocOrigin :: CtLoc -> (CtOrigin -> CtOrigin) -> CtLoc
setCtLocEnv :: CtLoc -> TcLclEnv -> CtLoc
setCtLocSpan :: CtLoc -> RealSrcSpan -> CtLoc
data CtOrigin
GivenOrigin :: SkolemInfo -> CtOrigin
OccurrenceOf :: Name -> CtOrigin
OccurrenceOfRecSel :: RdrName -> CtOrigin
AppOrigin :: CtOrigin
SpecPragOrigin :: UserTypeCtxt -> CtOrigin
TypeEqOrigin :: TcType -> TcType -> Maybe SDoc -> Bool -> CtOrigin
[uo_actual] :: CtOrigin -> TcType
[uo_expected] :: CtOrigin -> TcType

-- | The thing that has type "actual"
[uo_thing] :: CtOrigin -> Maybe SDoc

-- | Is at least one of the three elements above visible? (Errors from the
--   polymorphic subsumption check are considered visible.) Only used for
--   prioritizing error messages.
[uo_visible] :: CtOrigin -> Bool
KindEqOrigin :: TcType -> Maybe TcType -> CtOrigin -> Maybe TypeOrKind -> CtOrigin
IPOccOrigin :: HsIPName -> CtOrigin
OverLabelOrigin :: FastString -> CtOrigin
LiteralOrigin :: HsOverLit GhcRn -> CtOrigin
NegateOrigin :: CtOrigin
ArithSeqOrigin :: ArithSeqInfo GhcRn -> CtOrigin
AssocFamPatOrigin :: CtOrigin
SectionOrigin :: CtOrigin
TupleOrigin :: CtOrigin
ExprSigOrigin :: CtOrigin
PatSigOrigin :: CtOrigin
PatOrigin :: CtOrigin
ProvCtxtOrigin :: PatSynBind GhcRn GhcRn -> CtOrigin
RecordUpdOrigin :: CtOrigin
ViewPatOrigin :: CtOrigin
ScOrigin :: TypeSize -> CtOrigin
DerivClauseOrigin :: CtOrigin
DerivOriginDC :: DataCon -> Int -> Bool -> CtOrigin
DerivOriginCoerce :: Id -> Type -> Type -> Bool -> CtOrigin
StandAloneDerivOrigin :: CtOrigin
DefaultOrigin :: CtOrigin
DoOrigin :: CtOrigin
DoPatOrigin :: LPat GhcRn -> CtOrigin
MCompOrigin :: CtOrigin
MCompPatOrigin :: LPat GhcRn -> CtOrigin
IfOrigin :: CtOrigin
ProcOrigin :: CtOrigin
AnnOrigin :: CtOrigin
FunDepOrigin1 :: PredType -> CtLoc -> PredType -> CtLoc -> CtOrigin
FunDepOrigin2 :: PredType -> CtOrigin -> PredType -> SrcSpan -> CtOrigin
HoleOrigin :: CtOrigin
UnboundOccurrenceOf :: OccName -> CtOrigin
ListOrigin :: CtOrigin
StaticOrigin :: CtOrigin
FailablePattern :: LPat GhcTcId -> CtOrigin
Shouldn'tHappenOrigin :: String -> CtOrigin
InstProvidedOrigin :: Module -> ClsInst -> CtOrigin
exprCtOrigin :: HsExpr GhcRn -> CtOrigin

-- | Extract a suitable CtOrigin from a HsExpr
lexprCtOrigin :: LHsExpr GhcRn -> CtOrigin

-- | Extract a suitable CtOrigin from a MatchGroup
matchesCtOrigin :: MatchGroup GhcRn (LHsExpr GhcRn) -> CtOrigin

-- | Extract a suitable CtOrigin from guarded RHSs
grhssCtOrigin :: GRHSs GhcRn (LHsExpr GhcRn) -> CtOrigin
isVisibleOrigin :: CtOrigin -> Bool
toInvisibleOrigin :: CtOrigin -> CtOrigin

-- | Flag to see whether we're type-checking terms or kind-checking types
data TypeOrKind
TypeLevel :: TypeOrKind
KindLevel :: TypeOrKind
isTypeLevel :: TypeOrKind -> Bool
isKindLevel :: TypeOrKind -> Bool
pprCtOrigin :: CtOrigin -> SDoc
pprCtLoc :: CtLoc -> SDoc
pushErrCtxt :: CtOrigin -> ErrCtxt -> CtLoc -> CtLoc
pushErrCtxtSameOrigin :: ErrCtxt -> CtLoc -> CtLoc
data SkolemInfo
SigSkol :: UserTypeCtxt -> TcType -> [(Name, TcTyVar)] -> SkolemInfo
SigTypeSkol :: UserTypeCtxt -> SkolemInfo
ForAllSkol :: SDoc -> SkolemInfo
DerivSkol :: Type -> SkolemInfo
InstSkol :: SkolemInfo
InstSC :: TypeSize -> SkolemInfo
FamInstSkol :: SkolemInfo
PatSkol :: ConLike -> HsMatchContext Name -> SkolemInfo
ArrowSkol :: SkolemInfo
IPSkol :: [HsIPName] -> SkolemInfo
RuleSkol :: RuleName -> SkolemInfo
InferSkol :: [(Name, TcType)] -> SkolemInfo
BracketSkol :: SkolemInfo
UnifyForAllSkol :: TcType -> SkolemInfo
TyConSkol :: TyConFlavour -> Name -> SkolemInfo
DataConSkol :: Name -> SkolemInfo
ReifySkol :: SkolemInfo
QuantCtxtSkol :: SkolemInfo
UnkSkol :: SkolemInfo
pprSigSkolInfo :: UserTypeCtxt -> TcType -> SDoc
pprSkolInfo :: SkolemInfo -> SDoc
data CtEvidence
CtGiven :: TcPredType -> EvVar -> CtLoc -> CtEvidence
[ctev_pred] :: CtEvidence -> TcPredType
[ctev_evar] :: CtEvidence -> EvVar
[ctev_loc] :: CtEvidence -> CtLoc
CtWanted :: TcPredType -> TcEvDest -> ShadowInfo -> CtLoc -> CtEvidence
[ctev_pred] :: CtEvidence -> TcPredType
[ctev_dest] :: CtEvidence -> TcEvDest
[ctev_nosh] :: CtEvidence -> ShadowInfo
[ctev_loc] :: CtEvidence -> CtLoc
CtDerived :: TcPredType -> CtLoc -> CtEvidence
[ctev_pred] :: CtEvidence -> TcPredType
[ctev_loc] :: CtEvidence -> CtLoc

-- | A place for type-checking evidence to go after it is generated. Wanted
--   equalities are always HoleDest; other wanteds are always EvVarDest.
data TcEvDest

-- | bind this var to the evidence EvVarDest is always used for
--   non-type-equalities e.g. class constraints
EvVarDest :: EvVar -> TcEvDest

-- | fill in this hole with the evidence HoleDest is always used for
--   type-equalities See Note [Coercion holes] in TyCoRep
HoleDest :: CoercionHole -> TcEvDest
mkKindLoc :: TcType -> TcType -> CtLoc -> CtLoc

-- | Take a CtLoc and moves it to the kind level
toKindLoc :: CtLoc -> CtLoc
mkGivenLoc :: TcLevel -> SkolemInfo -> TcLclEnv -> CtLoc
isWanted :: CtEvidence -> Bool
isGiven :: CtEvidence -> Bool
isDerived :: CtEvidence -> Bool
isGivenOrWDeriv :: CtFlavour -> Bool

-- | Get the role relevant for a <a>CtEvidence</a>
ctEvRole :: CtEvidence -> Role
wrapType :: Type -> [TyVar] -> [PredType] -> Type

-- | Wraps the given type with the constraints (via ic_given) in the given
--   implication, according to the variables mentioned (via ic_skols) in
--   the implication, but taking care to only wrap those variables that are
--   mentioned in the type or the implication.
wrapTypeWithImplication :: Type -> Implication -> Type
removeBindingShadowing :: HasOccName a => [a] -> [a]
data TcPlugin
TcPlugin :: TcPluginM s -> (s -> TcPluginSolver) -> (s -> TcPluginM ()) -> TcPlugin

-- | Initialize plugin, when entering type-checker.
[tcPluginInit] :: TcPlugin -> TcPluginM s

-- | Solve some constraints. TODO: WRITE MORE DETAILS ON HOW THIS WORKS.
[tcPluginSolve] :: TcPlugin -> s -> TcPluginSolver

-- | Clean up after the plugin, when exiting the type-checker.
[tcPluginStop] :: TcPlugin -> s -> TcPluginM ()
data TcPluginResult

-- | The plugin found a contradiction. The returned constraints are removed
--   from the inert set, and recorded as insoluble.
TcPluginContradiction :: [Ct] -> TcPluginResult

-- | The first field is for constraints that were solved. These are removed
--   from the inert set, and the evidence for them is recorded. The second
--   field contains new work, that should be processed by the constraint
--   solver.
TcPluginOk :: [(EvTerm, Ct)] -> [Ct] -> TcPluginResult
type TcPluginSolver = [Ct] -> [Ct] -> [Ct] -> TcPluginM TcPluginResult
data TcPluginM a
runTcPluginM :: TcPluginM a -> EvBindsVar -> TcM a

-- | This function provides an escape for direct access to the <a>TcM</a>
--   monad. It should not be used lightly, and the provided
--   <a>TcPluginM</a> API should be favoured instead.
unsafeTcPluginTcM :: TcM a -> TcPluginM a

-- | Access the <a>EvBindsVar</a> carried by the <a>TcPluginM</a> during
--   constraint solving. Returns <a>Nothing</a> if invoked during
--   <a>tcPluginInit</a> or <a>tcPluginStop</a>.
getEvBindsTcPluginM :: TcPluginM EvBindsVar
data CtFlavour
Given :: CtFlavour
Wanted :: ShadowInfo -> CtFlavour
Derived :: CtFlavour
data ShadowInfo
WDeriv :: ShadowInfo
WOnly :: ShadowInfo
ctEvFlavour :: CtEvidence -> CtFlavour

-- | Whether or not one <a>Ct</a> can rewrite another is determined by its
--   flavour and its equality relation. See also Note [Flavours with roles]
--   in TcSMonad
type CtFlavourRole = (CtFlavour, EqRel)

-- | Extract the flavour, role, and boxity from a <a>CtEvidence</a>
ctEvFlavourRole :: CtEvidence -> CtFlavourRole

-- | Extract the flavour and role from a <a>Ct</a>
ctFlavourRole :: Ct -> CtFlavourRole
eqCanRewrite :: EqRel -> EqRel -> Bool
eqCanRewriteFR :: CtFlavourRole -> CtFlavourRole -> Bool
eqMayRewriteFR :: CtFlavourRole -> CtFlavourRole -> Bool
eqCanDischargeFR :: CtFlavourRole -> CtFlavourRole -> Bool
funEqCanDischarge :: CtEvidence -> CtEvidence -> (SwapFlag, Bool)
funEqCanDischargeF :: CtFlavour -> CtFlavour -> (SwapFlag, Bool)
pprEvVarTheta :: [EvVar] -> SDoc
pprEvVars :: [EvVar] -> SDoc
pprEvVarWithType :: EvVar -> SDoc
type TcId = Id
type TcIdSet = IdSet

-- | An expression or type hole
data Hole

-- | Either an out-of-scope variable or a "true" hole in an expression
--   (TypedHoles)
ExprHole :: UnboundVar -> Hole

-- | A hole in a type (PartialTypeSignatures)
TypeHole :: OccName -> Hole
holeOcc :: Hole -> OccName

-- | A <a>NameShape</a> is a substitution on <a>Name</a>s that can be used
--   to refine the identities of a hole while we are renaming interfaces
--   (see <tt>RnModIface</tt>). Specifically, a <a>NameShape</a> for
--   <tt>ns_module_name</tt> <tt>A</tt>, defines a mapping from
--   <tt>{A.T}</tt> (for some <a>OccName</a> <tt>T</tt>) to some arbitrary
--   other <a>Name</a>.
--   
--   The most intruiging thing about a <a>NameShape</a>, however, is how
--   it's constructed. A <a>NameShape</a> is *implied* by the exported
--   <a>AvailInfo</a>s of the implementor of an interface: if an
--   implementor of signature <tt><a>H</a></tt> exports <tt>M.T</tt>, you
--   implicitly define a substitution from <tt>{H.T}</tt> to <tt>M.T</tt>.
--   So a <a>NameShape</a> is computed from the list of <a>AvailInfo</a>s
--   that are exported by the implementation of a module, or successively
--   merged together by the export lists of signatures which are joining
--   together.
--   
--   It's not the most obvious way to go about doing this, but it does seem
--   to work!
--   
--   NB: Can't boot this and put it in NameShape because then we start
--   pulling in too many DynFlags things.
data NameShape
NameShape :: ModuleName -> [AvailInfo] -> OccEnv Name -> NameShape
[ns_mod_name] :: NameShape -> ModuleName
[ns_exports] :: NameShape -> [AvailInfo]
[ns_map] :: NameShape -> OccEnv Name
type RoleAnnotEnv = NameEnv (LRoleAnnotDecl GhcRn)
emptyRoleAnnotEnv :: RoleAnnotEnv
mkRoleAnnotEnv :: [LRoleAnnotDecl GhcRn] -> RoleAnnotEnv
lookupRoleAnnot :: RoleAnnotEnv -> Name -> Maybe (LRoleAnnotDecl GhcRn)
getRoleAnnots :: [Name] -> RoleAnnotEnv -> ([LRoleAnnotDecl GhcRn], RoleAnnotEnv)
instance GHC.Classes.Eq TcRnTypes.TypeOrKind
instance Outputable.Outputable TcRnTypes.SubGoalDepth
instance GHC.Classes.Ord TcRnTypes.SubGoalDepth
instance GHC.Classes.Eq TcRnTypes.SubGoalDepth
instance GHC.Classes.Eq TcRnTypes.CtFlavour
instance GHC.Classes.Eq TcRnTypes.ShadowInfo
instance Module.ContainsModule TcRnTypes.TcGblEnv
instance Outputable.Outputable TcRnTypes.ThStage
instance Outputable.Outputable TcRnTypes.QCInst
instance Outputable.Outputable TcRnTypes.Ct
instance Outputable.Outputable TcRnTypes.WantedConstraints
instance Outputable.Outputable TcRnTypes.Implication
instance Outputable.Outputable TcRnTypes.CtEvidence
instance Outputable.Outputable TcRnTypes.CtOrigin
instance GHC.Base.Functor TcRnTypes.TcPluginM
instance GHC.Base.Applicative TcRnTypes.TcPluginM
instance GHC.Base.Monad TcRnTypes.TcPluginM
instance Control.Monad.Fail.MonadFail TcRnTypes.TcPluginM
instance Outputable.Outputable TcRnTypes.TypeOrKind
instance Outputable.Outputable TcRnTypes.SkolemInfo
instance Outputable.Outputable TcRnTypes.CtFlavour
instance Outputable.Outputable TcRnTypes.TcEvDest
instance Outputable.Outputable TcRnTypes.ImplicStatus
instance Outputable.Outputable TcRnTypes.Hole
instance Outputable.Outputable TcRnTypes.TcSigInfo
instance Outputable.Outputable TcRnTypes.TcPatSynInfo
instance Outputable.Outputable TcRnTypes.TcIdSigInst
instance Outputable.Outputable TcRnTypes.TcIdSigInfo
instance Outputable.Outputable TcRnTypes.WhereFrom
instance Outputable.Outputable TcRnTypes.TcTyThing
instance Outputable.Outputable TcRnTypes.IdBindingInfo
instance Outputable.Outputable TcRnTypes.PromotionErr
instance Outputable.Outputable TcRnTypes.TcBinder
instance OccName.HasOccName TcRnTypes.TcBinder
instance Module.ContainsModule TcRnTypes.DsGblEnv
instance DynFlags.ContainsDynFlags (TcRnTypes.Env gbl lcl)
instance Module.ContainsModule gbl => Module.ContainsModule (TcRnTypes.Env gbl lcl)


-- | The CompPipeline monad and associated ops
--   
--   Defined in separate module so that it can safely be imported from
--   Hooks
module PipelineMonad
newtype CompPipeline a
P :: (PipeEnv -> PipeState -> IO (PipeState, a)) -> CompPipeline a
[unP] :: CompPipeline a -> PipeEnv -> PipeState -> IO (PipeState, a)
evalP :: CompPipeline a -> PipeEnv -> PipeState -> IO a
data PhasePlus
RealPhase :: Phase -> PhasePlus
HscOut :: HscSource -> ModuleName -> HscStatus -> PhasePlus
data PipeEnv
PipeEnv :: Phase -> String -> String -> String -> PipelineOutput -> PipeEnv

-- | Stop just before this phase
[stop_phase] :: PipeEnv -> Phase

-- | basename of original input source
[src_filename] :: PipeEnv -> String

-- | basename of original input source
[src_basename] :: PipeEnv -> String

-- | its extension
[src_suffix] :: PipeEnv -> String

-- | says where to put the pipeline output
[output_spec] :: PipeEnv -> PipelineOutput
data PipeState
PipeState :: HscEnv -> Maybe ModLocation -> [FilePath] -> PipeState

-- | only the DynFlags change in the HscEnv. The DynFlags change at various
--   points, for example when we read the OPTIONS_GHC pragmas in the Cpp
--   phase.
[hsc_env] :: PipeState -> HscEnv

-- | the ModLocation. This is discovered during compilation, in the Hsc
--   phase where we read the module header.
[maybe_loc] :: PipeState -> Maybe ModLocation

-- | additional object files resulting from compiling foreign code. They
--   come from two sources: foreign stubs, and add{C,Cxx,Objc,Objcxx}File
--   from template haskell
[foreign_os] :: PipeState -> [FilePath]
data PipelineOutput

-- | Output should be to a temporary file: we're going to run more
--   compilation steps on this output later.
Temporary :: TempFileLifetime -> PipelineOutput

-- | We want a persistent file, i.e. a file in the current directory
--   derived from the input filename, but with the appropriate extension.
--   eg. in "ghc -c Foo.hs" the output goes into ./Foo.o.
Persistent :: PipelineOutput

-- | The output must go into the specific outputFile in DynFlags. We don't
--   store the filename in the constructor as it changes when doing
--   -dynamic-too.
SpecificFile :: PipelineOutput
getPipeEnv :: CompPipeline PipeEnv
getPipeState :: CompPipeline PipeState
setDynFlags :: DynFlags -> CompPipeline ()
setModLocation :: ModLocation -> CompPipeline ()
setForeignOs :: [FilePath] -> CompPipeline ()
instance GHC.Show.Show PipelineMonad.PipelineOutput
instance GHC.Base.Functor PipelineMonad.CompPipeline
instance GHC.Base.Applicative PipelineMonad.CompPipeline
instance GHC.Base.Monad PipelineMonad.CompPipeline
instance Control.Monad.IO.Class.MonadIO PipelineMonad.CompPipeline
instance DynFlags.HasDynFlags PipelineMonad.CompPipeline
instance Outputable.Outputable PipelineMonad.PhasePlus

module GhcMonad

-- | A monad that has all the features needed by GHC API calls.
--   
--   In short, a GHC monad
--   
--   <ul>
--   <li>allows embedding of IO actions,</li>
--   <li>can log warnings,</li>
--   <li>allows handling of (extensible) exceptions, and</li>
--   <li>maintains a current session.</li>
--   </ul>
--   
--   If you do not use <a>Ghc</a> or <a>GhcT</a>, make sure to call
--   <a>initGhcMonad</a> before any call to the GHC API functions can
--   occur.
class (Functor m, MonadIO m, ExceptionMonad m, HasDynFlags m) => GhcMonad m
getSession :: GhcMonad m => m HscEnv
setSession :: GhcMonad m => HscEnv -> m ()

-- | A minimal implementation of a <a>GhcMonad</a>. If you need a custom
--   monad, e.g., to maintain additional state consider wrapping this monad
--   or using <a>GhcT</a>.
newtype Ghc a
Ghc :: (Session -> IO a) -> Ghc a
[unGhc] :: Ghc a -> Session -> IO a

-- | A monad transformer to add GHC specific features to another monad.
--   
--   Note that the wrapped monad must support IO and handling of
--   exceptions.
newtype GhcT m a
GhcT :: (Session -> m a) -> GhcT m a
[unGhcT] :: GhcT m a -> Session -> m a
liftGhcT :: m a -> GhcT m a

-- | Reflect a computation in the <a>Ghc</a> monad into the <a>IO</a>
--   monad.
--   
--   You can use this to call functions returning an action in the
--   <a>Ghc</a> monad inside an <a>IO</a> action. This is needed for some
--   (too restrictive) callback arguments of some library functions:
--   
--   <pre>
--   libFunc :: String -&gt; (Int -&gt; IO a) -&gt; IO a
--   ghcFunc :: Int -&gt; Ghc a
--   
--   ghcFuncUsingLibFunc :: String -&gt; Ghc a -&gt; Ghc a
--   ghcFuncUsingLibFunc str =
--     reifyGhc $ \s -&gt;
--       libFunc $ \i -&gt; do
--         reflectGhc (ghcFunc i) s
--   </pre>
reflectGhc :: Ghc a -> Session -> IO a
reifyGhc :: (Session -> IO a) -> Ghc a

-- | Grabs the DynFlags from the Session
getSessionDynFlags :: GhcMonad m => m DynFlags

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | The Session is a handle to the complete state of a compilation
--   session. A compilation session consists of a set of modules
--   constituting the current program or library, the context for
--   interactive evaluation, and various caches.
data Session
Session :: !IORef HscEnv -> Session

-- | Call the argument with the current session.
withSession :: GhcMonad m => (HscEnv -> m a) -> m a

-- | Set the current session to the result of applying the current session
--   to the argument.
modifySession :: GhcMonad m => (HscEnv -> HscEnv) -> m ()

-- | Call an action with a temporarily modified Session.
withTempSession :: GhcMonad m => (HscEnv -> HscEnv) -> m a -> m a

-- | A monad that allows logging of warnings.
logWarnings :: GhcMonad m => WarningMessages -> m ()

-- | Print the error message and all warnings. Useful inside exception
--   handlers. Clears warnings after printing.
printException :: GhcMonad m => SourceError -> m ()

-- | A function called to log warnings and errors.
type WarnErrLogger = forall m. GhcMonad m => Maybe SourceError -> m ()
defaultWarnErrLogger :: WarnErrLogger
instance GHC.Base.Functor m => GHC.Base.Functor (GhcMonad.GhcT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (GhcMonad.GhcT m)
instance GHC.Base.Monad m => GHC.Base.Monad (GhcMonad.GhcT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (GhcMonad.GhcT m)
instance Exception.ExceptionMonad m => Exception.ExceptionMonad (GhcMonad.GhcT m)
instance Control.Monad.IO.Class.MonadIO m => DynFlags.HasDynFlags (GhcMonad.GhcT m)
instance Exception.ExceptionMonad m => GhcMonad.GhcMonad (GhcMonad.GhcT m)
instance GHC.Base.Functor GhcMonad.Ghc
instance GHC.Base.Applicative GhcMonad.Ghc
instance GHC.Base.Monad GhcMonad.Ghc
instance Control.Monad.IO.Class.MonadIO GhcMonad.Ghc
instance Control.Monad.Fix.MonadFix GhcMonad.Ghc
instance Exception.ExceptionMonad GhcMonad.Ghc
instance DynFlags.HasDynFlags GhcMonad.Ghc
instance GhcMonad.GhcMonad GhcMonad.Ghc

module Plugins

-- | <a>Plugin</a> is the compiler plugin data type. Try to avoid
--   constructing one of these directly, and just modify some fields of
--   <a>defaultPlugin</a> instead: this is to try and preserve source-code
--   compatibility when we add fields to this.
--   
--   Nonetheless, this API is preliminary and highly likely to change in
--   the future.
data Plugin
Plugin :: CorePlugin -> TcPlugin -> ([CommandLineOption] -> IO PluginRecompile) -> ([CommandLineOption] -> ModSummary -> HsParsedModule -> Hsc HsParsedModule) -> ([CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)) -> ([CommandLineOption] -> ModSummary -> TcGblEnv -> TcM TcGblEnv) -> ([CommandLineOption] -> LHsExpr GhcTc -> TcM (LHsExpr GhcTc)) -> (forall lcl. [CommandLineOption] -> ModIface -> IfM lcl ModIface) -> Plugin

-- | Modify the Core pipeline that will be used for compilation. This is
--   called as the Core pipeline is built for every module being compiled,
--   and plugins get the opportunity to modify the pipeline in a
--   nondeterministic order.
[installCoreToDos] :: Plugin -> CorePlugin

-- | An optional typechecker plugin, which may modify the behaviour of the
--   constraint solver.
[tcPlugin] :: Plugin -> TcPlugin

-- | Specify how the plugin should affect recompilation.
[pluginRecompile] :: Plugin -> [CommandLineOption] -> IO PluginRecompile

-- | Modify the module when it is parsed. This is called by HscMain when
--   the parsing is successful.
[parsedResultAction] :: Plugin -> [CommandLineOption] -> ModSummary -> HsParsedModule -> Hsc HsParsedModule

-- | Modify each group after it is renamed. This is called after each
--   <a>HsGroup</a> has been renamed.
[renamedResultAction] :: Plugin -> [CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)

-- | Modify the module when it is type checked. This is called add the very
--   end of typechecking.
[typeCheckResultAction] :: Plugin -> [CommandLineOption] -> ModSummary -> TcGblEnv -> TcM TcGblEnv

-- | Modify the TH splice or quasiqoute before it is run.
[spliceRunAction] :: Plugin -> [CommandLineOption] -> LHsExpr GhcTc -> TcM (LHsExpr GhcTc)

-- | Modify an interface that have been loaded. This is called by LoadIface
--   when an interface is successfully loaded. Not applied to the loading
--   of the plugin interface. Tools that rely on information from modules
--   other than the currently compiled one should implement this function.
[interfaceLoadAction] :: Plugin -> forall lcl. [CommandLineOption] -> ModIface -> IfM lcl ModIface

-- | Default plugin: does nothing at all! For compatibility reasons you
--   should base all your plugin definitions on this default value.
defaultPlugin :: Plugin

-- | Command line options gathered from the -PModule.Name:stuff syntax are
--   given to you as this type
type CommandLineOption = String
purePlugin :: [CommandLineOption] -> IO PluginRecompile
impurePlugin :: [CommandLineOption] -> IO PluginRecompile
flagRecompile :: [CommandLineOption] -> IO PluginRecompile
data PluginRecompile
ForceRecompile :: PluginRecompile
NoForceRecompile :: PluginRecompile
MaybeRecompile :: Fingerprint -> PluginRecompile
data FrontendPlugin
FrontendPlugin :: FrontendPluginAction -> FrontendPlugin
[frontend] :: FrontendPlugin -> FrontendPluginAction
defaultFrontendPlugin :: FrontendPlugin
type FrontendPluginAction = [String] -> [(String, Maybe Phase)] -> Ghc ()
type CorePlugin = [CommandLineOption] -> [CoreToDo] -> CoreM [CoreToDo]
type TcPlugin = [CommandLineOption] -> Maybe TcPlugin

-- | A renamer plugin which mades the renamed source available in a
--   typechecker plugin.
keepRenamedSource :: [CommandLineOption] -> TcGblEnv -> HsGroup GhcRn -> TcM (TcGblEnv, HsGroup GhcRn)
data PluginWithArgs
PluginWithArgs :: Plugin -> [CommandLineOption] -> PluginWithArgs

-- | the actual callable plugin
[paPlugin] :: PluginWithArgs -> Plugin

-- | command line arguments for the plugin
[paArguments] :: PluginWithArgs -> [CommandLineOption]
plugins :: DynFlags -> [PluginWithArgs]
pluginRecompile' :: PluginWithArgs -> IO PluginRecompile

-- | A plugin with its arguments. The result of loading the plugin.
data LoadedPlugin
LoadedPlugin :: PluginWithArgs -> ModIface -> LoadedPlugin

-- | the actual plugin together with its commandline arguments
[lpPlugin] :: LoadedPlugin -> PluginWithArgs

-- | the module containing the plugin
[lpModule] :: LoadedPlugin -> ModIface
lpModuleName :: LoadedPlugin -> ModuleName

-- | A static plugin with its arguments. For registering compiled-in
--   plugins through the GHC API.
data StaticPlugin
StaticPlugin :: PluginWithArgs -> StaticPlugin

-- | the actual plugin together with its commandline arguments
[spPlugin] :: StaticPlugin -> PluginWithArgs
mapPlugins :: DynFlags -> (Plugin -> [CommandLineOption] -> a) -> [a]

-- | Perform an operation by using all of the plugins in turn.
withPlugins :: Monad m => DynFlags -> PluginOperation m a -> a -> m a

-- | Perform a constant operation by using all of the plugins in turn.
withPlugins_ :: Monad m => DynFlags -> ConstPluginOperation m a -> a -> m ()
instance Outputable.Outputable Plugins.PluginRecompile
instance GHC.Base.Semigroup Plugins.PluginRecompile
instance GHC.Base.Monoid Plugins.PluginRecompile

module CoreMonad
data CoreToDo
CoreDoSimplify :: Int -> SimplMode -> CoreToDo
CoreDoPluginPass :: String -> CorePluginPass -> CoreToDo
CoreDoFloatInwards :: CoreToDo
CoreDoFloatOutwards :: FloatOutSwitches -> CoreToDo
CoreLiberateCase :: CoreToDo
CoreDoPrintCore :: CoreToDo
CoreDoStaticArgs :: CoreToDo
CoreDoCallArity :: CoreToDo
CoreDoExitify :: CoreToDo
CoreDoStrictness :: CoreToDo
CoreDoWorkerWrapper :: CoreToDo
CoreDoSpecialising :: CoreToDo
CoreDoSpecConstr :: CoreToDo
CoreCSE :: CoreToDo
CoreDoRuleCheck :: CompilerPhase -> String -> CoreToDo
CoreDoNothing :: CoreToDo
CoreDoPasses :: [CoreToDo] -> CoreToDo
CoreDesugar :: CoreToDo
CoreDesugarOpt :: CoreToDo
CoreTidy :: CoreToDo
CorePrep :: CoreToDo
CoreOccurAnal :: CoreToDo
runWhen :: Bool -> CoreToDo -> CoreToDo
runMaybe :: Maybe a -> (a -> CoreToDo) -> CoreToDo
data SimplMode
SimplMode :: [String] -> CompilerPhase -> DynFlags -> Bool -> Bool -> Bool -> Bool -> SimplMode
[sm_names] :: SimplMode -> [String]
[sm_phase] :: SimplMode -> CompilerPhase
[sm_dflags] :: SimplMode -> DynFlags
[sm_rules] :: SimplMode -> Bool
[sm_inline] :: SimplMode -> Bool
[sm_case_case] :: SimplMode -> Bool
[sm_eta_expand] :: SimplMode -> Bool
data FloatOutSwitches
FloatOutSwitches :: Maybe Int -> Bool -> Bool -> Bool -> FloatOutSwitches

-- | Just n <a>=</a> float lambdas to top level, if doing so will abstract
--   over n or fewer value variables Nothing <a>=</a> float all lambdas to
--   top level, regardless of how many free variables Just 0 is the vanilla
--   case: float a lambda iff it has no free vars
[floatOutLambdas] :: FloatOutSwitches -> Maybe Int

-- | True <a>=</a> float constants to top level, even if they do not escape
--   a lambda
[floatOutConstants] :: FloatOutSwitches -> Bool

-- | True <a>=</a> float out over-saturated applications based on arity
--   information. See Note [Floating over-saturated applications] in
--   SetLevels
[floatOutOverSatApps] :: FloatOutSwitches -> Bool

-- | Allow floating to the top level only.
[floatToTopLevelOnly] :: FloatOutSwitches -> Bool
pprPassDetails :: CoreToDo -> SDoc

-- | A description of the plugin pass itself
type CorePluginPass = ModGuts -> CoreM ModGuts
bindsOnlyPass :: (CoreProgram -> CoreM CoreProgram) -> ModGuts -> CoreM ModGuts
data SimplCount
doSimplTick :: DynFlags -> Tick -> SimplCount -> SimplCount
doFreeSimplTick :: Tick -> SimplCount -> SimplCount
simplCountN :: SimplCount -> Int
pprSimplCount :: SimplCount -> SDoc
plusSimplCount :: SimplCount -> SimplCount -> SimplCount
zeroSimplCount :: DynFlags -> SimplCount
isZeroSimplCount :: SimplCount -> Bool
hasDetailedCounts :: SimplCount -> Bool
data Tick
PreInlineUnconditionally :: Id -> Tick
PostInlineUnconditionally :: Id -> Tick
UnfoldingDone :: Id -> Tick
RuleFired :: FastString -> Tick
LetFloatFromLet :: Tick
EtaExpansion :: Id -> Tick
EtaReduction :: Id -> Tick
BetaReduction :: Id -> Tick
CaseOfCase :: Id -> Tick
KnownBranch :: Id -> Tick
CaseMerge :: Id -> Tick
AltMerge :: Id -> Tick
CaseElim :: Id -> Tick
CaseIdentity :: Id -> Tick
FillInCaseDefault :: Id -> Tick
SimplifierDone :: Tick

-- | The monad used by Core-to-Core passes to access common state, register
--   simplification statistics and so on
data CoreM a
runCoreM :: HscEnv -> RuleBase -> UniqSupply -> Module -> ModuleSet -> PrintUnqualified -> SrcSpan -> CoreM a -> IO (a, SimplCount)
getHscEnv :: CoreM HscEnv
getRuleBase :: CoreM RuleBase
getModule :: HasModule m => m Module
getDynFlags :: HasDynFlags m => m DynFlags

-- | The original name cache is the current mapping from <a>Module</a> and
--   <tt>OccName</tt> to a compiler-wide unique <tt>Name</tt>
getOrigNameCache :: CoreM OrigNameCache
getPackageFamInstEnv :: CoreM PackageFamInstEnv
getVisibleOrphanMods :: CoreM ModuleSet
getPrintUnqualified :: CoreM PrintUnqualified
getSrcSpanM :: CoreM SrcSpan
addSimplCount :: SimplCount -> CoreM ()

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Lift an <a>IO</a> operation into <a>CoreM</a> while consuming its
--   <a>SimplCount</a>
liftIOWithCount :: IO (SimplCount, a) -> CoreM a

-- | Lift an <a>IO</a> operation with 1 argument into another monad
liftIO1 :: MonadIO m => (a -> IO b) -> a -> m b

-- | Lift an <a>IO</a> operation with 2 arguments into another monad
liftIO2 :: MonadIO m => (a -> b -> IO c) -> a -> b -> m c

-- | Lift an <a>IO</a> operation with 3 arguments into another monad
liftIO3 :: MonadIO m => (a -> b -> c -> IO d) -> a -> b -> c -> m d

-- | Lift an <a>IO</a> operation with 4 arguments into another monad
liftIO4 :: MonadIO m => (a -> b -> c -> d -> IO e) -> a -> b -> c -> d -> m e

-- | <i>Deprecated: It is not necessary to call reinitializeGlobals. Since
--   GHC 8.2, this function is a no-op and will be removed in GHC 8.4</i>
reinitializeGlobals :: CoreM ()

-- | Get all annotations of a given type. This happens lazily, that is no
--   deserialization will take place until the [a] is actually demanded and
--   the [a] can also be empty (the UniqFM is not filtered).
--   
--   This should be done once at the start of a Core-to-Core pass that uses
--   annotations.
--   
--   See Note [Annotations]
getAnnotations :: Typeable a => ([Word8] -> a) -> ModGuts -> CoreM (UniqFM [a])

-- | Get at most one annotation of a given type per Unique.
getFirstAnnotations :: Typeable a => ([Word8] -> a) -> ModGuts -> CoreM (UniqFM a)

-- | Output a message to the screen
putMsg :: SDoc -> CoreM ()

-- | Output a String message to the screen
putMsgS :: String -> CoreM ()

-- | Output an error to the screen. Does not cause the compiler to die.
errorMsg :: SDoc -> CoreM ()

-- | Output an error to the screen. Does not cause the compiler to die.
errorMsgS :: String -> CoreM ()
warnMsg :: SDoc -> CoreM ()

-- | Output a fatal error to the screen. Does not cause the compiler to
--   die.
fatalErrorMsg :: SDoc -> CoreM ()

-- | Output a fatal error to the screen. Does not cause the compiler to
--   die.
fatalErrorMsgS :: String -> CoreM ()

-- | Outputs a debugging message at verbosity level of <tt>-v</tt> or
--   higher
debugTraceMsg :: SDoc -> CoreM ()

-- | Output a string debugging message at verbosity level of <tt>-v</tt> or
--   higher
debugTraceMsgS :: String -> CoreM ()

-- | Show some labelled <a>SDoc</a> if a particular flag is set or at a
--   verbosity level of <tt>-v -ddump-most</tt> or higher
dumpIfSet_dyn :: DumpFlag -> String -> SDoc -> CoreM ()
instance Outputable.Outputable CoreMonad.CoreToDo
instance GHC.Base.Functor CoreMonad.CoreM
instance GHC.Base.Monad CoreMonad.CoreM
instance GHC.Base.Applicative CoreMonad.CoreM
instance GHC.Base.Alternative CoreMonad.CoreM
instance GHC.Base.MonadPlus CoreMonad.CoreM
instance UniqSupply.MonadUnique CoreMonad.CoreM
instance Control.Monad.IO.Class.MonadIO CoreMonad.CoreM
instance DynFlags.HasDynFlags CoreMonad.CoreM
instance Module.HasModule CoreMonad.CoreM
instance Outputable.Outputable CoreMonad.Tick
instance GHC.Classes.Eq CoreMonad.Tick
instance GHC.Classes.Ord CoreMonad.Tick
instance Outputable.Outputable CoreMonad.FloatOutSwitches
instance Outputable.Outputable CoreMonad.SimplMode

module HaddockUtils
addFieldDoc :: LConDeclField a -> Maybe LHsDocString -> LConDeclField a
addFieldDocs :: [LConDeclField a] -> Maybe LHsDocString -> [LConDeclField a]
addConDoc :: LConDecl a -> Maybe LHsDocString -> LConDecl a
addConDocs :: [LConDecl a] -> Maybe LHsDocString -> [LConDecl a]
addConDocFirst :: [LConDecl a] -> Maybe LHsDocString -> [LConDecl a]


-- | This is the syntax for bkp files which are parsed in 'ghc --backpack'
--   mode. This syntax is used purely for testing purposes.
module BkpSyn
data HsUnitId n
HsUnitId :: Located n -> [LHsModuleSubst n] -> HsUnitId n
type LHsUnitId n = Located (HsUnitId n)
type HsModuleSubst n = (Located ModuleName, LHsModuleId n)
type LHsModuleSubst n = Located (HsModuleSubst n)
data HsModuleId n
HsModuleVar :: Located ModuleName -> HsModuleId n
HsModuleId :: LHsUnitId n -> Located ModuleName -> HsModuleId n
type LHsModuleId n = Located (HsModuleId n)
data HsComponentId
HsComponentId :: PackageName -> ComponentId -> HsComponentId
[hsPackageName] :: HsComponentId -> PackageName
[hsComponentId] :: HsComponentId -> ComponentId
type LHsUnit n = Located (HsUnit n)

-- | Top level <tt>unit</tt> declaration in a Backpack file.
data HsUnit n
HsUnit :: Located n -> [LHsUnitDecl n] -> HsUnit n
[hsunitName] :: HsUnit n -> Located n
[hsunitBody] :: HsUnit n -> [LHsUnitDecl n]
type LHsUnitDecl n = Located (HsUnitDecl n)
data HsUnitDecl n
DeclD :: HsDeclType -> Located ModuleName -> Maybe (Located (HsModule GhcPs)) -> HsUnitDecl n
IncludeD :: IncludeDecl n -> HsUnitDecl n

-- | A declaration in a package, e.g. a module or signature definition, or
--   an include.
data HsDeclType
ModuleD :: HsDeclType
SignatureD :: HsDeclType

-- | An include of another unit
data IncludeDecl n
IncludeDecl :: LHsUnitId n -> Maybe [LRenaming] -> Bool -> IncludeDecl n
[idUnitId] :: IncludeDecl n -> LHsUnitId n
[idModRenaming] :: IncludeDecl n -> Maybe [LRenaming]

-- | Is this a <tt>dependency signature</tt> include? If so, we don't
--   compile this include when we instantiate this unit (as there should
--   not be any modules brought into scope.)
[idSignatureInclude] :: IncludeDecl n -> Bool
type LRenaming = Located Renaming

-- | Rename a module from one name to another. The identity renaming means
--   that the module should be brought into scope.
data Renaming
Renaming :: Located ModuleName -> Maybe (Located ModuleName) -> Renaming
[renameFrom] :: Renaming -> Located ModuleName
[renameTo] :: Renaming -> Maybe (Located ModuleName)
instance Outputable.Outputable BkpSyn.HsComponentId


-- | This module provides the generated Happy parser for Haskell. It
--   exports a number of parsers which may be used in any library that uses
--   the GHC API. A common usage pattern is to initialize the parser state
--   with a given string and then parse that string:
--   
--   <pre>
--   runParser :: DynFlags -&gt; String -&gt; P a -&gt; ParseResult a
--   runParser flags str parser = unP parser parseState
--   where
--     filename = "&lt;interactive&gt;"
--     location = mkRealSrcLoc (mkFastString filename) 1 1
--     buffer = stringToStringBuffer str
--     parseState = mkPState flags buffer location
--   </pre>
module Parser
parseModule :: P (Located (HsModule GhcPs))
parseSignature :: P (Located (HsModule GhcPs))
parseImport :: P (LImportDecl GhcPs)
parseStatement :: P (LStmt GhcPs (LHsExpr GhcPs))
parseBackpack :: P [LHsUnit PackageName]
parseDeclaration :: P (LHsDecl GhcPs)
parseExpression :: P (LHsExpr GhcPs)
parsePattern :: P (LPat GhcPs)
parseTypeSignature :: P (LHsDecl GhcPs)
parseStmt :: P (Maybe (LStmt GhcPs (LHsExpr GhcPs)))
parseIdentifier :: P (Located RdrName)
parseType :: P (LHsType GhcPs)
parseHeader :: P (Located (HsModule GhcPs))


-- | Parsing the top of a Haskell source file to get its module name,
--   imports and options.
--   
--   (c) Simon Marlow 2005 (c) Lemmih 2006
module HeaderInfo

-- | Parse the imports of a source file.
--   
--   Throws a <a>SourceError</a> if parsing fails.
getImports :: DynFlags -> StringBuffer -> FilePath -> FilePath -> IO ([(Maybe FastString, Located ModuleName)], [(Maybe FastString, Located ModuleName)], Located ModuleName)
mkPrelImports :: ModuleName -> SrcSpan -> Bool -> [LImportDecl GhcPs] -> [LImportDecl GhcPs]

-- | Parse OPTIONS and LANGUAGE pragmas of the source file.
--   
--   Throws a <a>SourceError</a> if flag parsing fails (including
--   unsupported flags.)
getOptionsFromFile :: DynFlags -> FilePath -> IO [Located String]

-- | Parse OPTIONS and LANGUAGE pragmas of the source file.
--   
--   Throws a <a>SourceError</a> if flag parsing fails (including
--   unsupported flags.)
getOptions :: DynFlags -> StringBuffer -> FilePath -> [Located String]
optionsErrorMsgs :: DynFlags -> [String] -> [Located String] -> FilePath -> Messages

-- | Complain about non-dynamic flags in OPTIONS pragmas.
--   
--   Throws a <a>SourceError</a> if the input list is non-empty claiming
--   that the input flags are unknown.
checkProcessArgsResult :: MonadIO m => DynFlags -> [Located String] -> m ()

module Hooks
data Hooks

-- | Hooks can be used by GHC API clients to replace parts of the compiler
--   pipeline. If a hook is not installed, GHC uses the default built-in
--   behaviour
emptyHooks :: Hooks
lookupHook :: (Hooks -> Maybe a) -> a -> DynFlags -> a
getHooked :: (Functor f, HasDynFlags f) => (Hooks -> Maybe a) -> a -> f a
dsForeignsHook :: Hooks -> Maybe ([LForeignDecl GhcTc] -> DsM (ForeignStubs, OrdList (Id, CoreExpr)))
tcForeignImportsHook :: Hooks -> Maybe ([LForeignDecl GhcRn] -> TcM ([Id], [LForeignDecl GhcTc], Bag GlobalRdrElt))
tcForeignExportsHook :: Hooks -> Maybe ([LForeignDecl GhcRn] -> TcM (LHsBinds GhcTcId, [LForeignDecl GhcTcId], Bag GlobalRdrElt))
hscFrontendHook :: Hooks -> Maybe (ModSummary -> Hsc FrontendResult)
hscCompileCoreExprHook :: Hooks -> Maybe (HscEnv -> SrcSpan -> CoreExpr -> IO ForeignHValue)
ghcPrimIfaceHook :: Hooks -> Maybe ModIface
runPhaseHook :: Hooks -> Maybe (PhasePlus -> FilePath -> DynFlags -> CompPipeline (PhasePlus, FilePath))
runMetaHook :: Hooks -> Maybe (MetaHook TcM)
linkHook :: Hooks -> Maybe (GhcLink -> DynFlags -> Bool -> HomePackageTable -> IO SuccessFlag)
runRnSpliceHook :: Hooks -> Maybe (HsSplice GhcRn -> RnM (HsSplice GhcRn))
getValueSafelyHook :: Hooks -> Maybe (HscEnv -> Name -> Type -> IO (Maybe HValue))
createIservProcessHook :: Hooks -> Maybe (CreateProcess -> IO ProcessHandle)


-- | Commonly useful utilites for manipulating the Core language
module CoreUtils

-- | Wrap the given expression in the coercion safely, dropping identity
--   coercions and coalescing nested coercions
mkCast :: CoreExpr -> CoercionR -> CoreExpr

-- | Wraps the given expression in the source annotation, dropping the
--   annotation if possible.
mkTick :: Tickish Id -> CoreExpr -> CoreExpr
mkTicks :: [Tickish Id] -> CoreExpr -> CoreExpr
mkTickNoHNF :: Tickish Id -> CoreExpr -> CoreExpr
tickHNFArgs :: Tickish Id -> CoreExpr -> CoreExpr

-- | <tt>bindNonRec x r b</tt> produces either:
--   
--   <pre>
--   let x = r in b
--   </pre>
--   
--   or:
--   
--   <pre>
--   case r of x { _DEFAULT_ -&gt; b }
--   </pre>
--   
--   depending on whether we have to use a <tt>case</tt> or <tt>let</tt>
--   binding for the expression (see <a>needsCaseBinding</a>). It's used by
--   the desugarer to avoid building bindings that give Core Lint a heart
--   attack, although actually the simplifier deals with them perfectly
--   well. See also <a>mkCoreLet</a>
bindNonRec :: Id -> CoreExpr -> CoreExpr -> CoreExpr

-- | Tests whether we have to use a <tt>case</tt> rather than <tt>let</tt>
--   binding for this expression as per the invariants of <a>CoreExpr</a>:
--   see <a>CoreSyn#let_app_invariant</a>
needsCaseBinding :: Type -> CoreExpr -> Bool

-- | This guy constructs the value that the scrutinee must have given that
--   you are in one particular branch of a case
mkAltExpr :: AltCon -> [CoreBndr] -> [Type] -> CoreExpr

-- | Extract the default case alternative
findDefault :: [(AltCon, [a], b)] -> ([(AltCon, [a], b)], Maybe b)
addDefault :: [(AltCon, [a], b)] -> Maybe b -> [(AltCon, [a], b)]

-- | Find the case alternative corresponding to a particular constructor:
--   panics if no such constructor exists
findAlt :: AltCon -> [(AltCon, a, b)] -> Maybe (AltCon, a, b)
isDefaultAlt :: (AltCon, a, b) -> Bool

-- | Merge alternatives preserving order; alternatives in the first
--   argument shadow ones in the second
mergeAlts :: [(AltCon, a, b)] -> [(AltCon, a, b)] -> [(AltCon, a, b)]

-- | Given:
--   
--   <pre>
--   case (C a b x y) of
--          C b x y -&gt; ...
--   </pre>
--   
--   We want to drop the leading type argument of the scrutinee leaving the
--   arguments to match against the pattern
trimConArgs :: AltCon -> [CoreArg] -> [CoreArg]
filterAlts :: TyCon -> [Type] -> [AltCon] -> [(AltCon, [Var], a)] -> ([AltCon], [(AltCon, [Var], a)])
combineIdenticalAlts :: [AltCon] -> [CoreAlt] -> (Bool, [AltCon], [CoreAlt])

-- | Refine the default alternative to a <a>DataAlt</a>, if there is a
--   unique way to do so. See Note [Refine Default Alts]
refineDefaultAlt :: [Unique] -> TyCon -> [Type] -> [AltCon] -> [CoreAlt] -> (Bool, [CoreAlt])

-- | Recover the type of a well-typed Core expression. Fails when applied
--   to the actual <a>Type</a> expression as it cannot really be said to
--   have a type
exprType :: CoreExpr -> Type

-- | Returns the type of the alternatives right hand side
coreAltType :: CoreAlt -> Type

-- | Returns the type of the first alternative, which should be the same as
--   for all alternatives
coreAltsType :: [CoreAlt] -> Type

-- | Is this expression levity polymorphic? This should be the same as
--   saying (isKindLevPoly . typeKind . exprType) but much faster.
isExprLevPoly :: CoreExpr -> Bool
exprIsDupable :: DynFlags -> CoreExpr -> Bool
exprIsTrivial :: CoreExpr -> Bool
getIdFromTrivialExpr :: HasDebugCallStack => CoreExpr -> Id
exprIsBottom :: CoreExpr -> Bool
getIdFromTrivialExpr_maybe :: CoreExpr -> Maybe Id
exprIsCheap :: CoreExpr -> Bool
exprIsExpandable :: CoreExpr -> Bool
exprIsCheapX :: CheapAppFun -> CoreExpr -> Bool
type CheapAppFun = Id -> Arity -> Bool

-- | exprIsHNF returns true for expressions that are certainly
--   <i>already</i> evaluated to <i>head</i> normal form. This is used to
--   decide whether it's ok to change:
--   
--   <pre>
--   case x of _ -&gt; e
--   </pre>
--   
--   into:
--   
--   <pre>
--   e
--   </pre>
--   
--   and to decide whether it's safe to discard a <a>seq</a>.
--   
--   So, it does <i>not</i> treat variables as evaluated, unless they say
--   they are. However, it <i>does</i> treat partial applications and
--   constructor applications as values, even if their arguments are
--   non-trivial, provided the argument type is lifted. For example, both
--   of these are values:
--   
--   <pre>
--   (:) (f x) (map f xs)
--   map (...redex...)
--   </pre>
--   
--   because <a>seq</a> on such things completes immediately.
--   
--   For unlifted argument types, we have to be careful:
--   
--   <pre>
--   C (f x :: Int#)
--   </pre>
--   
--   Suppose <tt>f x</tt> diverges; then <tt>C (f x)</tt> is not a value.
--   However this can't happen: see <a>CoreSyn#let_app_invariant</a>. This
--   invariant states that arguments of unboxed type must be
--   ok-for-speculation (or trivial).
exprIsHNF :: CoreExpr -> Bool

-- | <a>exprOkForSpeculation</a> returns True of an expression that is:
--   
--   <ul>
--   <li>Safe to evaluate even if normal order eval might not evaluate the
--   expression at all, or</li>
--   <li>Safe <i>not</i> to evaluate even if normal order would do so</li>
--   </ul>
--   
--   It is usually called on arguments of unlifted type, but not always In
--   particular, Simplify.rebuildCase calls it on lifted types when a
--   'case' is a plain <a>seq</a>. See the example in Note
--   [exprOkForSpeculation: case expressions] below
--   
--   Precisely, it returns <tt>True</tt> iff: a) The expression guarantees
--   to terminate, b) soon, c) without causing a write side effect (e.g.
--   writing a mutable variable) d) without throwing a Haskell exception e)
--   without risking an unchecked runtime exception (array out of bounds,
--   divide by zero)
--   
--   For <tt>exprOkForSideEffects</tt> the list is the same, but omitting
--   (e).
--   
--   Note that exprIsHNF implies exprOkForSpeculation exprOkForSpeculation
--   implies exprOkForSideEffects
--   
--   See Note [PrimOp can_fail and has_side_effects] in PrimOp and Note
--   [Transformations affected by can_fail and has_side_effects]
--   
--   As an example of the considerations in this test, consider:
--   
--   <pre>
--   let x = case y# +# 1# of { r# -&gt; I# r# }
--   in E
--   </pre>
--   
--   being translated to:
--   
--   <pre>
--   case y# +# 1# of { r# -&gt;
--      let x = I# r#
--      in E
--   }
--   </pre>
--   
--   We can only do this if the <tt>y + 1</tt> is ok for speculation: it
--   has no side effects, and can't diverge or raise an exception.
exprOkForSpeculation :: CoreExpr -> Bool

-- | <a>exprOkForSpeculation</a> returns True of an expression that is:
--   
--   <ul>
--   <li>Safe to evaluate even if normal order eval might not evaluate the
--   expression at all, or</li>
--   <li>Safe <i>not</i> to evaluate even if normal order would do so</li>
--   </ul>
--   
--   It is usually called on arguments of unlifted type, but not always In
--   particular, Simplify.rebuildCase calls it on lifted types when a
--   'case' is a plain <a>seq</a>. See the example in Note
--   [exprOkForSpeculation: case expressions] below
--   
--   Precisely, it returns <tt>True</tt> iff: a) The expression guarantees
--   to terminate, b) soon, c) without causing a write side effect (e.g.
--   writing a mutable variable) d) without throwing a Haskell exception e)
--   without risking an unchecked runtime exception (array out of bounds,
--   divide by zero)
--   
--   For <tt>exprOkForSideEffects</tt> the list is the same, but omitting
--   (e).
--   
--   Note that exprIsHNF implies exprOkForSpeculation exprOkForSpeculation
--   implies exprOkForSideEffects
--   
--   See Note [PrimOp can_fail and has_side_effects] in PrimOp and Note
--   [Transformations affected by can_fail and has_side_effects]
--   
--   As an example of the considerations in this test, consider:
--   
--   <pre>
--   let x = case y# +# 1# of { r# -&gt; I# r# }
--   in E
--   </pre>
--   
--   being translated to:
--   
--   <pre>
--   case y# +# 1# of { r# -&gt;
--      let x = I# r#
--      in E
--   }
--   </pre>
--   
--   We can only do this if the <tt>y + 1</tt> is ok for speculation: it
--   has no side effects, and can't diverge or raise an exception.
exprOkForSideEffects :: CoreExpr -> Bool
exprIsWorkFree :: CoreExpr -> Bool

-- | Returns <tt>True</tt> of expressions that are too big to be compared
--   by <a>cheapEqExpr</a>
exprIsBig :: Expr b -> Bool

-- | Similar to <a>exprIsHNF</a> but includes CONLIKE functions as well as
--   data constructors. Conlike arguments are considered interesting by the
--   inliner.
exprIsConLike :: CoreExpr -> Bool

-- | This function is called only on *top-level* right-hand sides. Returns
--   <tt>True</tt> if the RHS can be allocated statically in the output,
--   with no thunks involved at all.
rhsIsStatic :: Platform -> (Name -> Bool) -> (LitNumType -> Integer -> Maybe CoreExpr) -> CoreExpr -> Bool
isCheapApp :: CheapAppFun
isExpandableApp :: CheapAppFun

-- | Check if the expression is zero or more Ticks wrapped around a literal
--   string.
exprIsTickedString :: CoreExpr -> Bool

-- | Extract a literal string from an expression that is zero or more Ticks
--   wrapped around a literal string. Returns Nothing if the expression has
--   a different shape. Used to "look through" Ticks in places that need to
--   handle literal strings.
exprIsTickedString_maybe :: CoreExpr -> Maybe ByteString

-- | Can we bind this <a>CoreExpr</a> at the top level?
exprIsTopLevelBindable :: CoreExpr -> Type -> Bool
altsAreExhaustive :: [Alt b] -> Bool

-- | A cheap equality test which bales out fast! If it returns
--   <tt>True</tt> the arguments are definitely equal, otherwise, they may
--   or may not be equal.
--   
--   See also <a>exprIsBig</a>
cheapEqExpr :: Expr b -> Expr b -> Bool

-- | Cheap expression equality test, can ignore ticks by type.
cheapEqExpr' :: (Tickish Id -> Bool) -> Expr b -> Expr b -> Bool
eqExpr :: InScopeSet -> CoreExpr -> CoreExpr -> Bool

-- | Finds differences between core expressions, modulo alpha and renaming.
--   Setting <tt>top</tt> means that the <tt>IdInfo</tt> of bindings will
--   be checked for differences as well.
diffExpr :: Bool -> RnEnv2 -> CoreExpr -> CoreExpr -> [SDoc]

-- | Finds differences between core bindings, see <tt>diffExpr</tt>.
--   
--   The main problem here is that while we expect the binds to have the
--   same order in both lists, this is not guaranteed. To do this properly
--   we'd either have to do some sort of unification or check all possible
--   mappings, which would be seriously expensive. So instead we simply
--   match single bindings as far as we can. This leaves us just with
--   mutually recursive and/or mismatching bindings, which we then
--   speculatively match by ordering them. It's by no means perfect, but
--   gets the job done well enough.
diffBinds :: Bool -> RnEnv2 -> [(Var, CoreExpr)] -> [(Var, CoreExpr)] -> ([SDoc], RnEnv2)
tryEtaReduce :: [Var] -> CoreExpr -> Maybe CoreExpr

-- | If the expression is a <a>Expr</a>, converts. Otherwise, panics. NB:
--   This does <i>not</i> convert <a>Expr</a> to <tt>CoercionTy</tt>.
exprToType :: CoreExpr -> Type

-- | If the expression is a <a>Expr</a>, converts.
exprToCoercion_maybe :: CoreExpr -> Maybe Coercion

-- | A more efficient version of <a>applyTypeToArg</a> when we have several
--   arguments. The first argument is just for debugging, and gives some
--   context
applyTypeToArgs :: CoreExpr -> Type -> [CoreExpr] -> Type

-- | Determines the type resulting from applying an expression with given
--   type to a given argument expression
applyTypeToArg :: Type -> CoreExpr -> Type
dataConRepInstPat :: [Unique] -> DataCon -> [Type] -> ([TyCoVar], [Id])
dataConRepFSInstPat :: [FastString] -> [Unique] -> DataCon -> [Type] -> ([TyCoVar], [Id])

-- | True if the type has no non-bottom elements, e.g. when it is an empty
--   datatype, or a GADT with non-satisfiable type parameters, e.g. Int :~:
--   Bool. See Note [Bottoming expressions]
--   
--   See Note [No alternatives lint check] for another use of this
--   function.
isEmptyTy :: Type -> Bool

-- | Strip ticks satisfying a predicate from top of an expression
stripTicksTop :: (Tickish Id -> Bool) -> Expr b -> ([Tickish Id], Expr b)

-- | Strip ticks satisfying a predicate from top of an expression,
--   returning the remaining expression
stripTicksTopE :: (Tickish Id -> Bool) -> Expr b -> Expr b

-- | Strip ticks satisfying a predicate from top of an expression,
--   returning the ticks
stripTicksTopT :: (Tickish Id -> Bool) -> Expr b -> [Tickish Id]

-- | Completely strip ticks satisfying a predicate from an expression. Note
--   this is O(n) in the size of the expression!
stripTicksE :: (Tickish Id -> Bool) -> Expr b -> Expr b
stripTicksT :: (Tickish Id -> Bool) -> Expr b -> [Tickish Id]

-- | <tt>collectMakeStaticArgs (makeStatic t srcLoc e)</tt> yields <tt>Just
--   (makeStatic, t, srcLoc, e)</tt>.
--   
--   Returns <tt>Nothing</tt> for every other expression.
collectMakeStaticArgs :: CoreExpr -> Maybe (CoreExpr, Type, CoreExpr, CoreExpr)

-- | Does this binding bind a join point (or a recursive group of join
--   points)?
isJoinBind :: CoreBind -> Bool


-- | Handy functions for creating much Core syntax
module MkCore

-- | Bind a binding group over an expression, using a <tt>let</tt> or
--   <tt>case</tt> as appropriate (see <a>CoreSyn#let_app_invariant</a>)
mkCoreLet :: CoreBind -> CoreExpr -> CoreExpr

-- | Bind a list of binding groups over an expression. The leftmost binding
--   group becomes the outermost group in the resulting expression
mkCoreLets :: [CoreBind] -> CoreExpr -> CoreExpr

-- | Construct an expression which represents the application of one
--   expression to the other Respects the let/app invariant by building a
--   case expression where necessary See CoreSyn Note [CoreSyn let/app
--   invariant]
mkCoreApp :: SDoc -> CoreExpr -> CoreExpr -> CoreExpr
infixl 4 `mkCoreApp`

-- | Construct an expression which represents the application of a number
--   of expressions to another. The leftmost expression in the list is
--   applied first Respects the let/app invariant by building a case
--   expression where necessary See CoreSyn Note [CoreSyn let/app
--   invariant]
mkCoreApps :: CoreExpr -> [CoreExpr] -> CoreExpr
infixl 4 `mkCoreApps`

-- | Construct an expression which represents the application of a number
--   of expressions to that of a data constructor expression. The leftmost
--   expression in the list is applied first
mkCoreConApps :: DataCon -> [CoreExpr] -> CoreExpr

-- | Create a lambda where the given expression has a number of variables
--   bound over it. The leftmost binder is that bound by the outermost
--   lambda in the result
mkCoreLams :: [CoreBndr] -> CoreExpr -> CoreExpr
mkWildCase :: CoreExpr -> Type -> Type -> [CoreAlt] -> CoreExpr
mkIfThenElse :: CoreExpr -> CoreExpr -> CoreExpr -> CoreExpr

-- | Make a <i>wildcard binder</i>. This is typically used when you need a
--   binder that you expect to use only at a *binding* site. Do not use it
--   at occurrence sites because it has a single, fixed unique, and it's
--   very easy to get into difficulties with shadowing. That's why it is
--   used so little. See Note [WildCard binders] in SimplEnv
mkWildValBinder :: Type -> Id
mkWildEvBinder :: PredType -> EvVar
sortQuantVars :: [Var] -> [Var]
castBottomExpr :: CoreExpr -> Type -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the a <tt>Word</tt>
--   with the given value
mkWordExpr :: DynFlags -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Word</tt>
mkWordExprWord :: DynFlags -> Word -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given <tt>Int</tt>
mkIntExpr :: DynFlags -> Integer -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given <tt>Int</tt>
mkIntExprInt :: DynFlags -> Int -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Integer</tt>
mkIntegerExpr :: MonadThings m => Integer -> m CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Natural</tt>
mkNaturalExpr :: MonadThings m => Integer -> m CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Float</tt>
mkFloatExpr :: Float -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Double</tt>
mkDoubleExpr :: Double -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>Char</tt>
mkCharExpr :: Char -> CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to the given
--   <tt>String</tt>
mkStringExpr :: MonadThings m => String -> m CoreExpr

-- | Create a <a>CoreExpr</a> which will evaluate to a string morally
--   equivalent to the given <tt>FastString</tt>
mkStringExprFS :: MonadThings m => FastString -> m CoreExpr
mkStringExprFSWith :: Monad m => (Name -> m Id) -> FastString -> m CoreExpr
data FloatBind
FloatLet :: CoreBind -> FloatBind
FloatCase :: CoreExpr -> Id -> AltCon -> [Var] -> FloatBind
wrapFloat :: FloatBind -> CoreExpr -> CoreExpr

-- | Build a small tuple holding the specified variables One-tuples are
--   flattened; see Note [Flattening one-tuples]
mkCoreVarTup :: [Id] -> CoreExpr

-- | Build the type of a small tuple that holds the specified variables
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkCoreVarTupTy :: [Id] -> Type

-- | Build a small tuple holding the specified expressions One-tuples are
--   flattened; see Note [Flattening one-tuples]
mkCoreTup :: [CoreExpr] -> CoreExpr

-- | Build a small unboxed tuple holding the specified expressions, with
--   the given types. The types must be the types of the expressions. Do
--   not include the RuntimeRep specifiers; this function calculates them
--   for you. Does <i>not</i> flatten one-tuples; see Note [Flattening
--   one-tuples]
mkCoreUbxTup :: [Type] -> [CoreExpr] -> CoreExpr

-- | Make a core tuple of the given boxity
mkCoreTupBoxity :: Boxity -> [CoreExpr] -> CoreExpr

-- | The unit expression
unitExpr :: CoreExpr

-- | Build a big tuple holding the specified variables One-tuples are
--   flattened; see Note [Flattening one-tuples]
mkBigCoreVarTup :: [Id] -> CoreExpr
mkBigCoreVarTup1 :: [Id] -> CoreExpr

-- | Build the type of a big tuple that holds the specified variables
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkBigCoreVarTupTy :: [Id] -> Type

-- | Build the type of a big tuple that holds the specified type of thing
--   One-tuples are flattened; see Note [Flattening one-tuples]
mkBigCoreTupTy :: [Type] -> Type

-- | Build a big tuple holding the specified expressions One-tuples are
--   flattened; see Note [Flattening one-tuples]
mkBigCoreTup :: [CoreExpr] -> CoreExpr

-- | <a>mkSmallTupleSelector1</a> is like <a>mkSmallTupleSelector</a> but
--   one-tuples are NOT flattened (see Note [Flattening one-tuples])
--   
--   Like <a>mkTupleSelector</a> but for tuples that are guaranteed never
--   to be "big".
--   
--   <pre>
--   mkSmallTupleSelector [x] x v e = [| e |]
--   mkSmallTupleSelector [x,y,z] x v e = [| case e of v { (x,y,z) -&gt; x } |]
--   </pre>
mkSmallTupleSelector :: [Id] -> Id -> Id -> CoreExpr -> CoreExpr

-- | As <a>mkTupleCase</a>, but for a tuple that is small enough to be
--   guaranteed not to need nesting.
mkSmallTupleCase :: [Id] -> CoreExpr -> Id -> CoreExpr -> CoreExpr

-- | <a>mkTupleSelector1</a> is like <a>mkTupleSelector</a> but one-tuples
--   are NOT flattened (see Note [Flattening one-tuples])
--   
--   Builds a selector which scrutises the given expression and extracts
--   the one name from the list given. If you want the no-shadowing rule to
--   apply, the caller is responsible for making sure that none of these
--   names are in scope.
--   
--   If there is just one <a>Id</a> in the tuple, then the selector is just
--   the identity.
--   
--   If necessary, we pattern match on a "big" tuple.
mkTupleSelector :: [Id] -> Id -> Id -> CoreExpr -> CoreExpr

-- | Builds a selector which scrutises the given expression and extracts
--   the one name from the list given. If you want the no-shadowing rule to
--   apply, the caller is responsible for making sure that none of these
--   names are in scope.
--   
--   If there is just one <a>Id</a> in the tuple, then the selector is just
--   the identity.
--   
--   If necessary, we pattern match on a "big" tuple.
mkTupleSelector1 :: [Id] -> Id -> Id -> CoreExpr -> CoreExpr

-- | A generalization of <a>mkTupleSelector</a>, allowing the body of the
--   case to be an arbitrary expression.
--   
--   To avoid shadowing, we use uniques to invent new variables.
--   
--   If necessary we pattern match on a "big" tuple.
mkTupleCase :: UniqSupply -> [Id] -> CoreExpr -> Id -> CoreExpr -> CoreExpr

-- | Makes a list <tt>[]</tt> for lists of the specified type
mkNilExpr :: Type -> CoreExpr

-- | Makes a list <tt>(:)</tt> for lists of the specified type
mkConsExpr :: Type -> CoreExpr -> CoreExpr -> CoreExpr

-- | Make a list containing the given expressions, where the list has the
--   given type
mkListExpr :: Type -> [CoreExpr] -> CoreExpr

-- | Make a fully applied <a>foldr</a> expression
mkFoldrExpr :: MonadThings m => Type -> Type -> CoreExpr -> CoreExpr -> CoreExpr -> m CoreExpr

-- | Make a <tt>build</tt> expression applied to a locally-bound worker
--   function
mkBuildExpr :: (MonadFail m, MonadThings m, MonadUnique m) => Type -> ((Id, Type) -> (Id, Type) -> m CoreExpr) -> m CoreExpr

-- | Makes a Nothing for the specified type
mkNothingExpr :: Type -> CoreExpr

-- | Makes a Just from a value of the specified type
mkJustExpr :: Type -> CoreExpr -> CoreExpr
mkRuntimeErrorApp :: Id -> Type -> String -> CoreExpr
mkImpossibleExpr :: Type -> CoreExpr
mkAbsentErrorApp :: Type -> String -> CoreExpr
errorIds :: [Id]
rEC_CON_ERROR_ID :: Id
rUNTIME_ERROR_ID :: Id
nON_EXHAUSTIVE_GUARDS_ERROR_ID :: Id
nO_METHOD_BINDING_ERROR_ID :: Id
pAT_ERROR_ID :: Id
rEC_SEL_ERROR_ID :: Id
aBSENT_ERROR_ID :: Id
tYPE_ERROR_ID :: Id
aBSENT_SUM_FIELD_ERROR_ID :: Id
instance Outputable.Outputable MkCore.FloatBind

module CoreSubst

-- | A substitution environment, containing <a>Id</a>, <a>TyVar</a>, and
--   <a>CoVar</a> substitutions.
--   
--   Some invariants apply to how you use the substitution:
--   
--   <ol>
--   <li>Note [The substitution invariant] in TyCoRep</li>
--   <li>Note [Substitutions apply only once] in TyCoRep</li>
--   </ol>
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitution of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | An environment for substituting for <a>Id</a>s
type IdSubstEnv = IdEnv CoreExpr

-- | A set of variables that are in scope at some point "Secrets of the
--   Glasgow Haskell Compiler inliner" Section 3.2 provides the motivation
--   for this abstraction.
data InScopeSet

-- | De-shadowing the program is sometimes a useful pre-pass. It can be
--   done simply by running over the bindings with an empty substitution,
--   because substitution returns a result that has no-shadowing
--   guaranteed.
--   
--   (Actually, within a single <i>type</i> there might still be shadowing,
--   because <a>substTy</a> is a no-op for the empty substitution, but
--   that's probably OK.)
--   
--   <ul>
--   <li><i>Aug 09</i> This function is not used in GHC at the moment, but
--   seems so short and simple that I'm going to leave it here</li>
--   </ul>
deShadowBinds :: CoreProgram -> CoreProgram

-- | Substitutes for the <a>Id</a>s within the <tt>WorkerInfo</tt> given
--   the new function <a>Id</a>
substSpec :: Subst -> Id -> RuleInfo -> RuleInfo
substRulesForImportedIds :: Subst -> [CoreRule] -> [CoreRule]

-- | See <a>substTy</a>
substTy :: Subst -> Type -> Type

-- | See <a>substCo</a>
substCo :: Subst -> Coercion -> Coercion
substExpr :: SDoc -> Subst -> CoreExpr -> CoreExpr

-- | Apply a substitution to an entire <a>CoreExpr</a>. Remember, you may
--   only apply the substitution <i>once</i>: see Note [Substitutions apply
--   only once] in TyCoRep
--   
--   Do *not* attempt to short-cut in the case of an empty substitution!
--   See Note [Extending the Subst]
substExprSC :: SDoc -> Subst -> CoreExpr -> CoreExpr

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBind :: Subst -> CoreBind -> (Subst, CoreBind)

-- | Apply a substitution to an entire <a>CoreBind</a>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutions.
substBindSC :: Subst -> CoreBind -> (Subst, CoreBind)

-- | Substitutes for the <a>Id</a>s within an unfolding
substUnfolding :: Subst -> Unfolding -> Unfolding

-- | Substitutes for the <a>Id</a>s within an unfolding
substUnfoldingSC :: Subst -> Unfolding -> Unfolding

-- | Find the substitution for an <a>Id</a> in the <a>Subst</a>
lookupIdSubst :: SDoc -> Subst -> Id -> CoreExpr

-- | Find the substitution for a <a>TyVar</a> in the <a>Subst</a>
lookupTCvSubst :: Subst -> TyVar -> Type
substIdOcc :: Subst -> Id -> Id
substTickish :: Subst -> Tickish Id -> Tickish Id
substDVarSet :: Subst -> DVarSet -> DVarSet

-- | Substitute into some <a>IdInfo</a> with regard to the supplied new
--   <a>Id</a>.
substIdInfo :: Subst -> Id -> IdInfo -> Maybe IdInfo
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst
mkSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> IdSubstEnv -> Subst

-- | Simultaneously substitute for a bunch of variables No left-right
--   shadowing ie the substitution for (x y. e) a1 a2 so neither x nor y
--   scope over a1 a2
mkOpenSubst :: InScopeSet -> [(Var, CoreArg)] -> Subst

-- | Find the in-scope set: see TyCoRep Note [The substitution invariant]
substInScope :: Subst -> InScopeSet
isEmptySubst :: Subst -> Bool

-- | Add a substitution for an <a>Id</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that TyCoRep Note [The
--   substitution invariant] holds after extending the substitution like
--   this
extendIdSubst :: Subst -> Id -> CoreExpr -> Subst

-- | Adds multiple <a>Id</a> substitutions to the <a>Subst</a>: see also
--   <a>extendIdSubst</a>
extendIdSubstList :: Subst -> [(Id, CoreExpr)] -> Subst
extendTCvSubst :: TCvSubst -> TyCoVar -> Type -> TCvSubst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst

-- | Add a substitution appropriate to the thing being substituted (whether
--   an expression, type, or coercion). See also <a>extendIdSubst</a>,
--   <a>extendTvSubst</a>, <a>extendCvSubst</a>
extendSubst :: Subst -> Var -> CoreArg -> Subst

-- | Add a substitution as appropriate to each of the terms being
--   substituted (whether expressions, types, or coercions). See also
--   <a>extendSubst</a>.
extendSubstList :: Subst -> [(Var, CoreArg)] -> Subst
extendSubstWithVar :: Subst -> Var -> Var -> Subst

-- | Remove all substitutions for <a>Id</a>s and <a>Expr</a>s that might
--   have been built up while preserving the in-scope set
zapSubstEnv :: Subst -> Subst

-- | Add the <a>Expr</a> to the in-scope set, but do not remove any
--   existing substitutions for it
addInScopeSet :: Subst -> VarSet -> Subst

-- | Add the <a>Expr</a> to the in-scope set: as a side effect, and remove
--   any existing substitutions for it
extendInScope :: Subst -> Var -> Subst

-- | Add the <a>Expr</a>s to the in-scope set: see also
--   <a>extendInScope</a>
extendInScopeList :: Subst -> [Var] -> Subst

-- | Optimized version of <a>extendInScopeList</a> that can be used if you
--   are certain all the things being added are <a>Id</a>s and hence none
--   are <a>TyVar</a>s or <a>CoVar</a>s
extendInScopeIds :: Subst -> [Id] -> Subst
isInScope :: Var -> Subst -> Bool
setInScope :: Subst -> InScopeSet -> Subst
getTCvSubst :: Subst -> TCvSubst

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a> The
--   <a>TyVar</a> *must* be a real TyVar, and not a CoVar You must ensure
--   that the in-scope set is such that TyCoRep Note [The substitution
--   invariant] holds after extending the substitution like this.
extendTvSubst :: Subst -> TyVar -> Type -> Subst

-- | Add a substitution from a <a>CoVar</a> to a <a>Expr</a> to the
--   <a>Subst</a>: you must ensure that the in-scope set satisfies TyCoRep
--   Note [The substitution invariant] after extending the substitution
--   like this
extendCvSubst :: Subst -> CoVar -> Coercion -> Subst
delBndr :: Subst -> Var -> Subst
delBndrs :: Subst -> [Var] -> Subst

-- | Substitutes a <a>Expr</a> for another one according to the
--   <a>Subst</a> given, returning the result and an updated <a>Subst</a>
--   that should be used by subsequent substitutions. <a>IdInfo</a> is
--   preserved by this process, although it is substituted into
--   appropriately.
substBndr :: Subst -> Var -> (Subst, Var)

-- | Applies <a>substBndr</a> to a number of <a>Expr</a>s, accumulating a
--   new <a>Subst</a> left-to-right
substBndrs :: Subst -> [Var] -> (Subst, [Var])

-- | Substitute in a mutually recursive group of <a>Id</a>s
substRecBndrs :: Subst -> [Id] -> (Subst, [Id])
substTyVarBndr :: Subst -> TyVar -> (Subst, TyVar)
substCoVarBndr :: Subst -> TyVar -> (Subst, TyVar)
cloneBndr :: Subst -> Unique -> Var -> (Subst, Var)
cloneBndrs :: Subst -> UniqSupply -> [Var] -> (Subst, [Var])

-- | Very similar to <a>substBndr</a>, but it always allocates a new
--   <a>Unique</a> for each variable in its output. It substitutes the
--   IdInfo though.
cloneIdBndr :: Subst -> UniqSupply -> Id -> (Subst, Id)

-- | Applies <a>cloneIdBndr</a> to a number of <a>Id</a>s, accumulating a
--   final substitution from left to right
cloneIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])

-- | Clone a mutually recursive group of <a>Id</a>s
cloneRecIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])
instance Outputable.Outputable CoreSubst.Subst


-- | Arity and eta expansion
module CoreArity

-- | manifestArity sees how many leading value lambdas there are, after
--   looking through casts
manifestArity :: CoreExpr -> Arity
joinRhsArity :: CoreExpr -> JoinArity

-- | An approximate, fast, version of <a>exprEtaExpandArity</a>
exprArity :: CoreExpr -> Arity
typeArity :: Type -> [OneShotInfo]
exprEtaExpandArity :: DynFlags -> CoreExpr -> Arity
findRhsArity :: DynFlags -> Id -> CoreExpr -> Arity -> (Arity, Bool)
type CheapFun = CoreExpr -> Maybe Type -> Bool

-- | <tt>etaExpand n e</tt> returns an expression with the same meaning as
--   <tt>e</tt>, but with arity <tt>n</tt>.
--   
--   Given:
--   
--   <pre>
--   e' = etaExpand n e
--   </pre>
--   
--   We should have that:
--   
--   <pre>
--   ty = exprType e = exprType e'
--   </pre>
etaExpand :: Arity -> CoreExpr -> CoreExpr

-- | Split an expression into the given number of binders and a body,
--   eta-expanding if necessary. Counts value *and* type binders.
etaExpandToJoinPoint :: JoinArity -> CoreExpr -> ([CoreBndr], CoreExpr)
etaExpandToJoinPointRule :: JoinArity -> CoreRule -> CoreRule
exprBotStrictness_maybe :: CoreExpr -> Maybe (Arity, StrictSig)
instance Outputable.Outputable CoreArity.EtaInfo
instance Outputable.Outputable CoreArity.ArityType

module OccurAnal
occurAnalysePgm :: Module -> (Id -> Bool) -> (Activation -> Bool) -> [CoreRule] -> CoreProgram -> CoreProgram
occurAnalyseExpr :: CoreExpr -> CoreExpr
occurAnalyseExpr_NoBinderSwap :: CoreExpr -> CoreExpr
instance Outputable.Outputable OccurAnal.Details
instance Outputable.Outputable OccurAnal.UsageDetails
instance Outputable.Outputable OccurAnal.OccEncl

module CoreTidy
tidyExpr :: TidyEnv -> CoreExpr -> CoreExpr
tidyVarOcc :: TidyEnv -> Var -> Var
tidyRule :: TidyEnv -> CoreRule -> CoreRule
tidyRules :: TidyEnv -> [CoreRule] -> [CoreRule]
tidyUnfolding :: TidyEnv -> Unfolding -> Unfolding -> Unfolding

module CoreOpt
simpleOptPgm :: DynFlags -> Module -> CoreProgram -> [CoreRule] -> IO (CoreProgram, [CoreRule])
simpleOptExpr :: DynFlags -> CoreExpr -> CoreExpr
simpleOptExprWith :: DynFlags -> Subst -> InExpr -> OutExpr

-- | Returns Just (bndr,rhs) if the binding is a join point: If it's a
--   JoinId, just return it If it's not yet a JoinId but is always
--   tail-called, make it into a JoinId and return it. In the latter case,
--   eta-expand the RHS if necessary, to make the lambdas explicit, as is
--   required for join points
--   
--   Precondition: the InBndr has been occurrence-analysed, so its OccInfo
--   is valid
joinPointBinding_maybe :: InBndr -> InExpr -> Maybe (InBndr, InExpr)
joinPointBindings_maybe :: [(InBndr, InExpr)] -> Maybe [(InBndr, InExpr)]

-- | Returns <tt>Just (dc, [t1..tk], [x1..xn])</tt> if the argument
--   expression is a *saturated* constructor application of the form <tt>dc
--   t1..tk x1 .. xn</tt>, where t1..tk are the *universally-quantified*
--   type args of <tt>dc</tt>
exprIsConApp_maybe :: InScopeEnv -> CoreExpr -> Maybe (DataCon, [Type], [CoreExpr])
exprIsLiteral_maybe :: InScopeEnv -> CoreExpr -> Maybe Literal
exprIsLambda_maybe :: InScopeEnv -> CoreExpr -> Maybe (Var, CoreExpr, [Tickish Id])
pushCoArg :: CoercionR -> CoreArg -> Maybe (CoreArg, MCoercion)
pushCoValArg :: CoercionR -> Maybe (Coercion, MCoercion)
pushCoTyArg :: CoercionR -> Type -> Maybe (Type, MCoercionR)
collectBindersPushingCo :: CoreExpr -> ([Var], CoreExpr)
instance Outputable.Outputable CoreOpt.SimpleOptEnv


-- | Functions for collecting together and applying rewrite rules to a
--   module. The <a>CoreRule</a> datatype itself is declared elsewhere.
module Rules
emptyRuleBase :: RuleBase
mkRuleBase :: [CoreRule] -> RuleBase
extendRuleBaseList :: RuleBase -> [CoreRule] -> RuleBase
unionRuleBase :: RuleBase -> RuleBase -> RuleBase
pprRuleBase :: RuleBase -> SDoc

-- | Report partial matches for rules beginning with the specified string
--   for the purposes of error reporting
ruleCheckProgram :: CompilerPhase -> String -> (Id -> [CoreRule]) -> CoreProgram -> SDoc

-- | Make a <a>RuleInfo</a> containing a number of <a>CoreRule</a>s,
--   suitable for putting into an <tt>IdInfo</tt>
mkRuleInfo :: [CoreRule] -> RuleInfo
extendRuleInfo :: RuleInfo -> [CoreRule] -> RuleInfo
addRuleInfo :: RuleInfo -> RuleInfo -> RuleInfo
addIdSpecialisations :: Id -> [CoreRule] -> Id

-- | Gather all the rules for locally bound identifiers from the supplied
--   bindings
rulesOfBinds :: [CoreBind] -> [CoreRule]
getRules :: RuleEnv -> Id -> [CoreRule]
pprRulesForUser :: DynFlags -> [CoreRule] -> SDoc

-- | The main rule matching function. Attempts to apply all (active)
--   supplied rules to this instance of an application in a given context,
--   returning the rule applied and the resulting expression if successful.
lookupRule :: DynFlags -> InScopeEnv -> (Activation -> Bool) -> Id -> [CoreExpr] -> [CoreRule] -> Maybe (CoreRule, CoreExpr)

-- | Used to make <a>CoreRule</a> for an <a>Id</a> defined in the module
--   being compiled. See also <a>CoreRule</a>
mkRule :: Module -> Bool -> Bool -> RuleName -> Activation -> Name -> [CoreBndr] -> [CoreExpr] -> CoreExpr -> CoreRule

-- | Find the "top" free names of several expressions. Such names are
--   either:
--   
--   <ol>
--   <li>The function finally being applied to in an application chain (if
--   that name is a GlobalId: see <a>Var#globalvslocal</a>), or</li>
--   <li>The <tt>TyCon</tt> if the expression is a <a>Expr</a></li>
--   </ol>
--   
--   This is used for the fast-match-check for rules; if the top names
--   don't match, the rest can't
roughTopNames :: [CoreExpr] -> [Maybe Name]

module CoreUnfold

-- | Records the <i>unfolding</i> of an identifier, which is approximately
--   the form the identifier would have if we substituted its definition in
--   for the identifier. This type should be treated as abstract everywhere
--   except in <a>CoreUnfold</a>
data Unfolding

-- | <a>UnfoldingGuidance</a> says when unfolding should take place
data UnfoldingGuidance

-- | There is no known <a>Unfolding</a>
noUnfolding :: Unfolding
mkImplicitUnfolding :: DynFlags -> CoreExpr -> Unfolding
mkUnfolding :: DynFlags -> UnfoldingSource -> Bool -> Bool -> CoreExpr -> Unfolding
mkCoreUnfolding :: UnfoldingSource -> Bool -> CoreExpr -> UnfoldingGuidance -> Unfolding
mkTopUnfolding :: DynFlags -> Bool -> CoreExpr -> Unfolding
mkSimpleUnfolding :: DynFlags -> CoreExpr -> Unfolding
mkWorkerUnfolding :: DynFlags -> (CoreExpr -> CoreExpr) -> Unfolding -> Unfolding

-- | Make an unfolding that may be used unsaturated (ug_unsat_ok =
--   unSaturatedOk) and that is reported as having its manifest arity (the
--   number of outer lambdas applications will resolve before doing any
--   work).
mkInlineUnfolding :: CoreExpr -> Unfolding

-- | Make an unfolding that will be used once the RHS has been saturated to
--   the given arity.
mkInlineUnfoldingWithArity :: Arity -> CoreExpr -> Unfolding
mkInlinableUnfolding :: DynFlags -> CoreExpr -> Unfolding
mkWwInlineRule :: DynFlags -> CoreExpr -> Arity -> Unfolding
mkCompulsoryUnfolding :: CoreExpr -> Unfolding
mkDFunUnfolding :: [Var] -> DataCon -> [CoreExpr] -> Unfolding
specUnfolding :: DynFlags -> [Var] -> (CoreExpr -> CoreExpr) -> Arity -> Unfolding -> Unfolding
data ArgSummary
TrivArg :: ArgSummary
NonTrivArg :: ArgSummary
ValueArg :: ArgSummary
couldBeSmallEnoughToInline :: DynFlags -> Int -> CoreExpr -> Bool
inlineBoringOk :: CoreExpr -> Bool
certainlyWillInline :: DynFlags -> IdInfo -> Maybe Unfolding
smallEnoughToInline :: DynFlags -> Unfolding -> Bool
callSiteInline :: DynFlags -> Id -> Bool -> Bool -> [ArgSummary] -> CallCtxt -> Maybe CoreExpr
data CallCtxt
BoringCtxt :: CallCtxt
RhsCtxt :: CallCtxt
DiscArgCtxt :: CallCtxt
RuleArgCtxt :: CallCtxt
ValAppCtxt :: CallCtxt
CaseCtxt :: CallCtxt

-- | Returns <tt>Just (dc, [t1..tk], [x1..xn])</tt> if the argument
--   expression is a *saturated* constructor application of the form <tt>dc
--   t1..tk x1 .. xn</tt>, where t1..tk are the *universally-quantified*
--   type args of <tt>dc</tt>
exprIsConApp_maybe :: InScopeEnv -> CoreExpr -> Maybe (DataCon, [Type], [CoreExpr])
exprIsLiteral_maybe :: InScopeEnv -> CoreExpr -> Maybe Literal
instance Outputable.Outputable CoreUnfold.CallCtxt
instance Outputable.Outputable CoreUnfold.ArgSummary
instance Outputable.Outputable CoreUnfold.ExprSize

module PrelRules
primOpRules :: Name -> PrimOp -> Maybe CoreRule
builtinRules :: [CoreRule]

-- | Match the scrutinee of a case and potentially return a new scrutinee
--   and a function to apply to each literal alternative.
caseRules :: DynFlags -> CoreExpr -> Maybe (CoreExpr, AltCon -> Maybe AltCon, Id -> CoreExpr)
instance GHC.Base.Functor PrelRules.RuleM
instance GHC.Base.Applicative PrelRules.RuleM
instance GHC.Base.Monad PrelRules.RuleM
instance Control.Monad.Fail.MonadFail PrelRules.RuleM
instance GHC.Base.Alternative PrelRules.RuleM
instance GHC.Base.MonadPlus PrelRules.RuleM
instance DynFlags.HasDynFlags PrelRules.RuleM

module MkId
mkDictFunId :: Name -> [TyVar] -> ThetaType -> Class -> [Type] -> Id
mkDictFunTy :: [TyVar] -> ThetaType -> Class -> [Type] -> Type
mkDictSelId :: Name -> Class -> Id
mkDictSelRhs :: Class -> Int -> CoreExpr
mkPrimOpId :: PrimOp -> Id
mkFCallId :: DynFlags -> Unique -> ForeignCall -> Type -> Id
unwrapNewTypeBody :: TyCon -> [Type] -> CoreExpr -> CoreExpr
wrapFamInstBody :: TyCon -> [Type] -> CoreExpr -> CoreExpr

-- | Data Constructor Boxer
newtype DataConBoxer
DCB :: ([Type] -> [Var] -> UniqSM ([Var], [CoreBind])) -> DataConBoxer
mkDataConRep :: DynFlags -> FamInstEnvs -> Name -> Maybe [HsImplBang] -> DataCon -> UniqSM DataConRep
mkDataConWorkId :: Name -> DataCon -> Id
wiredInIds :: [Id]
ghcPrimIds :: [Id]
unsafeCoerceName :: Name
unsafeCoerceId :: Id
realWorldPrimId :: Id
voidPrimId :: Id
voidArgId :: Id
nullAddrId :: Id
seqId :: Id
lazyId :: Id
lazyIdKey :: Unique
coercionTokenId :: Id
magicDictId :: Id
coerceId :: Id
proxyHashId :: Id
noinlineId :: Id
noinlineIdName :: Name


-- | Functions for converting Core things to interface file things.
module ToIface
toIfaceTvBndr :: TyVar -> IfaceTvBndr
toIfaceTvBndrs :: [TyVar] -> [IfaceTvBndr]
toIfaceIdBndr :: Id -> IfaceIdBndr
toIfaceBndr :: Var -> IfaceBndr
toIfaceForAllBndr :: TyCoVarBinder -> IfaceForAllBndr
toIfaceTyCoVarBinders :: [VarBndr Var vis] -> [VarBndr IfaceBndr vis]
toIfaceTyVar :: TyVar -> FastString
toIfaceType :: Type -> IfaceType
toIfaceTypeX :: VarSet -> Type -> IfaceType
toIfaceKind :: Type -> IfaceType
toIfaceTcArgs :: TyCon -> [Type] -> IfaceAppArgs
toIfaceTyCon :: TyCon -> IfaceTyCon
toIfaceTyCon_name :: Name -> IfaceTyCon
toIfaceTyLit :: TyLit -> IfaceTyLit
tidyToIfaceType :: TidyEnv -> Type -> IfaceType
tidyToIfaceContext :: TidyEnv -> ThetaType -> IfaceContext
tidyToIfaceTcArgs :: TidyEnv -> TyCon -> [Type] -> IfaceAppArgs
toIfaceCoercion :: Coercion -> IfaceCoercion
toIfaceCoercionX :: VarSet -> Coercion -> IfaceCoercion
patSynToIfaceDecl :: PatSyn -> IfaceDecl
toIfaceExpr :: CoreExpr -> IfaceExpr
toIfaceBang :: TidyEnv -> HsImplBang -> IfaceBang
toIfaceSrcBang :: HsSrcBang -> IfaceSrcBang
toIfaceLetBndr :: Id -> IfaceLetBndr
toIfaceIdDetails :: IdDetails -> IfaceIdDetails
toIfaceIdInfo :: IdInfo -> IfaceIdInfo
toIfUnfolding :: Bool -> Unfolding -> Maybe IfaceInfoItem
toIfaceOneShot :: Id -> IfaceOneShot
toIfaceTickish :: Tickish Id -> Maybe IfaceTickish
toIfaceBind :: Bind Id -> IfaceBinding
toIfaceAlt :: (AltCon, [Var], CoreExpr) -> (IfaceConAlt, [FastString], IfaceExpr)
toIfaceCon :: AltCon -> IfaceConAlt
toIfaceApp :: Expr CoreBndr -> [Arg CoreBndr] -> IfaceExpr
toIfaceVar :: Id -> IfaceExpr
