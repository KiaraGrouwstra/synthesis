-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer
--   
--   Haskell-Source with Extensions (HSE, haskell-src-exts) is a standalone
--   parser for Haskell. In addition to standard Haskell, all extensions
--   implemented in GHC are supported.
--   
--   Apart from these standard extensions, it also handles regular patterns
--   as per the HaRP extension as well as HSX-style embedded XML syntax.
@package haskell-src-exts
@version 1.21.1


-- | This module defines the list of recognized modular features of
--   Haskell, most often (sloppily) referred to as "extensions".
--   
--   Closely mimicking the Language.Haskell.Extension module from the Cabal
--   library, this package also includes functionality for "computing"
--   languages as sets of features. Also, we make no promise not to add
--   extensions not yet recognized by Cabal.
module Language.Haskell.Exts.Extension
data Language

-- | The Haskell 98 language as defined by the Haskell 98 report.
--   <a>http://haskell.org/onlinereport/</a>
Haskell98 :: Language

-- | The Haskell 2010 language as defined by the Haskell 2010 report.
--   <a>http://www.haskell.org/onlinereport/haskell2010</a>
Haskell2010 :: Language

-- | The minimal language resulting from disabling all recognized
--   extensions - including ones that are part of all known language
--   definitions e.g. MonomorphismRestriction.
HaskellAllDisabled :: Language

-- | An unknown language, identified by its name.
UnknownLanguage :: String -> Language
knownLanguages :: [Language]
classifyLanguage :: String -> Language
prettyLanguage :: Language -> String

-- | This represents language extensions beyond a base <a>Language</a>
--   definition (such as <a>Haskell98</a>) that are supported by some
--   implementations, usually in some special mode.
data Extension

-- | Enable a known extension
EnableExtension :: KnownExtension -> Extension

-- | Disable a known extension
DisableExtension :: KnownExtension -> Extension

-- | An unknown extension, identified by the name of its <tt>LANGUAGE</tt>
--   pragma.
UnknownExtension :: String -> Extension
data KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.4</i> Allow overlapping class instances, provided
--   there is a unique most specific instance for each use.</li>
--   </ul>
OverlappingInstances :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.3</i> Ignore structural rules guaranteeing the
--   termination of class instance resolution. Termination is guaranteed by
--   a fixed-depth recursion stack, and compilation may fail if this depth
--   is exceeded.</li>
--   </ul>
UndecidableInstances :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.4</i> Implies <a>OverlappingInstances</a>. Allow
--   the implementation to choose an instance even when it is possible that
--   further instantiation of types will lead to a more specific instance
--   being applicable.</li>
--   </ul>
IncoherentInstances :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.5</i> Allow type signatures in instances.</li>
--   </ul>
InstanceSigs :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.8</i> Deprecated in GHC. Allows recursive bindings in
--   <tt>do</tt> blocks, using the <tt>rec</tt> keyword.</li>
--   </ul>
DoRec :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.8.2</i> Allows recursive bindings using <tt>mdo</tt>,
--   a variant of <tt>do</tt>, and <tt>rec</tt>.</li>
--   </ul>
RecursiveDo :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.9</i> Provide syntax for writing list comprehensions
--   which iterate over several lists together, like the <a>zipWith</a>
--   family of functions.</li>
--   </ul>
ParallelListComp :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.1.1</i> Allow multiple parameters in a type
--   class.</li>
--   </ul>
MultiParamTypeClasses :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.17</i> Enable the dreaded monomorphism
--   restriction.</li>
--   </ul>
MonomorphismRestriction :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.2</i> Allow a specification attached to a
--   multi-parameter type class which indicates that some parameters are
--   entirely determined by others. The implementation will check that this
--   property holds for the declared instances, and will use this property
--   to reduce ambiguity in instance resolution.</li>
--   </ul>
FunctionalDependencies :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.5</i> Like <a>RankNTypes</a> but does not allow a
--   higher-rank type to itself appear on the left of a function
--   arrow.</li>
--   </ul>
Rank2Types :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.5</i> Allow a universally-quantified type to occur on
--   the left of a function arrow.</li>
--   </ul>
RankNTypes :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.5</i> Allow data constructors to have polymorphic
--   arguments. Unlike <a>RankNTypes</a>, does not allow this for ordinary
--   functions.</li>
--   </ul>
PolymorphicComponents :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.4.4</i> Allow existentially-quantified data
--   constructors.</li>
--   </ul>
ExistentialQuantification :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.7</i> Cause a type variable in a signature, which has
--   an explicit <tt>forall</tt> quantifier, to scope over the definition
--   of the accompanying value declaration.</li>
--   </ul>
ScopedTypeVariables :: KnownExtension

-- | Deprecated, use <a>ScopedTypeVariables</a> instead.
PatternSignatures :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.3</i> Enable implicit function parameters with
--   dynamic scope.</li>
--   </ul>
ImplicitParams :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.2</i> Relax some restrictions on the form of the
--   context of a type signature.</li>
--   </ul>
FlexibleContexts :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.2</i> Relax some restrictions on the form of the
--   context of an instance declaration.</li>
--   </ul>
FlexibleInstances :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.4.1</i> Allow data type declarations with no
--   constructors.</li>
--   </ul>
EmptyDataDecls :: KnownExtension

-- | <ul>
--   <li><i>GHC § 4.10.3</i> Run the C preprocessor on Haskell source
--   code.</li>
--   </ul>
CPP :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.4</i> Allow an explicit kind signature giving the
--   kind of types over which a type variable ranges.</li>
--   </ul>
KindSignatures :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.11</i> Enable a form of pattern which forces evaluation
--   before an attempted match, and a form of strict
--   <tt>let</tt>/<tt>where</tt> binding.</li>
--   </ul>
BangPatterns :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.3.1</i> Allow type synonyms in instance heads.</li>
--   </ul>
TypeSynonymInstances :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.9</i> Enable Template Haskell, a system for
--   compile-time metaprogramming.</li>
--   </ul>
TemplateHaskell :: KnownExtension

-- | <ul>
--   <li><i>GHC § 8</i> Enable the Foreign Function Interface. In GHC,
--   implements the standard Haskell 98 Foreign Function Interface
--   Addendum, plus some GHC-specific extensions.</li>
--   </ul>
ForeignFunctionInterface :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.10</i> Enable arrow notation.</li>
--   </ul>
Arrows :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.16</i> Enable generic type classes, with default
--   instances defined in terms of the algebraic structure of a type.</li>
--   </ul>
Generics :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.11</i> Enable the implicit importing of the module
--   <tt>Prelude</tt>. When disabled, when desugaring certain built-in
--   syntax into ordinary identifiers, use whatever is in scope rather than
--   the <tt>Prelude</tt> -- version.</li>
--   </ul>
ImplicitPrelude :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.15</i> Enable syntax for implicitly binding local
--   names corresponding to the field names of a record. Puns bind specific
--   names, unlike <a>RecordWildCards</a>.</li>
--   </ul>
NamedFieldPuns :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.5</i> Enable a form of guard which matches a pattern
--   and binds variables.</li>
--   </ul>
PatternGuards :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.5.4</i> Allow a type declared with <tt>newtype</tt> to
--   use <tt>deriving</tt> for any class with an instance for the
--   underlying type.</li>
--   </ul>
GeneralizedNewtypeDeriving :: KnownExtension

-- | <ul>
--   <li><i>GHC § 9.6.10</i> Allow use of any typeclass in deriving
--   clauses.</li>
--   </ul>
DeriveAnyClass :: KnownExtension

-- | <ul>
--   <li><i>Hugs § 7.1</i> Enable the "Trex" extensible records
--   system.</li>
--   </ul>
ExtensibleRecords :: KnownExtension

-- | <ul>
--   <li><i>Hugs § 7.2</i> Enable type synonyms which are transparent in
--   some definitions and opaque elsewhere, as a way of implementing
--   abstract datatypes.</li>
--   </ul>
RestrictedTypeSynonyms :: KnownExtension

-- | <ul>
--   <li><i>Hugs § 7.3</i> Enable an alternate syntax for string literals,
--   with string templating.</li>
--   </ul>
HereDocuments :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.2</i> Allow the character <tt>#</tt> as a postfix
--   modifier on identifiers. Also enables literal syntax for unboxed
--   values.</li>
--   </ul>
MagicHash :: KnownExtension

-- | Binary integer literals
BinaryLiterals :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.7</i> Allow data types and type synonyms which are
--   indexed by types, i.e. ad-hoc polymorphism for types.</li>
--   </ul>
TypeFamilies :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.5.2</i> Allow a standalone declaration which invokes
--   the type class <tt>deriving</tt> mechanism.</li>
--   </ul>
StandaloneDeriving :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.1</i> Allow certain Unicode characters to stand for
--   certain ASCII character sequences, e.g. keywords and punctuation.</li>
--   </ul>
UnicodeSyntax :: KnownExtension

-- | <ul>
--   <li><i>GHC § 8.1.1</i> Allow the use of unboxed types as foreign
--   types, e.g. in <tt>foreign import</tt> and <tt>foreign
--   export</tt>.</li>
--   </ul>
UnliftedFFITypes :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.4.3</i> Defer validity checking of types until after
--   expanding type synonyms, relaxing the constraints on how synonyms may
--   be used.</li>
--   </ul>
LiberalTypeSynonyms :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.4.2</i> Allow the name of a type constructor, type
--   class, or type variable to be an infix operator.</li>
--   </ul>
TypeOperators :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.26.5</i> Parallel arrays for Data Parallel
--   Haskell.</li>
--   </ul>
ParallelArrays :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.16</i> Enable syntax for implicitly binding local
--   names corresponding to the field names of a record. A wildcard binds
--   all unmentioned names, unlike <a>NamedFieldPuns</a>.</li>
--   </ul>
RecordWildCards :: KnownExtension

-- | Deprecated, use <a>NamedFieldPuns</a> instead.
RecordPuns :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.14</i> Allow a record field name to be disambiguated
--   by the type of the record it's in.</li>
--   </ul>
DisambiguateRecordFields :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.4</i> Enable overloading of string literals using a
--   type class, much like integer literals.</li>
--   </ul>
OverloadedStrings :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.4.6</i> Enable generalized algebraic data types, in
--   which type variables may be instantiated on a per-constructor basis.
--   Implies GADTSyntax.</li>
--   </ul>
GADTs :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.17.2</i> Make pattern bindings monomorphic.</li>
--   </ul>
MonoPatBinds :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.8</i> Relax the requirements on mutually-recursive
--   polymorphic functions.</li>
--   </ul>
RelaxedPolyRec :: KnownExtension

-- | <ul>
--   <li><i>GHC § 2.4.5</i> Allow default instantiation of polymorphic
--   types in more situations.</li>
--   </ul>
ExtendedDefaultRules :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.2.2</i> Enable unboxed tuples.</li>
--   </ul>
UnboxedTuples :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.5.3</i> Enable <tt>deriving</tt> for classes
--   <tt>Data.Typeable.Typeable</tt> and <tt>Data.Generics.Data</tt>.</li>
--   </ul>
DeriveDataTypeable :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.1.3</i> Allow a class method's type to place
--   additional constraints on a class type variable.</li>
--   </ul>
ConstrainedClassMethods :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.18</i> Allow imports to be qualified by the package
--   name the module is intended to be imported from, e.g.</li>
--   </ul>
--   
--   <pre>
--   import "network" Network.Socket
--   </pre>
PackageImports :: KnownExtension
LambdaCase :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.20</i> Allow case expressions with no
--   alternatives.</li>
--   </ul>
EmptyCase :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.8.6</i> Deprecated in GHC 6.12 and will be removed in
--   GHC 7. Allow a type variable to be instantiated at a polymorphic
--   type.</li>
--   </ul>
ImpredicativeTypes :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.3</i> Change the syntax for qualified infix
--   operators.</li>
--   </ul>
NewQualifiedOperators :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.12</i> Relax the interpretation of left operator
--   sections to allow unary postfix operators.</li>
--   </ul>
PostfixOperators :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.9.5</i> Enable quasi-quotation, a mechanism for
--   defining new concrete syntax for expressions and patterns.</li>
--   </ul>
QuasiQuotes :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.10</i> Enable generalized list comprehensions,
--   supporting operations such as sorting and grouping.</li>
--   </ul>
TransformListComp :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.6</i> Enable view patterns, which match a value by
--   applying a function and matching on the result.</li>
--   </ul>
ViewPatterns :: KnownExtension

-- | Allow concrete XML syntax to be used in expressions and patterns, as
--   per the Haskell Server Pages extension language:
--   <a>http://www.haskell.org/haskellwiki/HSP</a>. The ideas behind it are
--   discussed in the paper "Haskell Server Pages through Dynamic Loading"
--   by Niklas Broberg, from Haskell Workshop '05.
XmlSyntax :: KnownExtension

-- | Allow regular pattern matching over lists, as discussed in the paper
--   "Regular Expression Patterns" by Niklas Broberg, Andreas Farre and
--   Josef Svenningsson, from ICFP '04.
RegularPatterns :: KnownExtension

-- | Enables the use of tuple sections, e.g. <tt>(, True)</tt> desugars
--   into <tt>x -&gt; (x, True)</tt>.
TupleSections :: KnownExtension

-- | Allows GHC primops, written in C--, to be imported into a Haskell
--   file.
GHCForeignImportPrim :: KnownExtension

-- | Support for patterns of the form <tt>n + k</tt>, where <tt>k</tt> is
--   an integer literal.
NPlusKPatterns :: KnownExtension

-- | Improve the layout rule when <tt>if</tt> expressions are used in a
--   <tt>do</tt> block.
DoAndIfThenElse :: KnownExtension

-- | Makes much of the Haskell sugar be desugared into calls to the
--   function with a particular name that is in scope.
RebindableSyntax :: KnownExtension

-- | Make <tt>forall</tt> a keyword in types, which can be used to give the
--   generalisation explicitly.
ExplicitForAll :: KnownExtension

-- | Allow contexts to be put on datatypes, e.g. the <tt>Eq a</tt> in
--   <tt>data Eq a =&gt; Set a = NilSet | ConsSet a (Set a)</tt>.
DatatypeContexts :: KnownExtension

-- | Local (<tt>let</tt> and <tt>where</tt>) bindings are monomorphic.
MonoLocalBinds :: KnownExtension

-- | Enable <tt>deriving</tt> for the <tt>Data.Functor.Functor</tt> class.
DeriveFunctor :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.5.3</i> Enable <tt>deriving</tt> for the
--   <tt>Generic</tt> and <tt>Generic1</tt> classes.</li>
--   </ul>
DeriveGeneric :: KnownExtension

-- | Enable <tt>deriving</tt> for the <tt>Data.Traversable.Traversable</tt>
--   class.
DeriveTraversable :: KnownExtension

-- | Enable <tt>deriving</tt> for the <tt>Data.Foldable.Foldable</tt>
--   class.
DeriveFoldable :: KnownExtension

-- | Enable non-decreasing indentation for 'do' blocks.
NondecreasingIndentation :: KnownExtension

-- | <ul>
--   <li><i>GHC § 8.1.4</i> Enable interruptible FFI.</li>
--   </ul>
InterruptibleFFI :: KnownExtension

-- | <ul>
--   <li><i>GHC § 8.1.5</i> Enable the <tt>capi</tt> calling convention in
--   the foreign function interface.</li>
--   </ul>
CApiFFI :: KnownExtension

-- | GHCJS FFI extension with convenient import patterns, asynchronous FFI
--   and a JSVal FFI type
JavaScriptFFI :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.27</i> Enable explicit namespaces in
--   import/export.</li>
--   </ul>
ExplicitNamespaces :: KnownExtension
DataKinds :: KnownExtension
PolyKinds :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.16</i> Enable the multi-way if-expressions extension
--   to accept conditional expressions with multiple branches.</li>
--   </ul>
MultiWayIf :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.20.3</i> Allow imports to be qualified with a safe
--   keyword that requires the imported module be trusted as according to
--   the Safe Haskell definition of trust.</li>
--   </ul>
--   
--   <pre>
--   import safe Network.Socket
--   </pre>
SafeImports :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.20</i> Compile a module in the Safe, Safe Haskell mode
--   -- a restricted form of the Haskell language to ensure type
--   safety.</li>
--   </ul>
Safe :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.20</i> Compile a module in the Trustworthy, Safe
--   Haskell mode -- no restrictions apply but the module is marked as
--   trusted as long as the package the module resides in is trusted.</li>
--   </ul>
Trustworthy :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.6.1.4</i> Allow default signatures in class
--   definitions. They apply to default methods implemented in this
--   class.</li>
--   </ul>
DefaultSignatures :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.40</i> Allow type class<i>implicit
--   parameter</i>equality constraints to be used as types with the special
--   kind Constraint. Also generalise the (ctxt =&gt; ty) syntax so that
--   any type of kind Constraint can occur before the arrow.</li>
--   </ul>
ConstraintKinds :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.25.3</i> Allow role annotations.</li>
--   </ul>
RoleAnnotations :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.3.8</i> Enable giving names to parametrized pattern
--   schemes</li>
--   </ul>
PatternSynonyms :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.15</i> Allow partial specified type signatures. Note
--   that this extension does not affect parsing. It only affects whether
--   the program is able to be run with partial signatures.</li>
--   </ul>
PartialTypeSignatures :: KnownExtension

-- | <ul>
--   <li><i>GHC § 7.15.1.2</i> This extension treats type variables which
--   start with an underscore as wildcards. For example, `foo :: _x` is
--   equivalent to `foo :: _`.</li>
--   </ul>
NamedWildCards :: KnownExtension
TypeApplications :: KnownExtension
TypeFamilyDependencies :: KnownExtension
OverloadedLabels :: KnownExtension

-- | Allow multiple <tt>deriving</tt> clauses, each optionally qualified
--   with a <i>strategy</i>.
DerivingStrategies :: KnownExtension
UnboxedSums :: KnownExtension
TypeInType :: KnownExtension
Strict :: KnownExtension
StrictData :: KnownExtension

-- | Enable deriving instances via types of the same runtime
--   representation. Implies <a>DerivingStrategies</a>.
DerivingVia :: KnownExtension

-- | A clever version of read that returns an <a>UnknownExtension</a> if
--   the string is not recognised.
classifyExtension :: String -> Extension

-- | Parse an enabled or disabled extension; returns
--   <a>UnknownExtension</a> if the parse fails.
parseExtension :: String -> Extension

-- | Pretty print an extension. Disabled extensions are prefixed with 'No'.
prettyExtension :: Extension -> String
ghcDefault :: [Extension]

-- | The list of extensions enabled by GHC's portmanteau -fglasgow-exts
--   flag.
glasgowExts :: [Extension]

-- | List of all known extensions, both "yes" and "no" versions.
knownExtensions :: [Extension]

-- | Extensions that have been deprecated, possibly paired with another
--   extension that replaces it.
deprecatedExtensions :: [(Extension, Maybe Extension)]

-- | Certain extensions imply other extensions, and this function makes the
--   implication explicit. This also handles deprecated extensions, which
--   imply their replacements. The returned value is the transitive closure
--   of implied extensions.
impliesExts :: [KnownExtension] -> [KnownExtension]
toExtensionList :: Language -> [Extension] -> [KnownExtension]
instance GHC.Classes.Ord Language.Haskell.Exts.Extension.Extension
instance GHC.Classes.Eq Language.Haskell.Exts.Extension.Extension
instance GHC.Read.Read Language.Haskell.Exts.Extension.Extension
instance GHC.Show.Show Language.Haskell.Exts.Extension.Extension
instance Data.Data.Data Language.Haskell.Exts.Extension.KnownExtension
instance GHC.Enum.Bounded Language.Haskell.Exts.Extension.KnownExtension
instance GHC.Enum.Enum Language.Haskell.Exts.Extension.KnownExtension
instance GHC.Classes.Ord Language.Haskell.Exts.Extension.KnownExtension
instance GHC.Classes.Eq Language.Haskell.Exts.Extension.KnownExtension
instance GHC.Read.Read Language.Haskell.Exts.Extension.KnownExtension
instance GHC.Show.Show Language.Haskell.Exts.Extension.KnownExtension
instance Data.Data.Data Language.Haskell.Exts.Extension.Language
instance GHC.Classes.Ord Language.Haskell.Exts.Extension.Language
instance GHC.Classes.Eq Language.Haskell.Exts.Extension.Language
instance GHC.Read.Read Language.Haskell.Exts.Extension.Language
instance GHC.Show.Show Language.Haskell.Exts.Extension.Language


-- | This module defines various data types representing source location
--   information, of varying degree of preciseness.
module Language.Haskell.Exts.SrcLoc

-- | A single position in the source.
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
[srcFilename] :: SrcLoc -> String
[srcLine] :: SrcLoc -> Int
[srcColumn] :: SrcLoc -> Int
noLoc :: SrcLoc

-- | A portion of the source, spanning one or more lines and zero or more
--   columns.
data SrcSpan
SrcSpan :: String -> Int -> Int -> Int -> Int -> SrcSpan
[srcSpanFilename] :: SrcSpan -> String
[srcSpanStartLine] :: SrcSpan -> Int
[srcSpanStartColumn] :: SrcSpan -> Int
[srcSpanEndLine] :: SrcSpan -> Int
[srcSpanEndColumn] :: SrcSpan -> Int

-- | Returns <a>srcSpanStartLine</a> and <a>srcSpanStartColumn</a> in a
--   pair.
srcSpanStart :: SrcSpan -> (Int, Int)

-- | Returns <a>srcSpanEndLine</a> and <a>srcSpanEndColumn</a> in a pair.
srcSpanEnd :: SrcSpan -> (Int, Int)

-- | Combine two locations in the source to denote a span.
mkSrcSpan :: SrcLoc -> SrcLoc -> SrcSpan

-- | Merge two source spans into a single span from the start of the first
--   to the end of the second. Assumes that the two spans relate to the
--   same source file.
mergeSrcSpan :: SrcSpan -> SrcSpan -> SrcSpan

-- | Test if a given span starts and ends at the same location.
isNullSpan :: SrcSpan -> Bool
spanSize :: SrcSpan -> (Int, Int)

-- | An entity located in the source.
data Loc a
Loc :: SrcSpan -> a -> Loc a
[loc] :: Loc a -> SrcSpan
[unLoc] :: Loc a -> a

-- | A portion of the source, extended with information on the position of
--   entities within the span.
data SrcSpanInfo
SrcSpanInfo :: SrcSpan -> [SrcSpan] -> SrcSpanInfo
[srcInfoSpan] :: SrcSpanInfo -> SrcSpan
[srcInfoPoints] :: SrcSpanInfo -> [SrcSpan]

-- | Generate a <a>SrcSpanInfo</a> with no positional information for
--   entities.
noInfoSpan :: SrcSpan -> SrcSpanInfo

-- | A bogus <a>SrcSpanInfo</a>, the location is <tt>noLoc</tt>. `noSrcSpan
--   = noInfoSpan (mkSrcSpan noLoc noLoc)`
noSrcSpan :: SrcSpanInfo

-- | Generate a <a>SrcSpanInfo</a> with the supplied positional information
--   for entities.
infoSpan :: SrcSpan -> [SrcSpan] -> SrcSpanInfo

-- | Combine two <a>SrcSpanInfo</a>s into one that spans the combined
--   source area of the two arguments, leaving positional information
--   blank.
combSpanInfo :: SrcSpanInfo -> SrcSpanInfo -> SrcSpanInfo

-- | Like '(<a>+?</a>)', but it also concatenates the <a>srcInfoPoints</a>.
combSpanMaybe :: SrcSpanInfo -> Maybe SrcSpanInfo -> SrcSpanInfo

-- | Short name for <a>combSpanInfo</a>
(<++>) :: SrcSpanInfo -> SrcSpanInfo -> SrcSpanInfo
infixl 5 <++>

-- | Optionally combine the first argument with the second, or return it
--   unchanged if the second argument is <a>Nothing</a>.
(<+?>) :: SrcSpanInfo -> Maybe SrcSpanInfo -> SrcSpanInfo
infixl 4 <+?>

-- | Optionally combine the second argument with the first, or return it
--   unchanged if the first argument is <a>Nothing</a>.
(<?+>) :: Maybe SrcSpanInfo -> SrcSpanInfo -> SrcSpanInfo
infixl 4 <?+>

-- | Add more positional information for entities of a span.
(<**) :: SrcSpanInfo -> [SrcSpan] -> SrcSpanInfo
infixl 4 <**

-- | Merge two <a>SrcSpan</a>s and lift them to a <tt>SrcInfoSpan</tt> with
--   no positional information for entities.
(<^^>) :: SrcSpan -> SrcSpan -> SrcSpanInfo
infixl 6 <^^>

-- | A class to work over all kinds of source location information.
class SrcInfo si
toSrcInfo :: SrcInfo si => SrcLoc -> [SrcSpan] -> SrcLoc -> si
fromSrcInfo :: SrcInfo si => SrcSpanInfo -> si
getPointLoc :: SrcInfo si => si -> SrcLoc
fileName :: SrcInfo si => si -> String
startLine :: SrcInfo si => si -> Int
startColumn :: SrcInfo si => si -> Int
instance GHC.Generics.Generic Language.Haskell.Exts.SrcLoc.SrcSpanInfo
instance Data.Data.Data Language.Haskell.Exts.SrcLoc.SrcSpanInfo
instance GHC.Classes.Ord Language.Haskell.Exts.SrcLoc.SrcSpanInfo
instance GHC.Classes.Eq Language.Haskell.Exts.SrcLoc.SrcSpanInfo
instance GHC.Generics.Generic (Language.Haskell.Exts.SrcLoc.Loc a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Haskell.Exts.SrcLoc.Loc a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Haskell.Exts.SrcLoc.Loc a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Haskell.Exts.SrcLoc.Loc a)
instance GHC.Generics.Generic Language.Haskell.Exts.SrcLoc.SrcSpan
instance Data.Data.Data Language.Haskell.Exts.SrcLoc.SrcSpan
instance GHC.Classes.Ord Language.Haskell.Exts.SrcLoc.SrcSpan
instance GHC.Classes.Eq Language.Haskell.Exts.SrcLoc.SrcSpan
instance GHC.Generics.Generic Language.Haskell.Exts.SrcLoc.SrcLoc
instance Data.Data.Data Language.Haskell.Exts.SrcLoc.SrcLoc
instance GHC.Classes.Ord Language.Haskell.Exts.SrcLoc.SrcLoc
instance GHC.Classes.Eq Language.Haskell.Exts.SrcLoc.SrcLoc
instance Language.Haskell.Exts.SrcLoc.SrcInfo Language.Haskell.Exts.SrcLoc.SrcLoc
instance Language.Haskell.Exts.SrcLoc.SrcInfo Language.Haskell.Exts.SrcLoc.SrcSpan
instance Language.Haskell.Exts.SrcLoc.SrcInfo Language.Haskell.Exts.SrcLoc.SrcSpanInfo
instance GHC.Show.Show Language.Haskell.Exts.SrcLoc.SrcSpanInfo
instance GHC.Show.Show Language.Haskell.Exts.SrcLoc.SrcSpan
instance GHC.Show.Show Language.Haskell.Exts.SrcLoc.SrcLoc


-- | A suite of datatypes describing the (semi-concrete) abstract syntax of
--   Haskell 98 <a>http://www.haskell.org/onlinereport/</a> plus registered
--   extensions, including:
--   
--   <ul>
--   <li>multi-parameter type classes with functional dependencies
--   (MultiParamTypeClasses, FunctionalDependencies)</li>
--   <li>parameters of type class assertions are unrestricted
--   (FlexibleContexts)</li>
--   <li><tt>forall</tt> types as universal and existential quantification
--   (RankNTypes, ExistentialQuantification, etc)</li>
--   <li>pattern guards (PatternGuards)</li>
--   <li>implicit parameters (ImplicitParameters)</li>
--   <li>generalised algebraic data types (GADTs)</li>
--   <li>template haskell (TemplateHaskell)</li>
--   <li>empty data type declarations (EmptyDataDecls)</li>
--   <li>unboxed tuples (UnboxedTuples)</li>
--   <li>regular patterns (RegularPatterns)</li>
--   <li>HSP-style XML expressions and patterns (XmlSyntax)</li>
--   </ul>
--   
--   All nodes in the syntax tree are annotated with something of a
--   user-definable data type. When parsing, this annotation will contain
--   information about the source location that the particular node comes
--   from.
module Language.Haskell.Exts.Syntax

-- | A complete Haskell source module.
data Module l

-- | an ordinary Haskell module
Module :: l -> Maybe (ModuleHead l) -> [ModulePragma l] -> [ImportDecl l] -> [Decl l] -> Module l

-- | a module consisting of a single XML document. The ModuleName never
--   appears in the source but is needed for semantic purposes, it will be
--   the same as the file name.
XmlPage :: l -> ModuleName l -> [ModulePragma l] -> XName l -> [XAttr l] -> Maybe (Exp l) -> [Exp l] -> Module l

-- | a hybrid module combining an XML document with an ordinary module
XmlHybrid :: l -> Maybe (ModuleHead l) -> [ModulePragma l] -> [ImportDecl l] -> [Decl l] -> XName l -> [XAttr l] -> Maybe (Exp l) -> [Exp l] -> Module l

-- | The head of a module, including the name and export specification.
data ModuleHead l
ModuleHead :: l -> ModuleName l -> Maybe (WarningText l) -> Maybe (ExportSpecList l) -> ModuleHead l

-- | Warning text to optionally use in the module header of e.g. a
--   deprecated module.
data WarningText l
DeprText :: l -> String -> WarningText l
WarnText :: l -> String -> WarningText l

-- | An explicit export specification.
data ExportSpecList l
ExportSpecList :: l -> [ExportSpec l] -> ExportSpecList l

-- | An item in a module's export specification.
data ExportSpec l

-- | variable.
EVar :: l -> QName l -> ExportSpec l

-- | <tt>T</tt>: a class or datatype exported abstractly, or a type
--   synonym.
EAbs :: l -> Namespace l -> QName l -> ExportSpec l

-- | <tt>T(C_1,...,C_n)</tt>: a class exported with some of its methods, or
--   a datatype exported with some of its constructors.
EThingWith :: l -> EWildcard l -> QName l -> [CName l] -> ExportSpec l

-- | <tt>module M</tt>: re-export a module.
EModuleContents :: l -> ModuleName l -> ExportSpec l

-- | Indicates the position of the wildcard in an export list
data EWildcard l
NoWildcard :: l -> EWildcard l
EWildcard :: l -> Int -> EWildcard l

-- | An import declaration.
data ImportDecl l
ImportDecl :: l -> ModuleName l -> Bool -> Bool -> Bool -> Maybe String -> Maybe (ModuleName l) -> Maybe (ImportSpecList l) -> ImportDecl l

-- | annotation, used by parser for position of the <tt>import</tt>
--   keyword.
[importAnn] :: ImportDecl l -> l

-- | name of the module imported.
[importModule] :: ImportDecl l -> ModuleName l

-- | imported <tt>qualified</tt>?
[importQualified] :: ImportDecl l -> Bool

-- | imported with <tt>{-# SOURCE #-}</tt>?
[importSrc] :: ImportDecl l -> Bool

-- | Import <tt>safe</tt>?
[importSafe] :: ImportDecl l -> Bool

-- | imported with explicit package name
[importPkg] :: ImportDecl l -> Maybe String

-- | optional alias name in an <tt>as</tt> clause.
[importAs] :: ImportDecl l -> Maybe (ModuleName l)

-- | optional list of import specifications.
[importSpecs] :: ImportDecl l -> Maybe (ImportSpecList l)

-- | An explicit import specification list.
data ImportSpecList l

-- | A list of import specifications. The <a>Bool</a> is <a>True</a> if the
--   names are excluded by <tt>hiding</tt>.
ImportSpecList :: l -> Bool -> [ImportSpec l] -> ImportSpecList l

-- | An import specification, representing a single explicit item imported
--   (or hidden) from a module.
data ImportSpec l

-- | variable
IVar :: l -> Name l -> ImportSpec l

-- | <tt>T</tt>: the name of a class, datatype or type synonym.
IAbs :: l -> Namespace l -> Name l -> ImportSpec l

-- | <tt>T(..)</tt>: a class imported with all of its methods, or a
--   datatype imported with all of its constructors.
IThingAll :: l -> Name l -> ImportSpec l

-- | <tt>T(C_1,...,C_n)</tt>: a class imported with some of its methods, or
--   a datatype imported with some of its constructors.
IThingWith :: l -> Name l -> [CName l] -> ImportSpec l

-- | Associativity of an operator.
data Assoc l

-- | non-associative operator (declared with <tt>infix</tt>)
AssocNone :: l -> Assoc l

-- | left-associative operator (declared with <tt>infixl</tt>).
AssocLeft :: l -> Assoc l

-- | right-associative operator (declared with <tt>infixr</tt>)
AssocRight :: l -> Assoc l

-- | Namespaces for imports/exports.
data Namespace l
NoNamespace :: l -> Namespace l
TypeNamespace :: l -> Namespace l
PatternNamespace :: l -> Namespace l

-- | A top-level declaration.
data Decl l

-- | A type declaration
TypeDecl :: l -> DeclHead l -> Type l -> Decl l

-- | A type family declaration
TypeFamDecl :: l -> DeclHead l -> Maybe (ResultSig l) -> Maybe (InjectivityInfo l) -> Decl l

-- | A closed type family declaration
ClosedTypeFamDecl :: l -> DeclHead l -> Maybe (ResultSig l) -> Maybe (InjectivityInfo l) -> [TypeEqn l] -> Decl l

-- | A data OR newtype declaration
DataDecl :: l -> DataOrNew l -> Maybe (Context l) -> DeclHead l -> [QualConDecl l] -> [Deriving l] -> Decl l

-- | A data OR newtype declaration, GADT style
GDataDecl :: l -> DataOrNew l -> Maybe (Context l) -> DeclHead l -> Maybe (Kind l) -> [GadtDecl l] -> [Deriving l] -> Decl l

-- | A data family declaration
DataFamDecl :: l -> Maybe (Context l) -> DeclHead l -> Maybe (ResultSig l) -> Decl l

-- | A type family instance declaration
TypeInsDecl :: l -> Type l -> Type l -> Decl l

-- | A data family instance declaration
DataInsDecl :: l -> DataOrNew l -> Type l -> [QualConDecl l] -> [Deriving l] -> Decl l

-- | A data family instance declaration, GADT style
GDataInsDecl :: l -> DataOrNew l -> Type l -> Maybe (Kind l) -> [GadtDecl l] -> [Deriving l] -> Decl l

-- | A declaration of a type class
ClassDecl :: l -> Maybe (Context l) -> DeclHead l -> [FunDep l] -> Maybe [ClassDecl l] -> Decl l

-- | An declaration of a type class instance
InstDecl :: l -> Maybe (Overlap l) -> InstRule l -> Maybe [InstDecl l] -> Decl l

-- | A standalone deriving declaration
DerivDecl :: l -> Maybe (DerivStrategy l) -> Maybe (Overlap l) -> InstRule l -> Decl l

-- | A declaration of operator fixity
InfixDecl :: l -> Assoc l -> Maybe Int -> [Op l] -> Decl l

-- | A declaration of default types
DefaultDecl :: l -> [Type l] -> Decl l

-- | A Template Haskell splicing declaration
SpliceDecl :: l -> Exp l -> Decl l

-- | A type signature declaration
TypeSig :: l -> [Name l] -> Type l -> Decl l

-- | A pattern synonym signature declation
PatSynSig :: l -> [Name l] -> Maybe [TyVarBind l] -> Maybe (Context l) -> Maybe [TyVarBind l] -> Maybe (Context l) -> Type l -> Decl l

-- | A set of function binding clauses
FunBind :: l -> [Match l] -> Decl l

-- | A pattern binding
PatBind :: l -> Pat l -> Rhs l -> Maybe (Binds l) -> Decl l

-- | A pattern synonym binding
PatSyn :: l -> Pat l -> Pat l -> PatternSynDirection l -> Decl l

-- | A foreign import declaration
ForImp :: l -> CallConv l -> Maybe (Safety l) -> Maybe String -> Name l -> Type l -> Decl l

-- | A foreign export declaration
ForExp :: l -> CallConv l -> Maybe String -> Name l -> Type l -> Decl l

-- | A RULES pragma
RulePragmaDecl :: l -> [Rule l] -> Decl l

-- | A DEPRECATED pragma
DeprPragmaDecl :: l -> [([Name l], String)] -> Decl l

-- | A WARNING pragma
WarnPragmaDecl :: l -> [([Name l], String)] -> Decl l

-- | An INLINE pragma
InlineSig :: l -> Bool -> Maybe (Activation l) -> QName l -> Decl l

-- | An INLINE CONLIKE pragma
InlineConlikeSig :: l -> Maybe (Activation l) -> QName l -> Decl l

-- | A SPECIALISE pragma
SpecSig :: l -> Maybe (Activation l) -> QName l -> [Type l] -> Decl l

-- | A SPECIALISE INLINE pragma
SpecInlineSig :: l -> Bool -> Maybe (Activation l) -> QName l -> [Type l] -> Decl l

-- | A SPECIALISE instance pragma
InstSig :: l -> InstRule l -> Decl l

-- | An ANN pragma
AnnPragma :: l -> Annotation l -> Decl l

-- | A MINIMAL pragma
MinimalPragma :: l -> Maybe (BooleanFormula l) -> Decl l

-- | A role annotation
RoleAnnotDecl :: l -> QName l -> [Role l] -> Decl l

-- | A COMPLETE pragma
CompletePragma :: l -> [Name l] -> Maybe (QName l) -> Decl l

-- | The head of a type or class declaration, which consists of the type or
--   class name applied to some type variables
--   
--   <tt>class C a b</tt> is represented as
--   
--   <pre>
--   DHApp
--      ()
--      (DHApp
--         () (DHead () (Ident () "C")) (UnkindedVar () (Ident () "a")))
--      (UnkindedVar () (Ident () "b"))
--   </pre>
--   
--   (where the annotation type <tt>l</tt> is instantiated with
--   <tt>()</tt>)
--   
--   <tt>class (a :&lt; b) c</tt> is represented as
--   
--   <pre>
--   DHApp
--      ()
--      (DHParen
--         ()
--         (DHApp
--            ()
--            (DHInfix () (UnkindedVar () (Ident () "a")) (Symbol () ":&lt;"))
--            (UnkindedVar () (Ident () "b"))))
--      (UnkindedVar () (Ident () "c"))
--   </pre>
data DeclHead l

-- | type or class name
DHead :: l -> Name l -> DeclHead l

-- | infix application of the type/class name to the left operand
DHInfix :: l -> TyVarBind l -> Name l -> DeclHead l

-- | parenthesized declaration head
DHParen :: l -> DeclHead l -> DeclHead l

-- | application to one more type variable
DHApp :: l -> DeclHead l -> TyVarBind l -> DeclHead l

-- | The instance declaration rule, which is, roughly, the part of the
--   instance declaration before the <tt>where</tt> keyword.
--   
--   Example: <tt>instance Ord a =&gt; Ord (Maybe a)</tt> is represented as
--   
--   <pre>
--   IRule
--      ()
--      Nothing
--      (Just
--         (CxSingle
--            ()
--            (ClassA
--               () (UnQual () (Ident () "Ord")) [ TyVar () (Ident () "a") ])))
--      (IHApp
--         ()
--         (IHCon () (UnQual () (Ident () "Ord")))
--         (TyParen
--            ()
--            (TyApp
--               ()
--               (TyCon () (UnQual () (Ident () "Maybe")))
--               (TyVar () (Ident () "a")))))
--   </pre>
--   
--   An optional explicit forall after <tt>instance</tt> is supported:
--   <tt>instance forall a . Ord a =&gt; Ord (Maybe a) where</tt> becomes
--   
--   <pre>
--   IRule
--      ()
--      (Just [ UnkindedVar () (Ident () "a") ])
--      ...
--   </pre>
data InstRule l
IRule :: l -> Maybe [TyVarBind l] -> Maybe (Context l) -> InstHead l -> InstRule l
IParen :: l -> InstRule l -> InstRule l

-- | The instance head. The split between rule/head allow us to represent
--   <tt>instance (Bounded a =&gt; Bounded [a]) where</tt> faithfully.
--   
--   The structure of <a>InstHead</a> follows one of <a>DeclHead</a>.
--   
--   For example, <tt>instance C (Maybe a) Int where</tt> is represented as
--   
--   <pre>
--   IHApp
--      ()
--      (IHApp
--         ()
--         (IHCon () (UnQual () (Ident () "C")))
--         (TyParen
--            ()
--            (TyApp
--               ()
--               (TyCon () (UnQual () (Ident () "Maybe")))
--               (TyVar () (Ident () "a")))))
--      (TyCon () (UnQual () (Ident () "Int")))))
--   </pre>
data InstHead l

-- | type or class name
IHCon :: l -> QName l -> InstHead l

-- | infix application of the type/class name to the left operand
IHInfix :: l -> Type l -> QName l -> InstHead l

-- | parenthesized instance head
IHParen :: l -> InstHead l -> InstHead l

-- | application to one more type
IHApp :: l -> InstHead l -> Type l -> InstHead l

-- | A binding group inside a <tt>let</tt> or <tt>where</tt> clause.
data Binds l

-- | An ordinary binding group
BDecls :: l -> [Decl l] -> Binds l

-- | A binding group for implicit parameters
IPBinds :: l -> [IPBind l] -> Binds l

-- | A binding of an implicit parameter.
data IPBind l
IPBind :: l -> IPName l -> Exp l -> IPBind l
data PatternSynDirection l

-- | A unidirectional pattern synonym with "&lt;-"
Unidirectional :: PatternSynDirection l

-- | A bidirectional pattern synonym with "="
ImplicitBidirectional :: PatternSynDirection l

-- | A birectional pattern synonym with the construction specified.
ExplicitBidirectional :: l -> [Decl l] -> PatternSynDirection l

-- | Injectivity info for injective type families
data InjectivityInfo l
InjectivityInfo :: l -> Name l -> [Name l] -> InjectivityInfo l
data ResultSig l
KindSig :: l -> Kind l -> ResultSig l
TyVarSig :: l -> TyVarBind l -> ResultSig l

-- | Declarations inside a class declaration.
data ClassDecl l

-- | ordinary declaration
ClsDecl :: l -> Decl l -> ClassDecl l

-- | declaration of an associated data type
ClsDataFam :: l -> Maybe (Context l) -> DeclHead l -> Maybe (ResultSig l) -> ClassDecl l

-- | declaration of an associated type synonym
ClsTyFam :: l -> DeclHead l -> Maybe (ResultSig l) -> Maybe (InjectivityInfo l) -> ClassDecl l

-- | default choice for an associated type synonym
ClsTyDef :: l -> TypeEqn l -> ClassDecl l

-- | default signature
ClsDefSig :: l -> Name l -> Type l -> ClassDecl l

-- | Declarations inside an instance declaration.
data InstDecl l

-- | ordinary declaration
InsDecl :: l -> Decl l -> InstDecl l

-- | an associated type definition
InsType :: l -> Type l -> Type l -> InstDecl l

-- | an associated data type implementation
InsData :: l -> DataOrNew l -> Type l -> [QualConDecl l] -> [Deriving l] -> InstDecl l

-- | an associated data type implemented using GADT style
InsGData :: l -> DataOrNew l -> Type l -> Maybe (Kind l) -> [GadtDecl l] -> [Deriving l] -> InstDecl l

-- | A deriving clause following a data type declaration.
data Deriving l
Deriving :: l -> Maybe (DerivStrategy l) -> [InstRule l] -> Deriving l

-- | Which technique the user explicitly requested when deriving an
--   instance.
data DerivStrategy l

-- | GHC's "standard" strategy, which is to implement a custom instance for
--   the data type. This only works for certain types that GHC knows about
--   (e.g., <a>Eq</a>, <a>Show</a>, <a>Functor</a> when
--   <tt>-XDeriveFunctor</tt> is enabled, etc.)
DerivStock :: l -> DerivStrategy l

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
DerivAnyclass :: l -> DerivStrategy l

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
DerivNewtype :: l -> DerivStrategy l

-- | <pre>
--   -XDerivingVia
--   </pre>
DerivVia :: l -> Type l -> DerivStrategy l

-- | A flag stating whether a declaration is a data or newtype declaration.
data DataOrNew l
DataType :: l -> DataOrNew l
NewType :: l -> DataOrNew l

-- | Declaration of an ordinary data constructor.
data ConDecl l

-- | ordinary data constructor
ConDecl :: l -> Name l -> [Type l] -> ConDecl l

-- | infix data constructor
InfixConDecl :: l -> Type l -> Name l -> Type l -> ConDecl l

-- | record constructor
RecDecl :: l -> Name l -> [FieldDecl l] -> ConDecl l

-- | Declaration of a (list of) named field(s).
data FieldDecl l
FieldDecl :: l -> [Name l] -> Type l -> FieldDecl l

-- | A single constructor declaration within a data type declaration, which
--   may have an existential quantification binding.
data QualConDecl l
QualConDecl :: l -> Maybe [TyVarBind l] -> Maybe (Context l) -> ConDecl l -> QualConDecl l

-- | A single constructor declaration in a GADT data type declaration.
--   
--   If the GADT is declared using the record syntax, e.g.
--   
--   <pre>
--   data Ty where
--     TCon :: { field1 :: Int, field2 :: Bool } -&gt; Ty
--   </pre>
--   
--   then the fields are stored as a list of <a>FieldDecl</a>s, and the
--   final type (<tt>Ty</tt> in the above example) is stored in the last
--   <a>Type</a> field.
--   
--   If the GADT is declared using the ordinary syntax, e.g.
--   
--   <pre>
--   data Ty where
--     TCon :: Int -&gt; Bool -&gt; Ty
--   </pre>
--   
--   then <tt><a>Maybe</a> [<a>FieldDecl</a> l]</tt> is <a>Nothing</a>, and
--   the whole constructor's type (such as <tt>Int -&gt; Bool -&gt;
--   Ty</tt>) is stored in the last <a>Type</a> field.
data GadtDecl l
GadtDecl :: l -> Name l -> Maybe [TyVarBind l] -> Maybe (Context l) -> Maybe [FieldDecl l] -> Type l -> GadtDecl l

-- | The type of a constructor argument or field, optionally including a
--   strictness annotation.
data BangType l

-- | strict component, marked with "<tt>!</tt>"
BangedTy :: l -> BangType l

-- | lazy component, marked with "<tt>~</tt>"
LazyTy :: l -> BangType l

-- | No strictness information
NoStrictAnnot :: l -> BangType l
data Unpackedness l

-- | "<tt>{-# UNPACK #-}</tt>"
Unpack :: l -> Unpackedness l

-- | "<tt>{-# NOUNPACK #-}</tt>"
NoUnpack :: l -> Unpackedness l

-- | No unpack pragma
NoUnpackPragma :: l -> Unpackedness l

-- | Clauses of a function binding.
data Match l

-- | A clause defined with prefix notation, i.e. the function name followed
--   by its argument patterns, the right-hand side and an optional where
--   clause.
Match :: l -> Name l -> [Pat l] -> Rhs l -> Maybe (Binds l) -> Match l

-- | A clause defined with infix notation, i.e. first its first argument
--   pattern, then the function name, then its following argument(s), the
--   right-hand side and an optional where clause. Note that there can be
--   more than two arguments to a function declared infix, hence the list
--   of pattern arguments.
InfixMatch :: l -> Pat l -> Name l -> [Pat l] -> Rhs l -> Maybe (Binds l) -> Match l

-- | The right hand side of a function binding, pattern binding, or a case
--   alternative.
data Rhs l

-- | unguarded right hand side (<i>exp</i>)
UnGuardedRhs :: l -> Exp l -> Rhs l

-- | guarded right hand side (<i>gdrhs</i>)
GuardedRhss :: l -> [GuardedRhs l] -> Rhs l

-- | A guarded right hand side <tt>|</tt> <i>stmts</i> <tt>=</tt>
--   <i>exp</i>, or <tt>|</tt> <i>stmts</i> <tt>-&gt;</tt> <i>exp</i> for
--   case alternatives. The guard is a series of statements when using
--   pattern guards, otherwise it will be a single qualifier expression.
data GuardedRhs l
GuardedRhs :: l -> [Stmt l] -> Exp l -> GuardedRhs l

-- | A context is a set of assertions
data Context l
CxSingle :: l -> Asst l -> Context l
CxTuple :: l -> [Asst l] -> Context l
CxEmpty :: l -> Context l

-- | A functional dependency, given on the form l1 l2 ... ln -&gt; r2 r3 ..
--   rn
data FunDep l
FunDep :: l -> [Name l] -> [Name l] -> FunDep l

-- | Class assertions. In Haskell 98, the argument would be a <i>tyvar</i>,
--   but this definition allows multiple parameters, and allows them to be
--   <i>type</i>s. Also extended with support for implicit parameters and
--   equality constraints.
data Asst l

-- | ordinary class assertion
ClassA :: l -> QName l -> [Type l] -> Asst l

-- | constraint kind assertion, <tt>Dict :: cxt a =&gt; Dict cxt</tt>
AppA :: l -> Name l -> [Type l] -> Asst l

-- | class assertion where the class name is given infix
InfixA :: l -> Type l -> QName l -> Type l -> Asst l

-- | implicit parameter assertion
IParam :: l -> IPName l -> Type l -> Asst l

-- | type equality constraint
EqualP :: l -> Type l -> Type l -> Asst l

-- | parenthesised class assertion
ParenA :: l -> Asst l -> Asst l

-- | Context Wildcard
WildCardA :: l -> Maybe (Name l) -> Asst l

-- | A type qualified with a context. An unqualified type has an empty
--   context.
data Type l

-- | qualified type
TyForall :: l -> Maybe [TyVarBind l] -> Maybe (Context l) -> Type l -> Type l

-- | <tt>*</tt>, the type of types
TyStar :: l -> Type l

-- | function type
TyFun :: l -> Type l -> Type l -> Type l

-- | tuple type, possibly boxed
TyTuple :: l -> Boxed -> [Type l] -> Type l

-- | unboxed tuple type
TyUnboxedSum :: l -> [Type l] -> Type l

-- | list syntax, e.g. [a], as opposed to [] a
TyList :: l -> Type l -> Type l

-- | parallel array syntax, e.g. [:a:]
TyParArray :: l -> Type l -> Type l

-- | application of a type constructor
TyApp :: l -> Type l -> Type l -> Type l

-- | type variable
TyVar :: l -> Name l -> Type l

-- | named type or type constructor
TyCon :: l -> QName l -> Type l

-- | type surrounded by parentheses
TyParen :: l -> Type l -> Type l

-- | infix type constructor
TyInfix :: l -> Type l -> MaybePromotedName l -> Type l -> Type l

-- | type with explicit kind signature
TyKind :: l -> Type l -> Kind l -> Type l

-- | <tt>'K</tt>, a promoted data type (-XDataKinds).
TyPromoted :: l -> Promoted l -> Type l

-- | type equality predicate enabled by ConstraintKinds
TyEquals :: l -> Type l -> Type l -> Type l

-- | template haskell splice type
TySplice :: l -> Splice l -> Type l

-- | Strict type marked with "<tt>!</tt>" or type marked with UNPACK
--   pragma.
TyBang :: l -> BangType l -> Unpackedness l -> Type l -> Type l

-- | Either an anonymous of named type wildcard
TyWildCard :: l -> Maybe (Name l) -> Type l

-- | <pre>
--   [$<i>name</i>| <i>string</i> |]
--   </pre>
TyQuasiQuote :: l -> String -> String -> Type l

-- | Flag denoting whether a tuple is boxed or unboxed.
data Boxed
Boxed :: Boxed
Unboxed :: Boxed

-- | An explicit kind annotation.
type Kind = Type

-- | A type variable declaration, optionally with an explicit kind
--   annotation.
data TyVarBind l

-- | variable binding with kind annotation
KindedVar :: l -> Name l -> Kind l -> TyVarBind l

-- | ordinary variable binding
UnkindedVar :: l -> Name l -> TyVarBind l

-- | Bools here are True if there was a leading quote which may be left
--   out. For example <tt>'[k1,k2]</tt> means the same thing as
--   <tt>[k1,k2]</tt>.
data Promoted l

-- | parsed value and raw string
PromotedInteger :: l -> Integer -> String -> Promoted l

-- | parsed value and raw string
PromotedString :: l -> String -> String -> Promoted l
PromotedCon :: l -> Bool -> QName l -> Promoted l
PromotedList :: l -> Bool -> [Type l] -> Promoted l
PromotedTuple :: l -> [Type l] -> Promoted l
PromotedUnit :: l -> Promoted l

-- | A type equation as found in closed type families.
data TypeEqn l
TypeEqn :: l -> Type l -> Type l -> TypeEqn l

-- | Haskell expressions.
data Exp l

-- | variable
Var :: l -> QName l -> Exp l

-- | Overloaded label #foo
OverloadedLabel :: l -> String -> Exp l

-- | implicit parameter variable
IPVar :: l -> IPName l -> Exp l

-- | data constructor
Con :: l -> QName l -> Exp l

-- | literal constant
Lit :: l -> Literal l -> Exp l

-- | infix application
InfixApp :: l -> Exp l -> QOp l -> Exp l -> Exp l

-- | ordinary application
App :: l -> Exp l -> Exp l -> Exp l

-- | negation expression <tt>-<i>exp</i></tt> (unary minus)
NegApp :: l -> Exp l -> Exp l

-- | lambda expression
Lambda :: l -> [Pat l] -> Exp l -> Exp l

-- | local declarations with <tt>let</tt> ... <tt>in</tt> ...
Let :: l -> Binds l -> Exp l -> Exp l

-- | <tt>if</tt> <i>exp</i> <tt>then</tt> <i>exp</i> <tt>else</tt>
--   <i>exp</i>
If :: l -> Exp l -> Exp l -> Exp l -> Exp l

-- | <tt>if</tt> <tt>|</tt> <i>stmts</i> <tt>-&gt;</tt> <i>exp</i> ...
MultiIf :: l -> [GuardedRhs l] -> Exp l

-- | <tt>case</tt> <i>exp</i> <tt>of</tt> <i>alts</i>
Case :: l -> Exp l -> [Alt l] -> Exp l

-- | <tt>do</tt>-expression: the last statement in the list should be an
--   expression.
Do :: l -> [Stmt l] -> Exp l

-- | <tt>mdo</tt>-expression
MDo :: l -> [Stmt l] -> Exp l

-- | tuple expression
Tuple :: l -> Boxed -> [Exp l] -> Exp l

-- | unboxed sum
UnboxedSum :: l -> Int -> Int -> Exp l -> Exp l

-- | tuple section expression, e.g. <tt>(,,3)</tt>
TupleSection :: l -> Boxed -> [Maybe (Exp l)] -> Exp l

-- | list expression
List :: l -> [Exp l] -> Exp l

-- | parallel array expression
ParArray :: l -> [Exp l] -> Exp l

-- | parenthesised expression
Paren :: l -> Exp l -> Exp l

-- | left section <tt>(</tt><i>exp</i> <i>qop</i><tt>)</tt>
LeftSection :: l -> Exp l -> QOp l -> Exp l

-- | right section <tt>(</tt><i>qop</i> <i>exp</i><tt>)</tt>
RightSection :: l -> QOp l -> Exp l -> Exp l

-- | record construction expression
RecConstr :: l -> QName l -> [FieldUpdate l] -> Exp l

-- | record update expression
RecUpdate :: l -> Exp l -> [FieldUpdate l] -> Exp l

-- | unbounded arithmetic sequence, incrementing by 1: <tt>[from ..]</tt>
EnumFrom :: l -> Exp l -> Exp l

-- | bounded arithmetic sequence, incrementing by 1 <tt>[from .. to]</tt>
EnumFromTo :: l -> Exp l -> Exp l -> Exp l

-- | unbounded arithmetic sequence, with first two elements given
--   <tt>[from, then ..]</tt>
EnumFromThen :: l -> Exp l -> Exp l -> Exp l

-- | bounded arithmetic sequence, with first two elements given <tt>[from,
--   then .. to]</tt>
EnumFromThenTo :: l -> Exp l -> Exp l -> Exp l -> Exp l

-- | Parallel array bounded arithmetic sequence, incrementing by 1
--   <tt>[:from .. to:]</tt>
ParArrayFromTo :: l -> Exp l -> Exp l -> Exp l

-- | bounded arithmetic sequence, with first two elements given <tt>[:from,
--   then .. to:]</tt>
ParArrayFromThenTo :: l -> Exp l -> Exp l -> Exp l -> Exp l

-- | ordinary list comprehension
ListComp :: l -> Exp l -> [QualStmt l] -> Exp l

-- | parallel list comprehension
ParComp :: l -> Exp l -> [[QualStmt l]] -> Exp l

-- | parallel array comprehension
ParArrayComp :: l -> Exp l -> [[QualStmt l]] -> Exp l

-- | expression with explicit type signature
ExpTypeSig :: l -> Exp l -> Type l -> Exp l

-- | <tt>'x</tt> for template haskell reifying of expressions
VarQuote :: l -> QName l -> Exp l

-- | <tt>''T</tt> for template haskell reifying of types
TypQuote :: l -> QName l -> Exp l

-- | template haskell bracket expression
BracketExp :: l -> Bracket l -> Exp l

-- | template haskell splice expression
SpliceExp :: l -> Splice l -> Exp l

-- | quasi-quotaion: <tt>[$<i>name</i>| <i>string</i> |]</tt>
QuasiQuote :: l -> String -> String -> Exp l

-- | Visible type application
TypeApp :: l -> Type l -> Exp l

-- | xml element, with attributes and children
XTag :: l -> XName l -> [XAttr l] -> Maybe (Exp l) -> [Exp l] -> Exp l

-- | empty xml element, with attributes
XETag :: l -> XName l -> [XAttr l] -> Maybe (Exp l) -> Exp l

-- | PCDATA child element
XPcdata :: l -> String -> Exp l

-- | escaped haskell expression inside xml
XExpTag :: l -> Exp l -> Exp l

-- | children of an xml element
XChildTag :: l -> [Exp l] -> Exp l

-- | CORE pragma
CorePragma :: l -> String -> Exp l -> Exp l

-- | SCC pragma
SCCPragma :: l -> String -> Exp l -> Exp l

-- | GENERATED pragma
GenPragma :: l -> String -> (Int, Int) -> (Int, Int) -> Exp l -> Exp l

-- | arrows proc: <tt>proc</tt> <i>pat</i> <tt>-&gt;</tt> <i>exp</i>
Proc :: l -> Pat l -> Exp l -> Exp l

-- | arrow application (from left): <i>exp</i> <tt>-&lt;</tt> <i>exp</i>
LeftArrApp :: l -> Exp l -> Exp l -> Exp l

-- | arrow application (from right): <i>exp</i> <tt>&gt;-</tt> <i>exp</i>
RightArrApp :: l -> Exp l -> Exp l -> Exp l

-- | higher-order arrow application (from left): <i>exp</i>
--   <tt>-&lt;&lt;</tt> <i>exp</i>
LeftArrHighApp :: l -> Exp l -> Exp l -> Exp l

-- | higher-order arrow application (from right): <i>exp</i>
--   <tt>&gt;&gt;-</tt> <i>exp</i>
RightArrHighApp :: l -> Exp l -> Exp l -> Exp l

-- | <tt>case</tt> <i>alts</i>
LCase :: l -> [Alt l] -> Exp l

-- | A statement, representing both a <i>stmt</i> in a
--   <tt>do</tt>-expression, an ordinary <i>qual</i> in a list
--   comprehension, as well as a <i>stmt</i> in a pattern guard.
data Stmt l

-- | a generator: <i>pat</i> <tt>&lt;-</tt> <i>exp</i>
Generator :: l -> Pat l -> Exp l -> Stmt l

-- | an <i>exp</i> by itself: in a <tt>do</tt>-expression, an action whose
--   result is discarded; in a list comprehension and pattern guard, a
--   guard expression
Qualifier :: l -> Exp l -> Stmt l

-- | local bindings
LetStmt :: l -> Binds l -> Stmt l

-- | a recursive binding group for arrows
RecStmt :: l -> [Stmt l] -> Stmt l

-- | A general <i>transqual</i> in a list comprehension, which could
--   potentially be a transform of the kind enabled by TransformListComp.
data QualStmt l

-- | an ordinary statement
QualStmt :: l -> Stmt l -> QualStmt l

-- | <tt>then</tt> <i>exp</i>
ThenTrans :: l -> Exp l -> QualStmt l

-- | <tt>then</tt> <i>exp</i> <tt>by</tt> <i>exp</i>
ThenBy :: l -> Exp l -> Exp l -> QualStmt l

-- | <tt>then</tt> <tt>group</tt> <tt>by</tt> <i>exp</i>
GroupBy :: l -> Exp l -> QualStmt l

-- | <tt>then</tt> <tt>group</tt> <tt>using</tt> <i>exp</i>
GroupUsing :: l -> Exp l -> QualStmt l

-- | <tt>then</tt> <tt>group</tt> <tt>by</tt> <i>exp</i> <tt>using</tt>
--   <i>exp</i>
GroupByUsing :: l -> Exp l -> Exp l -> QualStmt l

-- | An <i>fbind</i> in a labeled construction or update expression.
data FieldUpdate l

-- | ordinary label-expresion pair
FieldUpdate :: l -> QName l -> Exp l -> FieldUpdate l

-- | record field pun
FieldPun :: l -> QName l -> FieldUpdate l

-- | record field wildcard
FieldWildcard :: l -> FieldUpdate l

-- | An <i>alt</i> alternative in a <tt>case</tt> expression.
data Alt l
Alt :: l -> Pat l -> Rhs l -> Maybe (Binds l) -> Alt l

-- | An xml attribute, which is a name-expression pair.
data XAttr l
XAttr :: l -> XName l -> Exp l -> XAttr l

-- | A pattern, to be matched against a value.
data Pat l

-- | variable
PVar :: l -> Name l -> Pat l

-- | literal constant
PLit :: l -> Sign l -> Literal l -> Pat l

-- | n+k pattern
PNPlusK :: l -> Name l -> Integer -> Pat l

-- | pattern with an infix data constructor
PInfixApp :: l -> Pat l -> QName l -> Pat l -> Pat l

-- | data constructor and argument patterns
PApp :: l -> QName l -> [Pat l] -> Pat l

-- | tuple pattern
PTuple :: l -> Boxed -> [Pat l] -> Pat l

-- | unboxed sum
PUnboxedSum :: l -> Int -> Int -> Pat l -> Pat l

-- | list pattern
PList :: l -> [Pat l] -> Pat l

-- | parenthesized pattern
PParen :: l -> Pat l -> Pat l

-- | labelled pattern, record style
PRec :: l -> QName l -> [PatField l] -> Pat l

-- | <tt>@</tt>-pattern
PAsPat :: l -> Name l -> Pat l -> Pat l

-- | wildcard pattern: <tt>_</tt>
PWildCard :: l -> Pat l

-- | irrefutable pattern: <tt>~<i>pat</i></tt>
PIrrPat :: l -> Pat l -> Pat l

-- | pattern with type signature
PatTypeSig :: l -> Pat l -> Type l -> Pat l

-- | view patterns of the form <tt>(<i>exp</i> -&gt; <i>pat</i>)</tt>
PViewPat :: l -> Exp l -> Pat l -> Pat l

-- | regular list pattern
PRPat :: l -> [RPat l] -> Pat l

-- | XML element pattern
PXTag :: l -> XName l -> [PXAttr l] -> Maybe (Pat l) -> [Pat l] -> Pat l

-- | XML singleton element pattern
PXETag :: l -> XName l -> [PXAttr l] -> Maybe (Pat l) -> Pat l

-- | XML PCDATA pattern
PXPcdata :: l -> String -> Pat l

-- | XML embedded pattern
PXPatTag :: l -> Pat l -> Pat l

-- | XML regular list pattern
PXRPats :: l -> [RPat l] -> Pat l

-- | template haskell splice pattern
PSplice :: l -> Splice l -> Pat l

-- | quasi quote pattern: <tt>[$<i>name</i>| <i>string</i> |]</tt>
PQuasiQuote :: l -> String -> String -> Pat l

-- | strict (bang) pattern: <tt>f !x = ...</tt>
PBangPat :: l -> Pat l -> Pat l

-- | An <i>fpat</i> in a labeled record pattern.
data PatField l

-- | ordinary label-pattern pair
PFieldPat :: l -> QName l -> Pat l -> PatField l

-- | record field pun
PFieldPun :: l -> QName l -> PatField l

-- | record field wildcard
PFieldWildcard :: l -> PatField l

-- | An XML attribute in a pattern.
data PXAttr l
PXAttr :: l -> XName l -> Pat l -> PXAttr l

-- | An entity in a regular pattern.
data RPat l

-- | operator pattern, e.g. pat*
RPOp :: l -> RPat l -> RPatOp l -> RPat l

-- | choice pattern, e.g. (1 | 2)
RPEither :: l -> RPat l -> RPat l -> RPat l

-- | sequence pattern, e.g. (| 1, 2, 3 |)
RPSeq :: l -> [RPat l] -> RPat l

-- | guarded pattern, e.g. (| p | p &lt; 3 |)
RPGuard :: l -> Pat l -> [Stmt l] -> RPat l

-- | non-linear variable binding, e.g. (foo@:(1 | 2))*
RPCAs :: l -> Name l -> RPat l -> RPat l

-- | linear variable binding, e.g. foo@(1 | 2)
RPAs :: l -> Name l -> RPat l -> RPat l

-- | parenthesised pattern, e.g. (2*)
RPParen :: l -> RPat l -> RPat l

-- | an ordinary pattern
RPPat :: l -> Pat l -> RPat l

-- | A regular pattern operator.
data RPatOp l

-- | <tt>*</tt> = 0 or more
RPStar :: l -> RPatOp l

-- | <tt>*!</tt> = 0 or more, greedy
RPStarG :: l -> RPatOp l

-- | <tt>+</tt> = 1 or more
RPPlus :: l -> RPatOp l

-- | <tt>+!</tt> = 1 or more, greedy
RPPlusG :: l -> RPatOp l

-- | <tt>?</tt> = 0 or 1
RPOpt :: l -> RPatOp l

-- | <tt>?!</tt> = 0 or 1, greedy
RPOptG :: l -> RPatOp l

-- | <i>literal</i> Values of this type hold the abstract value of the
--   literal, along with the precise string representation used. For
--   example, <tt>10</tt>, <tt>0o12</tt> and <tt>0xa</tt> have the same
--   value representation, but each carry a different string
--   representation.
data Literal l

-- | character literal
Char :: l -> Char -> String -> Literal l

-- | string literal
String :: l -> String -> String -> Literal l

-- | integer literal
Int :: l -> Integer -> String -> Literal l

-- | floating point literal
Frac :: l -> Rational -> String -> Literal l

-- | unboxed integer literal
PrimInt :: l -> Integer -> String -> Literal l

-- | unboxed word literal
PrimWord :: l -> Integer -> String -> Literal l

-- | unboxed float literal
PrimFloat :: l -> Rational -> String -> Literal l

-- | unboxed double literal
PrimDouble :: l -> Rational -> String -> Literal l

-- | unboxed character literal
PrimChar :: l -> Char -> String -> Literal l

-- | unboxed string literal
PrimString :: l -> String -> String -> Literal l

-- | An indication whether a literal pattern has been negated or not.
data Sign l
Signless :: l -> Sign l
Negative :: l -> Sign l

-- | The name of a Haskell module.
data ModuleName l
ModuleName :: l -> String -> ModuleName l

-- | This type is used to represent qualified variables, and also qualified
--   constructors.
data QName l

-- | name qualified with a module name
Qual :: l -> ModuleName l -> Name l -> QName l

-- | unqualified local name
UnQual :: l -> Name l -> QName l

-- | built-in constructor with special syntax
Special :: l -> SpecialCon l -> QName l

-- | This type is used to represent variables, and also constructors.
data Name l

-- | <i>varid</i> or <i>conid</i>.
Ident :: l -> String -> Name l

-- | <i>varsym</i> or <i>consym</i>
Symbol :: l -> String -> Name l

-- | Possibly qualified infix operators (<i>qop</i>), appearing in
--   expressions.
data QOp l

-- | variable operator (<i>qvarop</i>)
QVarOp :: l -> QName l -> QOp l

-- | constructor operator (<i>qconop</i>)
QConOp :: l -> QName l -> QOp l

-- | Operators appearing in <tt>infix</tt> declarations are never
--   qualified.
data Op l

-- | variable operator (<i>varop</i>)
VarOp :: l -> Name l -> Op l

-- | constructor operator (<i>conop</i>)
ConOp :: l -> Name l -> Op l

-- | Constructors with special syntax. These names are never qualified, and
--   always refer to builtin type or data constructors.
data SpecialCon l

-- | unit type and data constructor <tt>()</tt>
UnitCon :: l -> SpecialCon l

-- | list type and data constructor <tt>[]</tt>
ListCon :: l -> SpecialCon l

-- | function type constructor <tt>-&gt;</tt>
FunCon :: l -> SpecialCon l

-- | <i>n</i>-ary tuple type and data constructors <tt>(,)</tt> etc,
--   possibly boxed <tt>(#,#)</tt>
TupleCon :: l -> Boxed -> Int -> SpecialCon l

-- | list data constructor <tt>(:)</tt>
Cons :: l -> SpecialCon l

-- | unboxed singleton tuple constructor <tt>(# #)</tt>
UnboxedSingleCon :: l -> SpecialCon l

-- | An expression hole _
ExprHole :: l -> SpecialCon l

-- | A name (<i>cname</i>) of a component of a class or data type in an
--   <tt>import</tt> or export specification.
data CName l

-- | name of a method or field
VarName :: l -> Name l -> CName l

-- | name of a data constructor
ConName :: l -> Name l -> CName l

-- | An implicit parameter name.
data IPName l

-- | ?<i>ident</i>, non-linear implicit parameter
IPDup :: l -> String -> IPName l

-- | %<i>ident</i>, linear implicit parameter
IPLin :: l -> String -> IPName l

-- | The name of an xml element or attribute, possibly qualified with a
--   namespace.
data XName l
XName :: l -> String -> XName l
XDomName :: l -> String -> String -> XName l
data Role l
Nominal :: l -> Role l
Representational :: l -> Role l
Phantom :: l -> Role l
RoleWildcard :: l -> Role l
data MaybePromotedName l
PromotedName :: l -> QName l -> MaybePromotedName l
UnpromotedName :: l -> QName l -> MaybePromotedName l

-- | A template haskell bracket expression.
data Bracket l

-- | expression bracket: <tt>[| ... |]</tt>
ExpBracket :: l -> Exp l -> Bracket l

-- | pattern bracket: <tt>[p| ... |]</tt>
PatBracket :: l -> Pat l -> Bracket l

-- | type bracket: <tt>[t| ... |]</tt>
TypeBracket :: l -> Type l -> Bracket l

-- | declaration bracket: <tt>[d| ... |]</tt>
DeclBracket :: l -> [Decl l] -> Bracket l

-- | A template haskell splice expression
data Splice l

-- | variable splice: <tt>$var</tt>
IdSplice :: l -> String -> Splice l

-- | parenthesised expression splice: <tt>$(<i>exp</i>)</tt>
ParenSplice :: l -> Exp l -> Splice l

-- | The safety of a foreign function call.
data Safety l

-- | unsafe
PlayRisky :: l -> Safety l

-- | safe (<a>False</a>) or threadsafe (<a>True</a>)
PlaySafe :: l -> Bool -> Safety l

-- | interruptible
PlayInterruptible :: l -> Safety l

-- | The calling convention of a foreign function call.
data CallConv l
StdCall :: l -> CallConv l
CCall :: l -> CallConv l
CPlusPlus :: l -> CallConv l
DotNet :: l -> CallConv l
Jvm :: l -> CallConv l
Js :: l -> CallConv l
JavaScript :: l -> CallConv l
CApi :: l -> CallConv l

-- | A top level options pragma, preceding the module header.
data ModulePragma l

-- | LANGUAGE pragma
LanguagePragma :: l -> [Name l] -> ModulePragma l

-- | OPTIONS pragma, possibly qualified with a tool, e.g. OPTIONS_GHC
OptionsPragma :: l -> Maybe Tool -> String -> ModulePragma l

-- | ANN pragma with module scope
AnnModulePragma :: l -> Annotation l -> ModulePragma l

-- | Recognised tools for OPTIONS pragmas.
data Tool
GHC :: Tool
HUGS :: Tool
NHC98 :: Tool
YHC :: Tool
HADDOCK :: Tool
UnknownTool :: String -> Tool

-- | Recognised overlaps for overlap pragmas.
data Overlap l

-- | NO_OVERLAP pragma
NoOverlap :: l -> Overlap l

-- | OVERLAP pragma
Overlap :: l -> Overlap l
Overlapping :: l -> Overlap l
Overlaps :: l -> Overlap l
Overlappable :: l -> Overlap l

-- | INCOHERENT pragma
Incoherent :: l -> Overlap l

-- | The body of a RULES pragma.
data Rule l
Rule :: l -> String -> Maybe (Activation l) -> Maybe [RuleVar l] -> Exp l -> Exp l -> Rule l

-- | Variables used in a RULES pragma, optionally annotated with types
data RuleVar l
RuleVar :: l -> Name l -> RuleVar l
TypedRuleVar :: l -> Name l -> Type l -> RuleVar l

-- | Activation clause of a RULES pragma.
data Activation l
ActiveFrom :: l -> Int -> Activation l
ActiveUntil :: l -> Int -> Activation l

-- | An annotation through an ANN pragma.
data Annotation l

-- | An annotation for a declared name.
Ann :: l -> Name l -> Exp l -> Annotation l

-- | An annotation for a declared type.
TypeAnn :: l -> Name l -> Exp l -> Annotation l

-- | An annotation for the defining module.
ModuleAnn :: l -> Exp l -> Annotation l

-- | A boolean formula for MINIMAL pragmas.
data BooleanFormula l

-- | A variable.
VarFormula :: l -> Name l -> BooleanFormula l

-- | And boolean formulas.
AndFormula :: l -> [BooleanFormula l] -> BooleanFormula l

-- | Or boolean formulas.
OrFormula :: l -> [BooleanFormula l] -> BooleanFormula l

-- | Parenthesized boolean formulas.
ParenFormula :: l -> BooleanFormula l -> BooleanFormula l
prelude_mod :: l -> ModuleName l
main_mod :: l -> ModuleName l
main_name :: l -> Name l
unit_con_name :: l -> QName l
tuple_con_name :: l -> Boxed -> Int -> QName l
list_con_name :: l -> QName l
list_cons_name :: l -> QName l
unboxed_singleton_con_name :: l -> QName l
unit_con :: l -> Exp l
tuple_con :: l -> Boxed -> Int -> Exp l
unboxed_singleton_con :: l -> Exp l
as_name :: l -> Name l
qualified_name :: l -> Name l
hiding_name :: l -> Name l
minus_name :: l -> Name l
bang_name :: l -> Name l
dot_name :: l -> Name l
star_name :: l -> Name l
export_name :: l -> Name l
safe_name :: l -> Name l
unsafe_name :: l -> Name l
interruptible_name :: l -> Name l
threadsafe_name :: l -> Name l
stdcall_name :: l -> Name l
ccall_name :: l -> Name l
cplusplus_name :: l -> Name l
dotnet_name :: l -> Name l
jvm_name :: l -> Name l
js_name :: l -> Name l
javascript_name :: l -> Name l
capi_name :: l -> Name l
forall_name :: l -> Name l
family_name :: l -> Name l
role_name :: l -> Name l
hole_name :: l -> QName l
stock_name :: l -> Name l
anyclass_name :: l -> Name l
via_name :: l -> Name l
unit_tycon_name :: l -> QName l
fun_tycon_name :: l -> QName l
list_tycon_name :: l -> QName l
tuple_tycon_name :: l -> Boxed -> Int -> QName l
unboxed_singleton_tycon_name :: l -> QName l
unit_tycon :: l -> Type l
fun_tycon :: l -> Type l
list_tycon :: l -> Type l
tuple_tycon :: l -> Boxed -> Int -> Type l
unboxed_singleton_tycon :: l -> Type l

-- | AST nodes are annotated, and this class allows manipulation of the
--   annotations.
class Functor ast => Annotated ast

-- | Retrieve the annotation of an AST node.
ann :: Annotated ast => ast l -> l

-- | Change the annotation of an AST node. Note that only the annotation of
--   the node itself is affected, and not the annotations of any child
--   nodes. if all nodes in the AST tree are to be affected, use
--   <a>fmap</a>.
amap :: Annotated ast => (l -> l) -> ast l -> ast l

-- | Test if two AST elements are equal modulo annotations.
(=~=) :: (Annotated a, Eq (a ())) => a l1 -> a l2 -> Bool
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Module l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Module
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Module
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Module
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Module l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Module l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Module l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Module l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.ModulePragma l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.ModulePragma
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.ModulePragma
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.ModulePragma
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.ModulePragma l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.ModulePragma l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.ModulePragma l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.ModulePragma l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.PXAttr l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.PXAttr
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.PXAttr
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.PXAttr
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.PXAttr l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.PXAttr l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.PXAttr l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.PXAttr l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.XAttr l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.XAttr
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.XAttr
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.XAttr
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.XAttr l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.XAttr l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.XAttr l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.XAttr l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.PatternSynDirection l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.PatternSynDirection
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.PatternSynDirection
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.PatternSynDirection
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.PatternSynDirection l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.PatternSynDirection l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.PatternSynDirection l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.PatternSynDirection l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Annotation l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Annotation
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Annotation
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Annotation
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Annotation l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Annotation l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Annotation l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Annotation l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.IPBind l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.IPBind
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.IPBind
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.IPBind
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.IPBind l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.IPBind l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.IPBind l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.IPBind l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Binds l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Binds
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Binds
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Binds
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Binds l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Binds l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Binds l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Binds l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Match l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Match
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Match
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Match
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Match l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Match l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Match l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Match l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.TypeEqn l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.TypeEqn
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.TypeEqn
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.TypeEqn
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.TypeEqn l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.TypeEqn l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.TypeEqn l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.TypeEqn l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.ResultSig l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.ResultSig
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.ResultSig
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.ResultSig
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.ResultSig l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.ResultSig l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.ResultSig l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.ResultSig l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.DeclHead l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.DeclHead
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.DeclHead
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.DeclHead
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.DeclHead l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.DeclHead l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.DeclHead l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.DeclHead l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.ClassDecl l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.ClassDecl
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.ClassDecl
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.ClassDecl
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.ClassDecl l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.ClassDecl l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.ClassDecl l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.ClassDecl l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.InstHead l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.InstHead
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.InstHead
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.InstHead
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.InstHead l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.InstHead l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.InstHead l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.InstHead l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.InstRule l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.InstRule
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.InstRule
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.InstRule
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.InstRule l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.InstRule l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.InstRule l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.InstRule l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.DerivStrategy l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.DerivStrategy
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.DerivStrategy
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.DerivStrategy
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.DerivStrategy l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.DerivStrategy l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.DerivStrategy l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.DerivStrategy l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Deriving l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Deriving
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Deriving
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Deriving
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Deriving l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Deriving l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Deriving l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Deriving l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.ConDecl l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.ConDecl
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.ConDecl
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.ConDecl
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.ConDecl l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.ConDecl l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.ConDecl l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.ConDecl l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.QualConDecl l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.QualConDecl
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.QualConDecl
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.QualConDecl
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.QualConDecl l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.QualConDecl l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.QualConDecl l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.QualConDecl l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.FieldDecl l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.FieldDecl
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.FieldDecl
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.FieldDecl
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.FieldDecl l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.FieldDecl l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.FieldDecl l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.FieldDecl l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.GadtDecl l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.GadtDecl
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.GadtDecl
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.GadtDecl
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.GadtDecl l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.GadtDecl l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.GadtDecl l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.GadtDecl l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.InstDecl l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.InstDecl
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.InstDecl
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.InstDecl
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.InstDecl l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.InstDecl l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.InstDecl l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.InstDecl l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.GuardedRhs l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.GuardedRhs
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.GuardedRhs
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.GuardedRhs
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.GuardedRhs l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.GuardedRhs l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.GuardedRhs l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.GuardedRhs l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Rhs l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Rhs
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Rhs
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Rhs
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Rhs l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Rhs l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Rhs l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Rhs l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.RuleVar l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.RuleVar
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.RuleVar
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.RuleVar
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.RuleVar l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.RuleVar l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.RuleVar l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.RuleVar l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Rule l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Rule
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Rule
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Rule
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Rule l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Rule l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Rule l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Rule l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Decl l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Decl
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Decl
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Decl
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Decl l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Decl l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Decl l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Decl l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Promoted l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Promoted
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Promoted
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Promoted
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Promoted l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Promoted l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Promoted l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Promoted l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.TyVarBind l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.TyVarBind
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.TyVarBind
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.TyVarBind
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.TyVarBind l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.TyVarBind l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.TyVarBind l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.TyVarBind l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Asst l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Asst
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Asst
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Asst
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Asst l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Asst l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Asst l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Asst l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Context l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Context
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Context
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Context
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Context l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Context l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Context l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Context l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Type l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Type
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Type
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Type
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Type l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Type l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Type l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Type l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Bracket l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Bracket
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Bracket
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Bracket
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Bracket l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Bracket l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Bracket l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Bracket l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Splice l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Splice
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Splice
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Splice
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Splice l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Splice l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Splice l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Splice l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.QualStmt l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.QualStmt
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.QualStmt
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.QualStmt
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.QualStmt l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.QualStmt l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.QualStmt l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.QualStmt l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.FieldUpdate l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.FieldUpdate
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.FieldUpdate
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.FieldUpdate
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.FieldUpdate l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.FieldUpdate l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.FieldUpdate l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.FieldUpdate l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Exp l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Exp
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Exp
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Exp
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Exp l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Exp l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Exp l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Exp l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Stmt l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Stmt
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Stmt
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Stmt
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Stmt l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Stmt l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Stmt l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Stmt l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.RPat l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.RPat
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.RPat
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.RPat
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.RPat l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.RPat l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.RPat l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.RPat l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.PatField l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.PatField
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.PatField
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.PatField
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.PatField l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.PatField l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.PatField l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.PatField l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Pat l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Pat
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Pat
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Pat
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Pat l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Pat l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Pat l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Pat l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Alt l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Alt
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Alt
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Alt
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Alt l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Alt l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Alt l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Alt l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.RPatOp l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.RPatOp
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.RPatOp
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.RPatOp
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.RPatOp l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.RPatOp l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.RPatOp l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.RPatOp l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.ModuleHead l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.ModuleHead
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.ModuleHead
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.ModuleHead
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.ModuleHead l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.ModuleHead l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.ModuleHead l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.ModuleHead l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.WarningText l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.WarningText
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.WarningText
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.WarningText
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.WarningText l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.WarningText l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.WarningText l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.WarningText l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Activation l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Activation
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Activation
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Activation
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Activation l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Activation l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Activation l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Activation l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Overlap l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Overlap
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Overlap
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Overlap
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Overlap l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Overlap l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Overlap l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Overlap l)
instance GHC.Generics.Generic Language.Haskell.Exts.Syntax.Tool
instance Data.Data.Data Language.Haskell.Exts.Syntax.Tool
instance GHC.Show.Show Language.Haskell.Exts.Syntax.Tool
instance GHC.Classes.Ord Language.Haskell.Exts.Syntax.Tool
instance GHC.Classes.Eq Language.Haskell.Exts.Syntax.Tool
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.CallConv l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.CallConv
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.CallConv
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.CallConv
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.CallConv l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.CallConv l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.CallConv l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.CallConv l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Safety l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Safety
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Safety
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Safety
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Safety l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Safety l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Safety l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Safety l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.XName l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.XName
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.XName
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.XName
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.XName l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.XName l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.XName l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.XName l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Sign l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Sign
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Sign
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Sign
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Sign l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Sign l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Sign l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Sign l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Literal l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Literal
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Literal
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Literal
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Literal l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Literal l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Literal l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Literal l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.FunDep l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.FunDep
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.FunDep
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.FunDep
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.FunDep l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.FunDep l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.FunDep l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.FunDep l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.QOp l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.QOp
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.QOp
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.QOp
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.QOp l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.QOp l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.QOp l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.QOp l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.ExportSpecList l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.ExportSpecList
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.ExportSpecList
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.ExportSpecList
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.ExportSpecList l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.ExportSpecList l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.ExportSpecList l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.ExportSpecList l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.ExportSpec l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.ExportSpec
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.ExportSpec
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.ExportSpec
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.ExportSpec l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.ExportSpec l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.ExportSpec l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.ExportSpec l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.MaybePromotedName l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.MaybePromotedName
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.MaybePromotedName
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.MaybePromotedName
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.MaybePromotedName l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.MaybePromotedName l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.MaybePromotedName l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.MaybePromotedName l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.QName l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.QName
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.QName
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.QName
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.QName l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.QName l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.QName l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.QName l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.SpecialCon l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.SpecialCon
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.SpecialCon
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.SpecialCon
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.SpecialCon l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.SpecialCon l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.SpecialCon l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.SpecialCon l)
instance GHC.Generics.Generic Language.Haskell.Exts.Syntax.Boxed
instance Data.Data.Data Language.Haskell.Exts.Syntax.Boxed
instance GHC.Show.Show Language.Haskell.Exts.Syntax.Boxed
instance GHC.Classes.Ord Language.Haskell.Exts.Syntax.Boxed
instance GHC.Classes.Eq Language.Haskell.Exts.Syntax.Boxed
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Unpackedness l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Unpackedness
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Unpackedness
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Unpackedness
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Unpackedness l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Unpackedness l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Unpackedness l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Unpackedness l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.BangType l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.BangType
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.BangType
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.BangType
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.BangType l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.BangType l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.BangType l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.BangType l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.InjectivityInfo l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.InjectivityInfo
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.InjectivityInfo
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.InjectivityInfo
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.InjectivityInfo l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.InjectivityInfo l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.InjectivityInfo l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.InjectivityInfo l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.DataOrNew l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.DataOrNew
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.DataOrNew
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.DataOrNew
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.DataOrNew l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.DataOrNew l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.DataOrNew l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.DataOrNew l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Role l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Role
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Role
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Role
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Role l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Role l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Role l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Role l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.BooleanFormula l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.BooleanFormula
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.BooleanFormula
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.BooleanFormula
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.BooleanFormula l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.BooleanFormula l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.BooleanFormula l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.BooleanFormula l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Assoc l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Assoc
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Assoc
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Assoc
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Assoc l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Assoc l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Assoc l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Assoc l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.ImportDecl l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.ImportDecl
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.ImportDecl
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.ImportDecl
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.ImportDecl l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.ImportDecl l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.ImportDecl l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.ImportDecl l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.ImportSpecList l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.ImportSpecList
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.ImportSpecList
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.ImportSpecList
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.ImportSpecList l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.ImportSpecList l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.ImportSpecList l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.ImportSpecList l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.ImportSpec l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.ImportSpec
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.ImportSpec
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.ImportSpec
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.ImportSpec l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.ImportSpec l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.ImportSpec l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.ImportSpec l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Namespace l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Namespace
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Namespace
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Namespace
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Namespace l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Namespace l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Namespace l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Namespace l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.EWildcard l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.EWildcard
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.EWildcard
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.EWildcard
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.EWildcard l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.EWildcard l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.EWildcard l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.EWildcard l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.CName l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.CName
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.CName
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.CName
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.CName l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.CName l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.CName l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.CName l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Op l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Op
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Op
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Op
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Op l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Op l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Op l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Op l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.IPName l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.IPName
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.IPName
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.IPName
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.IPName l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.IPName l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.IPName l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.IPName l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.Name l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.Name
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.Name
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.Name
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.Name l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.Name l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.Name l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.Name l)
instance GHC.Generics.Generic (Language.Haskell.Exts.Syntax.ModuleName l)
instance GHC.Base.Functor Language.Haskell.Exts.Syntax.ModuleName
instance Data.Traversable.Traversable Language.Haskell.Exts.Syntax.ModuleName
instance Data.Foldable.Foldable Language.Haskell.Exts.Syntax.ModuleName
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Syntax.ModuleName l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Syntax.ModuleName l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Syntax.ModuleName l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Syntax.ModuleName l)
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.ModuleName
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.SpecialCon
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.QName
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Name
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.IPName
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.QOp
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Op
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.CName
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Module
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.ModuleHead
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.ExportSpecList
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.ExportSpec
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.EWildcard
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Namespace
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.ImportDecl
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.ImportSpecList
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.ImportSpec
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Assoc
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Deriving
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.DerivStrategy
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.TypeEqn
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.InjectivityInfo
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.ResultSig
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Decl
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Role
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Annotation
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.BooleanFormula
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.DataOrNew
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.DeclHead
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.InstRule
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.InstHead
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Binds
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.IPBind
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Match
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.QualConDecl
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.ConDecl
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.FieldDecl
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.GadtDecl
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.ClassDecl
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.InstDecl
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.BangType
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Unpackedness
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Rhs
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.GuardedRhs
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Type
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.MaybePromotedName
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.TyVarBind
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.FunDep
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Context
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Asst
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Literal
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Sign
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Exp
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.XName
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.XAttr
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Bracket
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Splice
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Safety
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.CallConv
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.ModulePragma
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Overlap
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Activation
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Rule
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.RuleVar
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.WarningText
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Pat
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.PXAttr
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.RPatOp
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.RPat
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.PatField
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Stmt
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.QualStmt
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.FieldUpdate
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Alt
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.Syntax.Promoted


-- | Pretty printer for Haskell with extensions.
module Language.Haskell.Exts.Pretty

-- | Things that can be pretty-printed, including all the syntactic objects
--   in <a>Language.Haskell.Exts.Syntax</a>.
class Pretty a

-- | render the document with a given mode. renderWithMode :: PPHsMode
--   -&gt; Doc -&gt; String renderWithMode = renderStyleMode P.style
--   
--   render the document with <a>defaultMode</a>. render :: Doc -&gt;
--   String render = renderWithMode defaultMode
--   
--   pretty-print with a given style and mode.
prettyPrintStyleMode :: Pretty a => Style -> PPHsMode -> a -> String

-- | pretty-print with the default style and a given mode.
prettyPrintWithMode :: Pretty a => PPHsMode -> a -> String

-- | pretty-print with the default style and <a>defaultMode</a>.
prettyPrint :: Pretty a => a -> String

-- | A rendering style. Allows us to specify constraints to choose among
--   the many different rendering options.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode.
[mode] :: Style -> Mode

-- | Maximum length of a line, in characters.
[lineLength] :: Style -> Int

-- | Ratio of line length to ribbon length. A ribbon refers to the
--   characters on a line <i>excluding</i> indentation. So a
--   <a>lineLength</a> of 100, with a <a>ribbonsPerLine</a> of <tt>2.0</tt>
--   would only allow up to 50 characters of ribbon to be displayed on a
--   line, while allowing it to be indented up to 50 characters.
[ribbonsPerLine] :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Rendering mode.
data Mode

-- | Normal rendering (<a>lineLength</a> and <a>ribbonsPerLine</a>
--   respected').
PageMode :: Mode

-- | With zig-zag cuts.
ZigZagMode :: Mode

-- | No indentation, infinitely long lines (<a>lineLength</a> ignored), but
--   explicit new lines, i.e., <tt>text "one" $$ text "two"</tt>, are
--   respected.
LeftMode :: Mode

-- | All on one line, <a>lineLength</a> ignored and explicit new lines
--   (<tt>$$</tt>) are turned into spaces.
OneLineMode :: Mode

-- | Pretty-printing parameters.
--   
--   <i>Note:</i> the <a>onsideIndent</a> must be positive and less than
--   all other indents.
data PPHsMode
PPHsMode :: Indent -> Indent -> Indent -> Indent -> Indent -> Indent -> Indent -> Bool -> PPLayout -> Bool -> PPHsMode

-- | indentation of a class or instance
[classIndent] :: PPHsMode -> Indent

-- | indentation of a <tt>do</tt>-expression
[doIndent] :: PPHsMode -> Indent

-- | indentation of the body of a <tt>case</tt> expression
[multiIfIndent] :: PPHsMode -> Indent

-- | indentation of the body of a multi-<tt>if</tt> expression
[caseIndent] :: PPHsMode -> Indent

-- | indentation of the declarations in a <tt>let</tt> expression
[letIndent] :: PPHsMode -> Indent

-- | indentation of the declarations in a <tt>where</tt> clause
[whereIndent] :: PPHsMode -> Indent

-- | indentation added for continuation lines that would otherwise be
--   offside
[onsideIndent] :: PPHsMode -> Indent

-- | blank lines between statements?
[spacing] :: PPHsMode -> Bool

-- | Pretty-printing style to use
[layout] :: PPHsMode -> PPLayout

-- | add GHC-style <tt>LINE</tt> pragmas to output?
[linePragmas] :: PPHsMode -> Bool
type Indent = Int

-- | Varieties of layout we can use.
data PPLayout

-- | classical layout
PPOffsideRule :: PPLayout

-- | classical layout made explicit
PPSemiColon :: PPLayout

-- | inline decls, with newlines between them
PPInLine :: PPLayout

-- | everything on a single line
PPNoLayout :: PPLayout

-- | The default mode: pretty-print using the offside rule and sensible
--   defaults.
defaultMode :: PPHsMode

-- | pretty-print with the default style and <a>defaultMode</a>.
prettyPrim :: Pretty a => a -> Doc

-- | pretty-print with the default style and a given mode.
prettyPrimWithMode :: Pretty a => PPHsMode -> a -> Doc
instance GHC.Classes.Eq Language.Haskell.Exts.Pretty.PPLayout
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Pretty.GuardedAlts l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Pretty.GuardedAlt l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Exp l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Alt l)
instance Language.Haskell.Exts.Pretty.PrettyDeclLike (Language.Haskell.Exts.Syntax.Decl l)
instance Language.Haskell.Exts.Pretty.PrettyDeclLike (Language.Haskell.Exts.Syntax.ClassDecl l)
instance Language.Haskell.Exts.Pretty.PrettyDeclLike (Language.Haskell.Exts.Syntax.InstDecl l)
instance Language.Haskell.Exts.Pretty.PrettyDeclLike (Language.Haskell.Exts.Syntax.IPBind l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.ModuleHead l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.ExportSpecList l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.ModuleName l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Namespace l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.ExportSpec l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.ImportDecl l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.ImportSpecList l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.ImportSpec l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.TypeEqn l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.InjectivityInfo l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.ResultSig l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Decl l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.InstRule l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.InstHead l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Annotation l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.BooleanFormula l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Role l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.DataOrNew l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Assoc l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Match l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.ClassDecl l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.DeclHead l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.InstDecl l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Safety l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.CallConv l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Rule l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Activation l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Overlap l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.RuleVar l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.ModulePragma l)
instance Language.Haskell.Exts.Pretty.Pretty Language.Haskell.Exts.Syntax.Tool
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.QualConDecl l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.GadtDecl l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.ConDecl l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.FieldDecl l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.BangType l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Unpackedness l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Deriving l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.DerivStrategy l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Type l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.MaybePromotedName l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Promoted l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.TyVarBind l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.FunDep l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Rhs l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.GuardedRhs l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Literal l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.XAttr l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.XName l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Bracket l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Splice l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Pat l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.PXAttr l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.PatField l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.RPat l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.RPatOp l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Stmt l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.QualStmt l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.FieldUpdate l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.QOp l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.QName l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Op l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Name l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.IPName l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.IPBind l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.CName l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.SpecialCon l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Context l)
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Asst l)
instance Language.Haskell.Exts.Pretty.Pretty Language.Haskell.Exts.SrcLoc.SrcLoc
instance Language.Haskell.Exts.Pretty.Pretty Language.Haskell.Exts.SrcLoc.SrcSpan
instance Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.Syntax.Module pos)
instance Language.Haskell.Exts.SrcLoc.SrcInfo loc => Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.ParseSyntax.PExp loc)
instance Language.Haskell.Exts.SrcLoc.SrcInfo loc => Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.ParseSyntax.PFieldUpdate loc)
instance Language.Haskell.Exts.SrcLoc.SrcInfo loc => Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.ParseSyntax.ParseXAttr loc)
instance Language.Haskell.Exts.SrcLoc.SrcInfo loc => Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.ParseSyntax.PContext loc)
instance Language.Haskell.Exts.SrcLoc.SrcInfo loc => Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.ParseSyntax.PAsst loc)
instance Language.Haskell.Exts.SrcLoc.SrcInfo loc => Language.Haskell.Exts.Pretty.Pretty (Language.Haskell.Exts.ParseSyntax.PType loc)
instance GHC.Base.Functor (Language.Haskell.Exts.Pretty.DocM s)
instance GHC.Base.Applicative (Language.Haskell.Exts.Pretty.DocM s)
instance GHC.Base.Monad (Language.Haskell.Exts.Pretty.DocM s)


-- | Fixity information to give the parser so that infix operators can be
--   parsed properly.
module Language.Haskell.Exts.Fixity

-- | Operator fixities are represented by their associativity (left, right
--   or none) and their precedence (0-9).
data Fixity
Fixity :: Assoc () -> Int -> QName () -> Fixity
infix_ :: Int -> [String] -> [Fixity]
infixl_ :: Int -> [String] -> [Fixity]
infixr_ :: Int -> [String] -> [Fixity]

-- | All fixities defined in the Prelude.
preludeFixities :: [Fixity]

-- | All fixities defined in the base package.
--   
--   Note that the <tt>+++</tt> operator appears in both Control.Arrows and
--   Text.ParserCombinators.ReadP. The listed precedence for <tt>+++</tt>
--   in this list is that of Control.Arrows.
baseFixities :: [Fixity]

-- | All AST elements that may include expressions which in turn may need
--   fixity tweaking will be instances of this class.
class AppFixity ast

-- | Tweak any expressions in the element to account for the fixities
--   given. Assumes that all operator expressions are fully left
--   associative chains to begin with.
applyFixities :: (AppFixity ast, MonadFail m) => [Fixity] -> ast SrcSpanInfo -> m (ast SrcSpanInfo)
instance Data.Data.Data Language.Haskell.Exts.Fixity.Fixity
instance GHC.Show.Show Language.Haskell.Exts.Fixity.Fixity
instance GHC.Classes.Ord Language.Haskell.Exts.Fixity.Fixity
instance GHC.Classes.Eq Language.Haskell.Exts.Fixity.Fixity
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Exp
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Pat
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Module
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Decl
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.PatternSynDirection
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Annotation
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.ClassDecl
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.InstDecl
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Match
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Rhs
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.GuardedRhs
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.PatField
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.RPat
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.PXAttr
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Stmt
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Binds
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.IPBind
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.FieldUpdate
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Alt
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.QualStmt
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Bracket
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.Splice
instance Language.Haskell.Exts.Fixity.AppFixity Language.Haskell.Exts.Syntax.XAttr


-- | This module processes comments along with an annotated AST, to be able
--   to associate Haddock comments with the actual item they refer to.
--   
--   Example:
--   
--   <pre>
--   let
--    parse1Result :: ParseResult (Module SrcSpanInfo,[Comment])
--    parse1Result =
--      parseFileContentsWithComments
--       (defaultParseMode { parseFilename = file })
--        contents
--    withC :: ParseResult (Module (SrcSpanInfo,[Comment]))
--    withC = case parse1Result of
--              ParseOk res         -&gt; ParseOk $ associateHaddock res
--              ParseFailed sloc msg -&gt; ParseFailed sloc msg
--   </pre>
--   
--   In this code sample, parse1Result is what you get when you parse a
--   file: a <a>Module</a> annotated wth <a>SrcSpanInfo</a>, and a list of
--   comments After passing the result to <a>associateHaddock</a>, you get
--   a <a>Module</a> annotated with both a <a>SrcSpanInfo</a> and the list
--   of <a>Comment</a> related to the specific AST node.
module Language.Haskell.Exts.Comments

-- | Associates an AST with Source Span Information with relevant Haddock
--   comments
associateHaddock :: (Annotated ast, Traversable ast) => (ast SrcSpanInfo, [Comment]) -> ast (SrcSpanInfo, [Comment])

-- | A Haskell comment. The <a>Bool</a> is <a>True</a> if the comment is
--   multi-line, i.e. <tt>{- -}</tt>.
data Comment
Comment :: Bool -> SrcSpan -> String -> Comment

-- | An unknown pragma.
data UnknownPragma
UnknownPragma :: SrcSpan -> String -> UnknownPragma
instance Data.Data.Data Language.Haskell.Exts.Comments.UnknownPragma
instance GHC.Show.Show Language.Haskell.Exts.Comments.UnknownPragma
instance GHC.Classes.Eq Language.Haskell.Exts.Comments.UnknownPragma
instance Data.Data.Data Language.Haskell.Exts.Comments.Comment
instance GHC.Show.Show Language.Haskell.Exts.Comments.Comment
instance GHC.Classes.Eq Language.Haskell.Exts.Comments.Comment


-- | Lexer for Haskell with extensions.
module Language.Haskell.Exts.Lexer

-- | Lex a string into a list of Haskell 2010 source tokens.
lexTokenStream :: String -> ParseResult [Loc Token]

-- | Lex a string into a list of Haskell source tokens, using an explicit
--   mode.
lexTokenStreamWithMode :: ParseMode -> String -> ParseResult [Loc Token]
data Token
VarId :: String -> Token
LabelVarId :: String -> Token
QVarId :: (String, String) -> Token
IDupVarId :: String -> Token
ILinVarId :: String -> Token
ConId :: String -> Token
QConId :: (String, String) -> Token
DVarId :: [String] -> Token
VarSym :: String -> Token
ConSym :: String -> Token
QVarSym :: (String, String) -> Token
QConSym :: (String, String) -> Token
IntTok :: (Integer, String) -> Token
FloatTok :: (Rational, String) -> Token
Character :: (Char, String) -> Token
StringTok :: (String, String) -> Token
IntTokHash :: (Integer, String) -> Token
WordTokHash :: (Integer, String) -> Token
FloatTokHash :: (Rational, String) -> Token
DoubleTokHash :: (Rational, String) -> Token
CharacterHash :: (Char, String) -> Token
StringHash :: (String, String) -> Token
LeftParen :: Token
RightParen :: Token
LeftHashParen :: Token
RightHashParen :: Token
SemiColon :: Token
LeftCurly :: Token
RightCurly :: Token
VRightCurly :: Token
LeftSquare :: Token
RightSquare :: Token
ParArrayLeftSquare :: Token
ParArrayRightSquare :: Token
Comma :: Token
Underscore :: Token
BackQuote :: Token
Dot :: Token
DotDot :: Token
Colon :: Token
QuoteColon :: Token
DoubleColon :: Token
Equals :: Token
Backslash :: Token
Bar :: Token
LeftArrow :: Token
RightArrow :: Token
At :: Token
TApp :: Token
Tilde :: Token
DoubleArrow :: Token
Minus :: Token
Exclamation :: Token
Star :: Token
LeftArrowTail :: Token
RightArrowTail :: Token
LeftDblArrowTail :: Token
RightDblArrowTail :: Token
THExpQuote :: Token
THPatQuote :: Token
THDecQuote :: Token
THTypQuote :: Token
THCloseQuote :: Token

-- | ]
THIdEscape :: String -> Token
THParenEscape :: Token
THVarQuote :: Token
THTyQuote :: Token
THQuasiQuote :: (String, String) -> Token
RPGuardOpen :: Token
RPGuardClose :: Token

-- | )
RPCAt :: Token
XCodeTagOpen :: Token
XCodeTagClose :: Token
XStdTagOpen :: Token
XStdTagClose :: Token
XCloseTagOpen :: Token
XEmptyTagClose :: Token
XChildTagOpen :: Token
XPCDATA :: String -> Token
XRPatOpen :: Token
XRPatClose :: Token
PragmaEnd :: Token
RULES :: Token
INLINE :: Bool -> Token
INLINE_CONLIKE :: Token
SPECIALISE :: Token
SPECIALISE_INLINE :: Bool -> Token
SOURCE :: Token
DEPRECATED :: Token
WARNING :: Token
SCC :: Token
GENERATED :: Token
CORE :: Token
UNPACK :: Token
NOUNPACK :: Token
OPTIONS :: (Maybe String, String) -> Token
LANGUAGE :: Token
ANN :: Token
MINIMAL :: Token
NO_OVERLAP :: Token
OVERLAP :: Token
OVERLAPPING :: Token
OVERLAPPABLE :: Token
OVERLAPS :: Token
INCOHERENT :: Token
COMPLETE :: Token
KW_As :: Token
KW_By :: Token
KW_Case :: Token
KW_Class :: Token
KW_Data :: Token
KW_Default :: Token
KW_Deriving :: Token
KW_Do :: Token
KW_MDo :: Token
KW_Else :: Token
KW_Family :: Token
KW_Forall :: Token
KW_Group :: Token
KW_Hiding :: Token
KW_If :: Token
KW_Import :: Token
KW_In :: Token
KW_Infix :: Token
KW_InfixL :: Token
KW_InfixR :: Token
KW_Instance :: Token
KW_Let :: Token
KW_Module :: Token
KW_NewType :: Token
KW_Of :: Token
KW_Proc :: Token
KW_Rec :: Token
KW_Role :: Token
KW_Then :: Token
KW_Type :: Token
KW_Using :: Token
KW_Where :: Token
KW_Qualified :: Token
KW_Pattern :: Token
KW_Stock :: Token
KW_Anyclass :: Token
KW_Via :: Token
KW_Foreign :: Token
KW_Export :: Token
KW_Safe :: Token
KW_Unsafe :: Token
KW_Threadsafe :: Token
KW_Interruptible :: Token
KW_StdCall :: Token
KW_CCall :: Token
KW_CPlusPlus :: Token
KW_DotNet :: Token
KW_Jvm :: Token
KW_Js :: Token
KW_JavaScript :: Token
KW_CApi :: Token
EOF :: Token

-- | An entity located in the source.
data Loc a
Loc :: SrcSpan -> a -> Loc a
[loc] :: Loc a -> SrcSpan
[unLoc] :: Loc a -> a
showToken :: Token -> String


-- | Annotated parser for Haskell with extensions.
module Language.Haskell.Exts.Parser

-- | Class providing function for parsing at many different types.
--   
--   Note that for convenience of implementation, the default methods have
--   definitions equivalent to <a>undefined</a>. The minimal definition is
--   all of the visible methods.
class Parseable ast

-- | Parse a string with default mode.
parse :: Parseable ast => String -> ParseResult ast

-- | Parse a string with an explicit <a>ParseMode</a>.
parseWithMode :: Parseable ast => ParseMode -> String -> ParseResult ast

-- | Parse a string with an explicit <a>ParseMode</a>, returning all
--   comments along with the AST.
parseWithComments :: Parseable ast => ParseMode -> String -> ParseResult (ast, [Comment])

-- | Static parameters governing a parse. Note that the various parse
--   functions in <a>Language.Haskell.Exts.Parser</a> never look at
--   LANGUAGE pragmas, regardless of what the
--   <tt>ignoreLanguagePragmas</tt> flag is set to. Only the various
--   <tt>parseFile</tt> functions in <a>Language.Haskell.Exts</a> will act
--   on it, when set to <a>False</a>.
data ParseMode
ParseMode :: String -> Language -> [Extension] -> Bool -> Bool -> Maybe [Fixity] -> Bool -> ParseMode

-- | original name of the file being parsed
[parseFilename] :: ParseMode -> String

-- | base language (e.g. Haskell98, Haskell2010)
[baseLanguage] :: ParseMode -> Language

-- | list of extensions enabled for parsing
[extensions] :: ParseMode -> [Extension]

-- | if <a>True</a>, the parser won't care about further extensions in
--   LANGUAGE pragmas in source files
[ignoreLanguagePragmas] :: ParseMode -> Bool

-- | if <a>True</a>, the parser won't read line position information from
--   LINE pragmas in source files
[ignoreLinePragmas] :: ParseMode -> Bool

-- | list of fixities to be aware of
[fixities] :: ParseMode -> Maybe [Fixity]

-- | Checks whether functions have a consistent arity
[ignoreFunctionArity] :: ParseMode -> Bool

-- | Default parameters for a parse. The default is an unknown filename, no
--   extensions (i.e. Haskell 98), don't ignore LANGUAGE pragmas, do ignore
--   LINE pragmas, and be aware of fixities from the <tt>Prelude</tt>.
defaultParseMode :: ParseMode

-- | The result of a parse.
data ParseResult a

-- | The parse succeeded, yielding a value.
ParseOk :: a -> ParseResult a

-- | The parse failed at the specified source location, with an error
--   message.
ParseFailed :: SrcLoc -> String -> ParseResult a

-- | Retrieve the result of a successful parse, throwing an error if the
--   parse is actually not successful.
fromParseResult :: ParseResult a -> a

-- | Parse of a string, which should contain a complete Haskell module,
--   using <a>defaultParseMode</a>.
parseModule :: String -> ParseResult (Module SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit <a>ParseMode</a>.
parseModuleWithMode :: ParseMode -> String -> ParseResult (Module SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit <a>ParseMode</a>, retaining comments.
parseModuleWithComments :: ParseMode -> String -> ParseResult (Module SrcSpanInfo, [Comment])

-- | Parse of a string containing a Haskell expression, using
--   <a>defaultParseMode</a>.
parseExp :: String -> ParseResult (Exp SrcSpanInfo)

-- | Parse of a string containing a Haskell expression, using an explicit
--   <a>ParseMode</a>.
parseExpWithMode :: ParseMode -> String -> ParseResult (Exp SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit <a>ParseMode</a>, retaining comments.
parseExpWithComments :: ParseMode -> String -> ParseResult (Exp SrcSpanInfo, [Comment])

-- | Parse of a string containing a Haskell statement, using
--   <a>defaultParseMode</a>.
parseStmt :: String -> ParseResult (Stmt SrcSpanInfo)

-- | Parse of a string containing a Haskell type, using an explicit
--   <a>ParseMode</a>.
parseStmtWithMode :: ParseMode -> String -> ParseResult (Stmt SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit <a>ParseMode</a>, retaining comments.
parseStmtWithComments :: ParseMode -> String -> ParseResult (Stmt SrcSpanInfo, [Comment])

-- | Parse of a string containing a Haskell pattern, using
--   <a>defaultParseMode</a>.
parsePat :: String -> ParseResult (Pat SrcSpanInfo)

-- | Parse of a string containing a Haskell pattern, using an explicit
--   <a>ParseMode</a>.
parsePatWithMode :: ParseMode -> String -> ParseResult (Pat SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit <a>ParseMode</a>, retaining comments.
parsePatWithComments :: ParseMode -> String -> ParseResult (Pat SrcSpanInfo, [Comment])

-- | Parse of a string containing a Haskell top-level declaration, using
--   <a>defaultParseMode</a>.
parseDecl :: String -> ParseResult (Decl SrcSpanInfo)

-- | Parse of a string containing a Haskell top-level declaration, using an
--   explicit <a>ParseMode</a>.
parseDeclWithMode :: ParseMode -> String -> ParseResult (Decl SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit <a>ParseMode</a>, retaining comments.
parseDeclWithComments :: ParseMode -> String -> ParseResult (Decl SrcSpanInfo, [Comment])

-- | Parse of a string containing a Haskell type, using
--   <a>defaultParseMode</a>.
parseType :: String -> ParseResult (Type SrcSpanInfo)

-- | Parse of a string containing a Haskell type, using an explicit
--   <a>ParseMode</a>.
parseTypeWithMode :: ParseMode -> String -> ParseResult (Type SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit <a>ParseMode</a>, retaining comments.
parseTypeWithComments :: ParseMode -> String -> ParseResult (Type SrcSpanInfo, [Comment])

-- | Parse of a string containing a Haskell statement, using
--   <a>defaultParseMode</a>.
parseImportDecl :: String -> ParseResult (ImportDecl SrcSpanInfo)

-- | Parse of a string containing a Haskell type, using an explicit
--   <a>ParseMode</a>.
parseImportDeclWithMode :: ParseMode -> String -> ParseResult (ImportDecl SrcSpanInfo)

-- | Parse of a string containing a complete Haskell module, using an
--   explicit <a>ParseMode</a>, retaining comments.
parseImportDeclWithComments :: ParseMode -> String -> ParseResult (ImportDecl SrcSpanInfo, [Comment])

-- | Instances of <a>Parseable</a> for <tt>NonGreedy a</tt> will only
--   consume the input until <tt>a</tt> is fully parsed. This means that
--   parse errors that come later in the input will be ignored. It's also
--   more efficient, as it's fully lazy in the remainder of the input:
--   
--   <pre>
--   &gt;&gt;&gt; parse (unlines ("module A where" : "main =" : repeat "blah")) :: ParseResult PragmasAndModuleHead
--   ParseOk (NonGreedy {unNonGreedy = PragmasAndModuleHead [] (ModuleName "A",Nothing,Nothing)})
--   </pre>
--   
--   (this example uses the simplified AST)
newtype NonGreedy a
NonGreedy :: a -> NonGreedy a
[unNonGreedy] :: NonGreedy a -> a

-- | <tt>ListOf a</tt> stores lists of the AST type <tt>a</tt>, along with
--   a <a>SrcSpanInfo</a>, in order to provide <a>Parseable</a> instances
--   for lists. These instances are provided when the type is used as a
--   list in the syntax, and the same delimiters are used in all of its
--   usages. Some exceptions are made:
data ListOf a
ListOf :: SrcSpanInfo -> [a] -> ListOf a
unListOf :: ListOf a -> [a]

-- | Non-greedy parse of a string starting with a series of top-level
--   option pragmas.
getTopPragmas :: String -> ParseResult [ModulePragma SrcSpanInfo]

-- | Type intended to be used with <a>Parseable</a>, with instances that
--   implement a non-greedy parse of the module name, including top-level
--   pragmas. This means that a parse error that comes after the module
--   header won't be returned. If the <a>Maybe</a> value is <a>Nothing</a>,
--   then this means that there was no module header.
data PragmasAndModuleName l
PragmasAndModuleName :: l -> [ModulePragma l] -> Maybe (ModuleName l) -> PragmasAndModuleName l
data PragmasAndModuleHead l
PragmasAndModuleHead :: l -> [ModulePragma l] -> Maybe (ModuleHead l) -> PragmasAndModuleHead l
data ModuleHeadAndImports l
ModuleHeadAndImports :: l -> [ModulePragma l] -> Maybe (ModuleHead l) -> [ImportDecl l] -> ModuleHeadAndImports l
instance GHC.Base.Functor Language.Haskell.Exts.Parser.ListOf
instance Data.Data.Data a => Data.Data.Data (Language.Haskell.Exts.Parser.ListOf a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Haskell.Exts.Parser.ListOf a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Haskell.Exts.Parser.ListOf a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Haskell.Exts.Parser.ListOf a)
instance Data.Data.Data a => Data.Data.Data (Language.Haskell.Exts.Parser.NonGreedy a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Haskell.Exts.Parser.NonGreedy a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Haskell.Exts.Parser.NonGreedy a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Haskell.Exts.Parser.NonGreedy a)
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Parser.ModuleHeadAndImports l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Parser.ModuleHeadAndImports l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Parser.ModuleHeadAndImports l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Parser.ModuleHeadAndImports l)
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Parser.PragmasAndModuleHead l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Parser.PragmasAndModuleHead l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Parser.PragmasAndModuleHead l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Parser.PragmasAndModuleHead l)
instance Data.Data.Data l => Data.Data.Data (Language.Haskell.Exts.Parser.PragmasAndModuleName l)
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.Parser.PragmasAndModuleName l)
instance GHC.Classes.Ord l => GHC.Classes.Ord (Language.Haskell.Exts.Parser.PragmasAndModuleName l)
instance GHC.Classes.Eq l => GHC.Classes.Eq (Language.Haskell.Exts.Parser.PragmasAndModuleName l)
instance Language.Haskell.Exts.ParseMonad.Parseable (Language.Haskell.Exts.Parser.NonGreedy (Language.Haskell.Exts.Parser.ListOf (Language.Haskell.Exts.Syntax.ModulePragma Language.Haskell.Exts.SrcLoc.SrcSpanInfo)))
instance Language.Haskell.Exts.ParseMonad.Parseable (Language.Haskell.Exts.Parser.NonGreedy (Language.Haskell.Exts.Parser.PragmasAndModuleName Language.Haskell.Exts.SrcLoc.SrcSpanInfo))
instance Language.Haskell.Exts.ParseMonad.Parseable (Language.Haskell.Exts.Parser.NonGreedy (Language.Haskell.Exts.Parser.PragmasAndModuleHead Language.Haskell.Exts.SrcLoc.SrcSpanInfo))
instance Language.Haskell.Exts.ParseMonad.Parseable (Language.Haskell.Exts.Parser.NonGreedy (Language.Haskell.Exts.Parser.ModuleHeadAndImports Language.Haskell.Exts.SrcLoc.SrcSpanInfo))
instance GHC.Base.Functor Language.Haskell.Exts.Parser.NonGreedy
instance Language.Haskell.Exts.ParseMonad.Parseable (Language.Haskell.Exts.Syntax.Decl Language.Haskell.Exts.SrcLoc.SrcSpanInfo)
instance Language.Haskell.Exts.ParseMonad.Parseable (Language.Haskell.Exts.Syntax.Exp Language.Haskell.Exts.SrcLoc.SrcSpanInfo)
instance Language.Haskell.Exts.ParseMonad.Parseable (Language.Haskell.Exts.Syntax.Module Language.Haskell.Exts.SrcLoc.SrcSpanInfo)
instance Language.Haskell.Exts.ParseMonad.Parseable (Language.Haskell.Exts.Syntax.Pat Language.Haskell.Exts.SrcLoc.SrcSpanInfo)
instance Language.Haskell.Exts.ParseMonad.Parseable (Language.Haskell.Exts.Syntax.Stmt Language.Haskell.Exts.SrcLoc.SrcSpanInfo)
instance Language.Haskell.Exts.ParseMonad.Parseable (Language.Haskell.Exts.Syntax.Type Language.Haskell.Exts.SrcLoc.SrcSpanInfo)
instance Language.Haskell.Exts.ParseMonad.Parseable (Language.Haskell.Exts.Syntax.ImportDecl Language.Haskell.Exts.SrcLoc.SrcSpanInfo)


-- | Exact-printer for Haskell abstract syntax. The input is a
--   (semi-concrete) abstract syntax tree, annotated with exact source
--   information to enable printing the tree exactly as it was parsed.
module Language.Haskell.Exts.ExactPrint

-- | Print an AST exactly as specified by the annotations on the nodes in
--   the tree.
exactPrint :: ExactP ast => ast SrcSpanInfo -> [Comment] -> String
class Annotated ast => ExactP ast
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.ExactPrint.GuardedAlt l)
instance GHC.Base.Functor Language.Haskell.Exts.ExactPrint.GuardedAlt
instance GHC.Show.Show l => GHC.Show.Show (Language.Haskell.Exts.ExactPrint.GuardedAlts l)
instance GHC.Base.Functor Language.Haskell.Exts.ExactPrint.GuardedAlts
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Exp
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.ExactPrint.GuardedAlt
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.ExactPrint.GuardedAlts
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.ExactPrint.GuardedAlt
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Alt
instance Language.Haskell.Exts.Syntax.Annotated Language.Haskell.Exts.ExactPrint.GuardedAlts
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Literal
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Sign
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.ModuleName
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.SpecialCon
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.QName
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Name
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.IPName
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.QOp
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Op
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.CName
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Namespace
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.ExportSpec
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.ExportSpecList
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.ImportSpecList
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.ImportSpec
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.ImportDecl
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Module
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.ModuleHead
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.ModulePragma
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.WarningText
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Assoc
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.DataOrNew
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.TypeEqn
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.InjectivityInfo
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.ResultSig
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Decl
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Role
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Annotation
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.BooleanFormula
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.DeclHead
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.InstRule
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.InstHead
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.TyVarBind
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Type
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.MaybePromotedName
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Promoted
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Context
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Asst
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Deriving
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.DerivStrategy
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.ClassDecl
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.InstDecl
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.FunDep
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.QualConDecl
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.ConDecl
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.GadtDecl
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.BangType
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Unpackedness
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Splice
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.FieldUpdate
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Stmt
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.QualStmt
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Bracket
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.XAttr
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Match
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Rhs
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.GuardedRhs
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Pat
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.PatField
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.RPat
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.RPatOp
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.PXAttr
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.XName
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Binds
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.CallConv
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Safety
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Rule
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.RuleVar
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Overlap
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.Activation
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.FieldDecl
instance Language.Haskell.Exts.ExactPrint.ExactP Language.Haskell.Exts.Syntax.IPBind
instance GHC.Base.Functor Language.Haskell.Exts.ExactPrint.EP
instance GHC.Base.Applicative Language.Haskell.Exts.ExactPrint.EP
instance GHC.Base.Monad Language.Haskell.Exts.ExactPrint.EP
instance Control.Monad.Fail.MonadFail Language.Haskell.Exts.ExactPrint.EP


-- | This module contains combinators to use when building Haskell source
--   trees programmatically, as opposed to parsing them from a string. The
--   contents here are quite experimental and will likely receive a lot of
--   attention when the rest has stabilised.
module Language.Haskell.Exts.Build

-- | An identifier with the given string as its name. The string should be
--   a valid Haskell identifier.
name :: String -> Name ()

-- | A symbol identifier. The string should be a valid Haskell symbol
--   identifier.
sym :: String -> Name ()

-- | A local variable as expression.
var :: Name () -> Exp ()

-- | Use the given identifier as an operator.
op :: Name () -> QOp ()

-- | A qualified variable as expression.
qvar :: ModuleName () -> Name () -> Exp ()

-- | A pattern variable.
pvar :: Name () -> Pat ()

-- | Application of expressions by juxtaposition.
app :: Exp () -> Exp () -> Exp ()

-- | Apply an operator infix.
infixApp :: Exp () -> QOp () -> Exp () -> Exp ()

-- | Apply a function to a list of arguments.
appFun :: Exp () -> [Exp ()] -> Exp ()

-- | A constructor pattern, with argument patterns.
pApp :: Name () -> [Pat ()] -> Pat ()

-- | A tuple expression.
tuple :: [Exp ()] -> Exp ()

-- | A tuple pattern.
pTuple :: [Pat ()] -> Pat ()

-- | A tuple expression consisting of variables only.
varTuple :: [Name ()] -> Exp ()

-- | A tuple pattern consisting of variables only.
pvarTuple :: [Name ()] -> Pat ()

-- | A function with a given name.
function :: String -> Exp ()

-- | A literal string expression.
strE :: String -> Exp ()

-- | A literal character expression.
charE :: Char -> Exp ()

-- | A literal integer expression.
intE :: Integer -> Exp ()

-- | A literal string pattern.
strP :: String -> Pat ()

-- | A literal character pattern.
charP :: Char -> Pat ()

-- | A literal integer pattern.
intP :: Integer -> Pat ()

-- | A do block formed by the given statements. The last statement in the
--   list should be a <a>Qualifier</a> expression.
doE :: [Stmt ()] -> Exp ()

-- | Lambda abstraction, given a list of argument patterns and an
--   expression body.
lamE :: [Pat ()] -> Exp () -> Exp ()

-- | A <tt>let</tt> ... <tt>in</tt> block.
letE :: [Decl ()] -> Exp () -> Exp ()

-- | A <tt>case</tt> expression.
caseE :: Exp () -> [Alt ()] -> Exp ()

-- | An unguarded alternative in a <tt>case</tt> expression.
alt :: Pat () -> Exp () -> Alt ()

-- | An alternative with a single guard in a <tt>case</tt> expression.
altGW :: Pat () -> [Stmt ()] -> Exp () -> Binds () -> Alt ()

-- | A list expression.
listE :: [Exp ()] -> Exp ()

-- | The empty list expression.
eList :: Exp ()

-- | The empty list pattern.
peList :: Pat ()

-- | Put parentheses around an expression.
paren :: Exp () -> Exp ()

-- | Put parentheses around a pattern.
pParen :: Pat () -> Pat ()

-- | A qualifier expression statement.
qualStmt :: Exp () -> Stmt ()

-- | A generator statement: <i>pat</i> <tt>&lt;-</tt> <i>exp</i>
genStmt :: Pat () -> Exp () -> Stmt ()

-- | A <tt>let</tt> binding group as a statement.
letStmt :: [Decl ()] -> Stmt ()

-- | Hoist a set of declarations to a binding group.
binds :: [Decl ()] -> Binds ()

-- | An empty binding group.
noBinds :: Maybe (Binds ())

-- | The wildcard pattern: <tt>_</tt>
wildcard :: Pat ()

-- | Generate k names by appending numbers 1 through k to a given string.
genNames :: String -> Int -> [Name ()]

-- | A function with a single clause
sfun :: Name () -> [Name ()] -> Rhs () -> Maybe (Binds ()) -> Decl ()

-- | A function with a single clause, a single argument, no guards and no
--   where declarations
simpleFun :: Name () -> Name () -> Exp () -> Decl ()

-- | A pattern bind where the pattern is a variable, and where there are no
--   guards and no 'where' clause.
patBind :: Pat () -> Exp () -> Decl ()

-- | A pattern bind where the pattern is a variable, and where there are no
--   guards, but with a 'where' clause.
patBindWhere :: Pat () -> Exp () -> [Decl ()] -> Decl ()

-- | Bind an identifier to an expression.
nameBind :: Name () -> Exp () -> Decl ()

-- | Apply function of a given name to a list of arguments.
metaFunction :: String -> [Exp ()] -> Exp ()

-- | Apply a constructor of a given name to a list of pattern arguments,
--   forming a constructor pattern.
metaConPat :: String -> [Pat ()] -> Pat ()


-- | An umbrella module for the various functionality of the package. Also
--   provides some convenient functionality for dealing directly with
--   source files.
module Language.Haskell.Exts
data Token
VarId :: String -> Token
LabelVarId :: String -> Token
QVarId :: (String, String) -> Token
IDupVarId :: String -> Token
ILinVarId :: String -> Token
ConId :: String -> Token
QConId :: (String, String) -> Token
DVarId :: [String] -> Token
VarSym :: String -> Token
ConSym :: String -> Token
QVarSym :: (String, String) -> Token
QConSym :: (String, String) -> Token
IntTok :: (Integer, String) -> Token
FloatTok :: (Rational, String) -> Token
Character :: (Char, String) -> Token
StringTok :: (String, String) -> Token
IntTokHash :: (Integer, String) -> Token
WordTokHash :: (Integer, String) -> Token
FloatTokHash :: (Rational, String) -> Token
DoubleTokHash :: (Rational, String) -> Token
CharacterHash :: (Char, String) -> Token
StringHash :: (String, String) -> Token
LeftParen :: Token
RightParen :: Token
LeftHashParen :: Token
RightHashParen :: Token
SemiColon :: Token
LeftCurly :: Token
RightCurly :: Token
VRightCurly :: Token
LeftSquare :: Token
RightSquare :: Token
ParArrayLeftSquare :: Token
ParArrayRightSquare :: Token
Comma :: Token
Underscore :: Token
BackQuote :: Token
Dot :: Token
DotDot :: Token
Colon :: Token
QuoteColon :: Token
DoubleColon :: Token
Equals :: Token
Backslash :: Token
Bar :: Token
LeftArrow :: Token
RightArrow :: Token
At :: Token
TApp :: Token
Tilde :: Token
DoubleArrow :: Token
Minus :: Token
Exclamation :: Token
Star :: Token
LeftArrowTail :: Token
RightArrowTail :: Token
LeftDblArrowTail :: Token
RightDblArrowTail :: Token
THExpQuote :: Token
THPatQuote :: Token
THDecQuote :: Token
THTypQuote :: Token
THCloseQuote :: Token

-- | ]
THIdEscape :: String -> Token
THParenEscape :: Token
THVarQuote :: Token
THTyQuote :: Token
THQuasiQuote :: (String, String) -> Token
RPGuardOpen :: Token
RPGuardClose :: Token

-- | )
RPCAt :: Token
XCodeTagOpen :: Token
XCodeTagClose :: Token
XStdTagOpen :: Token
XStdTagClose :: Token
XCloseTagOpen :: Token
XEmptyTagClose :: Token
XChildTagOpen :: Token
XPCDATA :: String -> Token
XRPatOpen :: Token
XRPatClose :: Token
PragmaEnd :: Token
RULES :: Token
INLINE :: Bool -> Token
INLINE_CONLIKE :: Token
SPECIALISE :: Token
SPECIALISE_INLINE :: Bool -> Token
SOURCE :: Token
DEPRECATED :: Token
WARNING :: Token
SCC :: Token
GENERATED :: Token
CORE :: Token
UNPACK :: Token
NOUNPACK :: Token
OPTIONS :: (Maybe String, String) -> Token
LANGUAGE :: Token
ANN :: Token
MINIMAL :: Token
NO_OVERLAP :: Token
OVERLAP :: Token
OVERLAPPING :: Token
OVERLAPPABLE :: Token
OVERLAPS :: Token
INCOHERENT :: Token
COMPLETE :: Token
KW_As :: Token
KW_By :: Token
KW_Case :: Token
KW_Class :: Token
KW_Data :: Token
KW_Default :: Token
KW_Deriving :: Token
KW_Do :: Token
KW_MDo :: Token
KW_Else :: Token
KW_Family :: Token
KW_Forall :: Token
KW_Group :: Token
KW_Hiding :: Token
KW_If :: Token
KW_Import :: Token
KW_In :: Token
KW_Infix :: Token
KW_InfixL :: Token
KW_InfixR :: Token
KW_Instance :: Token
KW_Let :: Token
KW_Module :: Token
KW_NewType :: Token
KW_Of :: Token
KW_Proc :: Token
KW_Rec :: Token
KW_Role :: Token
KW_Then :: Token
KW_Type :: Token
KW_Using :: Token
KW_Where :: Token
KW_Qualified :: Token
KW_Pattern :: Token
KW_Stock :: Token
KW_Anyclass :: Token
KW_Via :: Token
KW_Foreign :: Token
KW_Export :: Token
KW_Safe :: Token
KW_Unsafe :: Token
KW_Threadsafe :: Token
KW_Interruptible :: Token
KW_StdCall :: Token
KW_CCall :: Token
KW_CPlusPlus :: Token
KW_DotNet :: Token
KW_Jvm :: Token
KW_Js :: Token
KW_JavaScript :: Token
KW_CApi :: Token
EOF :: Token

-- | Lex a string into a list of Haskell 2010 source tokens.
lexTokenStream :: String -> ParseResult [Loc Token]

-- | Lex a string into a list of Haskell source tokens, using an explicit
--   mode.
lexTokenStreamWithMode :: ParseMode -> String -> ParseResult [Loc Token]

-- | Parse a source file on disk, using the default parse mode.
parseFile :: FilePath -> IO (ParseResult (Module SrcSpanInfo))

-- | Parse a source file on disk, supplying a custom parse mode.
parseFileWithMode :: ParseMode -> FilePath -> IO (ParseResult (Module SrcSpanInfo))

-- | Parse a source file on disk, with an extra set of extensions to know
--   about on top of what the file itself declares.
parseFileWithExts :: [Extension] -> FilePath -> IO (ParseResult (Module SrcSpanInfo))
parseFileWithComments :: ParseMode -> FilePath -> IO (ParseResult (Module SrcSpanInfo, [Comment]))

-- | Parse a source file on disk, supplying a custom parse mode, and
--   retaining comments as well as unknown pragmas.
parseFileWithCommentsAndPragmas :: ParseMode -> FilePath -> IO (ParseResult (Module SrcSpanInfo, [Comment], [UnknownPragma]))

-- | Parse a source file from a string using the default parse mode.
parseFileContents :: String -> ParseResult (Module SrcSpanInfo)

-- | Parse a source file from a string using a custom parse mode.
parseFileContentsWithMode :: ParseMode -> String -> ParseResult (Module SrcSpanInfo)

-- | Parse a source file from a string, with an extra set of extensions to
--   know about on top of what the file itself declares.
parseFileContentsWithExts :: [Extension] -> String -> ParseResult (Module SrcSpanInfo)
parseFileContentsWithComments :: ParseMode -> String -> ParseResult (Module SrcSpanInfo, [Comment])

-- | Gather the extensions declared in LANGUAGE pragmas at the top of the
--   file. Returns <a>Nothing</a> if the parse of the pragmas fails.
readExtensions :: String -> Maybe (Maybe Language, [Extension])
