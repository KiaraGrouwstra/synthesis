<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE CPP, DeriveDataTypeable, FlexibleInstances, DeriveFunctor #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# OPTIONS_GHC -fno-warn-orphans #-}</span><span>
</span><a name="line-3"></a><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><a name="line-4"></a><span class="hs-comment">-- |</span><span>
</span><a name="line-5"></a><span class="hs-comment">-- Module      :  Language.Haskell.Exts.Annotated.Parser</span><span>
</span><a name="line-6"></a><span class="hs-comment">-- Copyright   :  (c) Niklas Broberg 2004-2009</span><span>
</span><a name="line-7"></a><span class="hs-comment">--                (c) Michael Sloan 2013</span><span>
</span><a name="line-8"></a><span class="hs-comment">-- License     :  BSD-style (see the file LICENSE.txt)</span><span>
</span><a name="line-9"></a><span class="hs-comment">--</span><span>
</span><a name="line-10"></a><span class="hs-comment">-- Maintainer  :  Niklas Broberg, d00nibro@chalmers.se</span><span>
</span><a name="line-11"></a><span class="hs-comment">-- Stability   :  stable</span><span>
</span><a name="line-12"></a><span class="hs-comment">-- Portability :  portable</span><span>
</span><a name="line-13"></a><span class="hs-comment">--</span><span>
</span><a name="line-14"></a><span class="hs-comment">-- Annotated parser for Haskell with extensions.</span><span>
</span><a name="line-15"></a><span class="hs-comment">--</span><span>
</span><a name="line-16"></a><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><a name="line-17"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.Exts.Parser</span><span>
</span><a name="line-18"></a><span>    </span><span class="hs-special">(</span><span>
</span><a name="line-19"></a><span>    </span><span class="hs-comment">-- * General parsing</span><span>
</span><a name="line-20"></a><span>      </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span class="hs-special">(</span><a href="Language.Haskell.Exts.ParseMonad.html#parse"><span class="hs-identifier hs-var">parse</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithMode"><span class="hs-identifier hs-var">parseWithMode</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithComments"><span class="hs-identifier hs-var">parseWithComments</span></a><span class="hs-special">)</span><span>
</span><a name="line-21"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#defaultParseMode"><span class="hs-identifier hs-var">defaultParseMode</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#fromParseResult"><span class="hs-identifier hs-var">fromParseResult</span></a><span>
</span><a name="line-22"></a><span>    </span><span class="hs-comment">-- * Parsing of specific AST elements</span><span>
</span><a name="line-23"></a><span>    </span><span class="hs-comment">-- ** Modules</span><span>
</span><a name="line-24"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseModule"><span class="hs-identifier hs-var">parseModule</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseModuleWithMode"><span class="hs-identifier hs-var">parseModuleWithMode</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseModuleWithComments"><span class="hs-identifier hs-var">parseModuleWithComments</span></a><span>
</span><a name="line-25"></a><span>    </span><span class="hs-comment">-- ** Expressions</span><span>
</span><a name="line-26"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseExp"><span class="hs-identifier hs-var">parseExp</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseExpWithMode"><span class="hs-identifier hs-var">parseExpWithMode</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseExpWithComments"><span class="hs-identifier hs-var">parseExpWithComments</span></a><span>
</span><a name="line-27"></a><span>    </span><span class="hs-comment">-- ** Statements</span><span>
</span><a name="line-28"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseStmt"><span class="hs-identifier hs-var">parseStmt</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseStmtWithMode"><span class="hs-identifier hs-var">parseStmtWithMode</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseStmtWithComments"><span class="hs-identifier hs-var">parseStmtWithComments</span></a><span>
</span><a name="line-29"></a><span>    </span><span class="hs-comment">-- ** Patterns</span><span>
</span><a name="line-30"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parsePat"><span class="hs-identifier hs-var">parsePat</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parsePatWithMode"><span class="hs-identifier hs-var">parsePatWithMode</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parsePatWithComments"><span class="hs-identifier hs-var">parsePatWithComments</span></a><span>
</span><a name="line-31"></a><span>    </span><span class="hs-comment">-- ** Declarations</span><span>
</span><a name="line-32"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseDecl"><span class="hs-identifier hs-var">parseDecl</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseDeclWithMode"><span class="hs-identifier hs-var">parseDeclWithMode</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseDeclWithComments"><span class="hs-identifier hs-var">parseDeclWithComments</span></a><span>
</span><a name="line-33"></a><span>    </span><span class="hs-comment">-- ** Types</span><span>
</span><a name="line-34"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseType"><span class="hs-identifier hs-var">parseType</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseTypeWithMode"><span class="hs-identifier hs-var">parseTypeWithMode</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseTypeWithComments"><span class="hs-identifier hs-var">parseTypeWithComments</span></a><span>
</span><a name="line-35"></a><span>    </span><span class="hs-comment">-- ** Imports</span><span>
</span><a name="line-36"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseImportDecl"><span class="hs-identifier hs-var">parseImportDecl</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseImportDeclWithMode"><span class="hs-identifier hs-var">parseImportDeclWithMode</span></a><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#parseImportDeclWithComments"><span class="hs-identifier hs-var">parseImportDeclWithComments</span></a><span>
</span><a name="line-37"></a><span>    </span><span class="hs-comment">-- * Non-greedy parsers</span><span>
</span><a name="line-38"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-type">NonGreedy</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-39"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#ListOf"><span class="hs-identifier hs-type">ListOf</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#unListOf"><span class="hs-identifier hs-var">unListOf</span></a><span>
</span><a name="line-40"></a><span>    </span><span class="hs-comment">-- ** Module head parsers</span><span>
</span><a name="line-41"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#getTopPragmas"><span class="hs-identifier hs-var">getTopPragmas</span></a><span>
</span><a name="line-42"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#PragmasAndModuleName"><span class="hs-identifier hs-type">PragmasAndModuleName</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-43"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#PragmasAndModuleHead"><span class="hs-identifier hs-type">PragmasAndModuleHead</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-44"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.Parser.html#ModuleHeadAndImports"><span class="hs-identifier hs-type">ModuleHeadAndImports</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-45"></a><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-46"></a><span>
</span><a name="line-47"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data.Data</span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Fixity</span><span class="hs-special">)</span><span>
</span><a name="line-48"></a><span class="hs-keyword">import</span><span> </span><a href="Language.Haskell.Exts.Fixity.html"><span class="hs-identifier">Language.Haskell.Exts.Fixity</span></a><span>
</span><a name="line-49"></a><span class="hs-keyword">import</span><span> </span><a href="Language.Haskell.Exts.Syntax.html"><span class="hs-identifier">Language.Haskell.Exts.Syntax</span></a><span>
</span><a name="line-50"></a><span class="hs-keyword">import</span><span> </span><a href="Language.Haskell.Exts.Comments.html"><span class="hs-identifier">Language.Haskell.Exts.Comments</span></a><span>
</span><a name="line-51"></a><span class="hs-keyword">import</span><span> </span><a href="Language.Haskell.Exts.InternalParser.html"><span class="hs-identifier">Language.Haskell.Exts.InternalParser</span></a><span>
</span><a name="line-52"></a><span class="hs-keyword">import</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html"><span class="hs-identifier">Language.Haskell.Exts.ParseMonad</span></a><span>
</span><a name="line-53"></a><span class="hs-keyword">import</span><span> </span><a href="Language.Haskell.Exts.SrcLoc.html"><span class="hs-identifier">Language.Haskell.Exts.SrcLoc</span></a><span>
</span><a name="line-54"></a><span>
</span><a name="line-55"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a><span>   </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><a name="local-8214565720324075493"><a href="Language.Haskell.Exts.ParseMonad.html#parser"><span class="hs-identifier">parser</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.Parser.html#normalParser"><span class="hs-identifier hs-var">normalParser</span></a><span> </span><a href="Language.Haskell.Exts.InternalParser.html#mparseDecl"><span class="hs-identifier hs-var">mparseDecl</span></a><span>
</span><a name="line-56"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a><span>    </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><a name="local-8214565720324075493"><a href="Language.Haskell.Exts.ParseMonad.html#parser"><span class="hs-identifier">parser</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.Parser.html#normalParser"><span class="hs-identifier hs-var">normalParser</span></a><span> </span><a href="Language.Haskell.Exts.InternalParser.html#mparseExp"><span class="hs-identifier hs-var">mparseExp</span></a><span>
</span><a name="line-57"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Module"><span class="hs-identifier hs-type">Module</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><a name="local-8214565720324075493"><a href="Language.Haskell.Exts.ParseMonad.html#parser"><span class="hs-identifier">parser</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.Parser.html#normalParser"><span class="hs-identifier hs-var">normalParser</span></a><span> </span><a href="Language.Haskell.Exts.InternalParser.html#mparseModule"><span class="hs-identifier hs-var">mparseModule</span></a><span>
</span><a name="line-58"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a><span>    </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><a name="local-8214565720324075493"><a href="Language.Haskell.Exts.ParseMonad.html#parser"><span class="hs-identifier">parser</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.Parser.html#normalParser"><span class="hs-identifier hs-var">normalParser</span></a><span> </span><a href="Language.Haskell.Exts.InternalParser.html#mparsePat"><span class="hs-identifier hs-var">mparsePat</span></a><span>
</span><a name="line-59"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a><span>   </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><a name="local-8214565720324075493"><a href="Language.Haskell.Exts.ParseMonad.html#parser"><span class="hs-identifier">parser</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.Parser.html#normalParser"><span class="hs-identifier hs-var">normalParser</span></a><span> </span><a href="Language.Haskell.Exts.InternalParser.html#mparseStmt"><span class="hs-identifier hs-var">mparseStmt</span></a><span>
</span><a name="line-60"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a><span>   </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><a name="local-8214565720324075493"><a href="Language.Haskell.Exts.ParseMonad.html#parser"><span class="hs-identifier">parser</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.Parser.html#normalParserNoFixity"><span class="hs-identifier hs-var">normalParserNoFixity</span></a><span> </span><a href="Language.Haskell.Exts.InternalParser.html#mparseType"><span class="hs-identifier hs-var">mparseType</span></a><span>
</span><a name="line-61"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-type">ImportDecl</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span> </span><a name="local-8214565720324075493"><a href="Language.Haskell.Exts.ParseMonad.html#parser"><span class="hs-identifier">parser</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.Parser.html#normalParserNoFixity"><span class="hs-identifier hs-var">normalParserNoFixity</span></a><span> </span><a href="Language.Haskell.Exts.InternalParser.html#mparseImportDecl"><span class="hs-identifier hs-var">mparseImportDecl</span></a><span>
</span><a name="line-62"></a><span>
</span><a name="line-63"></a><span class="hs-identifier">normalParser</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.Fixity.html#AppFixity"><span class="hs-identifier hs-type">AppFixity</span></a><span> </span><a href="#local-6989586621679400491"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">=&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#P"><span class="hs-identifier hs-type">P</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679400491"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Fixity.html#Fixity"><span class="hs-identifier hs-type">Fixity</span></a><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#P"><span class="hs-identifier hs-type">P</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679400491"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-64"></a><a name="normalParser"><a href="Language.Haskell.Exts.Parser.html#normalParser"><span class="hs-identifier">normalParser</span></a></a><span> </span><a name="local-6989586621679400492"><a href="#local-6989586621679400492"><span class="hs-identifier">p</span></a></a><span> </span><span class="hs-identifier hs-var">Nothing</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679400492"><span class="hs-identifier hs-var">p</span></a><span>
</span><a name="line-65"></a><span class="hs-identifier">normalParser</span><span> </span><a name="local-6989586621679400493"><a href="#local-6989586621679400493"><span class="hs-identifier">p</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Just</span><span> </span><a name="local-6989586621679400494"><a href="#local-6989586621679400494"><span class="hs-identifier">fixs</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679400493"><span class="hs-identifier hs-var">p</span></a><span> </span><span class="hs-operator hs-var">&gt;&gt;=</span><span> </span><span class="hs-glyph">\</span><a name="local-6989586621679400495"><a href="#local-6989586621679400495"><span class="hs-identifier">ast</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.Fixity.html#applyFixities"><span class="hs-identifier hs-var">applyFixities</span></a><span> </span><a href="#local-6989586621679400494"><span class="hs-identifier hs-var">fixs</span></a><span> </span><a href="#local-6989586621679400495"><span class="hs-identifier hs-var">ast</span></a><span> </span><span class="hs-special">`</span><a href="Language.Haskell.Exts.ParseMonad.html#atSrcLoc"><span class="hs-identifier hs-var">atSrcLoc</span></a><span class="hs-special">`</span><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#noLoc"><span class="hs-identifier hs-var">noLoc</span></a><span>
</span><a name="line-66"></a><span>
</span><a name="line-67"></a><span class="hs-identifier">normalParserNoFixity</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#P"><span class="hs-identifier hs-type">P</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679400490"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Fixity.html#Fixity"><span class="hs-identifier hs-type">Fixity</span></a><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#P"><span class="hs-identifier hs-type">P</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679400490"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-68"></a><a name="normalParserNoFixity"><a href="Language.Haskell.Exts.Parser.html#normalParserNoFixity"><span class="hs-identifier">normalParserNoFixity</span></a></a><span> </span><a name="local-6989586621679400496"><a href="#local-6989586621679400496"><span class="hs-identifier">p</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679400496"><span class="hs-identifier hs-var">p</span></a><span>
</span><a name="line-69"></a><span>
</span><a name="line-70"></a><span class="hs-comment">-- Type-specific functions</span><span>
</span><a name="line-71"></a><span>
</span><a name="line-72"></a><span class="hs-comment">-- | Parse of a string, which should contain a complete Haskell module, using 'defaultParseMode'.</span><span>
</span><a name="line-73"></a><span class="hs-identifier">parseModule</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Module"><span class="hs-identifier hs-type">Module</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-74"></a><a name="parseModule"><a href="Language.Haskell.Exts.Parser.html#parseModule"><span class="hs-identifier">parseModule</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parse"><span class="hs-identifier hs-var">parse</span></a><span>
</span><a name="line-75"></a><span>
</span><a name="line-76"></a><span class="hs-comment">-- | Parse of a string containing a complete Haskell module, using an explicit 'ParseMode'.</span><span>
</span><a name="line-77"></a><span class="hs-identifier">parseModuleWithMode</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Module"><span class="hs-identifier hs-type">Module</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-78"></a><a name="parseModuleWithMode"><a href="Language.Haskell.Exts.Parser.html#parseModuleWithMode"><span class="hs-identifier">parseModuleWithMode</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithMode"><span class="hs-identifier hs-var">parseWithMode</span></a><span>
</span><a name="line-79"></a><span>
</span><a name="line-80"></a><span class="hs-comment">-- | Parse of a string containing a complete Haskell module, using an explicit 'ParseMode', retaining comments.</span><span>
</span><a name="line-81"></a><span class="hs-identifier">parseModuleWithComments</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Module"><span class="hs-identifier hs-type">Module</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Comments.html#Comment"><span class="hs-identifier hs-type">Comment</span></a><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-82"></a><a name="parseModuleWithComments"><a href="Language.Haskell.Exts.Parser.html#parseModuleWithComments"><span class="hs-identifier">parseModuleWithComments</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithComments"><span class="hs-identifier hs-var">parseWithComments</span></a><span>
</span><a name="line-83"></a><span>
</span><a name="line-84"></a><span class="hs-comment">-- | Parse of a string containing a Haskell expression, using 'defaultParseMode'.</span><span>
</span><a name="line-85"></a><span class="hs-identifier">parseExp</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-86"></a><a name="parseExp"><a href="Language.Haskell.Exts.Parser.html#parseExp"><span class="hs-identifier">parseExp</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parse"><span class="hs-identifier hs-var">parse</span></a><span>
</span><a name="line-87"></a><span>
</span><a name="line-88"></a><span class="hs-comment">-- | Parse of a string containing a Haskell expression, using an explicit 'ParseMode'.</span><span>
</span><a name="line-89"></a><span class="hs-identifier">parseExpWithMode</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-90"></a><a name="parseExpWithMode"><a href="Language.Haskell.Exts.Parser.html#parseExpWithMode"><span class="hs-identifier">parseExpWithMode</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithMode"><span class="hs-identifier hs-var">parseWithMode</span></a><span>
</span><a name="line-91"></a><span>
</span><a name="line-92"></a><span class="hs-comment">-- | Parse of a string containing a complete Haskell module, using an explicit 'ParseMode', retaining comments.</span><span>
</span><a name="line-93"></a><span class="hs-identifier">parseExpWithComments</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Exp"><span class="hs-identifier hs-type">Exp</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Comments.html#Comment"><span class="hs-identifier hs-type">Comment</span></a><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-94"></a><a name="parseExpWithComments"><a href="Language.Haskell.Exts.Parser.html#parseExpWithComments"><span class="hs-identifier">parseExpWithComments</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithComments"><span class="hs-identifier hs-var">parseWithComments</span></a><span>
</span><a name="line-95"></a><span>
</span><a name="line-96"></a><span class="hs-comment">-- | Parse of a string containing a Haskell pattern, using 'defaultParseMode'.</span><span>
</span><a name="line-97"></a><span class="hs-identifier">parsePat</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-98"></a><a name="parsePat"><a href="Language.Haskell.Exts.Parser.html#parsePat"><span class="hs-identifier">parsePat</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parse"><span class="hs-identifier hs-var">parse</span></a><span>
</span><a name="line-99"></a><span>
</span><a name="line-100"></a><span class="hs-comment">-- | Parse of a string containing a Haskell pattern, using an explicit 'ParseMode'.</span><span>
</span><a name="line-101"></a><span class="hs-identifier">parsePatWithMode</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-102"></a><a name="parsePatWithMode"><a href="Language.Haskell.Exts.Parser.html#parsePatWithMode"><span class="hs-identifier">parsePatWithMode</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithMode"><span class="hs-identifier hs-var">parseWithMode</span></a><span>
</span><a name="line-103"></a><span>
</span><a name="line-104"></a><span class="hs-comment">-- | Parse of a string containing a complete Haskell module, using an explicit 'ParseMode', retaining comments.</span><span>
</span><a name="line-105"></a><span class="hs-identifier">parsePatWithComments</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Pat"><span class="hs-identifier hs-type">Pat</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Comments.html#Comment"><span class="hs-identifier hs-type">Comment</span></a><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-106"></a><a name="parsePatWithComments"><a href="Language.Haskell.Exts.Parser.html#parsePatWithComments"><span class="hs-identifier">parsePatWithComments</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithComments"><span class="hs-identifier hs-var">parseWithComments</span></a><span>
</span><a name="line-107"></a><span>
</span><a name="line-108"></a><span class="hs-comment">-- | Parse of a string containing a Haskell top-level declaration, using 'defaultParseMode'.</span><span>
</span><a name="line-109"></a><span class="hs-identifier">parseDecl</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-110"></a><a name="parseDecl"><a href="Language.Haskell.Exts.Parser.html#parseDecl"><span class="hs-identifier">parseDecl</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parse"><span class="hs-identifier hs-var">parse</span></a><span>
</span><a name="line-111"></a><span>
</span><a name="line-112"></a><span class="hs-comment">-- | Parse of a string containing a Haskell top-level declaration, using an explicit 'ParseMode'.</span><span>
</span><a name="line-113"></a><span class="hs-identifier">parseDeclWithMode</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-114"></a><a name="parseDeclWithMode"><a href="Language.Haskell.Exts.Parser.html#parseDeclWithMode"><span class="hs-identifier">parseDeclWithMode</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithMode"><span class="hs-identifier hs-var">parseWithMode</span></a><span>
</span><a name="line-115"></a><span>
</span><a name="line-116"></a><span class="hs-comment">-- | Parse of a string containing a complete Haskell module, using an explicit 'ParseMode', retaining comments.</span><span>
</span><a name="line-117"></a><span class="hs-identifier">parseDeclWithComments</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Decl"><span class="hs-identifier hs-type">Decl</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Comments.html#Comment"><span class="hs-identifier hs-type">Comment</span></a><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-118"></a><a name="parseDeclWithComments"><a href="Language.Haskell.Exts.Parser.html#parseDeclWithComments"><span class="hs-identifier">parseDeclWithComments</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithComments"><span class="hs-identifier hs-var">parseWithComments</span></a><span>
</span><a name="line-119"></a><span>
</span><a name="line-120"></a><span class="hs-comment">-- | Parse of a string containing a Haskell type, using 'defaultParseMode'.</span><span>
</span><a name="line-121"></a><span class="hs-identifier">parseType</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-122"></a><a name="parseType"><a href="Language.Haskell.Exts.Parser.html#parseType"><span class="hs-identifier">parseType</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parse"><span class="hs-identifier hs-var">parse</span></a><span>
</span><a name="line-123"></a><span>
</span><a name="line-124"></a><span class="hs-comment">-- | Parse of a string containing a Haskell type, using an explicit 'ParseMode'.</span><span>
</span><a name="line-125"></a><span class="hs-identifier">parseTypeWithMode</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-126"></a><a name="parseTypeWithMode"><a href="Language.Haskell.Exts.Parser.html#parseTypeWithMode"><span class="hs-identifier">parseTypeWithMode</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithMode"><span class="hs-identifier hs-var">parseWithMode</span></a><span>
</span><a name="line-127"></a><span>
</span><a name="line-128"></a><span class="hs-comment">-- | Parse of a string containing a complete Haskell module, using an explicit 'ParseMode', retaining comments.</span><span>
</span><a name="line-129"></a><span class="hs-identifier">parseTypeWithComments</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Type"><span class="hs-identifier hs-type">Type</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Comments.html#Comment"><span class="hs-identifier hs-type">Comment</span></a><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-130"></a><a name="parseTypeWithComments"><a href="Language.Haskell.Exts.Parser.html#parseTypeWithComments"><span class="hs-identifier">parseTypeWithComments</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithComments"><span class="hs-identifier hs-var">parseWithComments</span></a><span>
</span><a name="line-131"></a><span>
</span><a name="line-132"></a><span class="hs-comment">-- | Parse of a string containing a Haskell statement, using 'defaultParseMode'.</span><span>
</span><a name="line-133"></a><span class="hs-identifier">parseStmt</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-134"></a><a name="parseStmt"><a href="Language.Haskell.Exts.Parser.html#parseStmt"><span class="hs-identifier">parseStmt</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parse"><span class="hs-identifier hs-var">parse</span></a><span>
</span><a name="line-135"></a><span>
</span><a name="line-136"></a><span class="hs-comment">-- | Parse of a string containing a Haskell type, using an explicit 'ParseMode'.</span><span>
</span><a name="line-137"></a><span class="hs-identifier">parseStmtWithMode</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-138"></a><a name="parseStmtWithMode"><a href="Language.Haskell.Exts.Parser.html#parseStmtWithMode"><span class="hs-identifier">parseStmtWithMode</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithMode"><span class="hs-identifier hs-var">parseWithMode</span></a><span>
</span><a name="line-139"></a><span>
</span><a name="line-140"></a><span class="hs-comment">-- | Parse of a string containing a complete Haskell module, using an explicit 'ParseMode', retaining comments.</span><span>
</span><a name="line-141"></a><span class="hs-identifier">parseStmtWithComments</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Comments.html#Comment"><span class="hs-identifier hs-type">Comment</span></a><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-142"></a><a name="parseStmtWithComments"><a href="Language.Haskell.Exts.Parser.html#parseStmtWithComments"><span class="hs-identifier">parseStmtWithComments</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithComments"><span class="hs-identifier hs-var">parseWithComments</span></a><span>
</span><a name="line-143"></a><span>
</span><a name="line-144"></a><span class="hs-comment">-- | Parse of a string containing a Haskell statement, using 'defaultParseMode'.</span><span>
</span><a name="line-145"></a><span class="hs-identifier">parseImportDecl</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-type">ImportDecl</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-146"></a><a name="parseImportDecl"><a href="Language.Haskell.Exts.Parser.html#parseImportDecl"><span class="hs-identifier">parseImportDecl</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parse"><span class="hs-identifier hs-var">parse</span></a><span>
</span><a name="line-147"></a><span>
</span><a name="line-148"></a><span class="hs-comment">-- | Parse of a string containing a Haskell type, using an explicit 'ParseMode'.</span><span>
</span><a name="line-149"></a><span class="hs-identifier">parseImportDeclWithMode</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-type">ImportDecl</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span>
</span><a name="line-150"></a><a name="parseImportDeclWithMode"><a href="Language.Haskell.Exts.Parser.html#parseImportDeclWithMode"><span class="hs-identifier">parseImportDeclWithMode</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithMode"><span class="hs-identifier hs-var">parseWithMode</span></a><span>
</span><a name="line-151"></a><span>
</span><a name="line-152"></a><span class="hs-comment">-- | Parse of a string containing a complete Haskell module, using an explicit 'ParseMode', retaining comments.</span><span>
</span><a name="line-153"></a><span class="hs-identifier">parseImportDeclWithComments</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseMode"><span class="hs-identifier hs-type">ParseMode</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-type">ImportDecl</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Comments.html#Comment"><span class="hs-identifier hs-type">Comment</span></a><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><a name="line-154"></a><a name="parseImportDeclWithComments"><a href="Language.Haskell.Exts.Parser.html#parseImportDeclWithComments"><span class="hs-identifier">parseImportDeclWithComments</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parseWithComments"><span class="hs-identifier hs-var">parseWithComments</span></a><span>
</span><a name="line-155"></a><span>
</span><a name="line-156"></a><span class="hs-comment">-- Non-greedy parsers (should use ng- prefixed parses exported by InternalParser)</span><span>
</span><a name="line-157"></a><span>
</span><a name="line-158"></a><span class="hs-comment">-- | Non-greedy parse of a string starting with a series of top-level option pragmas.</span><span>
</span><a name="line-159"></a><span class="hs-identifier">getTopPragmas</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#ParseResult"><span class="hs-identifier hs-type">ParseResult</span></a><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Syntax.html#ModulePragma"><span class="hs-identifier hs-type">ModulePragma</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">]</span><span>
</span><a name="line-160"></a><a name="getTopPragmas"><a href="Language.Haskell.Exts.Parser.html#getTopPragmas"><span class="hs-identifier">getTopPragmas</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#unListOf"><span class="hs-identifier hs-var">unListOf</span></a><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier">unNonGreedy</span><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#parse"><span class="hs-identifier hs-var">parse</span></a><span>
</span><a name="line-161"></a><span>
</span><a name="line-162"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-type">NonGreedy</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#ListOf"><span class="hs-identifier hs-type">ListOf</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#ModulePragma"><span class="hs-identifier hs-type">ModulePragma</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-163"></a><span>  </span><a name="local-8214565720324075493"><a href="Language.Haskell.Exts.ParseMonad.html#parser"><span class="hs-identifier">parser</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.Parser.html#nglistParserNoFixity"><span class="hs-identifier hs-var">nglistParserNoFixity</span></a><span> </span><a href="Language.Haskell.Exts.InternalParser.html#ngparseModulePragmas"><span class="hs-identifier hs-var">ngparseModulePragmas</span></a><span>
</span><a name="line-164"></a><span>
</span><a name="line-165"></a><span class="hs-identifier">nglistParserNoFixity</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#P"><span class="hs-identifier hs-type">P</span></a><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><a href="#local-6989586621679400489"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpan"><span class="hs-identifier hs-type">SrcSpan</span></a><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Fixity.html#Fixity"><span class="hs-identifier hs-type">Fixity</span></a><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#P"><span class="hs-identifier hs-type">P</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-type">NonGreedy</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#ListOf"><span class="hs-identifier hs-type">ListOf</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679400489"><span class="hs-identifier hs-type">a</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-166"></a><a name="nglistParserNoFixity"><a href="Language.Haskell.Exts.Parser.html#nglistParserNoFixity"><span class="hs-identifier">nglistParserNoFixity</span></a></a><span> </span><a name="local-6989586621679400497"><a href="#local-6989586621679400497"><span class="hs-identifier">f</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-var">NonGreedy</span></a><span> </span><span class="hs-operator hs-var">.</span><span> </span><a href="Language.Haskell.Exts.Parser.html#toListOf"><span class="hs-identifier hs-var">toListOf</span></a><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><a href="Language.Haskell.Exts.Parser.html#normalParserNoFixity"><span class="hs-identifier hs-var">normalParserNoFixity</span></a><span> </span><a href="#local-6989586621679400497"><span class="hs-identifier hs-var">f</span></a><span>
</span><a name="line-167"></a><span>
</span><a name="line-168"></a><span class="hs-comment">-- | Type intended to be used with 'Parseable', with instances that implement a</span><span>
</span><a name="line-169"></a><span class="hs-comment">--   non-greedy parse of the module name, including top-level pragmas.  This</span><span>
</span><a name="line-170"></a><span class="hs-comment">--   means that a parse error that comes after the module header won't be</span><span>
</span><a name="line-171"></a><span class="hs-comment">--   returned. If the 'Maybe' value is 'Nothing', then this means that there was</span><span>
</span><a name="line-172"></a><span class="hs-comment">--   no module header.</span><span>
</span><a name="line-173"></a><span class="hs-keyword">data</span><span> </span><a name="PragmasAndModuleName"><a href="Language.Haskell.Exts.Parser.html#PragmasAndModuleName"><span class="hs-identifier">PragmasAndModuleName</span></a></a><span> </span><a name="local-6989586621679400464"><a href="#local-6989586621679400464"><span class="hs-identifier">l</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="PragmasAndModuleName"><a href="Language.Haskell.Exts.Parser.html#PragmasAndModuleName"><span class="hs-identifier">PragmasAndModuleName</span></a></a><span> </span><a href="#local-6989586621679400464"><span class="hs-identifier hs-type">l</span></a><span>
</span><a name="line-174"></a><span>    </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Syntax.html#ModulePragma"><span class="hs-identifier hs-type">ModulePragma</span></a><span> </span><a href="#local-6989586621679400464"><span class="hs-identifier hs-type">l</span></a><span class="hs-special">]</span><span>
</span><a name="line-175"></a><span>    </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a><span> </span><a href="#local-6989586621679400464"><span class="hs-identifier hs-type">l</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-176"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Data</span><span class="hs-special">)</span><span>
</span><a name="line-177"></a><span>
</span><a name="line-178"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-type">NonGreedy</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#PragmasAndModuleName"><span class="hs-identifier hs-type">PragmasAndModuleName</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-179"></a><span>    </span><a name="local-8214565720324075493"><a href="Language.Haskell.Exts.ParseMonad.html#parser"><span class="hs-identifier">parser</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-180"></a><span>        </span><span class="hs-special">(</span><span class="hs-special">(</span><a name="local-6989586621679400482"><a href="#local-6989586621679400482"><span class="hs-identifier">pragmas</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679400483"><a href="#local-6989586621679400483"><span class="hs-identifier">pss</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679400484"><a href="#local-6989586621679400484"><span class="hs-identifier">pl</span></a></a><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a name="local-6989586621679400485"><a href="#local-6989586621679400485"><span class="hs-identifier">mn</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.Exts.InternalParser.html#ngparsePragmasAndModuleName"><span class="hs-identifier hs-var">ngparsePragmasAndModuleName</span></a><span>
</span><a name="line-181"></a><span>        </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679400486"><a href="#local-6989586621679400486"><span class="hs-identifier">l</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#combSpanMaybe"><span class="hs-identifier hs-var">combSpanMaybe</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679400484"><span class="hs-identifier hs-var">pl</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#%3C%2A%2A"><span class="hs-operator hs-var">&lt;**</span></a><span> </span><a href="#local-6989586621679400483"><span class="hs-identifier hs-var">pss</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">fmap</span><span> </span><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a><span> </span><a href="#local-6989586621679400485"><span class="hs-identifier hs-var">mn</span></a><span class="hs-special">)</span><span>
</span><a name="line-182"></a><span>        </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-var">NonGreedy</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="Language.Haskell.Exts.Parser.html#PragmasAndModuleName"><span class="hs-identifier hs-var">PragmasAndModuleName</span></a><span> </span><a href="#local-6989586621679400486"><span class="hs-identifier hs-var">l</span></a><span> </span><a href="#local-6989586621679400482"><span class="hs-identifier hs-var">pragmas</span></a><span> </span><a href="#local-6989586621679400485"><span class="hs-identifier hs-var">mn</span></a><span>
</span><a name="line-183"></a><span>
</span><a name="line-184"></a><span class="hs-comment">--   Type intended to be used with 'Parseable', with instances that</span><span>
</span><a name="line-185"></a><span class="hs-comment">--   implement a non-greedy parse of the module name, including</span><span>
</span><a name="line-186"></a><span class="hs-comment">--   top-level pragmas.  This means that a parse error that comes</span><span>
</span><a name="line-187"></a><span class="hs-comment">--   after the module header won't be returned. If the 'Maybe' value</span><span>
</span><a name="line-188"></a><span class="hs-comment">--   is 'Nothing', this means that there was no module head.</span><span>
</span><a name="line-189"></a><span class="hs-comment">--</span><span>
</span><a name="line-190"></a><span class="hs-comment">--   Note that the 'ParseMode' matters for this due to the 'MagicHash'</span><span>
</span><a name="line-191"></a><span class="hs-comment">--   changing the lexing of identifiers to include \&quot;#\&quot;.</span><span>
</span><a name="line-192"></a><span class="hs-keyword">data</span><span> </span><a name="PragmasAndModuleHead"><a href="Language.Haskell.Exts.Parser.html#PragmasAndModuleHead"><span class="hs-identifier">PragmasAndModuleHead</span></a></a><span> </span><a name="local-6989586621679400463"><a href="#local-6989586621679400463"><span class="hs-identifier">l</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="PragmasAndModuleHead"><a href="Language.Haskell.Exts.Parser.html#PragmasAndModuleHead"><span class="hs-identifier">PragmasAndModuleHead</span></a></a><span> </span><a href="#local-6989586621679400463"><span class="hs-identifier hs-type">l</span></a><span>
</span><a name="line-193"></a><span>    </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Syntax.html#ModulePragma"><span class="hs-identifier hs-type">ModulePragma</span></a><span> </span><a href="#local-6989586621679400463"><span class="hs-identifier hs-type">l</span></a><span class="hs-special">]</span><span>
</span><a name="line-194"></a><span>    </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#ModuleHead"><span class="hs-identifier hs-type">ModuleHead</span></a><span> </span><a href="#local-6989586621679400463"><span class="hs-identifier hs-type">l</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-195"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Data</span><span class="hs-special">)</span><span>
</span><a name="line-196"></a><span>
</span><a name="line-197"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-type">NonGreedy</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#PragmasAndModuleHead"><span class="hs-identifier hs-type">PragmasAndModuleHead</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-198"></a><span>    </span><a name="local-8214565720324075493"><a href="Language.Haskell.Exts.ParseMonad.html#parser"><span class="hs-identifier">parser</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-199"></a><span>        </span><span class="hs-special">(</span><span class="hs-special">(</span><a name="local-6989586621679400477"><a href="#local-6989586621679400477"><span class="hs-identifier">pragmas</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679400478"><a href="#local-6989586621679400478"><span class="hs-identifier">pss</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679400479"><a href="#local-6989586621679400479"><span class="hs-identifier">pl</span></a></a><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a name="local-6989586621679400480"><a href="#local-6989586621679400480"><span class="hs-identifier">mh</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.Exts.InternalParser.html#ngparsePragmasAndModuleHead"><span class="hs-identifier hs-var">ngparsePragmasAndModuleHead</span></a><span>
</span><a name="line-200"></a><span>        </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679400481"><a href="#local-6989586621679400481"><span class="hs-identifier">l</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#combSpanMaybe"><span class="hs-identifier hs-var">combSpanMaybe</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679400479"><span class="hs-identifier hs-var">pl</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#%3C%2A%2A"><span class="hs-operator hs-var">&lt;**</span></a><span> </span><a href="#local-6989586621679400478"><span class="hs-identifier hs-var">pss</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">fmap</span><span> </span><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a><span> </span><a href="#local-6989586621679400480"><span class="hs-identifier hs-var">mh</span></a><span class="hs-special">)</span><span>
</span><a name="line-201"></a><span>        </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-var">NonGreedy</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="Language.Haskell.Exts.Parser.html#PragmasAndModuleHead"><span class="hs-identifier hs-var">PragmasAndModuleHead</span></a><span> </span><a href="#local-6989586621679400481"><span class="hs-identifier hs-var">l</span></a><span> </span><a href="#local-6989586621679400477"><span class="hs-identifier hs-var">pragmas</span></a><span> </span><a href="#local-6989586621679400480"><span class="hs-identifier hs-var">mh</span></a><span>
</span><a name="line-202"></a><span>
</span><a name="line-203"></a><span class="hs-comment">--   Type intended to be used with 'Parseable', with instances that</span><span>
</span><a name="line-204"></a><span class="hs-comment">--   implement a non-greedy parse of the module head, including</span><span>
</span><a name="line-205"></a><span class="hs-comment">--   top-level pragmas, module name, export list, and import</span><span>
</span><a name="line-206"></a><span class="hs-comment">--   list. This means that if a parse error that comes after the</span><span>
</span><a name="line-207"></a><span class="hs-comment">--   imports won't be returned.  If the 'Maybe' value is 'Nothing',</span><span>
</span><a name="line-208"></a><span class="hs-comment">--   this means that there was no module head.</span><span>
</span><a name="line-209"></a><span class="hs-comment">--</span><span>
</span><a name="line-210"></a><span class="hs-comment">--   Note that the 'ParseMode' matters for this due to the 'MagicHash'</span><span>
</span><a name="line-211"></a><span class="hs-comment">--   changing the lexing of identifiers to include \&quot;#\&quot;.</span><span>
</span><a name="line-212"></a><span class="hs-keyword">data</span><span> </span><a name="ModuleHeadAndImports"><a href="Language.Haskell.Exts.Parser.html#ModuleHeadAndImports"><span class="hs-identifier">ModuleHeadAndImports</span></a></a><span> </span><a name="local-6989586621679400462"><a href="#local-6989586621679400462"><span class="hs-identifier">l</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="ModuleHeadAndImports"><a href="Language.Haskell.Exts.Parser.html#ModuleHeadAndImports"><span class="hs-identifier">ModuleHeadAndImports</span></a></a><span> </span><a href="#local-6989586621679400462"><span class="hs-identifier hs-type">l</span></a><span>
</span><a name="line-213"></a><span>    </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Syntax.html#ModulePragma"><span class="hs-identifier hs-type">ModulePragma</span></a><span> </span><a href="#local-6989586621679400462"><span class="hs-identifier hs-type">l</span></a><span class="hs-special">]</span><span>
</span><a name="line-214"></a><span>    </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Syntax.html#ModuleHead"><span class="hs-identifier hs-type">ModuleHead</span></a><span> </span><a href="#local-6989586621679400462"><span class="hs-identifier hs-type">l</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-215"></a><span>    </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.Syntax.html#ImportDecl"><span class="hs-identifier hs-type">ImportDecl</span></a><span> </span><a href="#local-6989586621679400462"><span class="hs-identifier hs-type">l</span></a><span class="hs-special">]</span><span>
</span><a name="line-216"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Data</span><span class="hs-special">)</span><span>
</span><a name="line-217"></a><span>
</span><a name="line-218"></a><span class="hs-keyword">instance</span><span> </span><a href="Language.Haskell.Exts.ParseMonad.html#Parseable"><span class="hs-identifier hs-type">Parseable</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-type">NonGreedy</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#ModuleHeadAndImports"><span class="hs-identifier hs-type">ModuleHeadAndImports</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-219"></a><span>    </span><a name="local-8214565720324075493"><a href="Language.Haskell.Exts.ParseMonad.html#parser"><span class="hs-identifier">parser</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a name="line-220"></a><span>        </span><span class="hs-special">(</span><span class="hs-special">(</span><a name="local-6989586621679400467"><a href="#local-6989586621679400467"><span class="hs-identifier">pragmas</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679400468"><a href="#local-6989586621679400468"><span class="hs-identifier">pss</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679400469"><a href="#local-6989586621679400469"><span class="hs-identifier">pl</span></a></a><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><a name="local-6989586621679400470"><a href="#local-6989586621679400470"><span class="hs-identifier">mh</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679400471"><a href="#local-6989586621679400471"><span class="hs-identifier">mimps</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><a href="Language.Haskell.Exts.InternalParser.html#ngparseModuleHeadAndImports"><span class="hs-identifier hs-var">ngparseModuleHeadAndImports</span></a><span>
</span><a name="line-221"></a><span>        </span><span class="hs-keyword">let</span><span> </span><a name="local-6989586621679400472"><a href="#local-6989586621679400472"><span class="hs-identifier">l</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679400469"><span class="hs-identifier hs-var">pl</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#%3C%2A%2A"><span class="hs-operator hs-var">&lt;**</span></a><span> </span><a href="#local-6989586621679400468"><span class="hs-identifier hs-var">pss</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">`</span><a href="Language.Haskell.Exts.SrcLoc.html#combSpanMaybe"><span class="hs-identifier hs-var">combSpanMaybe</span></a><span class="hs-special">`</span><span>
</span><a name="line-222"></a><span>                </span><span class="hs-special">(</span><span class="hs-identifier hs-var">fmap</span><span> </span><a href="Language.Haskell.Exts.Syntax.html#ann"><span class="hs-identifier hs-var">ann</span></a><span> </span><a href="#local-6989586621679400470"><span class="hs-identifier hs-var">mh</span></a><span class="hs-special">)</span><span> </span><span class="hs-special">`</span><a href="Language.Haskell.Exts.SrcLoc.html#combSpanMaybe"><span class="hs-identifier hs-var">combSpanMaybe</span></a><span class="hs-special">`</span><span>
</span><a name="line-223"></a><span>                </span><span class="hs-special">(</span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><a name="local-6989586621679400474"><a href="#local-6989586621679400474"><span class="hs-identifier">iss</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679400475"><a href="#local-6989586621679400475"><span class="hs-identifier">il</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679400475"><span class="hs-identifier hs-var">il</span></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#%3C%2A%2A"><span class="hs-operator hs-var">&lt;**</span></a><span> </span><a href="#local-6989586621679400474"><span class="hs-identifier hs-var">iss</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679400471"><span class="hs-identifier hs-var">mimps</span></a><span class="hs-special">)</span><span>
</span><a name="line-224"></a><span>            </span><a name="local-6989586621679400473"><a href="#local-6989586621679400473"><span class="hs-identifier">imps</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">maybe</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><a name="local-6989586621679400476"><a href="#local-6989586621679400476"><span class="hs-identifier">x</span></a></a><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679400476"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679400471"><span class="hs-identifier hs-var">mimps</span></a><span>
</span><a name="line-225"></a><span>        </span><span class="hs-identifier hs-var">return</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-var">NonGreedy</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="Language.Haskell.Exts.Parser.html#ModuleHeadAndImports"><span class="hs-identifier hs-var">ModuleHeadAndImports</span></a><span> </span><a href="#local-6989586621679400472"><span class="hs-identifier hs-var">l</span></a><span> </span><a href="#local-6989586621679400467"><span class="hs-identifier hs-var">pragmas</span></a><span> </span><a href="#local-6989586621679400470"><span class="hs-identifier hs-var">mh</span></a><span> </span><a href="#local-6989586621679400473"><span class="hs-identifier hs-var">imps</span></a><span>
</span><a name="line-226"></a><span>
</span><a name="line-227"></a><span class="hs-comment">-- | Instances of 'Parseable' for @NonGreedy a@ will only consume the input</span><span>
</span><a name="line-228"></a><span class="hs-comment">--   until @a@ is fully parsed.  This means that parse errors that come later</span><span>
</span><a name="line-229"></a><span class="hs-comment">--   in the input will be ignored.  It's also more efficient, as it's fully lazy</span><span>
</span><a name="line-230"></a><span class="hs-comment">--   in the remainder of the input:</span><span>
</span><a name="line-231"></a><span class="hs-comment">--</span><span>
</span><a name="line-232"></a><span class="hs-comment">--   &gt;&gt;&gt; parse (unlines (&quot;module A where&quot; : &quot;main =&quot; : repeat &quot;blah&quot;)) :: ParseResult PragmasAndModuleHead</span><span>
</span><a name="line-233"></a><span class="hs-comment">--   ParseOk (NonGreedy {unNonGreedy = PragmasAndModuleHead [] (ModuleName &quot;A&quot;,Nothing,Nothing)})</span><span>
</span><a name="line-234"></a><span class="hs-comment">--</span><span>
</span><a name="line-235"></a><span class="hs-comment">--   (this example uses the simplified AST)</span><span>
</span><a name="line-236"></a><span class="hs-keyword">newtype</span><span> </span><a name="NonGreedy"><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier">NonGreedy</span></a></a><span> </span><a name="local-6989586621679400461"><a href="#local-6989586621679400461"><span class="hs-identifier">a</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="NonGreedy"><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier">NonGreedy</span></a></a><span> </span><span class="hs-special">{</span><span> </span><a name="unNonGreedy"><a href="Language.Haskell.Exts.Parser.html#unNonGreedy"><span class="hs-identifier">unNonGreedy</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><a href="#local-6989586621679400461"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-special">}</span><span>
</span><a name="line-237"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Data</span><span class="hs-special">)</span><span>
</span><a name="line-238"></a><span>
</span><a name="line-239"></a><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier hs-type">Functor</span><span> </span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-type">NonGreedy</span></a><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-240"></a><span>    </span><a name="local-3458764513820541101"><span class="hs-identifier">fmap</span></a><span> </span><a name="local-6989586621679400465"><a href="#local-6989586621679400465"><span class="hs-identifier">f</span></a></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-var">NonGreedy</span></a><span> </span><a name="local-6989586621679400466"><a href="#local-6989586621679400466"><span class="hs-identifier">x</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.Parser.html#NonGreedy"><span class="hs-identifier hs-var">NonGreedy</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679400465"><span class="hs-identifier hs-var">f</span></a><span> </span><a href="#local-6989586621679400466"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">)</span><span>
</span><a name="line-241"></a><span>
</span><a name="line-242"></a><span class="hs-comment">-- | @ListOf a@ stores lists of the AST type @a@, along with a 'SrcSpanInfo',</span><span>
</span><a name="line-243"></a><span class="hs-comment">--   in order to provide 'Parseable' instances for lists.  These instances are</span><span>
</span><a name="line-244"></a><span class="hs-comment">--   provided when the type is used as a list in the syntax, and the same</span><span>
</span><a name="line-245"></a><span class="hs-comment">--   delimiters are used in all of its usages. Some exceptions are made:</span><span>
</span><a name="line-246"></a><span class="hs-keyword">data</span><span> </span><a name="ListOf"><a href="Language.Haskell.Exts.Parser.html#ListOf"><span class="hs-identifier">ListOf</span></a></a><span> </span><a name="local-6989586621679400460"><a href="#local-6989586621679400460"><span class="hs-identifier">a</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="ListOf"><a href="Language.Haskell.Exts.Parser.html#ListOf"><span class="hs-identifier">ListOf</span></a></a><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span> </span><span class="hs-special">[</span><a href="#local-6989586621679400460"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">]</span><span>
</span><a name="line-247"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Typeable</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Data</span><span class="hs-special">,</span><span class="hs-identifier hs-type">Functor</span><span class="hs-special">)</span><span>
</span><a name="line-248"></a><span>
</span><a name="line-249"></a><span class="hs-identifier">unListOf</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Language.Haskell.Exts.Parser.html#ListOf"><span class="hs-identifier hs-type">ListOf</span></a><span> </span><a href="#local-6989586621679400488"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679400488"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">]</span><span>
</span><a name="line-250"></a><a name="unListOf"><a href="Language.Haskell.Exts.Parser.html#unListOf"><span class="hs-identifier">unListOf</span></a></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.Parser.html#ListOf"><span class="hs-identifier hs-var">ListOf</span></a><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679400498"><a href="#local-6989586621679400498"><span class="hs-identifier">xs</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679400498"><span class="hs-identifier hs-var">xs</span></a><span>
</span><a name="line-251"></a><span>
</span><a name="line-252"></a><span class="hs-comment">-- It's safe to forget about the previous SrcSpanInfo 'srcInfoPoints',</span><span>
</span><a name="line-253"></a><span class="hs-comment">-- as long as they are created with (presently) are all created with</span><span>
</span><a name="line-254"></a><span class="hs-comment">-- 'noInfoSpan' ('nIS'), '(&lt;^^&gt;)', or '(&lt;++&gt;)', all of which have</span><span>
</span><a name="line-255"></a><span class="hs-comment">-- empty 'srcInfoPoints'. Ideally, the parsers would return better</span><span>
</span><a name="line-256"></a><span class="hs-comment">-- types, but this works.</span><span>
</span><a name="line-257"></a><span class="hs-identifier">toListOf</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><a href="#local-6989586621679400487"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpan"><span class="hs-identifier hs-type">SrcSpan</span></a><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><a href="Language.Haskell.Exts.SrcLoc.html#SrcSpanInfo"><span class="hs-identifier hs-type">SrcSpanInfo</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Language.Haskell.Exts.Parser.html#ListOf"><span class="hs-identifier hs-type">ListOf</span></a><span> </span><a href="#local-6989586621679400487"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-258"></a><a name="toListOf"><a href="Language.Haskell.Exts.Parser.html#toListOf"><span class="hs-identifier">toListOf</span></a></a><span> </span><span class="hs-special">(</span><a name="local-6989586621679400499"><a href="#local-6989586621679400499"><span class="hs-identifier">xs</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679400500"><a href="#local-6989586621679400500"><span class="hs-identifier">ss</span></a></a><span class="hs-special">,</span><span> </span><a name="local-6989586621679400501"><a href="#local-6989586621679400501"><span class="hs-identifier">l</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="Language.Haskell.Exts.Parser.html#ListOf"><span class="hs-identifier hs-var">ListOf</span></a><span> </span><span class="hs-special">(</span><a href="Language.Haskell.Exts.SrcLoc.html#infoSpan"><span class="hs-identifier hs-var">infoSpan</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">srcInfoSpan</span><span> </span><a href="#local-6989586621679400501"><span class="hs-identifier hs-var">l</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679400500"><span class="hs-identifier hs-var">ss</span></a><span class="hs-special">)</span><span> </span><a href="#local-6989586621679400499"><span class="hs-identifier hs-var">xs</span></a><span>
</span><a name="line-259"></a></pre></body></html>